(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapÄ¥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _self = this,
        _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'overNode',
        'overNodes',
        'outNode',
        'outNodes',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

    // Deal with resize:
    window.addEventListener('resize', function() {
      if (_self.settings)
        _self.refresh();
    });
  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.renderCamera(camera, camera.isAnimated);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'overNode',
          'overNodes',
          'overEdge',
          'overEdges',
          'outNode',
          'outNodes',
          'outEdge',
          'outEdges',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph.nodes(), {
          prefix: c.readPrefix,
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          c.settings('enableEdgeHovering')
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var i,
        l,
        a,
        prefix = 0;

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.settings('skipErrors'))
        try {
          this.renderers[a[i]].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".render()"'
            );
        }
      else
        this.renderers[a[i]].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "' + a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "' +
                    a[i].id +
                    '" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.2.1';




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exist or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every job that is stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */
  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number} x1  The X coordinate of the start point.
   * @param  {number} y1  The Y coordinate of the start point.
   * @param  {number} x2  The X coordinate of the end point.
   * @param  {number} y2  The Y coordinate of the end point.
   * @return {x,y}        The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {
    return {
      x: (x1 + x2) / 2 + (y2 - y1) / 4,
      y: (y1 + y2) / 2 + (x1 - x2) / 4
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,
      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = Math.pow(1 - t, 3),
        B1_t = 3 * t * Math.pow(1 - t, 2),
        B2_t = 3 * Math.pow(t, 2) * (1 - t),
        B3_t = Math.pow(t, 3);

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    // http://stackoverflow.com/a/328122
    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
        d = sigma.utils.getDistance(x1, y1, x2, y2),
        nCrossProduct = crossProduct / d; // normalized cross product

    return (nCrossProduct < epsilon &&
     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&
     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio)
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */
  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };




  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };
}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik MÃ¶ller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: true,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of hovered nodes.
    borderSize: 0,
    // {number} The default hovered node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,




    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the instance has to refresh itself
    //           automatically when a "resize" event is dispatched from the
    //           window object.
    autoResize: true,
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,




    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: Object.create(null),
      edgesIndex: Object.create(null),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: Object.create(null),
      outNeighborsIndex: Object.create(null),
      allNeighborsIndex: Object.create(null),

      inNeighborsCount: Object.create(null),
      outNeighborsCount: Object.create(null),
      allNeighborsCount: Object.create(null)
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex[node.id])
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex[id] = Object.create(null);
    this.outNeighborsIndex[id] = Object.create(null);
    this.allNeighborsIndex[id] = Object.create(null);

    this.inNeighborsCount[id] = 0;
    this.outNeighborsCount[id] = 0;
    this.allNeighborsCount[id] = 0;

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex[validNode.id] = validNode;

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex[edge.source])
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex[edge.target])
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex[edge.id])
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex[validEdge.id] = validEdge;

    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])
      this.inNeighborsIndex[validEdge.target][validEdge.source] =
        Object.create(null);
    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
      validEdge;

    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])
      this.outNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])
      this.allNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])
        this.allNeighborsIndex[validEdge.target][validEdge.source] =
          Object.create(null);
      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
        validEdge;
    }

    // Keep counts up to date:
    this.inNeighborsCount[validEdge.target]++;
    this.outNeighborsCount[validEdge.source]++;
    this.allNeighborsCount[validEdge.target]++;
    this.allNeighborsCount[validEdge.source]++;

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex[id])
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    delete this.nodesIndex[id];
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    delete this.inNeighborsIndex[id];
    delete this.outNeighborsIndex[id];
    delete this.allNeighborsIndex[id];

    delete this.inNeighborsCount[id];
    delete this.outNeighborsCount[id];
    delete this.allNeighborsCount[id];

    for (k in this.nodesIndex) {
      delete this.inNeighborsIndex[k][id];
      delete this.outNeighborsIndex[k][id];
      delete this.allNeighborsIndex[k][id];
    }

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex[id])
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex[id];
    delete this.edgesIndex[id];
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];
    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)
      delete this.inNeighborsIndex[edge.target][edge.source];

    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)
      delete this.outNeighborsIndex[edge.source][edge.target];

    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)
      delete this.allNeighborsIndex[edge.source][edge.target];

    if (edge.target !== edge.source) {
      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];
      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)
        delete this.allNeighborsIndex[edge.target][edge.source];
    }

    this.inNeighborsCount[edge.target]--;
    this.outNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.target]--;

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
    delete this.inNeighborsCount;
    delete this.outNeighborsCount;
    delete this.allNeighborsCount;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    __emptyObject(this.nodesIndex);
    __emptyObject(this.edgesIndex);
    __emptyObject(this.nodesIndex);
    __emptyObject(this.inNeighborsIndex);
    __emptyObject(this.outNeighborsIndex);
    __emptyObject(this.allNeighborsIndex);
    __emptyObject(this.inNeighborsCount);
    __emptyObject(this.outNeighborsCount);
    __emptyObject(this.allNeighborsCount);

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex[v];

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex[v[i]]);
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsCount,
      'out': this.outNeighborsCount
    }[which || ''] || this.allNeighborsCount;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which[v];

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which[v[i]]);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex[v];

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex[v[i]]);
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree  Property holding the quadtree object.
   * property {object} _geom  Exposition of the _geom namespace for testing.
   * property {object} _cache Cache for the area method.
   */
  var quad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
  };

  /**
   * Index a graph by inserting its nodes into the quadtree.
   *
   * @param  {array}  nodes   An array of nodes to index.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(nodes, params) {

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '';

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    // Inserting graph nodes into the tree
    for (var i = 0, l = nodes.length; i < l; i++) {

      // Inserting node
      _quadInsert(
        nodes[i],
        _geom.pointToSquare({
          x: nodes[i][prefix + 'x'],
          y: nodes[i][prefix + 'y'],
          size: nodes[i][prefix + 'size']
        }),
        this._tree
      );
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var nodes = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var nodesArray = [];
    for (var i in nodes)
      nodesArray.push(nodes[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = nodesArray;

    return nodesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module for edges
   * ===============================
   *
   * Author: SÃ©bastien Heymann,
   *   from the quad of Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 40,
      maxLevel: maxLevel || 8,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The edgequad API as exposed to sigma.
   */

  /**
   * The edgequad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree     Property holding the quadtree object.
   * property {object} _geom     Exposition of the _geom namespace for testing.
   * property {object} _cache    Cache for the area method.
   * property {boolean} _enabled Can index and retreive elements.
   */
  var edgequad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
  };

  /**
   * Index a graph by inserting its edges into the quadtree.
   *
   * @param  {object} graph   A graph instance.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for edge geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  edgequad.prototype.index = function(graph, params) {
    if (!this._enabled)
      return this._tree;

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.edgequad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        source,
        target,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    var edges = graph.edges();

    // Inserting graph edges into the tree
    for (var i = 0, l = edges.length; i < l; i++) {
      source = graph.nodes(edges[i].source);
      target = graph.nodes(edges[i].target);
      e = {
        x1: source[prefix + 'x'],
        y1: source[prefix + 'y'],
        x2: target[prefix + 'x'],
        y2: target[prefix + 'y'],
        size: edges[i][prefix + 'size'] || 0
      };

      // Inserting edge
      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
        if (source.id === target.id) {
          n = {
            x: source[prefix + 'x'],
            y: source[prefix + 'y'],
            size: source[prefix + 'size'] || 0
          };
          _quadInsert(
            edges[i],
            _geom.selfLoopToSquare(n),
            this._tree);
        }
        else {
          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);
          _quadInsert(
            edges[i],
            _geom.quadraticCurveToSquare(e, cp),
            this._tree);
        }
      }
      else {
        _quadInsert(
          edges[i],
          _geom.lineToSquare(e),
          this._tree);
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph edges held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph edges within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving edges
    var edges = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var edgesArray = [];
    for (var i in edges)
      edgesArray.push(edges[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = edgesArray;

    return edgesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.edgequad = edgequad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = edgequad;
    exports.edgequad = edgequad;
  } else
    this.edgequad = edgequad;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation,
          wheelDelta = sigma.utils.getDelta(e);

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {
        ratio = wheelDelta > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };




  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        renderers,
        rendererType,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      // First, let's identify which edges to draw. To do this, we just keep
      // every edges that have at least one extremity displayed according to
      // the quadtree and the "hidden" attribute. We also do not keep hidden
      // edges.
      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
        o = a[i];
        if (
          (index[o.source] || index[o.target]) &&
          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
        )
          this.edgesOnScreen.push(o);
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (this.settings(options, 'batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          renderers = sigma.canvas.edges;
          for (i = start; i < end; i++) {
            o = edges[i];
            (renderers[
              o.type || this.settings(options, 'defaultEdgeType')
            ] || renderers.def)(
              o,
              graph.nodes(o.source),
              graph.nodes(o.target),
              this.contexts.edges,
              embedSettings
            );
          }

          // Draw edge labels:
          if (drawEdgeLabels) {
            renderers = sigma.canvas.edges.labels;
            for (i = start; i < end; i++) {
              o = edges[i];
              if (!o.hidden)
                (renderers[
                  o.type || this.settings(options, 'defaultEdgeType')
                ] || renderers.def)(
                  o,
                  graph.nodes(o.source),
                  graph.nodes(o.target),
                  this.contexts.labels,
                  embedSettings
                );
            }
          }

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        renderers = sigma.canvas.edges;
        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
          o = a[i];
          (renderers[
            o.type || this.settings(options, 'defaultEdgeType')
          ] || renderers.def)(
            o,
            graph.nodes(o.source),
            graph.nodes(o.target),
            this.contexts.edges,
            embedSettings
          );
        }

        // Draw edge labels:
        // - No batching
        if (drawEdgeLabels) {
          renderers = sigma.canvas.edges.labels;
          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)
            if (!a[i].hidden)
              (renderers[
                a[i].type || this.settings(options, 'defaultEdgeType')
              ] || renderers.def)(
                a[i],
                graph.nodes(a[i].source),
                graph.nodes(a[i].target),
                this.contexts.labels,
                embedSettings
              );
        }
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      renderers = sigma.canvas.nodes;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.nodes,
            embedSettings
          );
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      renderers = sigma.canvas.labels;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.labels,
            embedSettings
          );
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          e = (subrenderers[a[i].type] || subrenderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.labels[a[i].id] = e;
          this.domElements.groups.labels.appendChild(e);
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        (subrenderers[a[i].type] || subrenderers.def).update(
          a[i],
          this.domElements.labels[a[i].id],
          embedSettings
        );
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function overNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      var hover = (renderers[node.type] || renderers.def).create(
        node,
        self.domElements.nodes[node.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[node.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
      hoveredNode = node;
    }

    function outNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      // Deleting element
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[node.id]
      );
      hoveredNode = null;
      delete self.domElements.hovers[node.id];

      // Reinstate
      self.domElements.groups.nodes.appendChild(
        self.domElements.nodes[node.id]
      );
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('overNode', overNode);
    this.bind('outNode', outNode);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = 1;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = w + 'px';
      this.domElements.graph.style.height = h + 'px';

      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {
        this.domElements.graph.setAttribute('width', (w * pixelRatio));
        this.domElements.graph.setAttribute('height', (h * pixelRatio));
      }
    }

    return this;
  };


  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Check if WebGL is enabled:
  var canvas,
      webgl = !!global.WebGLRenderingContext;
  if (webgl) {
    canvas = document.createElement('canvas');
    try {
      webgl = !!(
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl')
      );
    } catch (e) {
      webgl = false;
    }
  }

  // Copy the good renderer:
  sigma.renderers.def = webgl ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will just display the label on the right of the node.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.labels.def = function(node, context, settings) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'];

    if (size < settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +
      fontSize + 'px ' + settings('font');
    context.fillStyle = (settings('labelColor') === 'node') ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultLabelColor');

    context.fillText(
      node.label,
      Math.round(node[prefix + 'x'] + size + 3),
      Math.round(node[prefix + 'y'] + fontSize / 3)
    );
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;

    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (node.label && settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    if (node.label && typeof node.label === 'string') {
      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
      w = Math.round(
        context.measureText(node.label).width + fontSize / 2 + size + 7
      );
      h = Math.round(fontSize + 4);
      e = Math.round(fontSize / 2 + 2);

      context.moveTo(x, y + e);
      context.arcTo(x, y, x + e, y, e);
      context.lineTo(x + w, y);
      context.lineTo(x + w, y + h);
      context.lineTo(x + e, y + h);
      context.arcTo(x, y + h, x, y + h - e, e);
      context.lineTo(x, y + e);

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    // Node border:
    if (settings('borderSize') > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + settings('borderSize'),
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');

      context.fillText(
        node.label,
        Math.round(node[prefix + 'x'] + size + 3),
        Math.round(node[prefix + 'y'] + fontSize / 3)
      );
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = size * 2.5,
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (source.id === target.id) {
      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));
      aSize = size * 2.5;
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the node as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '';

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      // Control point
      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +
        (target[prefix + 'y'] - source[prefix + 'y']) / 4,
          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +
        (source[prefix + 'x'] - target[prefix + 'x']) / 4;

      // Path
      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +
              'Q' + cx + ',' + cy + ' ' +
              target[prefix + 'x'] + ',' + target[prefix + 'y'];

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              Math.pow(modifiedX - x, 2) +
              Math.pow(modifiedY - y, 2)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y']);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            i,
            l,
            le,
            outNodes = [],
            outEdges = [];

        for (k in overNodes)
          outNodes.push(overNodes[k]);

        overNodes = {};
        // Dispatch both single and multi events:
        for (i = 0, l = outNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: outNodes[i],
            captor: e.data
          });
        if (outNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: outNodes,
            captor: e.data
          });

        overEdges = {};
        // Dispatch both single and multi events:
        for (i = 0, le = outEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: outEdges[i],
            captor: e.data
          });
        if (outEdges.length)
          self.dispatchEvent('outEdges', {
            edges: outEdges,
            captor: e.data
          });
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            l = nodes.length,
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {},
            le = edges.length;

        // Check newly overred nodes:
        for (i = 0; i < l; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, l = newOverNodes.length; i < l; i++)
          self.dispatchEvent('overNode', {
            node: newOverNodes[i],
            captor: e.data
          });
        for (i = 0, l = newOutNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: newOutNodes[i],
            captor: e.data
          });
        if (newOverNodes.length)
          self.dispatchEvent('overNodes', {
            nodes: newOverNodes,
            captor: e.data
          });
        if (newOutNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: newOutNodes,
            captor: e.data
          });

        // Check newly overred edges:
        for (i = 0; i < le; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, le = newOverEdges.length; i < le; i++)
          self.dispatchEvent('overEdge', {
            edge: newOverEdges[i],
            captor: e.data
          });
        for (i = 0, le = newOutEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: newOutEdges[i],
            captor: e.data
          });
        if (newOverEdges.length)
          self.dispatchEvent('overEdges', {
            edges: newOverEdges,
            captor: e.data
          });
        if (newOutEdges.length)
          self.dispatchEvent('outEdges', {
            edges: newOutEdges,
            captor: e.data
          });
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
      self.bind('render', onMove);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph;

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('overNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('overEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('outNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('outEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "overNode", "outNode", "overEdge" and "outEdge"
   * events from a renderer and renders the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        hoveredNodes = {},
        hoveredEdges = {};

    this.bind('overNode', function(event) {
      var node = event.data.node;
      if (!node.hidden) {
        hoveredNodes[node.id] = node;
        draw();
      }
    });

    this.bind('outNode', function(event) {
      delete hoveredNodes[event.data.node.id];
      draw();
    });

    this.bind('overEdge', function(event) {
      var edge = event.data.edge;
      if (!edge.hidden) {
        hoveredEdges[edge.id] = edge;
        draw();
      }
    });

    this.bind('outEdge', function(event) {
      delete hoveredEdges[event.data.edge.id];
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {

      var k,
          source,
          target,
          hoveredNode,
          hoveredEdge,
          c = self.contexts.hover.canvas,
          defaultNodeType = self.settings('defaultNodeType'),
          defaultEdgeType = self.settings('defaultEdgeType'),
          nodeRenderers = sigma.canvas.hovers,
          edgeRenderers = sigma.canvas.edgehovers,
          extremitiesRenderers = sigma.canvas.extremities,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Clear self.contexts.hover:
      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render: single hover
      if (
        embedSettings('enableHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredNodes).length
      ) {
        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];
        (
          nodeRenderers[hoveredNode.type] ||
          nodeRenderers[defaultNodeType] ||
          nodeRenderers.def
        )(
          hoveredNode,
          self.contexts.hover,
          embedSettings
        );
      }

      // Node render: multiple hover
      if (
        embedSettings('enableHovering') &&
        !embedSettings('singleHover')
      )
        for (k in hoveredNodes)
          (
            nodeRenderers[hoveredNodes[k].type] ||
            nodeRenderers[defaultNodeType] ||
            nodeRenderers.def
          )(
            hoveredNodes[k],
            self.contexts.hover,
            embedSettings
          );

      // Edge render: single hover
      if (
        embedSettings('enableEdgeHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredEdges).length
      ) {
        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];
        source = self.graph.nodes(hoveredEdge.source);
        target = self.graph.nodes(hoveredEdge.target);

        if (! hoveredEdge.hidden) {
          (
            edgeRenderers[hoveredEdge.type] ||
            edgeRenderers[defaultEdgeType] ||
            edgeRenderers.def
          ) (
            hoveredEdge,
            source,
            target,
            self.contexts.hover,
            embedSettings
          );

          if (embedSettings('edgeHoverExtremities')) {
            (
              extremitiesRenderers[hoveredEdge.type] ||
              extremitiesRenderers.def
            )(
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

          } else {
            // Avoid edges rendered over nodes:
            (
              sigma.canvas.nodes[source.type] ||
              sigma.canvas.nodes.def
            ) (
              source,
              self.contexts.hover,
              embedSettings
            );
            (
              sigma.canvas.nodes[target.type] ||
              sigma.canvas.nodes.def
            ) (
              target,
              self.contexts.hover,
              embedSettings
            );
          }
        }
      }

      // Edge render: multiple hover
      if (
        embedSettings('enableEdgeHovering') &&
        !embedSettings('singleHover')
      ) {
        for (k in hoveredEdges) {
          hoveredEdge = hoveredEdges[k];
          source = self.graph.nodes(hoveredEdge.source);
          target = self.graph.nodes(hoveredEdge.target);

          if (!hoveredEdge.hidden) {
            (
              edgeRenderers[hoveredEdge.type] ||
              edgeRenderers[defaultEdgeType] ||
              edgeRenderers.def
            ) (
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

            if (embedSettings('edgeHoverExtremities')) {
              (
                extremitiesRenderers[hoveredEdge.type] ||
                extremitiesRenderers.def
              )(
                hoveredEdge,
                source,
                target,
                self.contexts.hover,
                embedSettings
              );
            } else {
              // Avoid edges rendered over nodes:
              (
                sigma.canvas.nodes[source.type] ||
                sigma.canvas.nodes.def
              ) (
                source,
                self.contexts.hover,
                embedSettings
              );
              (
                sigma.canvas.nodes[target.type] ||
                sigma.canvas.nodes.def
              ) (
                target,
                self.contexts.hover,
                embedSettings
              );
            }
          }
        }
      }
    }
  };
}).call(this);

},{}],2:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.layout.noverlap');

  /**
   * Noverlap Layout
   * ===============================
   *
   * Author: @apitts / Andrew Pitts
   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)
   * Acknowledgement: @sheyman / SÃ©bastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)
   * Version: 0.1
   */

  var settings = {
    speed: 3,
    scaleNodes: 1.2,
    nodeMargin: 5.0,
    gridSize: 20,
    permittedExpansion: 1.1,
    rendererIndex: 0,
    maxIterations: 500
  };

  var _instance = {};

  /**
   * Event emitter Object
   * ------------------
   */
  var _eventEmitter = {};

   /**
   * Noverlap Object
   * ------------------
   */
  function Noverlap() {
    var self = this;

    this.init = function (sigInst, options) {
      options = options || {};

      // Properties
      this.sigInst = sigInst;
      this.config = sigma.utils.extend(options, settings);
      this.easing = options.easing;
      this.duration = options.duration;

      if (options.nodes) {
        this.nodes = options.nodes;
        delete options.nodes;
      }

      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {
        throw new Error('sigma.plugins.animate is not declared');
      }

      // State
      this.running = false;
    };

    /**
     * Single layout iteration.
     */
    this.atomicGo = function () {
      if (!this.running || this.iterCount < 1) return false;

      var nodes = this.nodes || this.sigInst.graph.nodes(),
          nodesCount = nodes.length,
          i,
          n,
          n1,
          n2,
          xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity,
          xwidth,
          yheight,
          xcenter,
          ycenter,
          grid,
          row,
          col,
          minXBox,
          maxXBox,
          minYBox,
          maxYBox,
          adjacentNodes,
          subRow,
          subCol,
          nxmin,
          nxmax,
          nymin,
          nymax;

      this.iterCount--;
      this.running = false;

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        n.dn.dx = 0;
        n.dn.dy = 0;

        //Find the min and max for both x and y across all nodes
        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );

      }

      xwidth = xmax - xmin;
      yheight = ymax - ymin;
      xcenter = (xmin + xmax) / 2;
      ycenter = (ymin + ymax) / 2;
      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;
      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;
      ymin = ycenter - self.config.permittedExpansion*yheight / 2;
      ymax = ycenter + self.config.permittedExpansion*yheight / 2;

      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid

      for(row = 0; row < self.config.gridSize; row++) {
        grid[row] = {};
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col] = [];
        }
      }

      //Place nodes in grid
      for (i=0; i < nodesCount; i++) {
        n = nodes[i];

        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);

        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );
        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );
        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );
        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );
        for(col = minXBox; col <= maxXBox; col++) {
          for(row = minYBox; row <= maxYBox; row++) {
            grid[row][col].push(n.id);
          }
        }
      }


      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes

      for(row = 0; row < self.config.gridSize; row++) {
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col].forEach(function(nodeId) {
            if(!adjacentNodes[nodeId]) {
              adjacentNodes[nodeId] = [];
            }
            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {
              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {
                grid[subRow][subCol].forEach(function(subNodeId) {
                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {
                    adjacentNodes[nodeId].push(subNodeId);
                  }
                });
              }
            }
          });
        }
      }

      //If two nodes overlap then repulse them
      for (i=0; i < nodesCount; i++) {
        n1 = nodes[i];
        adjacentNodes[n1.id].forEach(function(nodeId) {
          var n2 = self.sigInst.graph.nodes(nodeId);
          var xDist = n2.dn_x - n1.dn_x;
          var yDist = n2.dn_y - n1.dn_y;
          var dist = Math.sqrt(xDist*xDist + yDist*yDist);
          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));
          if(collision) {
            self.running = true;
            if(dist > 0) {
              n2.dn.dx += xDist / dist * (1 + n1.dn_size);
              n2.dn.dy += yDist / dist * (1 + n1.dn_size);
            } else {
              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());
              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());
            }
          }
        });
      }

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        if(!n.fixed) {
          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;
          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;
        }
      }

      if(this.running && this.iterCount < 1) {
        this.running = false;
      }

      return this.running;
    };

    this.go = function () {
      this.iterCount = this.config.maxIterations;

      while (this.running) {
        this.atomicGo();
      };

      this.stop();
    };

    this.start = function() {
      if (this.running) return;

      var nodes = this.sigInst.graph.nodes();

      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;

      this.running = true;

      // Init nodes
      for (var i = 0; i < nodes.length; i++) {
        nodes[i].dn_x = nodes[i][prefix + 'x'];
        nodes[i].dn_y = nodes[i][prefix + 'y'];
        nodes[i].dn_size = nodes[i][prefix + 'size'];
        nodes[i].dn = {
          dx: 0,
          dy: 0
        };
      }
      _eventEmitter[self.sigInst.id].dispatchEvent('start');
      this.go();
    };

    this.stop = function() {
      var nodes = this.sigInst.graph.nodes();

      this.running = false;

      if (this.easing) {
        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');
        sigma.plugins.animate(
          self.sigInst,
          {
            x: 'dn_x',
            y: 'dn_y'
          },
          {
            easing: self.easing,
            onComplete: function() {
              self.sigInst.refresh();
              for (var i = 0; i < nodes.length; i++) {
                nodes[i].dn = null;
                nodes[i].dn_x = null;
                nodes[i].dn_y = null;
              }
              _eventEmitter[self.sigInst.id].dispatchEvent('stop');
            },
            duration: self.duration
          }
        );
      }
      else {
        // Apply changes
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].x = nodes[i].dn_x;
          nodes[i].y = nodes[i].dn_y;
        }

        this.sigInst.refresh();

        for (var i = 0; i < nodes.length; i++) {
          nodes[i].dn = null;
          nodes[i].dn_x = null;
          nodes[i].dn_y = null;
        }
        _eventEmitter[self.sigInst.id].dispatchEvent('stop');
      }
    };

    this.kill = function() {
      this.sigInst = null;
      this.config = null;
      this.easing = null;
    };
  };

  /**
   * Interface
   * ----------
   */

  /**
   * Configure the layout algorithm.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object:
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */
  sigma.prototype.configNoverlap = function(config) {

    var sigInst = this;

    if (!config) throw new Error('Missing argument: "config"');

    // Create instance if undefined
    if (!_instance[sigInst.id]) {
      _instance[sigInst.id] = new Noverlap();

      _eventEmitter[sigInst.id] = {};
      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);

      // Binding on kill to clear the references
      sigInst.bind('kill', function() {
        _instance[sigInst.id].kill();
        _instance[sigInst.id] = null;
        _eventEmitter[sigInst.id] = null;
      });
    }

    _instance[sigInst.id].init(sigInst, config);

    return _eventEmitter[sigInst.id];
  };

  /**
   * Start the layout algorithm. It will use the existing configuration if no
   * new configuration is passed.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */

  sigma.prototype.startNoverlap = function(config) {

    var sigInst = this;

    if (config) {
      this.configNoverlap(sigInst, config);
    }

    _instance[sigInst.id].start();

    return _eventEmitter[sigInst.id];
  };

  /**
   * Returns true if the layout has started and is not completed.
   *
   * @return {boolean}
   */
  sigma.prototype.isNoverlapRunning = function() {

    var sigInst = this;

    return !!_instance[sigInst.id] && _instance[sigInst.id].running;
  };

}).call(this);
},{}],3:[function(require,module,exports){
/**
 * This plugin provides a method to animate a sigma instance by interpolating
 * some node properties. Check the sigma.plugins.animate function doc or the
 * examples/animate.html code sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');

  var _id = 0,
      _cache = {};

  // TOOLING FUNCTIONS:
  // ******************
  function parseColor(val) {
    if (_cache[val])
      return _cache[val];

    var result = [0, 0, 0];

    if (val.match(/^#/)) {
      val = (val || '').replace(/^#/, '');
      result = (val.length === 3) ?
        [
          parseInt(val.charAt(0) + val.charAt(0), 16),
          parseInt(val.charAt(1) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(2), 16)
        ] :
        [
          parseInt(val.charAt(0) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(3), 16),
          parseInt(val.charAt(4) + val.charAt(5), 16)
        ];
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      result = [
        +val[1],
        +val[2],
        +val[3]
      ];
    }

    _cache[val] = {
      r: result[0],
      g: result[1],
      b: result[2]
    };

    return _cache[val];
  }

  function interpolateColors(c1, c2, p) {
    c1 = parseColor(c1);
    c2 = parseColor(c2);

    var c = {
      r: c1.r * (1 - p) + c2.r * p,
      g: c1.g * (1 - p) + c2.g * p,
      b: c1.b * (1 - p) + c2.b * p
    };

    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';
  }

  /**
   * This function will animate some specified node properties. It will
   * basically call requestAnimationFrame, interpolate the values and call the
   * refresh method during a specified duration.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {?array}             nodes      An array of node objects or node ids. If
   *                                   not specified, all nodes of the graph
   *                                   will be animated.
   *   {?(function|string)} easing     Either the name of an easing in the
   *                                   sigma.utils.easings package or a
   *                                   function. If not specified, the
   *                                   quadraticInOut easing from this package
   *                                   will be used instead.
   *   {?number}            duration   The duration of the animation. If not
   *                                   specified, the "animationsTime" setting
   *                                   value of the sigma instance will be used
   *                                   instead.
   *   {?function}          onComplete Eventually a function to call when the
   *                                   animation is ended.
   *
   * @param  {sigma}   s       The related sigma instance.
   * @param  {object}  animate An hash with the keys being the node properties
   *                           to interpolate, and the values being the related
   *                           target values.
   * @param  {?object} options Eventually an object with options.
   */
  sigma.plugins.animate = function(s, animate, options) {
    var o = options || {},
        id = ++_id,
        duration = o.duration || s.settings('animationsTime'),
        easing = typeof o.easing === 'string' ?
          sigma.utils.easings[o.easing] :
          typeof o.easing === 'function' ?
          o.easing :
          sigma.utils.easings.quadraticInOut,
        start = sigma.utils.dateNow(),
        nodes,
        startPositions;

    if (o.nodes && o.nodes.length) {
      if (typeof o.nodes[0] === 'object')
        nodes = o.nodes;
      else
        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs
    }
    else
      nodes = s.graph.nodes();

    // Store initial positions:
    startPositions = nodes.reduce(function(res, node) {
      var k;
      res[node.id] = {};
      for (k in animate)
        if (k in node)
          res[node.id][k] = node[k];
      return res;
    }, {});

    s.animations = s.animations || Object.create({});
    sigma.plugins.kill(s);

    // Do not refresh edgequadtree during drag:
    var k,
        c;
    for (k in s.cameras) {
      c = s.cameras[k];
      c.edgequadtree._enabled = false;
    }

    function step() {
      var p = (sigma.utils.dateNow() - start) / duration;

      if (p >= 1) {
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate)
              node[k] = node[animate[k]];
        });

        // Allow to refresh edgequadtree:
        var k,
            c;
        for (k in s.cameras) {
          c = s.cameras[k];
          c.edgequadtree._enabled = true;
        }

        s.refresh();
        if (typeof o.onComplete === 'function')
          o.onComplete();
      } else {
        p = easing(p);
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate) {
              if (k.match(/color$/))
                node[k] = interpolateColors(
                  startPositions[node.id][k],
                  node[animate[k]],
                  p
                );
              else
                node[k] =
                  node[animate[k]] * p +
                  startPositions[node.id][k] * (1 - p);
            }
        });

        s.refresh();
        s.animations[id] = requestAnimationFrame(step);
      }
    }

    step();
  };

  sigma.plugins.kill = function(s) {
    for (var k in (s.animations || {}))
      cancelAnimationFrame(s.animations[k]);

    // Allow to refresh edgequadtree:
    var k,
        c;
    for (k in s.cameras) {
      c = s.cameras[k];
      c.edgequadtree._enabled = true;
    }
  };
}).call(window);

},{}],4:[function(require,module,exports){
/**
 * This plugin provides a method to drag & drop nodes. Check the
 * sigma.plugins.dragNodes function doc or the examples/basic.html &
 * examples/api-candy.html code samples to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');


  /**
   * This function will add `mousedown`, `mouseup` & `mousemove` events to the
   * nodes in the `overNode`event to perform drag & drop operations. It uses
   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]
   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to
   * calculate the X and Y coordinates from the `cam` or `renderer` node
   * attributes. These attributes represent the coordinates of the nodes in
   * the real container, not in canvas.
   *
   * Fired events:
   * *************
   * startdrag  Fired at the beginning of the drag.
   * drag       Fired while the node is dragged.
   * drop       Fired at the end of the drag if the node has been dragged.
   * dragend    Fired at the end of the drag.
   *
   * Recognized parameters:
   * **********************
   * @param  {sigma}    s        The related sigma instance.
   * @param  {renderer} renderer The related renderer instance.
   */
  function DragNodes(s, renderer) {
    sigma.classes.dispatcher.extend(this);

    // A quick hardcoded rule to prevent people from using this plugin with the
    // WebGL renderer (which is impossible at the moment):
    // if (
    //   sigma.renderers.webgl &&
    //   renderer instanceof sigma.renderers.webgl
    // )
    //   throw new Error(
    //     'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'
    //   );

    // Init variables:
    var _self = this,
      _s = s,
      _body = document.body,
      _renderer = renderer,
      _mouse = renderer.container.lastChild,
      _camera = renderer.camera,
      _node = null,
      _prefix = '',
      _hoverStack = [],
      _hoverIndex = {},
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false;

    if (renderer instanceof sigma.renderers.svg) {
        _mouse = renderer.container.firstChild;
    }

    // It removes the initial substring ('read_') if it's a WegGL renderer.
    if (renderer instanceof sigma.renderers.webgl) {
      _prefix = renderer.options.prefix.substr(5);
    } else {
      _prefix = renderer.options.prefix;
    }

    renderer.bind('overNode', nodeMouseOver);
    renderer.bind('outNode', treatOutNode);
    renderer.bind('click', click);

    _s.bind('kill', function() {
      _self.unbindAll();
    });

    /**
     * Unbind all event listeners.
     */
    this.unbindAll = function() {
      _mouse.removeEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);
      _renderer.unbind('overNode', nodeMouseOver);
      _renderer.unbind('outNode', treatOutNode);
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function calculateOffset(element) {
      var style = window.getComputedStyle(element);
      var getCssProperty = function(prop) {
        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
      };
      return {
        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
        top: element.getBoundingClientRect().top + getCssProperty('padding-top')
      };
    };

    function click(event) {
      // event triggered at the end of the click
      _isMouseDown = false;
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      if (!_hoverStack.length) {
        _node = null;
      }
    };

    function nodeMouseOver(event) {
      // Don't treat the node if it is already registered
      if (_hoverIndex[event.data.node.id]) {
        return;
      }

      // Add node to array of current nodes over
      _hoverStack.push(event.data.node);
      _hoverIndex[event.data.node.id] = true;

      if(_hoverStack.length && ! _isMouseDown) {
        // Set the current node to be the last one in the array
        _node = _hoverStack[_hoverStack.length - 1];
        _mouse.addEventListener('mousedown', nodeMouseDown);
      }
    };

    function treatOutNode(event) {
      // Remove the node from the array
      var indexCheck = _hoverStack.map(function(e) { return e; }).indexOf(event.data.node);
      _hoverStack.splice(indexCheck, 1);
      delete _hoverIndex[event.data.node.id];

      if(_hoverStack.length && ! _isMouseDown) {
        // On out, set the current node to be the next stated in array
        _node = _hoverStack[_hoverStack.length - 1];
      } else {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
      }
    };

    function nodeMouseDown(event) {
      _isMouseDown = true;
      var size = _s.graph.nodes().length;

      // when there is only node in the graph, the plugin cannot apply
      // linear interpolation. So treat it as if a user is dragging
      // the graph
      if (_node && size > 1) {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
        _body.addEventListener('mousemove', nodeMouseMove);
        _body.addEventListener('mouseup', nodeMouseUp);

        // Do not refresh edgequadtree during drag:
        var k,
            c;
        for (k in _s.cameras) {
          c = _s.cameras[k];
          if (c.edgequadtree !== undefined) {
            c.edgequadtree._enabled = false;
          }
        }

        // Deactivate drag graph.
        _renderer.settings({mouseEnabled: false, enableHovering: false});
        _s.refresh();

        _self.dispatchEvent('startdrag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };

    function nodeMouseUp(event) {
      _isMouseDown = false;
      _mouse.addEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      // Allow to refresh edgequadtree:
      var k,
          c;
      for (k in _s.cameras) {
        c = _s.cameras[k];
        if (c.edgequadtree !== undefined) {
          c.edgequadtree._enabled = true;
        }
      }

      // Activate drag graph.
      _renderer.settings({mouseEnabled: true, enableHovering: true});
      _s.refresh();

      if (_drag) {
        _self.dispatchEvent('drop', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
      _self.dispatchEvent('dragend', {
        node: _node,
        captor: event,
        renderer: _renderer
      });

      _drag = false;
      _node = null;
    };

    function nodeMouseMove(event) {
      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        clearTimeout(timeOut);
        var timeOut = setTimeout(executeNodeMouseMove, 0);
      } else {
        executeNodeMouseMove();
      }

      function executeNodeMouseMove() {
        var offset = calculateOffset(_renderer.container),
            x = event.clientX - offset.left,
            y = event.clientY - offset.top,
            cos = Math.cos(_camera.angle),
            sin = Math.sin(_camera.angle),
            nodes = _s.graph.nodes(),
            ref = [];

        // Getting and derotating the reference coordinates.
        for (var i = 0; i < 2; i++) {
          var n = nodes[i];
          var aux = {
            x: n.x * cos + n.y * sin,
            y: n.y * cos - n.x * sin,
            renX: n[_prefix + 'x'],
            renY: n[_prefix + 'y'],
          };
          ref.push(aux);
        }

        // Applying linear interpolation.
        // if the nodes are on top of each other, we use the camera ratio to interpolate
        if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {
          var xRatio = (ref[0].renX === 0) ? 1 : ref[0].renX;
          var yRatio = (ref[0].renY === 0) ? 1 : ref[0].renY;
          x = (ref[0].x / xRatio) * (x - ref[0].renX) + ref[0].x;
          y = (ref[0].y / yRatio) * (y - ref[0].renY) + ref[0].y;
        } else {
          var xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);
          var yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);

          // if the coordinates are the same, we use the other ratio to interpolate
          if (ref[1].x === ref[0].x) {
            xRatio = yRatio;
          }

          if (ref[1].y === ref[0].y) {
            yRatio = xRatio;
          }

          x = (x - ref[0].renX) / xRatio + ref[0].x;
          y = (y - ref[0].renY) / yRatio + ref[0].y;
        }

        // Rotating the coordinates.
        _node.x = x * cos - y * sin;
        _node.y = y * cos + x * sin;

        _s.refresh();

        _drag = true;
        _self.dispatchEvent('drag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };
  };

  /**
   * Interface
   * ------------------
   *
   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0]);
   */
  var _instance = {};

  /**
   * @param  {sigma} s The related sigma instance.
   * @param  {renderer} renderer The related renderer instance.
   */
  sigma.plugins.dragNodes = function(s, renderer) {
    // Create object if undefined
    if (!_instance[s.id]) {
      _instance[s.id] = new DragNodes(s, renderer);
    }

    s.bind('kill', function() {
      sigma.plugins.killDragNodes(s);
    });

    return _instance[s.id];
  };

  /**
   * This method removes the event listeners and kills the dragNodes instance.
   *
   * @param  {sigma} s The related sigma instance.
   */
  sigma.plugins.killDragNodes = function(s) {
    if (_instance[s.id] instanceof DragNodes) {
      _instance[s.id].unbindAll();
      delete _instance[s.id];
    }
  };

}).call(window);

},{}],5:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

},{}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var arrays = require("./arrays");
var LinkedList = /** @class */ (function () {
    /**
    * Creates an empty Linked List.
    * @class A linked list is a data structure consisting of a group of nodes
    * which together represent a sequence.
    * @constructor
    */
    function LinkedList() {
        /**
        * First node in the list
        * @type {Object}
        * @private
        */
        this.firstNode = null;
        /**
        * Last node in the list
        * @type {Object}
        * @private
        */
        this.lastNode = null;
        /**
        * Number of elements in the list
        * @type {number}
        * @private
        */
        this.nElements = 0;
    }
    /**
    * Adds an element to this list.
    * @param {Object} item element to be added.
    * @param {number=} index optional index to add the element. If no index is specified
    * the element is added to the end of this list.
    * @return {boolean} true if the element was added or false if the index is invalid
    * or if the element is undefined.
    */
    LinkedList.prototype.add = function (item, index) {
        if (util.isUndefined(index)) {
            index = this.nElements;
        }
        if (index < 0 || index > this.nElements || util.isUndefined(item)) {
            return false;
        }
        var newNode = this.createNode(item);
        if (this.nElements === 0 || this.lastNode === null) {
            // First node in the list.
            this.firstNode = newNode;
            this.lastNode = newNode;
        }
        else if (index === this.nElements) {
            // Insert at the end.
            this.lastNode.next = newNode;
            this.lastNode = newNode;
        }
        else if (index === 0) {
            // Change first node.
            newNode.next = this.firstNode;
            this.firstNode = newNode;
        }
        else {
            var prev = this.nodeAtIndex(index - 1);
            if (prev == null) {
                return false;
            }
            newNode.next = prev.next;
            prev.next = newNode;
        }
        this.nElements++;
        return true;
    };
    /**
    * Returns the first element in this list.
    * @return {*} the first element of the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.first = function () {
        if (this.firstNode !== null) {
            return this.firstNode.element;
        }
        return undefined;
    };
    /**
    * Returns the last element in this list.
    * @return {*} the last element in the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.last = function () {
        if (this.lastNode !== null) {
            return this.lastNode.element;
        }
        return undefined;
    };
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index desired index.
     * @return {*} the element at the given index or undefined if the index is
     * out of bounds.
     */
    LinkedList.prototype.elementAtIndex = function (index) {
        var node = this.nodeAtIndex(index);
        if (node === null) {
            return undefined;
        }
        return node.element;
    };
    /**
     * Returns the index in this list of the first occurrence of the
     * specified element, or -1 if the List does not contain this element.
     * <p>If the elements inside this list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {number} the index in this list of the first occurrence
     * of the specified element, or -1 if this list does not contain the
     * element.
     */
    LinkedList.prototype.indexOf = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (util.isUndefined(item)) {
            return -1;
        }
        var currentNode = this.firstNode;
        var index = 0;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                return index;
            }
            index++;
            currentNode = currentNode.next;
        }
        return -1;
    };
    /**
       * Returns true if this list contains the specified element.
       * <p>If the elements inside the list are
       * not comparable with the === operator a custom equals function should be
       * provided to perform searches, the function must receive two arguments and
       * return true if they are equal, false otherwise. Example:</p>
       *
       * <pre>
       * const petsAreEqualByName = function(pet1, pet2) {
       *  return pet1.name === pet2.name;
       * }
       * </pre>
       * @param {Object} item element to search for.
       * @param {function(Object,Object):boolean=} equalsFunction Optional
       * function used to check if two elements are equal.
       * @return {boolean} true if this list contains the specified element, false
       * otherwise.
       */
    LinkedList.prototype.contains = function (item, equalsFunction) {
        return (this.indexOf(item, equalsFunction) >= 0);
    };
    /**
     * Removes the first occurrence of the specified element in this list.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to be removed from this list, if present.
     * @return {boolean} true if the list contained the specified element.
     */
    LinkedList.prototype.remove = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (this.nElements < 1 || util.isUndefined(item)) {
            return false;
        }
        var previous = null;
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                if (previous == null) {
                    this.firstNode = currentNode.next;
                    if (currentNode === this.lastNode) {
                        this.lastNode = null;
                    }
                }
                else if (currentNode === this.lastNode) {
                    this.lastNode = previous;
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                else {
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                this.nElements--;
                return true;
            }
            previous = currentNode;
            currentNode = currentNode.next;
        }
        return false;
    };
    /**
     * Removes all of the elements from this list.
     */
    LinkedList.prototype.clear = function () {
        this.firstNode = null;
        this.lastNode = null;
        this.nElements = 0;
    };
    /**
     * Returns true if this list is equal to the given list.
     * Two lists are equal if they have the same elements in the same order.
     * @param {LinkedList} other the other list.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function used to check if two elements are equal. If the elements in the lists
     * are custom objects you should provide a function, otherwise
     * the === operator is used to check equality between elements.
     * @return {boolean} true if this list is equal to the given list.
     */
    LinkedList.prototype.equals = function (other, equalsFunction) {
        var eqF = equalsFunction || util.defaultEquals;
        if (!(other instanceof LinkedList)) {
            return false;
        }
        if (this.size() !== other.size()) {
            return false;
        }
        return this.equalsAux(this.firstNode, other.firstNode, eqF);
    };
    /**
    * @private
    */
    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {
        while (n1 !== null && n2 !== null) {
            if (!eqF(n1.element, n2.element)) {
                return false;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    };
    /**
     * Removes the element at the specified position in this list.
     * @param {number} index given index.
     * @return {*} removed element or undefined if the index is out of bounds.
     */
    LinkedList.prototype.removeElementAtIndex = function (index) {
        if (index < 0 || index >= this.nElements || this.firstNode === null || this.lastNode === null) {
            return undefined;
        }
        var element;
        if (this.nElements === 1) {
            //First node in the list.
            element = this.firstNode.element;
            this.firstNode = null;
            this.lastNode = null;
        }
        else {
            var previous = this.nodeAtIndex(index - 1);
            if (previous === null) {
                element = this.firstNode.element;
                this.firstNode = this.firstNode.next;
            }
            else if (previous.next === this.lastNode) {
                element = this.lastNode.element;
                this.lastNode = previous;
            }
            if (previous !== null && previous.next !== null) {
                element = previous.next.element;
                previous.next = previous.next.next;
            }
        }
        this.nElements--;
        return element;
    };
    /**
     * Executes the provided function once for each element present in this list in order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    LinkedList.prototype.forEach = function (callback) {
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (callback(currentNode.element) === false) {
                break;
            }
            currentNode = currentNode.next;
        }
    };
    /**
     * Reverses the order of the elements in this linked list (makes the last
     * element first, and the first element last).
     */
    LinkedList.prototype.reverse = function () {
        var previous = null;
        var current = this.firstNode;
        var temp = null;
        while (current !== null) {
            temp = current.next;
            current.next = previous;
            previous = current;
            current = temp;
        }
        temp = this.firstNode;
        this.firstNode = this.lastNode;
        this.lastNode = temp;
    };
    /**
     * Returns an array containing all of the elements in this list in proper
     * sequence.
     * @return {Array.<*>} an array containing all of the elements in this list,
     * in proper sequence.
     */
    LinkedList.prototype.toArray = function () {
        var array = [];
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            array.push(currentNode.element);
            currentNode = currentNode.next;
        }
        return array;
    };
    /**
     * Returns the number of elements in this list.
     * @return {number} the number of elements in this list.
     */
    LinkedList.prototype.size = function () {
        return this.nElements;
    };
    /**
     * Returns true if this list contains no elements.
     * @return {boolean} true if this list contains no elements.
     */
    LinkedList.prototype.isEmpty = function () {
        return this.nElements <= 0;
    };
    LinkedList.prototype.toString = function () {
        return arrays.toString(this.toArray());
    };
    /**
     * @private
     */
    LinkedList.prototype.nodeAtIndex = function (index) {
        if (index < 0 || index >= this.nElements) {
            return null;
        }
        if (index === (this.nElements - 1)) {
            return this.lastNode;
        }
        var node = this.firstNode;
        for (var i = 0; i < index && node != null; i++) {
            node = node.next;
        }
        return node;
    };
    /**
     * @private
     */
    LinkedList.prototype.createNode = function (item) {
        return {
            element: item,
            next: null
        };
    };
    return LinkedList;
}()); // End of linked list
exports.default = LinkedList;

},{"./arrays":8,"./util":9}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinkedList_1 = require("./LinkedList");
var Queue = /** @class */ (function () {
    /**
     * Creates an empty queue.
     * @class A queue is a First-In-First-Out (FIFO) data structure, the first
     * element added to the queue will be the first one to be removed. This
     * implementation uses a linked list as a container.
     * @constructor
     */
    function Queue() {
        this.list = new LinkedList_1.default();
    }
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.enqueue = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.add = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Retrieves and removes the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.dequeue = function () {
        if (this.list.size() !== 0) {
            var el = this.list.first();
            this.list.removeElementAtIndex(0);
            return el;
        }
        return undefined;
    };
    /**
     * Retrieves, but does not remove, the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.peek = function () {
        if (this.list.size() !== 0) {
            return this.list.first();
        }
        return undefined;
    };
    /**
     * Returns the number of elements in this queue.
     * @return {number} the number of elements in this queue.
     */
    Queue.prototype.size = function () {
        return this.list.size();
    };
    /**
     * Returns true if this queue contains the specified element.
     * <p>If the elements inside this stack are
     * not comparable with the === operator, a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName (pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} elem element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function to check if two elements are equal.
     * @return {boolean} true if this queue contains the specified element,
     * false otherwise.
     */
    Queue.prototype.contains = function (elem, equalsFunction) {
        return this.list.contains(elem, equalsFunction);
    };
    /**
     * Checks if this queue is empty.
     * @return {boolean} true if and only if this queue contains no items; false
     * otherwise.
     */
    Queue.prototype.isEmpty = function () {
        return this.list.size() <= 0;
    };
    /**
     * Removes all of the elements from this queue.
     */
    Queue.prototype.clear = function () {
        this.list.clear();
    };
    /**
     * Executes the provided function once for each element present in this queue in
     * FIFO order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    Queue.prototype.forEach = function (callback) {
        this.list.forEach(callback);
    };
    return Queue;
}()); // End of queue
exports.default = Queue;

},{"./LinkedList":6}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
/**
 * Returns the position of the first occurrence of the specified item
 * within the specified array.4
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the first occurrence of the specified element
 * within the specified array, or -1 if not found.
 */
function indexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.indexOf = indexOf;
/**
 * Returns the position of the last occurrence of the specified element
 * within the specified array.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the last occurrence of the specified element
 * within the specified array or -1 if not found.
 */
function lastIndexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = length - 1; i >= 0; i--) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.lastIndexOf = lastIndexOf;
/**
 * Returns true if the specified array contains the specified element.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the specified array contains the specified element.
 */
function contains(array, item, equalsFunction) {
    return indexOf(array, item, equalsFunction) >= 0;
}
exports.contains = contains;
/**
 * Removes the first ocurrence of the specified element from the specified array.
 * @param {*} array the array in which to search element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the array changed after this call.
 */
function remove(array, item, equalsFunction) {
    var index = indexOf(array, item, equalsFunction);
    if (index < 0) {
        return false;
    }
    array.splice(index, 1);
    return true;
}
exports.remove = remove;
/**
 * Returns the number of elements in the specified array equal
 * to the specified object.
 * @param {Array} array the array in which to determine the frequency of the element.
 * @param {Object} item the element whose frequency is to be determined.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the number of elements in the specified array
 * equal to the specified object.
 */
function frequency(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    var freq = 0;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            freq++;
        }
    }
    return freq;
}
exports.frequency = frequency;
/**
 * Returns true if the two specified arrays are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number
 * of elements, and all corresponding pairs of elements in the two
 * arrays are equal and are in the same order.
 * @param {Array} array1 one array to be tested for equality.
 * @param {Array} array2 the other array to be tested for equality.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between elemements in the arrays.
 * @return {boolean} true if the two arrays are equal
 */
function equals(array1, array2, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    if (array1.length !== array2.length) {
        return false;
    }
    var length = array1.length;
    for (var i = 0; i < length; i++) {
        if (!equals(array1[i], array2[i])) {
            return false;
        }
    }
    return true;
}
exports.equals = equals;
/**
 * Returns shallow a copy of the specified array.
 * @param {*} array the array to copy.
 * @return {Array} a copy of the specified array
 */
function copy(array) {
    return array.concat();
}
exports.copy = copy;
/**
 * Swaps the elements at the specified positions in the specified array.
 * @param {Array} array The array in which to swap elements.
 * @param {number} i the index of one element to be swapped.
 * @param {number} j the index of the other element to be swapped.
 * @return {boolean} true if the array is defined and the indexes are valid.
 */
function swap(array, i, j) {
    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
        return false;
    }
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
    return true;
}
exports.swap = swap;
function toString(array) {
    return '[' + array.toString() + ']';
}
exports.toString = toString;
/**
 * Executes the provided function once for each element present in this array
 * starting from index 0 to length - 1.
 * @param {Array} array The array in which to iterate.
 * @param {function(Object):*} callback function to execute, it is
 * invoked with one argument: the element value, to break the iteration you can
 * optionally return false.
 */
function forEach(array, callback) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var ele = array_1[_i];
        if (callback(ele) === false) {
            return;
        }
    }
}
exports.forEach = forEach;

},{"./util":9}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
exports.has = function (obj, prop) {
    return _hasOwnProperty.call(obj, prop);
};
/**
 * Default function to compare element order.
 * @function
 */
function defaultCompare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a === b) {
        return 0;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
/**
 * Default function to test equality.
 * @function
 */
function defaultEquals(a, b) {
    return a === b;
}
exports.defaultEquals = defaultEquals;
/**
 * Default function to convert an object to a string.
 * @function
 */
function defaultToString(item) {
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return '$s' + item;
    }
    else {
        return '$o' + item.toString();
    }
}
exports.defaultToString = defaultToString;
/**
* Joins all the properies of the object using the provided join string
*/
function makeString(item, join) {
    if (join === void 0) { join = ','; }
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return item.toString();
    }
    else {
        var toret = '{';
        var first = true;
        for (var prop in item) {
            if (exports.has(item, prop)) {
                if (first) {
                    first = false;
                }
                else {
                    toret = toret + join;
                }
                toret = toret + prop + ':' + item[prop];
            }
        }
        return toret + '}';
    }
}
exports.makeString = makeString;
/**
 * Checks if the given argument is a function.
 * @function
 */
function isFunction(func) {
    return (typeof func) === 'function';
}
exports.isFunction = isFunction;
/**
 * Checks if the given argument is undefined.
 * @function
 */
function isUndefined(obj) {
    return (typeof obj) === 'undefined';
}
exports.isUndefined = isUndefined;
/**
 * Checks if the given argument is a string.
 * @function
 */
function isString(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
}
exports.isString = isString;
/**
 * Reverses a compare function.
 * @function
 */
function reverseCompareFunction(compareFunction) {
    if (isUndefined(compareFunction) || !isFunction(compareFunction)) {
        return function (a, b) {
            if (a < b) {
                return 1;
            }
            else if (a === b) {
                return 0;
            }
            else {
                return -1;
            }
        };
    }
    else {
        return function (d, v) {
            return compareFunction(d, v) * -1;
        };
    }
}
exports.reverseCompareFunction = reverseCompareFunction;
/**
 * Returns an equal function given a compare function.
 * @function
 */
function compareToEquals(compareFunction) {
    return function (a, b) {
        return compareFunction(a, b) === 0;
    };
}
exports.compareToEquals = compareToEquals;

},{}],10:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* /// <reference path="scripting.ts"/> */
const scripting_1 = require("./scripting");
const util_1 = require("typescript-collections/dist/lib/util");
let files = ["../data/university.csv",
    "../data/LastNames.csv"];
let sigma = require('sigma');
window.sigma = sigma;
require('sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes');
require('sigma/plugins/sigma.plugins.animate/sigma.plugins.animate');
require('sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap');
require('sigma/src/middlewares/sigma.middlewares.rescale');
//function for random color
//Taken from https://stackoverflow.com/questions/1484506/random-color-generator
function getRandomColor() {
    var letters = '0123456789ABCDEF';
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
function readFiles() {
    return __awaiter(this, void 0, void 0, function* () {
        let data = [];
        let rows;
        let BuildingList = {};
        let PrefixList = [];
        let returnList = [];
        for (var file of files) {
            let value = yield new Promise(function (resolve, reject) {
                var req = new XMLHttpRequest();
                req.onreadystatechange = function () {
                    if (this.readyState == 4) {
                        if (this.status == 200) {
                            var lines = this.responseText.split(/\n|\r\n/);
                            data.push(lines);
                            resolve(lines);
                        }
                        else {
                            reject(Error(req.statusText));
                        }
                    }
                };
                req.open("GET", file, true);
                req.responseType = "text";
                req.send(null);
            });
        }
        for (let i = 0; i < data[0].length; i++) {
            rows = data[0][i].split(',');
            console.log(rows);
            BuildingList[rows[0]] = scripting_1.getRandNumber(Number(rows[1]), Number(rows[2]));
        }
        PrefixList = data[1];
        for (var key in BuildingList) {
            for (let j = 0; j < BuildingList[key]; j++) {
                if (key != "Exit") {
                    let index = scripting_1.getRandNumber(0, PrefixList.length - 1);
                    returnList.push(PrefixList[index] + " " + key);
                    PrefixList.splice(index, 1);
                }
                else {
                    returnList.push(key);
                }
            }
        }
        return Promise.resolve(returnList);
    });
}
readFiles().then(function (value) {
    var Graph = connectNodes(value);
    InitializeVilillane(Graph);
});
function connectNodes(location) {
    let nodes = {};
    let visited = {};
    for (let i = 0; i < location.length; i++) {
        visited[location[i]] = false;
    }
    let stack = [];
    let rest = [];
    //randomly generate a graph
    for (let i = 0; i < location.length; i++) {
        if ((typeof nodes[location[i]]) === 'undefined') {
            nodes[location[i]] = [];
        }
        for (let j = i + 1; j < location.length; j++) {
            if ((typeof nodes[location[j]]) === 'undefined') {
                nodes[location[j]] = [];
            }
            if (Math.random() < 0.05) {
                nodes[location[i]].push(location[j]);
            }
        }
    }
    //making sure it is connected
    for (let i = 0; i < location.length; i++) {
        if (visited[location[i]] == false) {
            let item = location[i];
            stack.push(location[i]);
            while (stack.length > 0) {
                var cur = stack.pop();
                if (cur !== undefined) {
                    if (visited[cur] == false) {
                        visited[cur] = true;
                        if (Math.random() < 0.3) {
                            item = cur;
                        }
                        for (let val of nodes[cur]) {
                            stack.push(val);
                        }
                    }
                }
            }
            rest.push(item);
        }
    }
    for (let i = 0; i < rest.length - 1; i++) {
        nodes[rest[i]].push(rest[i + 1]);
    }
    return nodes;
}
function visualize(Graph) {
    //for custom shapes
    sigma.canvas.nodes.border = function (node, context, settings) {
        var prefix = settings('prefix') || '';
        context.fillStyle = node.color || settings('defaultNodeColor');
        context.beginPath();
        context.arc(node[prefix + 'x'], node[prefix + 'y'], node[prefix + 'size'], 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
        // Adding a border
        context.lineWidth = node.borderWidth || 2;
        context.strokeStyle = node.borderColor || '#fff';
        context.stroke();
    };
    //Initialize sigma
    var sigmaInstance = new sigma({
        graph: {
            nodes: [],
            edges: []
        },
        renderer: {
            type: 'canvas',
            container: 'graph-container'
        },
        settings: {
            defaultNodeColor: '#000',
            defaultNodeType: 'border',
            defaultLabelColor: '#fff',
            labelThreshold: 100,
            defaultEdgeColor: '#fff',
            edgeColor: 'default'
        }
    });
    var edgeID = 0;
    for (var locations in Graph) {
        sigmaInstance.graph.addNode({
            // Main attributes:
            id: locations,
            label: locations,
            x: Math.random(),
            y: Math.random(),
            size: 17,
            borderColor: getRandomColor()
        });
    }
    for (var locations in Graph) {
        let adjacent = Graph[locations];
        for (var adj of adjacent) {
            sigmaInstance.graph.addEdge({
                id: 'e' + (edgeID++).toString(),
                source: locations,
                target: adj,
                size: 10
            });
        }
    }
    var dragListener = sigma.plugins.dragNodes(sigmaInstance, sigmaInstance.renderers[0]);
    dragListener.bind('startdrag', function (event) {
        console.log(event);
    });
    dragListener.bind('drag', function (event) {
        console.log(event);
    });
    dragListener.bind('drop', function (event) {
        console.log(event);
    });
    dragListener.bind('dragend', function (event) {
        console.log(event);
    });
    sigmaInstance.refresh();
    var config = {
        nodeMargin: 20,
        gridSize: 5,
    };
    //Configure the algorithm
    var listener = sigmaInstance.configNoverlap(config);
    //Bind all events:
    listener.bind('start stop interpolate', function (event) {
        console.log(event.type);
    });
    //Start the algorithm:
    sigmaInstance.startNoverlap();
}
function InitializeVilillane(Graph) {
    for (let key in Graph) {
        scripting_1.addLocation(key, Graph[key]);
    }
    var locations = Object.keys(Graph);
    // agents
    var alien = scripting_1.addAgent("Alien");
    // items
    var randomLocation = [];
    for (let i = 0; i < 4; i++) {
        var index = scripting_1.getRandNumber(0, locations.length - 1);
        randomLocation.push(locations[index]);
        locations.splice(index, 1);
    }
    console.log("loc1:" + randomLocation[0]);
    console.log("loc2:" + randomLocation[1]);
    var crewCard1 = scripting_1.addItem("Crew card1");
    var crewCard2 = scripting_1.addItem("Crew card2");
    scripting_1.setItemVariable(crewCard1, "currentLocation", randomLocation[0]);
    scripting_1.setItemVariable(crewCard2, "currentLocation", randomLocation[1]);
    // variables
    //alien
    scripting_1.setAgentVariable(alien, "currentLocation", randomLocation[2]);
    //player
    var playerLocation = scripting_1.setVariable("playerLocation", randomLocation[3]);
    var crewCardsCollected = scripting_1.setVariable("crewCardsCollected", 0);
    // 2. Define BTs
    // create ground actions
    //Recover location array
    locations = Object.keys(Graph);
    let setRandNumber = scripting_1.action(() => true, () => {
        scripting_1.setVariable("randNumber", scripting_1.getRandNumber(1, locations.length));
    }, 0);
    var BTlist = [];
    let id = 0;
    for (let i = 0; i < locations.length; i++) {
        //console.log(locations[i]);
        let actions = scripting_1.action(() => scripting_1.getVariable("randNumber") == i + 1, () => scripting_1.setVariable("destination", locations[i]), 0);
        BTlist.push(actions);
    }
    let atDestination = () => scripting_1.getVariable("destination") == scripting_1.getAgentVariable(alien, "currentLocation");
    let setDestinationPrecond = () => scripting_1.isVariableNotSet("destination") || atDestination();
    // create behavior trees
    let setNextDestination = scripting_1.sequence([
        setRandNumber,
        scripting_1.selector(BTlist),
    ]);
    let gotoNextLocation = scripting_1.action(() => true, () => {
        scripting_1.setAgentVariable(alien, "currentLocation", scripting_1.getNextLocation(scripting_1.getAgentVariable(alien, "currentLocation"), scripting_1.getVariable("destination")));
        console.log("Alien is at: " + scripting_1.getAgentVariable(alien, "currentLocation"));
    }, 0);
    let eatPlayer = scripting_1.action(() => scripting_1.getAgentVariable(alien, "currentLocation") == scripting_1.getVariable(playerLocation), () => {
        scripting_1.setVariable("endGame", "lose");
        scripting_1.setVariable(playerLocation, "NA");
    }, 0);
    let search = scripting_1.sequence([
        scripting_1.selector([
            scripting_1.guard(setDestinationPrecond, setNextDestination),
            scripting_1.action(() => true, () => {
            }, 0)
        ]),
        gotoNextLocation,
    ]);
    let alienBT = scripting_1.selector([
        eatPlayer,
        scripting_1.sequence([
            search, eatPlayer
        ])
    ]);
    //attach behaviour trees to agents
    scripting_1.attachTreeToAgent(alien, alienBT);
    // 3. Construct story
    // create user actions
    for (let key in scripting_1.locationGraph) {
        let seq = [];
        seq.push(scripting_1.displayDescriptionAction("You enter the " + key + "."));
        seq.push(scripting_1.addUserAction("Stay where you are.", () => { }));
        for (let adj of scripting_1.locationGraph[key]) {
            seq.push(scripting_1.addUserAction("Enter the " + adj + ".", () => scripting_1.setVariable(playerLocation, adj)));
        }
        var StateBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == key, scripting_1.sequence(seq));
        scripting_1.addUserInteractionTree(StateBT);
    }
    var crewCard1BT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == scripting_1.getItemVariable(crewCard1, "currentLocation"), scripting_1.sequence([
        scripting_1.displayDescriptionAction("You notice a crew card lying around."),
        scripting_1.addUserActionTree("Pick up the crew card", scripting_1.sequence([
            scripting_1.action(() => true, () => {
                scripting_1.displayActionEffectText("You pick up the crew card.");
                scripting_1.setItemVariable(crewCard1, "currentLocation", "player");
                scripting_1.setVariable(crewCardsCollected, scripting_1.getVariable(crewCardsCollected) + 1);
            }, 0),
            scripting_1.action(() => true, () => {
                scripting_1.displayActionEffectText("Wow you know how to pick up things.");
            }, 0)
        ]))
    ]));
    var crewCard2BT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == scripting_1.getItemVariable(crewCard2, "currentLocation"), scripting_1.sequence([
        scripting_1.displayDescriptionAction("You notice a crew card lying around."),
        scripting_1.addUserAction("Pick up the crew card", () => {
            scripting_1.displayActionEffectText("You pick up the crew card.");
            scripting_1.setItemVariable(crewCard2, "currentLocation", "player");
            scripting_1.setVariable(crewCardsCollected, scripting_1.getVariable(crewCardsCollected) + 1);
        })
    ]));
    scripting_1.addUserInteractionTree(crewCard1BT);
    scripting_1.addUserInteractionTree(crewCard2BT);
    var alienNearby = scripting_1.guard(() => scripting_1.areAdjacent(scripting_1.getVariable(playerLocation), scripting_1.getAgentVariable(alien, "currentLocation")), scripting_1.displayDescriptionAction("You hear a thumping sound. The alien is nearby."));
    scripting_1.addUserInteractionTree(alienNearby);
    var gameOver = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == "NA", scripting_1.selector([
        scripting_1.guard(() => scripting_1.getVariable("endGame") == "win", scripting_1.displayDescriptionAction("You have managed to escape!")),
        scripting_1.guard(() => scripting_1.getVariable("endGame") == "lose", scripting_1.displayDescriptionAction("The creature grabs you before you can react! You struggle for a bit before realising it's all over.."))
    ]));
    scripting_1.addUserInteractionTree(gameOver);
    //Initialize sigma
    //for custom shapes
    sigma.canvas.nodes.border = function (node, context, settings) {
        var prefix = settings('prefix') || '';
        context.fillStyle = node.color || settings('defaultNodeColor');
        context.beginPath();
        context.arc(node[prefix + 'x'], node[prefix + 'y'], node[prefix + 'size'], 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
        // Adding a border
        context.lineWidth = node.borderWidth || 2;
        context.strokeStyle = node.borderColor || '#fff';
        context.stroke();
    };
    //Initialize sigma
    var sigmaInstance = new sigma({
        graph: {
            nodes: [],
            edges: []
        },
        renderer: {
            type: 'canvas',
            container: 'graph-container'
        },
        settings: {
            defaultNodeColor: '#000',
            defaultNodeType: 'border',
            defaultLabelColor: '#fff',
            labelThreshold: 100,
            defaultEdgeColor: '#fff',
            edgeColor: 'default'
        }
    });
    var edgeID = 0;
    for (var locs in Graph) {
        sigmaInstance.graph.addNode({
            // Main attributes:
            id: locs,
            label: locs,
            x: Math.random(),
            y: Math.random(),
            size: 17,
            borderColor: getRandomColor()
        });
    }
    for (var locs in Graph) {
        let adjacent = Graph[locs];
        for (var adj of adjacent) {
            sigmaInstance.graph.addEdge({
                id: 'e' + (edgeID++).toString(),
                source: locs,
                target: adj,
                size: 10
            });
        }
    }
    var dragListener = sigma.plugins.dragNodes(sigmaInstance, sigmaInstance.renderers[0]);
    dragListener.bind('startdrag', function (event) {
        console.log(event);
    });
    dragListener.bind('drag', function (event) {
        console.log(event);
    });
    dragListener.bind('drop', function (event) {
        console.log(event);
    });
    dragListener.bind('dragend', function (event) {
        console.log(event);
    });
    //4. Run the world
    scripting_1.initialize();
    var userInteractionObject = scripting_1.getUserInteractionObject();
    //RENDERING-----
    //var displayPanel = {x: 500, y: 0};
    var textPanel = { x: 400, y: 425 };
    var actionsPanel = { x: 420, y: 475 };
    function render() {
        let alienLocation = scripting_1.getAgentVariable(alien, "currentLocation");
        let playerL = scripting_1.getVariable(playerLocation);
        for (var node of sigmaInstance.graph.nodes()) {
            node.color = '#000';
        }
        sigmaInstance.graph.nodes(alienLocation).color = '#0efa76';
        if (!util_1.isUndefined(sigmaInstance.graph.nodes(playerL))) {
            sigmaInstance.graph.nodes(playerL).color = '#f0f';
        }
        sigmaInstance.refresh();
        var config = {
            nodeMargin: 20,
            gridSize: 5,
        };
        //Configure the algorithm
        var listener = sigmaInstance.configNoverlap(config);
        //Bind all events:
        listener.bind('start stop interpolate', function (event) {
            console.log(event.type);
        });
        //Start the algorithm:
        sigmaInstance.startNoverlap();
        //sigmaInstance.startForceAtlas2();
        displayTextAndActions();
    }
    var canvas = document.getElementById('display');
    var context = canvas.getContext('2d');
    var currentSelection;
    var yOffset = actionsPanel.y + 25;
    var yOffsetIncrement = 50;
    function displayTextAndActions() {
        context.clearRect(textPanel.x, textPanel.y, 1000, 1000);
        yOffset = actionsPanel.y + 25;
        context.font = "15pt Calibri";
        context.fillStyle = 'white';
        console.log("Actions effect text: " + userInteractionObject.actionEffectsText);
        var textToDisplay = userInteractionObject.actionEffectsText.length != 0 ? userInteractionObject.actionEffectsText : userInteractionObject.text;
        context.fillText(textToDisplay, textPanel.x, textPanel.y + 20);
        context.font = "15pt Calibri";
        context.fillStyle = 'white';
        for (var i = 0; i < userInteractionObject.userActionsText.length; i++) {
            var userActionText = userInteractionObject.userActionsText[i];
            context.fillText(userActionText, actionsPanel.x + 20, yOffset);
            if (i == 0) {
                currentSelection = i;
            }
            yOffset += yOffsetIncrement;
        }
        displayArrow();
        console.log("Crew cards: " + scripting_1.getVariable(crewCardsCollected));
    }
    function displayArrow() {
        if (userInteractionObject.userActionsText.length != 0) {
            context.clearRect(actionsPanel.x, actionsPanel.y, 20, 1000);
            context.fillText("> ", 420, actionsPanel.y + 25 + (currentSelection * yOffsetIncrement));
        }
    }
    //User input
    function keyPress(e) {
        if (e.keyCode == 13) {
            var selectedAction = userInteractionObject.userActionsText[currentSelection];
            if (!util_1.isUndefined(selectedAction)) {
                scripting_1.executeUserAction(selectedAction);
                scripting_1.worldTick();
                render();
            }
        }
    }
    function keyDown(e) {
        if (e.keyCode == 40) { //down
            if (userInteractionObject.userActionsText.length != 0) {
                currentSelection++;
                currentSelection = currentSelection % userInteractionObject.userActionsText.length;
                displayArrow();
            }
        }
        else if (e.keyCode == 38) { //up
            if (userInteractionObject.userActionsText.length != 0) {
                currentSelection--;
                if (currentSelection < 0)
                    currentSelection = userInteractionObject.userActionsText.length - 1;
                displayArrow();
            }
        }
    }
    render();
    document.addEventListener("keypress", keyPress, false);
    document.addEventListener("keydown", keyDown, false);
}

},{"./scripting":11,"sigma":1,"sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap":2,"sigma/plugins/sigma.plugins.animate/sigma.plugins.animate":3,"sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes":4,"sigma/src/middlewares/sigma.middlewares.rescale":5,"typescript-collections/dist/lib/util":9}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("typescript-collections/dist/lib/Queue");
const util_1 = require("typescript-collections/dist/lib/util");
let sigma = require('sigma');
window.sigma = sigma;
require('sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes');
require('sigma/plugins/sigma.plugins.animate/sigma.plugins.animate');
require('sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap');
var Status;
(function (Status) {
    Status[Status["RUNNING"] = 0] = "RUNNING";
    Status[Status["SUCCESS"] = 1] = "SUCCESS";
    Status[Status["FAILURE"] = 2] = "FAILURE";
})(Status = exports.Status || (exports.Status = {}));
function terminateAndReturn(id, blackboard, status) {
    delete blackboard[id];
    return status;
}
var blackboard = {};
function getActionTick(id) {
    return (precondition, effect, ticksRequired = 1) => {
        return () => {
            if (precondition()) {
                if (!blackboard[id]) {
                    blackboard[id] = {};
                    blackboard[id].ticksDone = ticksRequired;
                }
                if (blackboard[id].ticksDone > 0) {
                    blackboard[id].ticksDone--;
                    return Status.RUNNING;
                }
                else {
                    effect();
                    return terminateAndReturn(id, blackboard, Status.SUCCESS);
                }
            }
            else {
                return Status.FAILURE;
            }
        };
    };
}
function getGuardTick() {
    return (precondition, astTick, negate = false) => {
        return () => {
            let proceed = negate ? !precondition() : precondition();
            return proceed ? execute(astTick) : Status.FAILURE;
        };
    };
}
function getSequenceTick(id) {
    return (astTicks) => {
        return () => {
            if (!blackboard[id]) {
                blackboard[id] = {};
                blackboard[id].currentIndex = 0;
            }
            while (blackboard[id].currentIndex < astTicks.length) {
                var childStatus = execute(astTicks[blackboard[id].currentIndex]);
                if (childStatus == Status.RUNNING)
                    return Status.RUNNING;
                else if (childStatus == Status.FAILURE)
                    return terminateAndReturn(id, blackboard, Status.FAILURE);
                else if (childStatus == Status.SUCCESS)
                    blackboard[id].currentIndex += 1;
            }
            return terminateAndReturn(id, blackboard, Status.SUCCESS);
        };
    };
}
function getSelectorTick(id) {
    return (astTicks) => {
        return () => {
            if (!blackboard[id]) {
                blackboard[id] = {};
                blackboard[id].currentIndex = 0;
            }
            while (blackboard[id].currentIndex < astTicks.length) {
                var childStatus = execute(astTicks[blackboard[id].currentIndex]);
                if (childStatus == Status.RUNNING)
                    return Status.RUNNING;
                else if (childStatus == Status.SUCCESS)
                    return terminateAndReturn(id, blackboard, Status.SUCCESS);
                else if (childStatus == Status.FAILURE)
                    blackboard[id].currentIndex += 1;
            }
            return terminateAndReturn(id, blackboard, Status.FAILURE);
        };
    };
}
function execute(astTick) {
    return astTick();
}
exports.execute = execute;
var globalIdCounter = 0;
function action(precondition, effect, ticksRequired) {
    return getActionTick(globalIdCounter++)(precondition, effect, ticksRequired);
}
exports.action = action;
function guard(precondition, astTick) {
    return getGuardTick()(precondition, astTick);
}
exports.guard = guard;
function neg_guard(precondition, astTick) {
    return getGuardTick()(precondition, astTick, true);
}
exports.neg_guard = neg_guard;
/**
 * Cycles over its children: iterates to the next child on success of a child
 * Succeeds if all succeed, else fails
 * @param {Tick[]} astTicks
 * @returns {Tick}
 */
function sequence(astTicks) {
    return getSequenceTick(globalIdCounter++)(astTicks);
}
exports.sequence = sequence;
/**
 * Cycles over its children: iterates to the next child on failure of a child(think of it as if-else blocks)
 * Succeeds if even one succeeds, else fails
 * @param {Tick[]} astTicks
 * @returns {Tick}
 */
function selector(astTicks) {
    return getSelectorTick(globalIdCounter++)(astTicks);
}
exports.selector = selector;
/*--------------- APIs --------------- */
//0. utilities
// min and max are inclusive
function getRandNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
exports.getRandNumber = getRandNumber;
//1. story instance
//1.1 locations
exports.locationGraph = {};
//add to both sides
function addLocation(locationName, adjacentLocations) {
    if (exports.locationGraph[locationName] == undefined) {
        exports.locationGraph[locationName] = [];
    }
    exports.locationGraph[locationName] = exports.locationGraph[locationName].concat(adjacentLocations);
    for (var i = 0; i < adjacentLocations.length; i++) {
        if (exports.locationGraph[adjacentLocations[i]] == undefined) {
            exports.locationGraph[adjacentLocations[i]] = [];
        }
        exports.locationGraph[adjacentLocations[i]].push(locationName);
    }
}
exports.addLocation = addLocation;
function areAdjacent(location1, location2) {
    console.log("Are adjacent: " + location1 + ", " + location2);
    if (exports.locationGraph[location1] == undefined || exports.locationGraph[location2] == undefined) {
        console.log("Either one/both locations undefined");
        return false;
    }
    for (var i = 0; i < exports.locationGraph[location1].length; i++) {
        if (exports.locationGraph[location1][i] == location2) {
            return true;
        }
    }
    return false;
}
exports.areAdjacent = areAdjacent;
//pathfinding primitives
function getNextLocation(start, destination) {
    var visited = {};
    var previous = {};
    for (var key in exports.locationGraph) {
        visited[key] = false;
    }
    visited[start] = true;
    var myQueue = new Queue_1.default();
    myQueue.enqueue(start);
    while (!myQueue.isEmpty()) {
        var current = myQueue.dequeue();
        if (current === destination) {
            break;
        }
        var neighbors = exports.locationGraph[current];
        for (var i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                myQueue.enqueue(neighbors[i]);
                visited[neighbors[i]] = true;
                previous[neighbors[i]] = current;
            }
        }
    }
    var current = destination;
    if (current == start)
        return current;
    while (previous[current] != start) {
        current = previous[current];
    }
    return current;
}
exports.getNextLocation = getNextLocation;
//1.2 agents
var agents = [];
function addAgent(agentName) {
    agents.push(agentName);
    return agentName;
}
exports.addAgent = addAgent;
//1.3 items
var items = [];
function addItem(itemName) {
    items.push(itemName);
    return itemName;
}
exports.addItem = addItem;
//1.4 variables
var variables = {};
var agentVariables = {};
var itemVariables = {};
function setVariable(varName, value) {
    variables[varName] = value;
    return varName;
}
exports.setVariable = setVariable;
function setAgentVariable(agent, varName, value) {
    if (util_1.isUndefined(agentVariables[agent]))
        agentVariables[agent] = {};
    agentVariables[agent][varName] = value;
    return value;
}
exports.setAgentVariable = setAgentVariable;
function getVariable(varName) {
    if (util_1.isUndefined(variables[varName])) {
        console.log("Variable " + varName + " not set!");
        return;
    }
    return variables[varName];
}
exports.getVariable = getVariable;
function getAgentVariable(agent, varName) {
    if (util_1.isUndefined(agentVariables[agent]) || util_1.isUndefined(agentVariables[agent][varName])) {
        console.log("Variable " + varName + " for agent " + agent + " not set!");
        return;
    }
    return agentVariables[agent][varName];
}
exports.getAgentVariable = getAgentVariable;
function isVariableNotSet(varName) {
    return util_1.isUndefined(variables[varName]);
}
exports.isVariableNotSet = isVariableNotSet;
function isAgentVariableNotSet(agent, varName) {
    return util_1.isUndefined(agentVariables[agent]) || util_1.isUndefined(agentVariables[agent][varName]);
}
exports.isAgentVariableNotSet = isAgentVariableNotSet;
function setItemVariable(item, varName, value) {
    if (util_1.isUndefined(itemVariables[item]))
        itemVariables[item] = {};
    itemVariables[item][varName] = value;
    return value;
}
exports.setItemVariable = setItemVariable;
function getItemVariable(item, varName) {
    if (util_1.isUndefined(itemVariables[item]) || util_1.isUndefined(itemVariables[item][varName])) {
        console.log("Variable " + varName + " for item " + item + " not set!");
        return;
    }
    return itemVariables[item][varName];
}
exports.getItemVariable = getItemVariable;
//2
//agent-behavior tree mapping
var agentTrees = {};
function attachTreeToAgent(agent, tree) {
    agentTrees[agent] = tree;
}
exports.attachTreeToAgent = attachTreeToAgent;
//3.1
//user actions
//TODO add variables to user action texts
var userInteractionObject = {
    text: "",
    userActionsText: [],
    actionEffectsText: ""
};
var userInteractionTrees = [];
var userActions = {};
function runUserInteractionTrees() {
    userInteractionObject.text = "";
    userInteractionObject.userActionsText = [];
    userActions = {}; //{"Go to location X" : effect
    for (var i = 0; i < userInteractionTrees.length; i++) {
        execute(userInteractionTrees[i]);
    }
}
exports.displayDescriptionAction = (text) => action(() => true, () => userInteractionObject.text += "\n" + text, 0);
exports.displayActionEffectText = (text) => userInteractionObject.actionEffectsText += "\n" + text;
exports.addUserActionTree = (text, effectTree) => action(() => true, () => mapUserActionToTree(text, effectTree), 0);
exports.addUserAction = (text, effect) => action(() => true, () => mapUserActionToTree(text, action(() => true, effect, 0)), 0);
function mapUserActionToTree(text, tree) {
    userActions[text] = tree;
    userInteractionObject.userActionsText.push(text);
}
function addUserInteractionTree(tick) {
    userInteractionTrees.push(tick);
}
exports.addUserInteractionTree = addUserInteractionTree;
function executeUserAction(text) {
    //execute the user action
    userInteractionObject.actionEffectsText = "";
    var userActionEffectTree = userActions[text];
    execute(userActionEffectTree);
}
exports.executeUserAction = executeUserAction;
//4.
function initialize() {
    runUserInteractionTrees();
}
exports.initialize = initialize;
function getUserInteractionObject() {
    return userInteractionObject;
}
exports.getUserInteractionObject = getUserInteractionObject;
function worldTick() {
    //all agent ticks
    for (var i = 0; i < agents.length; i++) {
        var tree = agentTrees[agents[i]];
        if (!util_1.isUndefined(tree)) {
            setVariable("executingAgent", agents[i]);
            execute(tree);
        }
    }
    runUserInteractionTrees();
}
exports.worldTick = worldTick;

},{"sigma":1,"sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap":2,"sigma/plugins/sigma.plugins.animate/sigma.plugins.animate":3,"sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes":4,"typescript-collections/dist/lib/Queue":7,"typescript-collections/dist/lib/util":9}]},{},[10])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvc2lnbWEvYnVpbGQvc2lnbWEucmVxdWlyZS5qcyIsIm5vZGVfbW9kdWxlcy9zaWdtYS9wbHVnaW5zL3NpZ21hLmxheW91dC5ub3ZlcmxhcC9zaWdtYS5sYXlvdXQubm92ZXJsYXAuanMiLCJub2RlX21vZHVsZXMvc2lnbWEvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmFuaW1hdGUvc2lnbWEucGx1Z2lucy5hbmltYXRlLmpzIiwibm9kZV9tb2R1bGVzL3NpZ21hL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMuanMiLCJub2RlX21vZHVsZXMvc2lnbWEvc3JjL21pZGRsZXdhcmVzL3NpZ21hLm1pZGRsZXdhcmVzLnJlc2NhbGUuanMiLCJub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1jb2xsZWN0aW9ucy9kaXN0L2xpYi9MaW5rZWRMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvUXVldWUuanMiLCJub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1jb2xsZWN0aW9ucy9kaXN0L2xpYi9hcnJheXMuanMiLCJub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1jb2xsZWN0aW9ucy9kaXN0L2xpYi91dGlsLmpzIiwic3JjL2lzb2xhdGlvbi50cyIsInNyYy9zY3JpcHRpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV5WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVJQSwwQ0FBMEM7QUFDMUMsMkNBTXFCO0FBQ3JCLCtEQUFpRTtBQUVqRSxJQUFJLEtBQUssR0FBRyxDQUFDLHdCQUF3QjtJQUNqQyx1QkFBdUIsQ0FBQyxDQUFBO0FBRTVCLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN2QixNQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUM1QixPQUFPLENBQUMsK0RBQStELENBQUMsQ0FBQztBQUN6RSxPQUFPLENBQUMsMkRBQTJELENBQUMsQ0FBQztBQUNyRSxPQUFPLENBQUMsMkRBQTJELENBQUMsQ0FBQztBQUNyRSxPQUFPLENBQUMsaURBQWlELENBQUMsQ0FBQztBQUUzRCwyQkFBMkI7QUFDM0IsK0VBQStFO0FBQy9FO0lBQ0ksSUFBSSxPQUFPLEdBQUcsa0JBQWtCLENBQUM7SUFDakMsSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDO0lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDeEIsS0FBSyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ3BEO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVEOztRQUNJLElBQUksSUFBSSxHQUFlLEVBQUUsQ0FBQztRQUMxQixJQUFJLElBQWMsQ0FBQztRQUNuQixJQUFJLFlBQVksR0FBOEIsRUFBRSxDQUFDO1FBQ2pELElBQUksVUFBVSxHQUFhLEVBQUUsQ0FBQztRQUM5QixJQUFJLFVBQVUsR0FBYSxFQUFFLENBQUM7UUFDOUIsS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUU7WUFDcEIsSUFBSSxLQUFLLEdBQUcsTUFBTSxJQUFJLE9BQU8sQ0FBQyxVQUFVLE9BQU8sRUFBRSxNQUFNO2dCQUMvQyxJQUFJLEdBQUcsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO2dCQUMvQixHQUFHLENBQUMsa0JBQWtCLEdBQUc7b0JBQ3JCLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLEVBQUU7d0JBQ3RCLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUU7NEJBQ3BCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzRCQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUNqQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ2xCOzZCQUFNOzRCQUNILE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7eUJBQ2pDO3FCQUNKO2dCQUNMLENBQUMsQ0FBQTtnQkFDRCxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzVCLEdBQUcsQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDO2dCQUMxQixHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ25CLENBQUMsQ0FDSixDQUFDO1NBQ0w7UUFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNyQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xCLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyx5QkFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzRTtRQUNELFVBQVUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckIsS0FBSyxJQUFJLEdBQUcsSUFBSSxZQUFZLEVBQUU7WUFDMUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDeEMsSUFBRyxHQUFHLElBQUksTUFBTSxFQUFFO29CQUNkLElBQUksS0FBSyxHQUFHLHlCQUFhLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3BELFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztvQkFDL0MsVUFBVSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQy9CO3FCQUFJO29CQUNELFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQ3hCO2FBQ0o7U0FDSjtRQUNELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN2QyxDQUFDO0NBQUE7QUFFRCxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLO0lBQzVCLElBQUksS0FBSyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQTtBQUdGLHNCQUFzQixRQUFrQjtJQUNwQyxJQUFJLEtBQUssR0FBZ0MsRUFBRSxDQUFDO0lBQzVDLElBQUksT0FBTyxHQUErQixFQUFFLENBQUM7SUFDN0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUNoQztJQUNELElBQUksS0FBSyxHQUFhLEVBQUUsQ0FBQztJQUN6QixJQUFJLElBQUksR0FBYSxFQUFFLENBQUM7SUFFeEIsMkJBQTJCO0lBQzNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUksQ0FBQyxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFdBQVcsRUFBRTtZQUM3QyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFBO1NBQzFCO1FBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzFDLElBQUksQ0FBQyxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLFdBQVcsRUFBRTtnQkFDN0MsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUMzQjtZQUNELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksRUFBRTtnQkFDdEIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN4QztTQUNKO0tBQ0o7SUFDRCw2QkFBNkI7SUFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxFQUFFO1lBQy9CLElBQUksSUFBSSxHQUFXLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvQixLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ3JCLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDdEIsSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO29CQUNuQixJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLEVBQUU7d0JBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7d0JBQ3BCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsRUFBRTs0QkFDckIsSUFBSSxHQUFHLEdBQUcsQ0FBQzt5QkFDZDt3QkFDRCxLQUFLLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTs0QkFDeEIsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzt5QkFDbkI7cUJBQ0o7aUJBQ0o7YUFDSjtZQUNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbkI7S0FDSjtJQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUN0QyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNwQztJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFFRCxtQkFBbUIsS0FBa0M7SUFDckQsbUJBQW1CO0lBQ2YsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLFVBQVUsSUFBUyxFQUFFLE9BQVksRUFBRSxRQUFhO1FBQ3hFLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFdEMsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQy9ELE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsR0FBRyxDQUNQLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQ2xCLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQ2xCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLEVBQ3JCLENBQUMsRUFDRCxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsRUFDWCxJQUFJLENBQ1AsQ0FBQztRQUVGLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFZixrQkFBa0I7UUFDbEIsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQztRQUMxQyxPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDO1FBQ2pELE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNyQixDQUFDLENBQUM7SUFDTixrQkFBa0I7SUFDZCxJQUFJLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQztRQUMxQixLQUFLLEVBQUU7WUFDSCxLQUFLLEVBQUUsRUFBRTtZQUNULEtBQUssRUFBRSxFQUFFO1NBQ1o7UUFDRCxRQUFRLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtZQUNkLFNBQVMsRUFBRSxpQkFBaUI7U0FDL0I7UUFDRCxRQUFRLEVBQUU7WUFDTixnQkFBZ0IsRUFBRSxNQUFNO1lBQ3hCLGVBQWUsRUFBRSxRQUFRO1lBQ3pCLGlCQUFpQixFQUFFLE1BQU07WUFDekIsY0FBYyxFQUFFLEdBQUc7WUFDbkIsZ0JBQWdCLEVBQUUsTUFBTTtZQUN4QixTQUFTLEVBQUUsU0FBUztTQUN2QjtLQUNKLENBQUMsQ0FBQztJQUVILElBQUksTUFBTSxHQUFXLENBQUMsQ0FBQztJQUV2QixLQUFLLElBQUksU0FBUyxJQUFJLEtBQUssRUFBRTtRQUN6QixhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztZQUN4QixtQkFBbUI7WUFDbkIsRUFBRSxFQUFFLFNBQVM7WUFDYixLQUFLLEVBQUUsU0FBUztZQUNoQixDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNoQixDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNoQixJQUFJLEVBQUUsRUFBRTtZQUNSLFdBQVcsRUFBRSxjQUFjLEVBQUU7U0FDaEMsQ0FBQyxDQUFDO0tBQ047SUFDRCxLQUFLLElBQUksU0FBUyxJQUFJLEtBQUssRUFBRTtRQUN6QixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEMsS0FBSyxJQUFJLEdBQUcsSUFBSSxRQUFRLEVBQUU7WUFDdEIsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7Z0JBQ3hCLEVBQUUsRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRTtnQkFDL0IsTUFBTSxFQUFFLFNBQVM7Z0JBQ2pCLE1BQU0sRUFBRSxHQUFHO2dCQUNYLElBQUksRUFBRSxFQUFFO2FBQ1gsQ0FBQyxDQUFBO1NBQ0w7S0FDSjtJQUVELElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUN0QyxhQUFhLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRS9DLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFVBQVUsS0FBYTtRQUNsRCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxLQUFhO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFDSCxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxVQUFVLEtBQWE7UUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUNILFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsS0FBYTtRQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBRXhCLElBQUksTUFBTSxHQUFHO1FBQ1QsVUFBVSxFQUFFLEVBQUU7UUFDZCxRQUFRLEVBQUUsQ0FBQztLQUNkLENBQUM7SUFFTix5QkFBeUI7SUFDckIsSUFBSSxRQUFRLEdBQUcsYUFBYSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUV4RCxrQkFBa0I7SUFDZCxRQUFRLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLFVBQVUsS0FBVTtRQUN4RCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QixDQUFDLENBQUMsQ0FBQztJQUVQLHNCQUFzQjtJQUNsQixhQUFhLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDbEMsQ0FBQztBQUVELDZCQUE2QixLQUFrQztJQUMzRCxLQUFLLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRTtRQUNuQix1QkFBVyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUNoQztJQUNELElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFdkMsU0FBUztJQUNMLElBQUksS0FBSyxHQUFHLG9CQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFbEMsUUFBUTtJQUNKLElBQUksY0FBYyxHQUFhLEVBQUUsQ0FBQztJQUNsQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3hCLElBQUksS0FBSyxHQUFHLHlCQUFhLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbkQsY0FBYyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN0QyxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztLQUM5QjtJQUNELE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXpDLElBQUksU0FBUyxHQUFHLG1CQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDdEMsSUFBSSxTQUFTLEdBQUcsbUJBQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN0QywyQkFBZSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRSwyQkFBZSxDQUFDLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVyRSxZQUFZO0lBRVosT0FBTztJQUVILDRCQUFnQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVsRSxRQUFRO0lBQ0osSUFBSSxjQUFjLEdBQUcsdUJBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RSxJQUFJLGtCQUFrQixHQUFHLHVCQUFXLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFbEUsZ0JBQWdCO0lBQ2hCLHdCQUF3QjtJQUVwQix3QkFBd0I7SUFDeEIsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsSUFBSSxhQUFhLEdBQUcsa0JBQU0sQ0FDdEIsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUNWLEdBQUcsRUFBRTtRQUNELHVCQUFXLENBQUMsWUFBWSxFQUFFLHlCQUFhLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUMsRUFDRCxDQUFDLENBQ0osQ0FBQztJQUVGLElBQUksTUFBTSxHQUFXLEVBQUUsQ0FBQztJQUN4QixJQUFJLEVBQUUsR0FBVyxDQUFDLENBQUM7SUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdkMsNEJBQTRCO1FBQzVCLElBQUksT0FBTyxHQUFTLGtCQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hILE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDeEI7SUFDRCxJQUFJLGFBQWEsR0FBaUIsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSw0QkFBZ0IsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUNqSCxJQUFJLHFCQUFxQixHQUFpQixHQUFHLEVBQUUsQ0FBQyw0QkFBZ0IsQ0FBQyxhQUFhLENBQUMsSUFBSSxhQUFhLEVBQUUsQ0FBQztJQUV2Ryx3QkFBd0I7SUFDcEIsSUFBSSxrQkFBa0IsR0FBRyxvQkFBUSxDQUFDO1FBQzlCLGFBQWE7UUFDYixvQkFBUSxDQUFDLE1BQU0sQ0FBQztLQUNuQixDQUFDLENBQUM7SUFFSCxJQUFJLGdCQUFnQixHQUFHLGtCQUFNLENBQ3pCLEdBQUcsRUFBRSxDQUFDLElBQUksRUFDVixHQUFHLEVBQUU7UUFDRCw0QkFBZ0IsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsMkJBQWUsQ0FBQyw0QkFBZ0IsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsRUFBRSx1QkFBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwSSxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsR0FBRyw0QkFBZ0IsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFBO0lBQzdFLENBQUMsRUFDRCxDQUFDLENBQ0osQ0FBQztJQUVGLElBQUksU0FBUyxHQUFHLGtCQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLElBQUksdUJBQVcsQ0FBQyxjQUFjLENBQUMsRUFDbEcsR0FBRyxFQUFFO1FBQ0QsdUJBQVcsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0IsdUJBQVcsQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdEMsQ0FBQyxFQUFFLENBQUMsQ0FDUCxDQUFDO0lBRUYsSUFBSSxNQUFNLEdBQUcsb0JBQVEsQ0FBQztRQUNsQixvQkFBUSxDQUFDO1lBQ0wsaUJBQUssQ0FBQyxxQkFBcUIsRUFBRSxrQkFBa0IsQ0FBQztZQUNoRCxrQkFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7WUFDeEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNSLENBQUM7UUFDRixnQkFBZ0I7S0FDbkIsQ0FBQyxDQUFDO0lBRUgsSUFBSSxPQUFPLEdBQUcsb0JBQVEsQ0FBQztRQUNuQixTQUFTO1FBQ1Qsb0JBQVEsQ0FBQztZQUNMLE1BQU0sRUFBRSxTQUFTO1NBQ3BCLENBQUM7S0FDTCxDQUFDLENBQUM7SUFFUCxrQ0FBa0M7SUFDOUIsNkJBQWlCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2xDLHFCQUFxQjtJQUNyQixzQkFBc0I7SUFDdEIsS0FBSyxJQUFJLEdBQUcsSUFBSSx5QkFBYSxFQUFFO1FBQzNCLElBQUksR0FBRyxHQUFVLEVBQUUsQ0FBQztRQUNwQixHQUFHLENBQUMsSUFBSSxDQUFDLG9DQUF3QixDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLEdBQUcsQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pELEtBQUssSUFBSSxHQUFHLElBQUkseUJBQWEsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzdGO1FBQ0QsSUFBSSxPQUFPLEdBQUcsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEdBQUcsRUFDeEQsb0JBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ25CLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ25DO0lBR0QsSUFBSSxXQUFXLEdBQUcsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLDJCQUFlLENBQUMsU0FBUyxFQUFFLGlCQUFpQixDQUFDLEVBQ3RHLG9CQUFRLENBQUM7UUFDRCxvQ0FBd0IsQ0FBQyxzQ0FBc0MsQ0FBQztRQUNoRSw2QkFBaUIsQ0FBQyx1QkFBdUIsRUFDckMsb0JBQVEsQ0FBQztZQUNMLGtCQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTtnQkFDcEIsbUNBQXVCLENBQUMsNEJBQTRCLENBQUMsQ0FBQztnQkFDdEQsMkJBQWUsQ0FBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ3hELHVCQUFXLENBQUMsa0JBQWtCLEVBQUUsdUJBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3pFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDTCxrQkFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7Z0JBQ3BCLG1DQUF1QixDQUFDLHFDQUFxQyxDQUFDLENBQUE7WUFDbEUsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNSLENBQUMsQ0FDTDtLQUNKLENBQ0osQ0FBQyxDQUFDO0lBQ1AsSUFBSSxXQUFXLEdBQUcsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLDJCQUFlLENBQUMsU0FBUyxFQUFFLGlCQUFpQixDQUFDLEVBQ3RHLG9CQUFRLENBQUM7UUFDRCxvQ0FBd0IsQ0FBQyxzQ0FBc0MsQ0FBQztRQUNoRSx5QkFBYSxDQUFDLHVCQUF1QixFQUFFLEdBQUcsRUFBRTtZQUN4QyxtQ0FBdUIsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1lBQ3RELDJCQUFlLENBQUMsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3hELHVCQUFXLENBQUMsa0JBQWtCLEVBQUUsdUJBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3pFLENBQUMsQ0FBQztLQUNMLENBQ0osQ0FBQyxDQUFDO0lBQ1Asa0NBQXNCLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDcEMsa0NBQXNCLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFcEMsSUFBSSxXQUFXLEdBQUcsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLEVBQUUsNEJBQWdCLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUMsRUFDOUcsb0NBQXdCLENBQUMsaURBQWlELENBQUMsQ0FBQyxDQUFDO0lBQ2pGLGtDQUFzQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRXBDLElBQUksUUFBUSxHQUFHLGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxjQUFjLENBQUMsSUFBSSxJQUFJLEVBQzFELG9CQUFRLENBQUM7UUFDRCxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsU0FBUyxDQUFDLElBQUksS0FBSyxFQUN2QyxvQ0FBd0IsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQzVELGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxNQUFNLEVBQ3hDLG9DQUF3QixDQUFDLHNHQUFzRyxDQUFDLENBQUM7S0FDeEksQ0FDSixDQUFDLENBQUM7SUFDUCxrQ0FBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUVyQyxrQkFBa0I7SUFFbEIsbUJBQW1CO0lBQ2YsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLFVBQVUsSUFBUyxFQUFFLE9BQVksRUFBRSxRQUFhO1FBQ3hFLElBQUksTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFdEMsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQy9ELE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsR0FBRyxDQUNQLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQ2xCLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQ2xCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLEVBQ3JCLENBQUMsRUFDRCxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsRUFDWCxJQUFJLENBQ1AsQ0FBQztRQUVGLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQixPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFZixrQkFBa0I7UUFDbEIsT0FBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQztRQUMxQyxPQUFPLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDO1FBQ2pELE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNyQixDQUFDLENBQUM7SUFFTixrQkFBa0I7SUFDZCxJQUFJLGFBQWEsR0FBRyxJQUFJLEtBQUssQ0FBQztRQUMxQixLQUFLLEVBQUU7WUFDSCxLQUFLLEVBQUUsRUFBRTtZQUNULEtBQUssRUFBRSxFQUFFO1NBQ1o7UUFDRCxRQUFRLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtZQUNkLFNBQVMsRUFBRSxpQkFBaUI7U0FDL0I7UUFDRCxRQUFRLEVBQUU7WUFDTixnQkFBZ0IsRUFBRSxNQUFNO1lBQ3hCLGVBQWUsRUFBRSxRQUFRO1lBQ3pCLGlCQUFpQixFQUFFLE1BQU07WUFDekIsY0FBYyxFQUFFLEdBQUc7WUFDbkIsZ0JBQWdCLEVBQUUsTUFBTTtZQUN4QixTQUFTLEVBQUUsU0FBUztTQUN2QjtLQUNKLENBQUMsQ0FBQztJQUVILElBQUksTUFBTSxHQUFXLENBQUMsQ0FBQztJQUV2QixLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssRUFBRTtRQUNwQixhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztZQUN4QixtQkFBbUI7WUFDbkIsRUFBRSxFQUFFLElBQUk7WUFDUixLQUFLLEVBQUUsSUFBSTtZQUNYLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLElBQUksRUFBRSxFQUFFO1lBQ1IsV0FBVyxFQUFFLGNBQWMsRUFBRTtTQUNoQyxDQUFDLENBQUM7S0FDTjtJQUNELEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFO1FBQ3BCLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQixLQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRTtZQUN0QixhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDeEIsRUFBRSxFQUFFLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFO2dCQUMvQixNQUFNLEVBQUUsSUFBSTtnQkFDWixNQUFNLEVBQUUsR0FBRztnQkFDWCxJQUFJLEVBQUUsRUFBRTthQUNYLENBQUMsQ0FBQTtTQUNMO0tBQ0o7SUFFRCxJQUFJLFlBQVksR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FDdEMsYUFBYSxFQUFFLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUvQyxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFVLEtBQWE7UUFDbEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUNILFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsS0FBYTtRQUM3QyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxLQUFhO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFDSCxZQUFZLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxVQUFVLEtBQWE7UUFDaEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUdQLGtCQUFrQjtJQUNkLHNCQUFVLEVBQUUsQ0FBQztJQUNiLElBQUkscUJBQXFCLEdBQUcsb0NBQXdCLEVBQUUsQ0FBQztJQUUzRCxnQkFBZ0I7SUFDaEIsb0NBQW9DO0lBQ2hDLElBQUksU0FBUyxHQUFHLEVBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFDLENBQUM7SUFDakMsSUFBSSxZQUFZLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUMsQ0FBQztJQUVwQztRQUNJLElBQUksYUFBYSxHQUFHLDRCQUFnQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQy9ELElBQUksT0FBTyxHQUFHLHVCQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDMUMsS0FBSyxJQUFJLElBQUksSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQzFDLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1NBQ3ZCO1FBQ0QsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztRQUMzRCxJQUFJLENBQUMsa0JBQVcsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1lBQ2xELGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7U0FDckQ7UUFDRCxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDeEIsSUFBSSxNQUFNLEdBQUc7WUFDVCxVQUFVLEVBQUUsRUFBRTtZQUNkLFFBQVEsRUFBRSxDQUFDO1NBQ2QsQ0FBQztRQUVWLHlCQUF5QjtRQUNqQixJQUFJLFFBQVEsR0FBRyxhQUFhLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTVELGtCQUFrQjtRQUNWLFFBQVEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsVUFBVSxLQUFVO1lBQ3hELE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFDO1FBRVgsc0JBQXNCO1FBQ2QsYUFBYSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQzlCLG1DQUFtQztRQUVuQyxxQkFBcUIsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFFRCxJQUFJLE1BQU0sR0FBdUIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRSxJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRDLElBQUksZ0JBQWdCLENBQUM7SUFDckIsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbEMsSUFBSSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFFMUI7UUFDSSxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEQsT0FBTyxHQUFHLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTlCLE9BQU8sQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDO1FBQzlCLE9BQU8sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEdBQUcscUJBQXFCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUMvRSxJQUFJLGFBQWEsR0FBRyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDO1FBQy9JLE9BQU8sQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUUvRCxPQUFPLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztRQUM5QixPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztRQUM1QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNuRSxJQUFJLGNBQWMsR0FBRyxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNSLGdCQUFnQixHQUFHLENBQUMsQ0FBQzthQUN4QjtZQUNELE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQztTQUMvQjtRQUVELFlBQVksRUFBRSxDQUFDO1FBQ2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEdBQUcsdUJBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEO1FBQ0ksSUFBSSxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtZQUNuRCxPQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDNUQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1NBQzVGO0lBQ0wsQ0FBQztJQUVMLFlBQVk7SUFDUixrQkFBa0IsQ0FBQztRQUNmLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUU7WUFDakIsSUFBSSxjQUFjLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDN0UsSUFBSSxDQUFDLGtCQUFXLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQzlCLDZCQUFpQixDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUNsQyxxQkFBUyxFQUFFLENBQUM7Z0JBQ1osTUFBTSxFQUFFLENBQUM7YUFDWjtTQUNKO0lBQ0wsQ0FBQztJQUVELGlCQUFpQixDQUFDO1FBQ2QsSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFJLEVBQUUsRUFBRSxFQUFDLE1BQU07WUFDeEIsSUFBSSxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRTtnQkFDbkQsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDbkIsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQztnQkFDbkYsWUFBWSxFQUFFLENBQUM7YUFDbEI7U0FDSjthQUFNLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUUsRUFBQyxJQUFJO1lBQzdCLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7Z0JBQ25ELGdCQUFnQixFQUFFLENBQUM7Z0JBQ25CLElBQUksZ0JBQWdCLEdBQUcsQ0FBQztvQkFDcEIsZ0JBQWdCLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7Z0JBQ3hFLFlBQVksRUFBRSxDQUFDO2FBQ2xCO1NBQ0o7SUFDTCxDQUFDO0lBRUQsTUFBTSxFQUFFLENBQUM7SUFFVCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN2RCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztBQUN6RCxDQUFDOzs7OztBQ2xsQkQsaUVBQTBEO0FBQzFELCtEQUFpRTtBQUNqRSxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkIsTUFBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDNUIsT0FBTyxDQUFDLCtEQUErRCxDQUFDLENBQUM7QUFDekUsT0FBTyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7QUFDckUsT0FBTyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7QUFFckUsSUFBWSxNQUlYO0FBSkQsV0FBWSxNQUFNO0lBQ2QseUNBQU8sQ0FBQTtJQUNQLHlDQUFPLENBQUE7SUFDUCx5Q0FBTyxDQUFBO0FBQ1gsQ0FBQyxFQUpXLE1BQU0sR0FBTixjQUFNLEtBQU4sY0FBTSxRQUlqQjtBQUVELDRCQUE0QixFQUFVLEVBQUUsVUFBZSxFQUFFLE1BQWM7SUFDbkUsT0FBTyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEIsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQWVELElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUVwQix1QkFBdUIsRUFBVTtJQUM3QixPQUFPLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRSxhQUFhLEdBQUcsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLFlBQVksRUFBRSxFQUFFO2dCQUNoQixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUNqQixVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNwQixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztpQkFDNUM7Z0JBRUQsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRTtvQkFDOUIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO29CQUMzQixPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUM7aUJBQ3pCO3FCQUFNO29CQUNILE1BQU0sRUFBRSxDQUFDO29CQUNULE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzdEO2FBQ0o7aUJBQU07Z0JBQ0gsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO2FBQ3pCO1FBQ0wsQ0FBQyxDQUFBO0lBQ0wsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVEO0lBQ0ksT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFBRSxFQUFFO1FBQzdDLE9BQU8sR0FBRyxFQUFFO1lBQ1IsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN4RCxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3ZELENBQUMsQ0FBQTtJQUNMLENBQUMsQ0FBQTtBQUNMLENBQUM7QUFFRCx5QkFBeUIsRUFBVTtJQUMvQixPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDaEIsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUNqQixVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNwQixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQzthQUNuQztZQUVELE9BQU8sVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFO2dCQUNsRCxJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUVqRSxJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsT0FBTztvQkFDN0IsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO3FCQUNyQixJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsT0FBTztvQkFDbEMsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztxQkFDekQsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQ2xDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO2FBQ3hDO1lBQ0QsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUE7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBRUQseUJBQXlCLEVBQVU7SUFDL0IsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFO1FBQ2hCLE9BQU8sR0FBRyxFQUFFO1lBQ1IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDakIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDcEIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7YUFDbkM7WUFFRCxPQUFPLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRTtnQkFDbEQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFFakUsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQzdCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztxQkFDckIsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQ2xDLE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQ3pELElBQUksV0FBVyxJQUFJLE1BQU0sQ0FBQyxPQUFPO29CQUNsQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQzthQUN4QztZQUNELE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFBO0lBQ0wsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVELGlCQUF3QixPQUFhO0lBQ2pDLE9BQU8sT0FBTyxFQUFFLENBQUM7QUFDckIsQ0FBQztBQUZELDBCQUVDO0FBRUQsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBRXhCLGdCQUF1QixZQUEwQixFQUFFLE1BQWMsRUFBRSxhQUFzQjtJQUNyRixPQUFPLGFBQWEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLFlBQVksRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUE7QUFDaEYsQ0FBQztBQUZELHdCQUVDO0FBRUQsZUFBc0IsWUFBMEIsRUFBRSxPQUFhO0lBQzNELE9BQU8sWUFBWSxFQUFFLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFGRCxzQkFFQztBQUVELG1CQUEwQixZQUEwQixFQUFFLE9BQWE7SUFDL0QsT0FBTyxZQUFZLEVBQUUsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFGRCw4QkFFQztBQUVEOzs7OztHQUtHO0FBQ0gsa0JBQXlCLFFBQWdCO0lBQ3JDLE9BQU8sZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUZELDRCQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxrQkFBeUIsUUFBZ0I7SUFDckMsT0FBTyxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRkQsNEJBRUM7QUFHRCx5Q0FBeUM7QUFHekMsY0FBYztBQUNkLDRCQUE0QjtBQUM1Qix1QkFBOEIsR0FBVyxFQUFFLEdBQVc7SUFDbEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDN0QsQ0FBQztBQUZELHNDQUVDO0FBRUQsbUJBQW1CO0FBRW5CLGVBQWU7QUFDSixRQUFBLGFBQWEsR0FBRyxFQUFFLENBQUM7QUFFOUIsbUJBQW1CO0FBQ25CLHFCQUE0QixZQUFvQixFQUFFLGlCQUEyQjtJQUN6RSxJQUFJLHFCQUFhLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxFQUFFO1FBQzFDLHFCQUFhLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3BDO0lBQ0QscUJBQWEsQ0FBQyxZQUFZLENBQUMsR0FBRyxxQkFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXBGLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsSUFBSSxxQkFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxFQUFFO1lBQ2xELHFCQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDNUM7UUFDRCxxQkFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzFEO0FBQ0wsQ0FBQztBQVpELGtDQVlDO0FBRUQscUJBQTRCLFNBQWlCLEVBQUUsU0FBaUI7SUFDNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsSUFBSSxHQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNELElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEVBQUM7UUFDL0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLHFCQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RELElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLEVBQUM7WUFDekMsT0FBTyxJQUFJLENBQUM7U0FDZjtLQUNKO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQWJELGtDQWFDO0FBRUQsd0JBQXdCO0FBQ3hCLHlCQUFnQyxLQUFhLEVBQUUsV0FBbUI7SUFDOUQsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNsQixLQUFLLElBQUksR0FBRyxJQUFJLHFCQUFhLEVBQUU7UUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUN4QjtJQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7SUFFdEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxlQUFLLEVBQVUsQ0FBQztJQUNsQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXZCLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDdkIsSUFBSSxPQUFPLEdBQVcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3hDLElBQUksT0FBTyxLQUFLLFdBQVcsRUFBRTtZQUN6QixNQUFNO1NBQ1Q7UUFDRCxJQUFJLFNBQVMsR0FBRyxxQkFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXZDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3hCLE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQzdCLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7YUFDcEM7U0FDSjtLQUNKO0lBRUQsSUFBSSxPQUFPLEdBQVcsV0FBVyxDQUFDO0lBQ2xDLElBQUksT0FBTyxJQUFJLEtBQUs7UUFDaEIsT0FBTyxPQUFPLENBQUM7SUFDbkIsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxFQUFFO1FBQy9CLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDL0I7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBbkNELDBDQW1DQztBQUVELFlBQVk7QUFDWixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFFaEIsa0JBQXlCLFNBQWlCO0lBQ3RDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkIsT0FBTyxTQUFTLENBQUM7QUFDckIsQ0FBQztBQUhELDRCQUdDO0FBRUQsV0FBVztBQUNYLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUVmLGlCQUF3QixRQUFnQjtJQUNwQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JCLE9BQU8sUUFBUSxDQUFDO0FBQ3BCLENBQUM7QUFIRCwwQkFHQztBQUVELGVBQWU7QUFDZixJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDbkIsSUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQ3hCLElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUV2QixxQkFBNEIsT0FBZSxFQUFFLEtBQVU7SUFDbkQsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMzQixPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBSEQsa0NBR0M7QUFFRCwwQkFBaUMsS0FBYSxFQUFFLE9BQWUsRUFBRSxLQUFVO0lBQ3ZFLElBQUksa0JBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEMsY0FBYyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUUvQixjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3ZDLE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFORCw0Q0FNQztBQUVELHFCQUE0QixPQUFlO0lBQ3ZDLElBQUksa0JBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUNqQyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxPQUFPLEdBQUcsV0FBVyxDQUFDLENBQUM7UUFDakQsT0FBTztLQUNWO0lBQ0QsT0FBTyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDOUIsQ0FBQztBQU5ELGtDQU1DO0FBRUQsMEJBQWlDLEtBQWEsRUFBRSxPQUFlO0lBQzNELElBQUksa0JBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ25GLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE9BQU8sR0FBRyxhQUFhLEdBQUcsS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFBO1FBQ3hFLE9BQU87S0FDVjtJQUNELE9BQU8sY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFORCw0Q0FNQztBQUVELDBCQUFpQyxPQUFlO0lBQzVDLE9BQU8sa0JBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRkQsNENBRUM7QUFFRCwrQkFBc0MsS0FBYSxFQUFFLE9BQWU7SUFDaEUsT0FBTyxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLGtCQUFXLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDN0YsQ0FBQztBQUZELHNEQUVDO0FBRUQseUJBQWdDLElBQVksRUFBRSxPQUFlLEVBQUUsS0FBVTtJQUNyRSxJQUFJLGtCQUFXLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFFN0IsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNyQyxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDO0FBTkQsMENBTUM7QUFFRCx5QkFBZ0MsSUFBWSxFQUFFLE9BQWU7SUFDekQsSUFBSSxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLGtCQUFXLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDL0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsT0FBTyxHQUFHLFlBQVksR0FBRyxJQUFJLEdBQUcsV0FBVyxDQUFDLENBQUE7UUFDdEUsT0FBTztLQUNWO0lBQ0QsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQU5ELDBDQU1DO0FBR0QsR0FBRztBQUNILDZCQUE2QjtBQUM3QixJQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFFcEIsMkJBQWtDLEtBQWEsRUFBRSxJQUFVO0lBQ3ZELFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDN0IsQ0FBQztBQUZELDhDQUVDO0FBRUQsS0FBSztBQUNMLGNBQWM7QUFDZCx5Q0FBeUM7QUFDekMsSUFBSSxxQkFBcUIsR0FBRztJQUN4QixJQUFJLEVBQUUsRUFBRTtJQUNSLGVBQWUsRUFBRSxFQUFFO0lBQ25CLGlCQUFpQixFQUFFLEVBQUU7Q0FDeEIsQ0FBQTtBQUNELElBQUksb0JBQW9CLEdBQUcsRUFBRSxDQUFDO0FBQzlCLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUVyQjtJQUNJLHFCQUFxQixDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7SUFDaEMscUJBQXFCLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUMzQyxXQUFXLEdBQUcsRUFBRSxDQUFDLENBQUEsOEJBQThCO0lBQy9DLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDbEQsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDcEM7QUFDTCxDQUFDO0FBRVUsUUFBQSx3QkFBd0IsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQ25ELE1BQU0sQ0FDRixHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQ1YsR0FBRyxFQUFFLENBQUMscUJBQXFCLENBQUMsSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUUsQ0FBQyxDQUNyRCxDQUFDO0FBQ0ssUUFBQSx1QkFBdUIsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMscUJBQXFCLENBQUMsaUJBQWlCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztBQUVuRyxRQUFBLGlCQUFpQixHQUFHLENBQUMsSUFBWSxFQUFFLFVBQWdCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FDckUsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUNWLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQ2pELENBQUM7QUFFUyxRQUFBLGFBQWEsR0FBRyxDQUFDLElBQVksRUFBRSxNQUFpQixFQUFFLEVBQUUsQ0FDM0QsTUFBTSxDQUNGLEdBQUcsRUFBRSxDQUFDLElBQUksRUFDVixHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEdBQUUsRUFBRSxDQUFBLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQ2xFLENBQUM7QUFFTiw2QkFBNkIsSUFBWSxFQUFFLElBQVU7SUFDakQsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQztJQUN6QixxQkFBcUIsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3JELENBQUM7QUFFRCxnQ0FBdUMsSUFBVTtJQUM3QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEMsQ0FBQztBQUZELHdEQUVDO0FBRUQsMkJBQWtDLElBQVk7SUFDMUMseUJBQXlCO0lBQ3pCLHFCQUFxQixDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztJQUM3QyxJQUFJLG9CQUFvQixHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBTEQsOENBS0M7QUFFRCxJQUFJO0FBQ0o7SUFDSSx1QkFBdUIsRUFBRSxDQUFDO0FBQzlCLENBQUM7QUFGRCxnQ0FFQztBQUVEO0lBQ0ksT0FBTyxxQkFBcUIsQ0FBQztBQUNqQyxDQUFDO0FBRkQsNERBRUM7QUFFRDtJQUNJLGlCQUFpQjtJQUNqQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNwQyxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLGtCQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEIsV0FBVyxDQUFDLGdCQUFnQixFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtLQUNKO0lBQ0QsdUJBQXVCLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBVkQsOEJBVUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCI7KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9faW5zdGFuY2VzID0ge307XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHNpZ21hIGluc3RhbmNlcyBjb25zdHJ1Y3Rvci4gT25lIGluc3RhbmNlIG9mIHNpZ21hIHJlcHJlc2VudFxuICAgKiBvbmUgZ3JhcGguIEl0IGlzIHBvc3NpYmxlIHRvIHJlcHJlc2VudCB0aGlzIGdyYXDEpSB3aXRoIHNldmVyYWwgcmVuZGVyZXJzXG4gICAqIGF0IHRoZSBzYW1lIHRpbWUuIEJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0IHJlbmRlcmVyIChXZWJHTCArIENhbnZhc1xuICAgKiBwb2x5ZmlsbCkgd2lsbCBiZSB1c2VkIGFzIHRoZSBvbmx5IHJlbmRlcmVyLCB3aXRoIHRoZSBjb250YWluZXIgc3BlY2lmaWVkXG4gICAqIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/Kn0gICAgY29uZiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgaW5zdGFuY2UuIFRoZXJlIGFyZSBhIGxvdCBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnQgcmVjb2duaXplZCBmb3JtcyB0byBpbnN0YW50aWF0ZSBzaWdtYSwgY2hlY2tcbiAgICogICAgICAgICAgICAgICAgICAgICAgZXhhbXBsZSBmaWxlcywgZG9jdW1lbnRhdGlvbiBpbiB0aGlzIGZpbGUgYW5kIHVuaXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgdGVzdHMgdG8ga25vdyBtb3JlLlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICBUaGUgZnJlc2ggbmV3IHNpZ21hIGluc3RhbmNlLlxuICAgKlxuICAgKiBJbnN0YW5jaWF0aW5nIHNpZ21hOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBJZiBubyBwYXJhbWV0ZXIgaXMgZ2l2ZW4gdG8gdGhlIGNvbnN0cnVjdG9yLCB0aGUgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAqIHdpdGhvdXQgYW55IHJlbmRlcmVyIG9yIGNhbWVyYS4gSXQgd2lsbCBqdXN0IGluc3RhbnRpYXRlIHRoZSBncmFwaCwgYW5kXG4gICAqIG90aGVyIG1vZHVsZXMgd2lsbCBoYXZlIHRvIGJlIGluc3RhbnRpYXRlZCB0aHJvdWdoIHRoZSBwdWJsaWMgbWV0aG9kcyxcbiAgICogbGlrZSBcImFkZFJlbmRlcmVyXCIgZXRjOlxuICAgKlxuICAgKiAgPiBzMCA9IG5ldyBzaWdtYSgpO1xuICAgKiAgPiBzMC5hZGRSZW5kZXJlcih7XG4gICAqICA+ICAgdHlwZTogJ2NhbnZhcycsXG4gICAqICA+ICAgY29udGFpbmVyOiAnbXktY29udGFpbmVyLWlkJ1xuICAgKiAgPiB9KTtcbiAgICpcbiAgICogSW4gbW9zdCBvZiB0aGUgY2FzZXMsIHNpZ21hIHdpbGwgc2ltcGx5IGJlIHVzZWQgd2l0aCB0aGUgZGVmYXVsdCByZW5kZXJlci5cbiAgICogVGhlbiwgc2luY2UgdGhlIG9ubHkgcmVxdWlyZWQgcGFyYW1ldGVyIGlzIHRoZSBET00gY29udGFpbmVyLCB0aGVyZSBhcmVcbiAgICogc29tZSBzaW1wbGVyIHdheSB0byBjYWxsIHRoZSBjb25zdHJ1Y3Rvci4gVGhlIGZvdXIgZm9sbG93aW5nIGNhbGxzIGRvIHRoZVxuICAgKiBleGFjdCBzYW1lIHRoaW5nczpcbiAgICpcbiAgICogID4gczEgPSBuZXcgc2lnbWEoJ215LWNvbnRhaW5lci1pZCcpO1xuICAgKiAgPiBzMiA9IG5ldyBzaWdtYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJykpO1xuICAgKiAgPiBzMyA9IG5ldyBzaWdtYSh7XG4gICAqICA+ICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcbiAgICogID4gfSk7XG4gICAqICA+IHM0ID0gbmV3IHNpZ21hKHtcbiAgICogID4gICByZW5kZXJlcnM6IFt7XG4gICAqICA+ICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1jb250YWluZXItaWQnKVxuICAgKiAgPiAgIH1dXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMsIHdoZW4gY2FsbGluZyB0aGVcbiAgICogY29uc3RydWN0b3Igd2l0aCB0byB0b3AgbGV2ZWwgY29uZmlndXJhdGlvbiBvYmplY3QgKGZvdXJ0aCBjYXNlIGluIHRoZVxuICAgKiBwcmV2aW91cyBleGFtcGxlcyk6XG4gICAqXG4gICAqICAgez9zdHJpbmd9IGlkICAgICAgICBUaGUgaWQgb2YgdGhlIGluc3RhbmNlLiBJdCB3aWxsIGJlIGdlbmVyYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljYWxseSBpZiBub3Qgc3BlY2lmaWVkLlxuICAgKiAgIHs/YXJyYXl9ICByZW5kZXJlcnMgQW4gYXJyYXkgY29udGFpbmluZyBvYmplY3RzIGRlc2NyaWJpbmcgcmVuZGVyZXJzLlxuICAgKiAgIHs/b2JqZWN0fSBncmFwaCAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2Ygbm9kZXMgYW5kIGFuIGFycmF5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICBvZiBlZGdlcywgdG8gYXZvaWQgaGF2aW5nIHRvIGFkZCB0aGVtIGJ5IGhhbmQgbGF0ZXIuXG4gICAqICAgez9vYmplY3R9IHNldHRpbmdzICBBbiBvYmplY3QgY29udGFpbmluZyBpbnN0YW5jZSBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9uZXMgZGVmaW5lZCBpbiB0aGUgb2JqZWN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS5zZXR0aW5ncy5cbiAgICovXG4gIHZhciBzaWdtYSA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICAvLyBMb2NhbCB2YXJpYWJsZXM6XG4gICAgLy8gKioqKioqKioqKioqKioqKlxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBjLFxuICAgICAgICBvLFxuICAgICAgICBpZDtcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBQcml2YXRlIGF0dHJpYnV0ZXM6XG4gICAgLy8gKioqKioqKioqKioqKioqKioqKlxuICAgIHZhciBfc2VsZiA9IHRoaXMsXG4gICAgICAgIF9jb25mID0gY29uZiB8fCB7fTtcblxuICAgIC8vIExpdHRsZSBzaG9ydGN1dDpcbiAgICAvLyAqKioqKioqKioqKioqKioqXG4gICAgLy8gVGhlIGNvbmZpZ3VyYXRpb24gaXMgc3VwcG9zZWQgdG8gaGF2ZSBhIGxpc3Qgb2YgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBvYmplY3RzIGZvciBlYWNoIHJlbmRlcmVyLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyBjb25maWd1cmF0aW9uIGF0IGFsbCwgdGhlbiBub3RoaW5nIGlzIGRvbmUuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3QsIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIG9iamVjdCB3aWxsIGJlXG4gICAgLy8gICAgY29uc2lkZXJlZCBhcyBkZXNjcmliaW5nIHRoZSBmaXJzdCBhbmQgb25seSByZW5kZXJlci5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gcmVuZGVyZXIgbGlzdCBub3IgXCJjb250YWluZXJcIiBvYmplY3QsIGl0IHdpbGwgYmVcbiAgICAvLyAgICBjb25zaWRlcmVkIGFzIHRoZSBjb250YWluZXIgaXRzZWxmIChhIERPTSBlbGVtZW50KS5cbiAgICAvLyAgLSBJZiB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIHNpZ21hKCkgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY29uc2lkZXJlZFxuICAgIC8vICAgIGFzIHRoZSBJRCBvZiB0aGUgRE9NIGNvbnRhaW5lci5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgX2NvbmYgPT09ICdzdHJpbmcnIHx8XG4gICAgICBfY29uZiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50XG4gICAgKVxuICAgICAgX2NvbmYgPSB7XG4gICAgICAgIHJlbmRlcmVyczogW19jb25mXVxuICAgICAgfTtcbiAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoX2NvbmYpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgX2NvbmYgPSB7XG4gICAgICAgIHJlbmRlcmVyczogX2NvbmZcbiAgICAgIH07XG5cbiAgICAvLyBBbHNvIGNoZWNrIFwicmVuZGVyZXJcIiBhbmQgXCJjb250YWluZXJcIiBrZXlzOlxuICAgIG8gPSBfY29uZi5yZW5kZXJlcnMgfHwgX2NvbmYucmVuZGVyZXIgfHwgX2NvbmYuY29udGFpbmVyO1xuICAgIGlmICghX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVycy5sZW5ndGggPT09IDApXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgKHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiAnY29udGFpbmVyJyBpbiBvKVxuICAgICAgKVxuICAgICAgICBfY29uZi5yZW5kZXJlcnMgPSBbb107XG5cbiAgICAvLyBSZWNlbnNlIHRoZSBpbnN0YW5jZTpcbiAgICBpZiAoX2NvbmYuaWQpIHtcbiAgICAgIGlmIChfX2luc3RhbmNlc1tfY29uZi5pZF0pXG4gICAgICAgIHRocm93ICdzaWdtYTogSW5zdGFuY2UgXCInICsgX2NvbmYuaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBfY29uZi5pZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlIChfX2luc3RhbmNlc1tpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogJycgKyBpZFxuICAgICAgfSk7XG4gICAgfVxuICAgIF9faW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcblxuICAgIC8vIEluaXRpYWxpemUgc2V0dGluZ3MgZnVuY3Rpb246XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBzaWdtYS5jbGFzc2VzLmNvbmZpZ3VyYWJsZShcbiAgICAgIHNpZ21hLnNldHRpbmdzLFxuICAgICAgX2NvbmYuc2V0dGluZ3MgfHwge31cbiAgICApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBsb2NrZWQgYXR0cmlidXRlczpcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2dyYXBoJywge1xuICAgICAgdmFsdWU6IG5ldyBzaWdtYS5jbGFzc2VzLmdyYXBoKHRoaXMuc2V0dGluZ3MpLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtaWRkbGV3YXJlcycsIHtcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhcycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZW5kZXJlcnNQZXJDYW1lcmEnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYUZyYW1lcycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhc1swXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2V2ZW50cycsIHtcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgICdjbGljaycsXG4gICAgICAgICdyaWdodENsaWNrJyxcbiAgICAgICAgJ2NsaWNrU3RhZ2UnLFxuICAgICAgICAnZG91YmxlQ2xpY2tTdGFnZScsXG4gICAgICAgICdyaWdodENsaWNrU3RhZ2UnLFxuICAgICAgICAnY2xpY2tOb2RlJyxcbiAgICAgICAgJ2NsaWNrTm9kZXMnLFxuICAgICAgICAnZG91YmxlQ2xpY2tOb2RlJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZXMnLFxuICAgICAgICAncmlnaHRDbGlja05vZGUnLFxuICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcbiAgICAgICAgJ292ZXJOb2RlJyxcbiAgICAgICAgJ292ZXJOb2RlcycsXG4gICAgICAgICdvdXROb2RlJyxcbiAgICAgICAgJ291dE5vZGVzJyxcbiAgICAgICAgJ2Rvd25Ob2RlJyxcbiAgICAgICAgJ2Rvd25Ob2RlcycsXG4gICAgICAgICd1cE5vZGUnLFxuICAgICAgICAndXBOb2RlcydcbiAgICAgIF0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIEFkZCBhIGN1c3RvbSBoYW5kbGVyLCB0byByZWRpc3BhdGNoIGV2ZW50cyBmcm9tIHJlbmRlcmVyczpcbiAgICB0aGlzLl9oYW5kbGVyID0gKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBrLFxuICAgICAgICAgIGRhdGEgPSB7fTtcblxuICAgICAgZm9yIChrIGluIGUuZGF0YSlcbiAgICAgICAgZGF0YVtrXSA9IGUuZGF0YVtrXTtcblxuICAgICAgZGF0YS5yZW5kZXJlciA9IGUudGFyZ2V0O1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUudHlwZSwgZGF0YSk7XG4gICAgfSkuYmluZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgcmVuZGVyZXJzOlxuICAgIGEgPSBfY29uZi5yZW5kZXJlcnMgfHwgW107XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgdGhpcy5hZGRSZW5kZXJlcihhW2ldKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWlkZGxld2FyZXM6XG4gICAgYSA9IF9jb25mLm1pZGRsZXdhcmVzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaChcbiAgICAgICAgdHlwZW9mIGFbaV0gPT09ICdzdHJpbmcnID9cbiAgICAgICAgICBzaWdtYS5taWRkbGV3YXJlc1thW2ldXSA6XG4gICAgICAgICAgYVtpXVxuICAgICAgKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBncmFwaCB0byBmaWxsIGluOlxuICAgIGlmICh0eXBlb2YgX2NvbmYuZ3JhcGggPT09ICdvYmplY3QnICYmIF9jb25mLmdyYXBoKSB7XG4gICAgICB0aGlzLmdyYXBoLnJlYWQoX2NvbmYuZ3JhcGgpO1xuXG4gICAgICAvLyBJZiBhIGdyYXBoIGlzIGdpdmVuIHRvIHRoZSB0byB0aGUgaW5zdGFuY2UsIHRoZSBcInJlZnJlc2hcIiBtZXRob2QgaXNcbiAgICAgIC8vIGRpcmVjdGx5IGNhbGxlZDpcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCByZXNpemU6XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKF9zZWxmLnNldHRpbmdzKVxuICAgICAgICBfc2VsZi5yZWZyZXNoKCk7XG4gICAgfSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyB3aWxsIGluc3RhbnRpYXRlIGFuZCByZWZlcmVuY2UgYSBuZXcgY2FtZXJhLiBJZiBubyBpZCBpc1xuICAgKiBzcGVjaWZpZWQsIHRoZW4gYW4gYXV0b21hdGljIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgICAgICAgICAgaWQgRXZlbnR1YWxseSB0aGUgY2FtZXJhIGlkLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgVGhlIGZyZXNoIG5ldyBjYW1lcmEgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUuYWRkQ2FtZXJhID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNhbWVyYTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWQgPSAwO1xuICAgICAgd2hpbGUgKHRoaXMuY2FtZXJhc1snJyArIGlkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIGlkID0gJycgKyBpZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYW1lcmFzW2lkXSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRDYW1lcmE6IFRoZSBjYW1lcmEgXCInICsgaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIGNhbWVyYSA9IG5ldyBzaWdtYS5jbGFzc2VzLmNhbWVyYShpZCwgdGhpcy5ncmFwaCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgdGhpcy5jYW1lcmFzW2lkXSA9IGNhbWVyYTtcblxuICAgIC8vIEFkZCBhIHF1YWR0cmVlIHRvIHRoZSBjYW1lcmE6XG4gICAgY2FtZXJhLnF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMucXVhZCgpO1xuXG4gICAgLy8gQWRkIGFuIGVkZ2VxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxuICAgIGlmIChzaWdtYS5jbGFzc2VzLmVkZ2VxdWFkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbWVyYS5lZGdlcXVhZHRyZWUgPSBuZXcgc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCgpO1xuICAgIH1cblxuICAgIGNhbWVyYS5iaW5kKCdjb29yZGluYXRlc1VwZGF0ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICBzZWxmLnJlbmRlckNhbWVyYShjYW1lcmEsIGNhbWVyYS5pc0FuaW1hdGVkKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2lkXSA9IFtdO1xuXG4gICAgcmV0dXJuIGNhbWVyYTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgYSBjYW1lcmEsIGFuZCBldmVyeSByZW5kZXJlciBhdHRhY2hlZCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGNhbWVyYX0gdiBUaGUgY2FtZXJhIHRvIGtpbGwgb3IgaXRzIElELlxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmtpbGxDYW1lcmEgPSBmdW5jdGlvbih2KSB7XG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMuY2FtZXJhc1t2XSA6IHY7XG5cbiAgICBpZiAoIXYpXG4gICAgICB0aHJvdyAnc2lnbWEua2lsbENhbWVyYTogVGhlIGNhbWVyYSBpcyB1bmRlZmluZWQuJztcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5pZF07XG5cbiAgICBmb3IgKGwgPSBhLmxlbmd0aCwgaSA9IGwgLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRoaXMua2lsbFJlbmRlcmVyKGFbaV0pO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYUZyYW1lc1t2LmlkXTtcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFzW3YuaWRdO1xuXG4gICAgaWYgKHYua2lsbClcbiAgICAgIHYua2lsbCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyB3aWxsIGluc3RhbnRpYXRlIGFuZCByZWZlcmVuY2UgYSBuZXcgcmVuZGVyZXIuIFRoZSBcInR5cGVcIlxuICAgKiBhcmd1bWVudCBjYW4gYmUgdGhlIGNvbnN0cnVjdG9yIG9yIGl0cyBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiXG4gICAqIHBhY2thZ2UuIElmIG5vIHR5cGUgaXMgc3BlY2lmaWVkLCB0aGVuIFwic2lnbWEucmVuZGVyZXJzLmRlZlwiIHdpbGwgYmUgdXNlZC5cbiAgICogSWYgbm8gaWQgaXMgc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVuZGVyZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm4ge3JlbmRlcmVyfSAgICAgICAgIFRoZSBmcmVzaCBuZXcgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgXCJvcHRpb25zXCJcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/c3RyaW5nfSAgICAgICAgICAgIGlkICAgICBFdmVudHVhbGx5IHRoZSByZW5kZXJlciBpZC5cbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSB0eXBlICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgY29uc3RydWN0b3Igb3IgaXRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgaW4gdGhlIFwic2lnbWEucmVuZGVyZXJzXCIgcGFja2FnZS5cbiAgICogICB7PyhjYW1lcmF8c3RyaW5nKX0gICBjYW1lcmEgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgY2FtZXJhIG9yIGl0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZC5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5hZGRSZW5kZXJlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIGZuLFxuICAgICAgICBjYW1lcmEsXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICBvID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIFBvbHltb3JwaGlzbTpcbiAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnKVxuICAgICAgbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvKVxuICAgICAgfTtcbiAgICBlbHNlIGlmIChvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXG4gICAgICBvID0ge1xuICAgICAgICBjb250YWluZXI6IG9cbiAgICAgIH07XG5cbiAgICAvLyBJZiB0aGUgY29udGFpbmVyIHN0aWxsIGlzIGEgc3RyaW5nLCB3ZSBnZXQgaXQgYnkgaWRcbiAgICBpZiAodHlwZW9mIG8uY29udGFpbmVyID09PSAnc3RyaW5nJylcbiAgICAgIG8uY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoby5jb250YWluZXIpO1xuXG4gICAgLy8gUmVmZXJlbmNlIHRoZSBuZXcgcmVuZGVyZXI6XG4gICAgaWYgKCEoJ2lkJyBpbiBvKSkge1xuICAgICAgaWQgPSAwO1xuICAgICAgd2hpbGUgKHRoaXMucmVuZGVyZXJzWycnICsgaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgaWQgPSAnJyArIGlkO1xuICAgIH0gZWxzZVxuICAgICAgaWQgPSBvLmlkO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyZXJzW2lkXSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIHJlbmRlcmVyIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICAvLyBGaW5kIHRoZSBnb29kIGNvbnN0cnVjdG9yOlxuICAgIGZuID0gdHlwZW9mIG8udHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IG8udHlwZSA6IHNpZ21hLnJlbmRlcmVyc1tvLnR5cGVdO1xuICAgIGZuID0gZm4gfHwgc2lnbWEucmVuZGVyZXJzLmRlZjtcblxuICAgIC8vIEZpbmQgdGhlIGdvb2QgY2FtZXJhOlxuICAgIGNhbWVyYSA9ICdjYW1lcmEnIGluIG8gP1xuICAgICAgKFxuICAgICAgICBvLmNhbWVyYSBpbnN0YW5jZW9mIHNpZ21hLmNsYXNzZXMuY2FtZXJhID9cbiAgICAgICAgICBvLmNhbWVyYSA6XG4gICAgICAgICAgdGhpcy5jYW1lcmFzW28uY2FtZXJhXSB8fCB0aGlzLmFkZENhbWVyYShvLmNhbWVyYSlcbiAgICAgICkgOlxuICAgICAgdGhpcy5hZGRDYW1lcmEoKTtcblxuICAgIGlmICh0aGlzLmNhbWVyYXNbY2FtZXJhLmlkXSAhPT0gY2FtZXJhKVxuICAgICAgdGhyb3cgJ3NpZ21hLmFkZFJlbmRlcmVyOiBUaGUgY2FtZXJhIGlzIG5vdCBwcm9wZXJseSByZWZlcmVuY2VkLic7XG5cbiAgICAvLyBJbnN0YW50aWF0ZTpcbiAgICByZW5kZXJlciA9IG5ldyBmbih0aGlzLmdyYXBoLCBjYW1lcmEsIHRoaXMuc2V0dGluZ3MsIG8pO1xuICAgIHRoaXMucmVuZGVyZXJzW2lkXSA9IHJlbmRlcmVyO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXJlciwgJ2lkJywge1xuICAgICAgdmFsdWU6IGlkXG4gICAgfSk7XG5cbiAgICAvLyBCaW5kIGV2ZW50czpcbiAgICBpZiAocmVuZGVyZXIuYmluZClcbiAgICAgIHJlbmRlcmVyLmJpbmQoXG4gICAgICAgIFtcbiAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICdyaWdodENsaWNrJyxcbiAgICAgICAgICAnY2xpY2tTdGFnZScsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxuICAgICAgICAgICdyaWdodENsaWNrU3RhZ2UnLFxuICAgICAgICAgICdjbGlja05vZGUnLFxuICAgICAgICAgICdjbGlja05vZGVzJyxcbiAgICAgICAgICAnY2xpY2tFZGdlJyxcbiAgICAgICAgICAnY2xpY2tFZGdlcycsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZXMnLFxuICAgICAgICAgICdkb3VibGVDbGlja0VkZ2UnLFxuICAgICAgICAgICdkb3VibGVDbGlja0VkZ2VzJyxcbiAgICAgICAgICAncmlnaHRDbGlja05vZGUnLFxuICAgICAgICAgICdyaWdodENsaWNrTm9kZXMnLFxuICAgICAgICAgICdyaWdodENsaWNrRWRnZScsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tFZGdlcycsXG4gICAgICAgICAgJ292ZXJOb2RlJyxcbiAgICAgICAgICAnb3Zlck5vZGVzJyxcbiAgICAgICAgICAnb3ZlckVkZ2UnLFxuICAgICAgICAgICdvdmVyRWRnZXMnLFxuICAgICAgICAgICdvdXROb2RlJyxcbiAgICAgICAgICAnb3V0Tm9kZXMnLFxuICAgICAgICAgICdvdXRFZGdlJyxcbiAgICAgICAgICAnb3V0RWRnZXMnLFxuICAgICAgICAgICdkb3duTm9kZScsXG4gICAgICAgICAgJ2Rvd25Ob2RlcycsXG4gICAgICAgICAgJ2Rvd25FZGdlJyxcbiAgICAgICAgICAnZG93bkVkZ2VzJyxcbiAgICAgICAgICAndXBOb2RlJyxcbiAgICAgICAgICAndXBOb2RlcycsXG4gICAgICAgICAgJ3VwRWRnZScsXG4gICAgICAgICAgJ3VwRWRnZXMnXG4gICAgICAgIF0sXG4gICAgICAgIHRoaXMuX2hhbmRsZXJcbiAgICAgICk7XG5cbiAgICAvLyBSZWZlcmVuY2UgdGhlIHJlbmRlcmVyIGJ5IGl0cyBjYW1lcmE6XG4gICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbY2FtZXJhLmlkXS5wdXNoKHJlbmRlcmVyKTtcblxuICAgIHJldHVybiByZW5kZXJlcjtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgYSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfHJlbmRlcmVyfSB2IFRoZSByZW5kZXJlciB0byBraWxsIG9yIGl0cyBJRC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmtpbGxSZW5kZXJlciA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2ID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdGhpcy5yZW5kZXJlcnNbdl0gOiB2O1xuXG4gICAgaWYgKCF2KVxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxSZW5kZXJlcjogVGhlIHJlbmRlcmVyIGlzIHVuZGVmaW5lZC4nO1xuXG4gICAgdmFyIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmNhbWVyYS5pZF0sXG4gICAgICAgIGkgPSBhLmluZGV4T2Yodik7XG5cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgYS5zcGxpY2UoaSwgMSk7XG5cbiAgICBpZiAodi5raWxsKVxuICAgICAgdi5raWxsKCk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnNbdi5pZF07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIsIHdpdGggdGhlIHNhbWVcbiAgICogYXJndW1lbnRzIHRoYW4gdGhlIFwicmVuZGVyXCIgbWV0aG9kLCBidXQgd2lsbCBhbHNvIGNoZWNrIGlmIHRoZSByZW5kZXJlclxuICAgKiBoYXMgYSBcInByb2Nlc3NcIiBtZXRob2QsIGFuZCBjYWxsIGl0IGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogSXQgaXMgdXNlZnVsIGZvciBxdWFkdHJlZXMgb3IgV2ViR0wgcHJvY2Vzc2luZywgZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgb3B0aW9ucyBFdmVudHVhbGx5IHNvbWUgb3B0aW9ucyB0byBnaXZlIHRvIHRoZSByZWZyZXNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P2Jvb2xlYW59IHNraXBJbmRleGF0aW9uIEEgZmxhZyBzcGVjaWZ5aW5nIHdldGhlciBvciBub3QgdGhlIHJlZnJlc2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZCByZWluZGV4IHRoZSBncmFwaCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWR0cmVlcyBvciBub3QgKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBjLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIHByZWZpeCA9IDA7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIENhbGwgZWFjaCBtaWRkbGV3YXJlOlxuICAgIGEgPSB0aGlzLm1pZGRsZXdhcmVzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGFbaV0uY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgKGkgPT09IDApID8gJycgOiAndG1wJyArIHByZWZpeCArICc6JyxcbiAgICAgICAgKGkgPT09IGwgLSAxKSA/ICdyZWFkeTonIDogKCd0bXAnICsgKCsrcHJlZml4KSArICc6JylcbiAgICAgICk7XG5cbiAgICAvLyBUaGVuLCBmb3IgZWFjaCBjYW1lcmEsIGNhbGwgdGhlIFwicmVzY2FsZVwiIG1pZGRsZXdhcmUsIHVubGVzcyB0aGVcbiAgICAvLyBzZXR0aW5ncyBzcGVjaWZ5IG5vdCB0bzpcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKSB7XG4gICAgICBjID0gdGhpcy5jYW1lcmFzW2tdO1xuICAgICAgaWYgKFxuICAgICAgICBjLnNldHRpbmdzKCdhdXRvUmVzY2FsZScpICYmXG4gICAgICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdICYmXG4gICAgICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdLmxlbmd0aFxuICAgICAgKVxuICAgICAgICBzaWdtYS5taWRkbGV3YXJlcy5yZXNjYWxlLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhLmxlbmd0aCA/ICdyZWFkeTonIDogJycsXG4gICAgICAgICAgYy5yZWFkUHJlZml4LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXVswXS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0uaGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhLmxlbmd0aCA/ICdyZWFkeTonIDogJycsXG4gICAgICAgICAgYy5yZWFkUHJlZml4XG4gICAgICAgICk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5za2lwSW5kZXhhdGlvbikge1xuICAgICAgICAvLyBGaW5kIGdyYXBoIGJvdW5kYXJpZXM6XG4gICAgICAgIGJvdW5kcyA9IHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMoXG4gICAgICAgICAgdGhpcy5ncmFwaCxcbiAgICAgICAgICBjLnJlYWRQcmVmaXhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBSZWZyZXNoIHF1YWR0cmVlOlxuICAgICAgICBjLnF1YWR0cmVlLmluZGV4KHRoaXMuZ3JhcGgubm9kZXMoKSwge1xuICAgICAgICAgIHByZWZpeDogYy5yZWFkUHJlZml4LFxuICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgeDogYm91bmRzLm1pblgsXG4gICAgICAgICAgICB5OiBib3VuZHMubWluWSxcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZWZyZXNoIGVkZ2VxdWFkdHJlZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBjLnNldHRpbmdzKCdkcmF3RWRnZXMnKSAmJlxuICAgICAgICAgIGMuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpXG4gICAgICAgICkge1xuICAgICAgICAgIGMuZWRnZXF1YWR0cmVlLmluZGV4KHRoaXMuZ3JhcGgsIHtcbiAgICAgICAgICAgIHByZWZpeDogYy5yZWFkUHJlZml4LFxuICAgICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgICB5OiBib3VuZHMubWluWSxcbiAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy5tYXhYIC0gYm91bmRzLm1pblgsXG4gICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBlYWNoIHJlbmRlcmVyOlxuICAgIGEgPSBPYmplY3Qua2V5cyh0aGlzLnJlbmRlcmVycyk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2VzcygpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0gKyAnXCIgY3Jhc2hlZCBvbiBcIi5wcm9jZXNzKClcIidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2VzcygpO1xuICAgICAgfVxuXG4gICAgdGhpcy5yZW5kZXIoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlci5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWF9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgcHJlZml4ID0gMDtcblxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlcnNbYVtpXV0ucmVuZGVyKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygndmVyYm9zZScpKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXSArICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnJlbmRlcigpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyIHRoYXQgaXMgYm91bmQgdG9cbiAgICogdGhlIHNwZWNpZmllZCBjYW1lcmEuIFRvIGltcHJvdmUgdGhlIHBlcmZvcm1hbmNlcywgaWYgdGhpcyBtZXRob2QgaXNcbiAgICogY2FsbGVkIHRvbyBvZnRlbiwgdGhlIG51bWJlciBvZiBlZmZlY3RpdmUgcmVuZGVyaW5ncyBpcyBsaW1pdGF0ZWQgdG8gb25lXG4gICAqIHBlciBmcmFtZSwgdW5sZXNzIHlvdSBhcmUgdXNpbmcgdGhlIFwiZm9yY2VcIiBmbGFnLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gY2FtZXJhIFRoZSBjYW1lcmEgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHs/Ym9vbGVhbn0gICAgICAgICAgICAgZm9yY2UgIElmIHRydWUsIHdpbGwgcmVuZGVyIHRoZSBjYW1lcmFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RseS5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyQ2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhLCBmb3JjZSkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGlmIChmb3JjZSkge1xuICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF07XG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldLmlkICsgJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF0pIHtcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF07XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICtcbiAgICAgICAgICAgICAgICAgICAgYVtpXS5pZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuXG4gICAgICAgIHRoaXMuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJraWxsXCIgbWV0aG9kIG9mIGVhY2ggbW9kdWxlIGFuZCBkZXN0cm95cyBhbnlcbiAgICogcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaztcblxuICAgIC8vIERpc3BhdGNoaW5nIGV2ZW50XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdraWxsJyk7XG5cbiAgICAvLyBLaWxsIGdyYXBoOlxuICAgIHRoaXMuZ3JhcGgua2lsbCgpO1xuXG4gICAgLy8gS2lsbCBtaWRkbGV3YXJlczpcbiAgICBkZWxldGUgdGhpcy5taWRkbGV3YXJlcztcblxuICAgIC8vIEtpbGwgZWFjaCByZW5kZXJlcjpcbiAgICBmb3IgKGsgaW4gdGhpcy5yZW5kZXJlcnMpXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcih0aGlzLnJlbmRlcmVyc1trXSk7XG5cbiAgICAvLyBLaWxsIGVhY2ggY2FtZXJhOlxuICAgIGZvciAoayBpbiB0aGlzLmNhbWVyYXMpXG4gICAgICB0aGlzLmtpbGxDYW1lcmEodGhpcy5jYW1lcmFzW2tdKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVycztcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFzO1xuXG4gICAgLy8gS2lsbCBldmVyeXRoaW5nIGVsc2U6XG4gICAgZm9yIChrIGluIHRoaXMpXG4gICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgZGVsZXRlIHRoaXNba107XG5cbiAgICBkZWxldGUgX19pbnN0YW5jZXNbdGhpcy5pZF07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgaW5zdGFuY2VzIG9iamVjdCBvciBhIHNwZWNpZmljIHJ1bm5pbmcgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IGlkIEV2ZW50dWFsbHkgYW4gaW5zdGFuY2UgSUQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFRoZSByZWxhdGVkIGluc3RhbmNlIG9yIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuXG4gICAqL1xuICBzaWdtYS5pbnN0YW5jZXMgPSBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID9cbiAgICAgIF9faW5zdGFuY2VzW2lkXSA6XG4gICAgICBzaWdtYS51dGlscy5leHRlbmQoe30sIF9faW5zdGFuY2VzKTtcbiAgfTtcblxuXG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZlcnNpb24gb2Ygc2lnbWE6XG4gICAqL1xuICBzaWdtYS52ZXJzaW9uID0gJzEuMi4xJztcblxuXG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdBbiBvYmplY3QgY2FsbGVkIHNpZ21hIGlzIGFscmVhZHkgaW4gdGhlIGdsb2JhbCBzY29wZS4nO1xuXG4gIHRoaXMuc2lnbWEgPSBzaWdtYTtcblxufSkuY2FsbCh0aGlzKTtcblxuLyoqXG4gKiBjb25yYWQuanMgaXMgYSB0aW55IEphdmFTY3JpcHQgam9icyBzY2hlZHVsZXIsXG4gKlxuICogVmVyc2lvbjogMC4xLjBcbiAqIFNvdXJjZXM6IGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qc1xuICogRG9jOiAgICAgaHR0cDovL2dpdGh1Yi5jb20vamFjb215YWwvY29ucmFkLmpzI3JlYWRtZVxuICpcbiAqIExpY2Vuc2U6XG4gKiAtLS0tLS0tLVxuICogQ29weXJpZ2h0IMKpIDIwMTMgQWxleGlzIEphY29teSwgU2NpZW5jZXMtUG8gbcOpZGlhbGFiXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4gKiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAqIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUaGUgU29mdHdhcmUgaXMgcHJvdmlkZWQgXCJhcyBpc1wiLCB3aXRob3V0IHdhcnJhbnR5IG9mIGFueSBraW5kLCBleHByZXNzIG9yXG4gKiBpbXBsaWVkLCBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIHRoZSB3YXJyYW50aWVzIG9mIG1lcmNoYW50YWJpbGl0eSxcbiAqIGZpdG5lc3MgZm9yIGEgcGFydGljdWxhciBwdXJwb3NlIGFuZCBub25pbmZyaW5nZW1lbnQuIEluIG5vIGV2ZW50IHNoYWxsIHRoZVxuICogYXV0aG9ycyBvciBjb3B5cmlnaHQgaG9sZGVycyBiZSBsaWFibGUgZm9yIGFueSBjbGFpbSwgZGFtYWdlcyBvciBvdGhlclxuICogbGlhYmlsaXR5LCB3aGV0aGVyIGluIGFuIGFjdGlvbiBvZiBjb250cmFjdCwgdG9ydCBvciBvdGhlcndpc2UsIGFyaXNpbmdcbiAqIGZyb20sIG91dCBvZiBvciBpbiBjb25uZWN0aW9uIHdpdGggdGhlIHNvZnR3YXJlIG9yIHRoZSB1c2Ugb3Igb3RoZXIgZGVhbGluZ3NcbiAqIGluIHRoZSBTb2Z0d2FyZS5cbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ2hlY2sgdGhhdCBjb25yYWQuanMgaGFzIG5vdCBiZWVuIGxvYWRlZCB5ZXQ6XG4gIGlmIChnbG9iYWwuY29ucmFkKVxuICAgIHRocm93IG5ldyBFcnJvcignY29ucmFkIGFscmVhZHkgZXhpc3RzJyk7XG5cblxuICAvKipcbiAgICogUFJJVkFURSBWQVJJQUJMRVM6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBjb25yYWQgaXMgcnVubmluZyBvciBub3QuXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICB2YXIgX2xhc3RGcmFtZVRpbWU7XG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgY29ucmFkIGlzIHJ1bm5pbmcgb3Igbm90LlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHZhciBfaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBoYXNoIG9mIHJlZ2lzdGVyZWQgam9icy4gRWFjaCBqb2IgbXVzdCBhdCBsZWFzdCBoYXZlIGEgdW5pcXVlIElEXG4gICAqIHVuZGVyIHRoZSBrZXkgXCJpZFwiIGFuZCBhIGZ1bmN0aW9uIHVuZGVyIHRoZSBrZXkgXCJqb2JcIi4gVGhpcyBoYXNoXG4gICAqIGNvbnRhaW5zIGVhY2ggcnVubmluZyBqb2IgYW5kIGVhY2ggd2FpdGluZyBqb2IuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX2pvYnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIGhhc2ggb2YgY3VycmVudGx5IHJ1bm5pbmcgam9icy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfcnVubmluZ0pvYnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMsIHNvcnRlZCBieSBwcmlvcml0eS5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIF9zb3J0ZWRCeVByaW9yaXR5Sm9icyA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgYXJyYXkgb2YgY3VycmVudGx5IHdhaXRpbmcgam9icy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfd2FpdGluZ0pvYnMgPSB7fTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGZpbmlzaGVkIGpvYnMuIFRoZXkgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSwgc2luY2UgdHdvIGpvYnNcbiAgICogd2l0aCB0aGUgc2FtZSBcImlkXCIgY2FuIGhhcHBlbiBhdCB0d28gZGlmZmVyZW50IHRpbWVzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB2YXIgX2RvbmVKb2JzID0gW107XG5cbiAgLyoqXG4gICAqIEEgZGlydHkgZmxhZyB0byBrZWVwIGNvbnJhZCBmcm9tIHN0YXJ0aW5nOiBJbmRlZWQsIHdoZW4gYWRkSm9iKCkgaXMgY2FsbGVkXG4gICAqIHdpdGggc2V2ZXJhbCBqb2JzLCBjb25yYWQgbXVzdCBiZSBzdGFydGVkIG9ubHkgYXQgdGhlIGVuZC4gVGhpcyBmbGFnIGtlZXBzXG4gICAqIG1lIGZyb20gZHVwbGljYXRpbmcgdGhlIGNvZGUgdGhhdCBlZmZlY3RpdmVseSBhZGRzIGEgam9iLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHZhciBfbm9TdGFydCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBbiBoYXNoIGNvbnRhaW5pbmcgc29tZSBnbG9iYWwgc2V0dGluZ3MgYWJvdXQgaG93IGNvbnJhZC5qcyBzaG91bGRcbiAgICogYmVoYXZlLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9wYXJhbWV0ZXJzID0ge1xuICAgIGZyYW1lRHVyYXRpb246IDIwLFxuICAgIGhpc3Rvcnk6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgZXZlcnkgaGFuZGxlcnMgYm91bmQgdG8gY29ucmFkIGV2ZW50cy4gSXQgZG9lcyBub3RcbiAgICogcmVxdWlyZWEgYW55IERPTSBpbXBsZW1lbnRhdGlvbiwgc2luY2UgdGhlIGV2ZW50cyBhcmUgYWxsIEphdmFTY3JpcHQuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4gIC8qKlxuICAgKiBQUklWQVRFIEZVTkNUSU9OUzpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXaWxsIGV4ZWN1dGUgdGhlIGhhbmRsZXIgZXZlcnl0aW1lIHRoYXQgdGhlIGluZGljYXRlZCBldmVudCAob3IgdGhlXG4gICAqIGluZGljYXRlZCBldmVudHMpIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl8b2JqZWN0fSBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihPYmplY3QpfSAgICBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIGJpbmQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfYmluZChldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QoYXJndW1lbnRzWzBdKSA9PT0gYXJndW1lbnRzWzBdXG4gICAgKVxuICAgICAgZm9yIChldmVudHMgaW4gYXJndW1lbnRzWzBdKVxuICAgICAgICBfYmluZChldmVudHMsIGFyZ3VtZW50c1swXVtldmVudHNdKTtcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZUFycmF5ID1cbiAgICAgICAgQXJyYXkuaXNBcnJheShldmVudHMpID9cbiAgICAgICAgICBldmVudHMgOlxuICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XG5cbiAgICAgICAgaWYgKCFfaGFuZGxlcnNbZXZlbnRdKVxuICAgICAgICAgIF9oYW5kbGVyc1tldmVudF0gPSBbXTtcblxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXG4gICAgICAgIF9oYW5kbGVyc1tldmVudF0ucHVzaCh7XG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgaGFuZGxlciBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50IChvciBzcGVjaWZpZWQgZXZlbnRzKS5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gIHs/ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byB1bmJpbmQuIElmIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudCBvciB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3VuYmluZChldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGosXG4gICAgICAgIGpfZW5kLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID9cbiAgICAgICAgICAgICAgICAgICBldmVudHMgOlxuICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgX2hhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBlbHNlIGlmIChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XG4gICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGg7IGogIT09IGpfZW5kOyBqICs9IDEpXG4gICAgICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxuICAgICAgICAgICAgICBhLnB1c2goX2hhbmRsZXJzW2V2ZW50XVtqXSk7XG5cbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdICYmIF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoID09PSAwKVxuICAgICAgICAgIGRlbGV0ZSBfaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKVxuICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2VBcnJheVtpXV07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAgez9PYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2Rpc3BhdGNoKGV2ZW50cywgZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBpX2VuZCxcbiAgICAgICAgal9lbmQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGE7XG5cbiAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcbiAgICAgIGV2ZW50TmFtZSA9IGVBcnJheVtpXTtcblxuICAgICAgaWYgKF9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcbiAgICAgICAgICBkYXRhOiBkYXRhIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChqID0gMCwgal9lbmQgPSBfaGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7IGogIT09IGpfZW5kOyBqICs9IDEpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9oYW5kbGVyc1tldmVudE5hbWVdW2pdLmhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBtb3N0IHByaW9yaXRhcnkgam9iIG9uY2UsIGFuZCBkZWFscyB3aXRoIGZpbGxpbmcgdGhlIHN0YXRzXG4gICAqIChkb25lLCB0aW1lLCBhdmVyYWdlVGltZSwgY3VycmVudFRpbWUsIGV0Yy4uLikuXG4gICAqXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgaGFzIHRvIGJlIGtpbGxlZCwgbnVsbCBlbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2V4ZWN1dGVGaXJzdEpvYigpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgdGVzdCxcbiAgICAgICAga2lsbCxcbiAgICAgICAgcHVzaGVkID0gZmFsc2UsXG4gICAgICAgIHRpbWUgPSBfX2RhdGVOb3coKSxcbiAgICAgICAgam9iID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNoaWZ0KCk7XG5cbiAgICAvLyBFeGVjdXRlIHRoZSBqb2IgYW5kIGxvb2sgYXQgdGhlIHJlc3VsdDpcbiAgICB0ZXN0ID0gam9iLmpvYigpO1xuXG4gICAgLy8gRGVhbCB3aXRoIHN0YXRzOlxuICAgIHRpbWUgPSBfX2RhdGVOb3coKSAtIHRpbWU7XG4gICAgam9iLmRvbmUrKztcbiAgICBqb2IudGltZSArPSB0aW1lO1xuICAgIGpvYi5jdXJyZW50VGltZSArPSB0aW1lO1xuICAgIGpvYi53ZWlnaHRUaW1lID0gam9iLmN1cnJlbnRUaW1lIC8gKGpvYi53ZWlnaHQgfHwgMSk7XG4gICAgam9iLmF2ZXJhZ2VUaW1lID0gam9iLnRpbWUgLyBqb2IuZG9uZTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBqb2IgaGFzIHRvIGJlIGtpbGxlZDpcbiAgICBraWxsID0gam9iLmNvdW50ID8gKGpvYi5jb3VudCA8PSBqb2IuZG9uZSkgOiAhdGVzdDtcblxuICAgIC8vIFJlc2V0IHByaW9yaXRpZXM6XG4gICAgaWYgKCFraWxsKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKF9zb3J0ZWRCeVByaW9yaXR5Sm9ic1tpXS53ZWlnaHRUaW1lID4gam9iLndlaWdodFRpbWUpIHtcbiAgICAgICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMuc3BsaWNlKGksIDAsIGpvYik7XG4gICAgICAgICAgcHVzaGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBpZiAoIXB1c2hlZClcbiAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnB1c2goam9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2lsbCA/IGpvYiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGEgam9iLCBieSBhZGRpbmcgaXQgdG8gdGhlIF9ydW5uaW5nSm9icyBvYmplY3QgYW5kIHRoZVxuICAgKiBfc29ydGVkQnlQcmlvcml0eUpvYnMgYXJyYXkuIEl0IGFsc28gaW5pdGlhbGl6ZXMgaXRzIGN1cnJlbnRUaW1lIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGpvYiBUaGUgam9iIHRvIGFjdGl2YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FjdGl2YXRlSm9iKGpvYikge1xuICAgIHZhciBsID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aDtcblxuICAgIC8vIEFkZCB0aGUgam9iIHRvIHRoZSBydW5uaW5nIGpvYnM6XG4gICAgX3J1bm5pbmdKb2JzW2pvYi5pZF0gPSBqb2I7XG4gICAgam9iLnN0YXR1cyA9ICdydW5uaW5nJztcblxuICAgIC8vIEFkZCB0aGUgam9iIHRvIHRoZSBwcmlvcml0aWVzOlxuICAgIGlmIChsKSB7XG4gICAgICBqb2Iud2VpZ2h0VGltZSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9ic1tsIC0gMV0ud2VpZ2h0VGltZTtcbiAgICAgIGpvYi5jdXJyZW50VGltZSA9IGpvYi53ZWlnaHRUaW1lICogKGpvYi53ZWlnaHQgfHwgMSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgam9iIGFuZCBkaXNwYXRjaDpcbiAgICBqb2Iuc3RhcnRUaW1lID0gX19kYXRlTm93KCk7XG4gICAgX2Rpc3BhdGNoKCdqb2JTdGFydGVkJywgX19jbG9uZShqb2IpKTtcblxuICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gbG9vcCBvZiBjb25yYWQuanM6XG4gICAqICAuIEl0IGV4ZWN1dGVzIGpvYiBzdWNoIHRoYXQgdGhleSBhbGwgb2NjdXBhdGUgdGhlIHNhbWUgcHJvY2Vzc2luZyB0aW1lLlxuICAgKiAgLiBJdCBzdG9wcyBqb2JzIHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgZXhlY3V0ZWQgYW55bW9yZS5cbiAgICogIC4gSXQgdHJpZ2dlcnMgY2FsbGJhY2tzIHdoZW4gaXQgaXMgcmVsZXZhbnQuXG4gICAqICAuIEl0IHN0YXJ0cyB3YWl0aW5nIGpvYnMgd2hlbiB0aGV5IG5lZWQgdG8gYmUgc3RhcnRlZC5cbiAgICogIC4gSXQgaW5qZWN0cyBmcmFtZXMgdG8ga2VlcCBhIGNvbnN0YW50IGZyYXBlcyBwZXIgc2Vjb25kIHJhdGlvLlxuICAgKiAgLiBJdCBzdG9wcyBpdHNlbGYgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBqb2JzIHRvIGV4ZWN1dGUuXG4gICAqL1xuICBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgayxcbiAgICAgICAgbyxcbiAgICAgICAgbCxcbiAgICAgICAgam9iLFxuICAgICAgICB0aW1lLFxuICAgICAgICBkZWFkSm9iO1xuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBuZXdseSBhZGRlZCBqb2JzICh0aGUgX2pvYnMgb2JqZWN0KTpcbiAgICBmb3IgKGsgaW4gX2pvYnMpIHtcbiAgICAgIGpvYiA9IF9qb2JzW2tdO1xuXG4gICAgICBpZiAoam9iLmFmdGVyKVxuICAgICAgICBfd2FpdGluZ0pvYnNba10gPSBqb2I7XG4gICAgICBlbHNlXG4gICAgICAgIF9hY3RpdmF0ZUpvYihqb2IpO1xuXG4gICAgICBkZWxldGUgX2pvYnNba107XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBfaXNSdW5uaW5nIGZsYWcgdG8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIHJ1bm5pbmcgam9iOlxuICAgIF9pc1J1bm5pbmcgPSAhIV9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XG5cbiAgICAvLyBEZWFsIHdpdGggdGhlIHJ1bm5pbmcgam9icyAodGhlIF9ydW5uaW5nSm9icyBvYmplY3QpOlxuICAgIHdoaWxlIChcbiAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGggJiZcbiAgICAgIF9fZGF0ZU5vdygpIC0gX2xhc3RGcmFtZVRpbWUgPCBfcGFyYW1ldGVycy5mcmFtZUR1cmF0aW9uXG4gICAgKSB7XG4gICAgICBkZWFkSm9iID0gX2V4ZWN1dGVGaXJzdEpvYigpO1xuXG4gICAgICAvLyBEZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGpvYiBoYXMgZW5kZWQ6XG4gICAgICBpZiAoZGVhZEpvYikge1xuICAgICAgICBfa2lsbEpvYihkZWFkSm9iLmlkKTtcblxuICAgICAgICAvLyBDaGVjayBmb3Igd2FpdGluZyBqb2JzOlxuICAgICAgICBmb3IgKGsgaW4gX3dhaXRpbmdKb2JzKVxuICAgICAgICAgIGlmIChfd2FpdGluZ0pvYnNba10uYWZ0ZXIgPT09IGRlYWRKb2IuaWQpIHtcbiAgICAgICAgICAgIF9hY3RpdmF0ZUpvYihfd2FpdGluZ0pvYnNba10pO1xuICAgICAgICAgICAgZGVsZXRlIF93YWl0aW5nSm9ic1trXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY29ucmFkIHN0aWxsIGhhcyBqb2JzIHRvIGRlYWwgd2l0aCwgYW5kIGtpbGwgaXQgaWYgbm90OlxuICAgIGlmIChfaXNSdW5uaW5nKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgX2Rpc3BhdGNoKCdlbnRlckZyYW1lJyk7XG4gICAgICBzZXRUaW1lb3V0KF9sb29wLCAwKTtcbiAgICB9IGVsc2VcbiAgICAgIF9kaXNwYXRjaCgnc3RvcCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb25lIG9yIG1vcmUgam9icywgYW5kIHN0YXJ0cyB0aGUgbG9vcCBpZiBubyBqb2Igd2FzIHJ1bm5pbmcgYmVmb3JlLiBBXG4gICAqIGpvYiBpcyBhdCBsZWFzdCBhIHVuaXF1ZSBzdHJpbmcgXCJpZFwiIGFuZCBhIGZ1bmN0aW9uLCBhbmQgdGhlcmUgYXJlIHNvbWVcbiAgICogcGFyYW1ldGVycyB0aGF0IHlvdSBjYW4gc3BlY2lmeSBmb3IgZWFjaCBqb2IgdG8gbW9kaWZ5IHRoZSB3YXkgY29ucmFkIHdpbGxcbiAgICogZXhlY3V0ZSBpdC4gSWYgYSBqb2IgaXMgYWRkZWQgd2l0aCB0aGUgXCJpZFwiIG9mIGFub3RoZXIgam9iIHRoYXQgaXMgd2FpdGluZ1xuICAgKiBvciBzdGlsbCBydW5uaW5nLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICpcbiAgICogV2hlbiBhIGpvYiBpcyBhZGRlZCwgaXQgaXMgcmVmZXJlbmNlZCBpbiB0aGUgX2pvYnMgb2JqZWN0LCBieSBpdHMgaWQuXG4gICAqIFRoZW4sIGlmIGl0IGhhcyB0byBiZSBleGVjdXRlZCByaWdodCBub3csIGl0IHdpbGwgYmUgYWxzbyByZWZlcmVuY2VkIGluXG4gICAqIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0LiBJZiBpdCBoYXMgdG8gd2FpdCwgdGhlbiBpdCB3aWxsIGJlIGFkZGVkIGludG8gdGhlXG4gICAqIF93YWl0aW5nSm9icyBvYmplY3QsIHVudGlsIGl0IGNhbiBzdGFydC5cbiAgICpcbiAgICogS2VlcCByZWFkaW5nIHRoaXMgZG9jdW1lbnRhdGlvbiB0byBzZWUgaG93IHRvIGNhbGwgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXG4gICAqXG4gICAqIEFkZGluZyBvbmUgam9iOlxuICAgKiAqKioqKioqKioqKioqKipcbiAgICogQmFzaWNhbGx5LCBhIGpvYiBpcyBkZWZpbmVkIGJ5IGl0cyBzdHJpbmcgaWQgYW5kIGEgZnVuY3Rpb24gKHRoZSBqb2IpLiBJdFxuICAgKiBpcyBhbHNvIHBvc3NpYmxlIHRvIGFkZCBzb21lIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCBteUpvYkZ1bmN0aW9uKTtcbiAgICogID4gY29ucmFkLmFkZEpvYignbXlKb2JJZCcsIHtcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBpZDogJ215Sm9iSWQnLFxuICAgKiAgPiAgIGpvYjogbXlKb2JGdW5jdGlvbixcbiAgICogID4gICBzb21lUGFyYW1ldGVyOiBzb21lVmFsdWVcbiAgICogID4gfSk7XG4gICAqXG4gICAqIEFkZGluZyBzZXZlcmFsIGpvYnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqXG4gICAqIFdoZW4gYWRkaW5nIHNldmVyYWwgam9icyBhdCB0aGUgc2FtZSB0aW1lLCBpdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5XG4gICAqIHBhcmFtZXRlcnMgZm9yIGVhY2ggb25lIGluZGl2aWR1YWxseSBvciBmb3IgYWxsOlxuICAgKlxuICAgKiAgPiBjb25yYWQuYWRkSm9iKFtcbiAgICogID4gICB7XG4gICAqICA+ICAgICBpZDogJ215Sm9iSWQxJyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxuICAgKiAgPiAgIH0sXG4gICAqICA+ICAge1xuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMicsXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcbiAgICogID4gICB9XG4gICAqICA+IF0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIG15Sm9iSWQxOiB7LFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIxOiBzb21lVmFsdWUxXG4gICAqICA+ICAgfSxcbiAgICogID4gICBteUpvYklkMjogeyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjIsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMjogc29tZVZhbHVlMlxuICAgKiAgPiAgIH1cbiAgICogID4gfSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgbXlKb2JJZDE6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgIG15Sm9iSWQyOiBteUpvYkZ1bmN0aW9uMlxuICAgKiAgPiB9LCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiAgUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAgKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiAgSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgIHs/RnVuY3Rpb259IGVuZCAgICAgIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBqb2IgaXMgZW5kZWQuIEl0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBleGVjdXRlZCBpZiB0aGUgam9iIGlzIGtpbGxlZCBpbnN0ZWFkIG9mIGVuZGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIFwibmF0dXJhbGx5XCIuXG4gICAqICAgIHs/SW50ZWdlcn0gIGNvdW50ICAgIFRoZSBudW1iZXIgb2YgdGltZSB0aGUgam9iIGhhcyB0byBiZSBleGVjdXRlZC5cbiAgICogICAgez9OdW1iZXJ9ICAgd2VpZ2h0ICAgSWYgc3BlY2lmaWVkLCB0aGUgam9iIHdpbGwgYmUgZXhlY3V0ZWQgYXMgaXQgd2FzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkIFwid2VpZ2h0XCIgdGltZXMuXG4gICAqICAgIHs/U3RyaW5nfSAgIGFmdGVyICAgIFRoZSBpZCBvZiBhbm90aGVyIGpvYiAoZXZlbnR1YWxseSBub3QgYWRkZWQgeWV0KS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgc3BlY2lmaWVkLCB0aGlzIGpvYiB3aWxsIHN0YXJ0IG9ubHkgd2hlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkIFwiYWZ0ZXJcIiBqb2IgaXMgZW5kZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkSm9iKHYxLCB2Mikge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBvO1xuXG4gICAgLy8gQXJyYXkgb2Ygam9iczpcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2MSkpIHtcbiAgICAgIC8vIEtlZXAgY29ucmFkIHRvIHN0YXJ0IHVudGlsIHRoZSBsYXN0IGpvYiBpcyBhZGRlZDpcbiAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHYxLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgX2FkZEpvYih2MVtpXS5pZCwgX19leHRlbmQodjFbaV0sIHYyKSk7XG5cbiAgICAgIF9ub1N0YXJ0ID0gZmFsc2U7XG4gICAgICBpZiAoIV9pc1J1bm5pbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBPbmUgam9iIChvYmplY3QpOlxuICAgICAgaWYgKHR5cGVvZiB2MS5pZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIF9hZGRKb2IodjEuaWQsIHYxKTtcblxuICAgICAgLy8gSGFzaCBvZiBqb2JzOlxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgY29ucmFkIHRvIHN0YXJ0IHVudGlsIHRoZSBsYXN0IGpvYiBpcyBhZGRlZDpcbiAgICAgICAgX25vU3RhcnQgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSBpbiB2MSlcbiAgICAgICAgICBpZiAodHlwZW9mIHYxW2ldID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgX2FkZEpvYihpLCBfX2V4dGVuZCh7XG4gICAgICAgICAgICAgIGpvYjogdjFbaV1cbiAgICAgICAgICAgIH0sIHYyKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgX2FkZEpvYihpLCBfX2V4dGVuZCh2MVtpXSwgdjIpKTtcblxuICAgICAgICBfbm9TdGFydCA9IGZhbHNlO1xuICAgICAgICBpZiAoIV9pc1J1bm5pbmcpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gT25lIGpvYiAoc3RyaW5nLCAqKTpcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChfaGFzSm9iKHYxKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdbY29ucmFkLmFkZEpvYl0gSm9iIHdpdGggaWQgXCInICsgdjEgKyAnXCIgYWxyZWFkeSBleGlzdHMuJ1xuICAgICAgICApO1xuXG4gICAgICAvLyBPbmUgam9iIChzdHJpbmcsIGZ1bmN0aW9uKTpcbiAgICAgIGlmICh0eXBlb2YgdjIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICBpZDogdjEsXG4gICAgICAgICAgZG9uZTogMCxcbiAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgIGN1cnJlbnRUaW1lOiAwLFxuICAgICAgICAgIGF2ZXJhZ2VUaW1lOiAwLFxuICAgICAgICAgIHdlaWdodFRpbWU6IDAsXG4gICAgICAgICAgam9iOiB2MlxuICAgICAgICB9O1xuXG4gICAgICAvLyBPbmUgam9iIChzdHJpbmcsIG9iamVjdCk6XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2MiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbyA9IF9fZXh0ZW5kKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiB2MSxcbiAgICAgICAgICAgIGRvbmU6IDAsXG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgc3RhdHVzOiAnd2FpdGluZycsXG4gICAgICAgICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgICAgICAgIGF2ZXJhZ2VUaW1lOiAwLFxuICAgICAgICAgICAgd2VpZ2h0VGltZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdjJcbiAgICAgICAgKTtcblxuICAgICAgLy8gSWYgbm9uZSBvZiB0aG9zZSBjYXNlcywgdGhyb3cgYW4gZXJyb3I6XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmFkZEpvYl0gV3JvbmcgYXJndW1lbnRzLicpO1xuXG4gICAgICAvLyBFZmZlY3RpdmVseSBhZGQgdGhlIGpvYjpcbiAgICAgIF9qb2JzW3YxXSA9IG87XG4gICAgICBfZGlzcGF0Y2goJ2pvYkFkZGVkJywgX19jbG9uZShvKSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBsb29wIGhhcyB0byBiZSBzdGFydGVkOlxuICAgICAgaWYgKCFfaXNSdW5uaW5nICYmICFfbm9TdGFydCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxuICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgIF9kaXNwYXRjaCgnc3RhcnQnKTtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cblxuICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmFkZEpvYl0gV3JvbmcgYXJndW1lbnRzLicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogS2lsbHMgb25lIG9yIG1vcmUgam9icywgaW5kaWNhdGVkIGJ5IHRoZWlyIGlkcy4gSXQgaXMgb25seSBwb3NzaWJsZSB0b1xuICAgKiBraWxsIHJ1bm5pbmcgam9icyBvciB3YWl0aW5nIGpvYnMuIElmIHlvdSB0cnkgdG8ga2lsbCBhIGpvYiB0aGF0IGRvZXMgbm90XG4gICAqIGV4aXN0IG9yIHRoYXQgaXMgYWxyZWFkeSBraWxsZWQsIGEgd2FybmluZyB3aWxsIGJlIHRocm93bi5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXl8U3RyaW5nfSB2MSBBIHN0cmluZyBqb2IgaWQgb3IgYW4gYXJyYXkgb2Ygam9iIGlkcy5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9raWxsSm9iKHYxKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGssXG4gICAgICAgIGEsXG4gICAgICAgIGpvYixcbiAgICAgICAgZm91bmQgPSBmYWxzZTtcblxuICAgIC8vIEFycmF5IG9mIGpvYiBpZHM6XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKVxuICAgICAgZm9yIChpID0gMCwgbCA9IHYxLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgX2tpbGxKb2IodjFbaV0pO1xuXG4gICAgLy8gT25lIGpvYidzIGlkOlxuICAgIGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGEgPSBbX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMsIF9qb2JzXTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBqb2IgZnJvbSB0aGUgaGFzaGVzOlxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodjEgaW4gYVtpXSkge1xuICAgICAgICAgIGpvYiA9IGFbaV1bdjFdO1xuXG4gICAgICAgICAgaWYgKF9wYXJhbWV0ZXJzLmhpc3RvcnkpIHtcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSAnZG9uZSc7XG4gICAgICAgICAgICBfZG9uZUpvYnMucHVzaChqb2IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9kaXNwYXRjaCgnam9iRW5kZWQnLCBfX2Nsb25lKGpvYikpO1xuICAgICAgICAgIGRlbGV0ZSBhW2ldW3YxXTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygam9iLmVuZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGpvYi5lbmQoKTtcblxuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIHByaW9yaXRpZXMgYXJyYXk6XG4gICAgICBhID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoYVtpXS5pZCA9PT0gdjEpIHtcbiAgICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjb25yYWQua2lsbEpvYl0gSm9iIFwiJyArIHYxICsgJ1wiIG5vdCBmb3VuZC4nKTtcblxuICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIGV2ZXJ5IHJ1bm5pbmcsIHdhaXRpbmcsIGFuZCBqdXN0IGFkZGVkIGpvYnMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfa2lsbEFsbCgpIHtcbiAgICB2YXIgayxcbiAgICAgICAgam9icyA9IF9fZXh0ZW5kKF9qb2JzLCBfcnVubmluZ0pvYnMsIF93YWl0aW5nSm9icyk7XG5cbiAgICAvLyBUYWtlIGV2ZXJ5IGpvYnMgYW5kIHB1c2ggdGhlbSBpbnRvIHRoZSBfZG9uZUpvYnMgb2JqZWN0OlxuICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KVxuICAgICAgZm9yIChrIGluIGpvYnMpIHtcbiAgICAgICAgam9ic1trXS5zdGF0dXMgPSAnZG9uZSc7XG4gICAgICAgIF9kb25lSm9icy5wdXNoKGpvYnNba10pO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygam9ic1trXS5lbmQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgam9ic1trXS5lbmQoKTtcbiAgICAgIH1cblxuICAgIC8vIFJlaW5pdGlhbGl6ZSB0aGUgZGlmZmVyZW50IGpvYnMgbGlzdHM6XG4gICAgX2pvYnMgPSB7fTtcbiAgICBfd2FpdGluZ0pvYnMgPSB7fTtcbiAgICBfcnVubmluZ0pvYnMgPSB7fTtcbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcblxuICAgIC8vIEluIGNhc2Ugc29tZSBqb2JzIGFyZSBhZGRlZCByaWdodCBhZnRlciB0aGUga2lsbDpcbiAgICBfaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBqb2Igd2l0aCB0aGUgc3BlY2lmaWVkIGlkIGlzIGN1cnJlbnRseSBydW5uaW5nIG9yXG4gICAqIHdhaXRpbmcsIGFuZCBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBpZCBUaGUgaWQgb2YgdGhlIGpvYi5cbiAgICogQHJldHVybiB7P09iamVjdH0gUmV0dXJucyB0aGUgam9iIG9iamVjdCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBmdW5jdGlvbiBfaGFzSm9iKGlkKSB7XG4gICAgdmFyIGpvYiA9IF9qb2JzW2lkXSB8fCBfcnVubmluZ0pvYnNbaWRdIHx8IF93YWl0aW5nSm9ic1tpZF07XG4gICAgcmV0dXJuIGpvYiA/IF9fZXh0ZW5kKGpvYikgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IHRoZSBzZXR0aW5nIHNwZWNpZmllZCBieSBcInYxXCIgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuICAgKiBieSBcInYyXCIgaWYgYm90aCBhcmUgZ2l2ZW4sIGFuZCBlbHNlIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGVcbiAgICogc2V0dGluZ3MgXCJ2MVwiLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgdjEgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gIHs/Kn0gICAgICAgdjIgRXZlbnR1YWxseSwgYSB2YWx1ZSB0byBzZXQgdG8gdGhlIHNwZWNpZmllZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAqIEByZXR1cm4ge09iamVjdHwqfSBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgc2V0dGluZ3MgdmFsdWUgaWYgXCJ2MlwiIGlzIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgICAgZ2l2ZW4sIGFuZCBjb25yYWQgZWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9zZXR0aW5ncyh2MSwgdjIpIHtcbiAgICB2YXIgbztcblxuICAgIGlmICh0eXBlb2YgYTEgPT09ICdzdHJpbmcnICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gX3BhcmFtZXRlcnNbYTFdO1xuICAgIGVsc2Uge1xuICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpID9cbiAgICAgICAgYTEgfHwge30gOlxuICAgICAgICB7fTtcbiAgICAgIGlmICh0eXBlb2YgYTEgPT09ICdzdHJpbmcnKVxuICAgICAgICBvW2ExXSA9IGEyO1xuXG4gICAgICBmb3IgKHZhciBrIGluIG8pXG4gICAgICAgIGlmIChvW2tdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3BhcmFtZXRlcnNba10gPSBvW2tdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZGVsZXRlIF9wYXJhbWV0ZXJzW2tdO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbnJhZCBpcyBjdXJyZW50bHkgcnVubmluZywgYW5kIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgX2lzUnVubmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRJc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIF9pc1J1bm5pbmc7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWZlcmVuY2UgZXZlcnkgam9iIHRoYXQgaXMgc3RvcmVkIGluIHRoZSBfZG9uZUpvYnMgb2JqZWN0LiBJdCB3aWxsXG4gICAqIG5vdCBiZSBwb3NzaWJsZSBhbnltb3JlIHRvIGdldCBzdGF0cyBhYm91dCB0aGVzZSBqb2JzLCBidXQgaXQgd2lsbCByZWxlYXNlXG4gICAqIHRoZSBtZW1vcnkuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfY2xlYXJIaXN0b3J5KCkge1xuICAgIF9kb25lSm9icyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiBldmVyeSBkYXRhIGFib3V0IGpvYnMgdGhhdCB3YWl0IHRvIGJlIHN0YXJ0ZWQsIGFyZVxuICAgKiBjdXJyZW50bHkgcnVubmluZyBvciBhcmUgZG9uZS5cbiAgICpcbiAgICogSXQgaXMgcG9zc2libGUgdG8gZ2V0IG9ubHkgcnVubmluZywgd2FpdGluZyBvciBkb25lIGpvYnMgYnkgZ2l2aW5nXG4gICAqIFwicnVubmluZ1wiLCBcIndhaXRpbmdcIiBvciBcImRvbmVcIiBhcyBmaXN0IGFyZ3VtZW50LlxuICAgKlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGdldCBldmVyeSBqb2Igd2l0aCBhIHNwZWNpZmllZCBpZCBieSBnaXZpbmcgaXQgYXNcbiAgICogZmlyc3QgYXJndW1lbnQuIEFsc28sIHVzaW5nIGEgUmVnRXhwIGluc3RlYWQgb2YgYW4gaWQgd2lsbCByZXR1cm4gZXZlcnlcbiAgICogam9icyB3aG9zZSBpZHMgbWF0Y2ggdGhlIFJlZ0V4cC4gQW5kIHRoZXNlIHR3byBsYXN0IHVzZSBjYXNlcyB3b3JrIGFzIHdlbGxcbiAgICogYnkgZ2l2aW5nIGJlZm9yZSBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgdGhlIG1hdGNoaW5nIGpvYnMuXG4gICAqXG4gICAqIFNvbWUgY2FsbCBleGFtcGxlczpcbiAgICogKioqKioqKioqKioqKioqKioqKlxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3dhaXRpbmcnKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ2RvbmUnKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ215Sm9iJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKC90ZXN0LylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJywgJ215UnVubmluZ0pvYicpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycsIC90ZXN0LylcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRTdGF0cyh2MSwgdjIpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGlzUGF0dGVyblN0cmluZztcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgc3RhdHMgPSBbXTtcblxuICAgICAgZm9yIChrIGluIF9qb2JzKVxuICAgICAgICBzdGF0cy5wdXNoKF9qb2JzW2tdKTtcblxuICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgc3RhdHMucHVzaChfd2FpdGluZ0pvYnNba10pO1xuXG4gICAgICBmb3IgKGsgaW4gX3J1bm5pbmdKb2JzKVxuICAgICAgICBzdGF0cy5wdXNoKF9ydW5uaW5nSm9ic1trXSk7XG5cbiAgICAgIHN0YXRzID0gc3RhdHMuY29uY2F0KF9kb25lSm9icyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpXG4gICAgICBzd2l0Y2ggKHYxKSB7XG4gICAgICAgIGNhc2UgJ3dhaXRpbmcnOlxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3dhaXRpbmdKb2JzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnVubmluZyc6XG4gICAgICAgICAgc3RhdHMgPSBfX29iamVjdFZhbHVlcyhfcnVubmluZ0pvYnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICBzdGF0cyA9IF9kb25lSm9icztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwYXR0ZXJuID0gdjE7XG4gICAgICB9XG5cbiAgICBpZiAodjEgaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICBwYXR0ZXJuID0gdjE7XG5cbiAgICBpZiAoIXBhdHRlcm4gJiYgKHR5cGVvZiB2MiA9PT0gJ3N0cmluZycgfHwgdjIgaW5zdGFuY2VvZiBSZWdFeHApKVxuICAgICAgcGF0dGVybiA9IHYyO1xuXG4gICAgLy8gRmlsdGVyIGpvYnMgaWYgYSBwYXR0ZXJuIGlzIGdpdmVuOlxuICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICBpc1BhdHRlcm5TdHJpbmcgPSB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZyc7XG5cbiAgICAgIGlmIChzdGF0cyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGEgPSBzdGF0cztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChrIGluIHN0YXRzKVxuICAgICAgICAgIGEgPSBhLmNvbmNhdChzdGF0c1trXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChrIGluIF9qb2JzKVxuICAgICAgICAgIGEucHVzaChfam9ic1trXSk7XG5cbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgICBhLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcblxuICAgICAgICBmb3IgKGsgaW4gX3J1bm5pbmdKb2JzKVxuICAgICAgICAgIGEucHVzaChfcnVubmluZ0pvYnNba10pO1xuXG4gICAgICAgIGEgPSBhLmNvbmNhdChfZG9uZUpvYnMpO1xuICAgICAgfVxuXG4gICAgICBzdGF0cyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoaXNQYXR0ZXJuU3RyaW5nID8gYVtpXS5pZCA9PT0gcGF0dGVybiA6IGFbaV0uaWQubWF0Y2gocGF0dGVybikpXG4gICAgICAgICAgc3RhdHMucHVzaChhW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX19jbG9uZShzdGF0cyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBUT09MUyBGVU5DVElPTlM6XG4gICAqICoqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW55IG51bWJlciBvZiBvYmplY3RzIGFzIGFyZ3VtZW50cywgY29waWVzIGZyb20gZWFjaFxuICAgKiBvZiB0aGVzZSBvYmplY3RzIGVhY2ggcGFpciBrZXkvdmFsdWUgaW50byBhIG5ldyBvYmplY3QsIGFuZCBmaW5hbGx5XG4gICAqIHJldHVybnMgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBhcmd1bWVudHMgYXJlIHBhcnNlZCBmcm9tIHRoZSBsYXN0IG9uZSB0byB0aGUgZmlyc3Qgb25lLCBzdWNoIHRoYXRcbiAgICogd2hlbiB0d28gb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiB2YXIgbzEgPSB7XG4gICAqICA+ICAgICAgIGE6IDEsXG4gICAqICA+ICAgICAgIGI6IDIsXG4gICAqICA+ICAgICAgIGM6ICczJ1xuICAgKiAgPiAgICAgfSxcbiAgICogID4gICAgIG8yID0ge1xuICAgKiAgPiAgICAgICBjOiAnNCcsXG4gICAqICA+ICAgICAgIGQ6IFsgNSBdXG4gICAqICA+ICAgICB9O1xuICAgKiAgPiBfX2V4dGVuZChvMSwgbzIpO1xuICAgKiAgPiAvLyBSZXR1cm5zOiB7XG4gICAqICA+IC8vICAgYTogMSxcbiAgICogID4gLy8gICBiOiAyLFxuICAgKiAgPiAvLyAgIGM6ICczJyxcbiAgICogID4gLy8gICBkOiBbIDUgXVxuICAgKiAgPiAvLyB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3QrfSBBbnkgbnVtYmVyIG9mIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gIFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX19leHRlbmQoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGssXG4gICAgICAgIHJlcyA9IHt9LFxuICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGwgLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGZvciAoayBpbiBhcmd1bWVudHNbaV0pXG4gICAgICAgIHJlc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBzaW1wbHkgY2xvbmVzIGFuIG9iamVjdC4gVGhpcyBvYmplY3QgbXVzdCBjb250YWluIG9ubHlcbiAgICogb2JqZWN0cywgYXJyYXlzIGFuZCBpbW11dGFibGUgdmFsdWVzLiBTaW5jZSBpdCBpcyBub3QgcHVibGljLCBpdCBkb2VzIG5vdFxuICAgKiBkZWFsIHdpdGggY3ljbGljIHJlZmVyZW5jZXMsIERPTSBlbGVtZW50cyBhbmQgaW5zdGFudGlhdGVkIG9iamVjdHMgLSBzb1xuICAgKiB1c2UgaXQgY2FyZWZ1bGx5LlxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gX19jbG9uZShpdGVtKSB7XG4gICAgdmFyIHJlc3VsdCwgaSwgaywgbDtcblxuICAgIGlmICghaXRlbSlcbiAgICAgIHJldHVybiBpdGVtO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGl0ZW0ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaChfX2Nsb25lKGl0ZW1baV0pKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGkgaW4gaXRlbSlcbiAgICAgICAgcmVzdWx0W2ldID0gX19jbG9uZShpdGVtW2ldKTtcbiAgICB9IGVsc2VcbiAgICAgIHJlc3VsdCA9IGl0ZW07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtBcnJheX0gIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfX29iamVjdFZhbHVlcyhvKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGEgPSBbXTtcblxuICAgIGZvciAoayBpbiBvKVxuICAgICAgYS5wdXNoKG9ba10pO1xuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICAvKipcbiAgICogQSBzaG9ydCBcIkRhdGUubm93KClcIiBwb2x5ZmlsbC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB0aW1lIChpbiBtcykuXG4gICAqL1xuICBmdW5jdGlvbiBfX2RhdGVOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlmaWxsIGZvciB0aGUgQXJyYXkuaXNBcnJheSBmdW5jdGlvbjpcbiAgICovXG4gIGlmICghQXJyYXkuaXNBcnJheSlcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVCBQVUJMSUMgQVBJOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG4gIHZhciBjb25yYWQgPSB7XG4gICAgaGFzSm9iOiBfaGFzSm9iLFxuICAgIGFkZEpvYjogX2FkZEpvYixcbiAgICBraWxsSm9iOiBfa2lsbEpvYixcbiAgICBraWxsQWxsOiBfa2lsbEFsbCxcbiAgICBzZXR0aW5nczogX3NldHRpbmdzLFxuICAgIGdldFN0YXRzOiBfZ2V0U3RhdHMsXG4gICAgaXNSdW5uaW5nOiBfZ2V0SXNSdW5uaW5nLFxuICAgIGNsZWFySGlzdG9yeTogX2NsZWFySGlzdG9yeSxcblxuICAgIC8vIEV2ZW50cyBtYW5hZ2VtZW50OlxuICAgIGJpbmQ6IF9iaW5kLFxuICAgIHVuYmluZDogX3VuYmluZCxcblxuICAgIC8vIFZlcnNpb246XG4gICAgdmVyc2lvbjogJzAuMS4wJ1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb25yYWQ7XG4gICAgZXhwb3J0cy5jb25yYWQgPSBjb25yYWQ7XG4gIH1cbiAgZ2xvYmFsLmNvbnJhZCA9IGNvbnJhZDtcbn0pKHRoaXMpO1xuXG4vLyBIYXJkY29kZWQgZXhwb3J0IGZvciB0aGUgbm9kZS5qcyB2ZXJzaW9uOlxudmFyIHNpZ21hID0gdGhpcy5zaWdtYSxcbiAgICBjb25yYWQgPSB0aGlzLmNvbnJhZDtcblxuc2lnbWEuY29ucmFkID0gY29ucmFkO1xuXG4vLyBEaXJ0eSBwb2x5ZmlsbHMgdG8gcGVybWl0IHNpZ21hIHVzYWdlIGluIG5vZGVcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnKVxuICBIVE1MRWxlbWVudCA9IGZ1bmN0aW9uKCkge307XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgd2luZG93ID0ge1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc2lnbWE7XG4gIGV4cG9ydHMuc2lnbWEgPSBzaWdtYTtcbn1cblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHZhciBfcm9vdCA9IHRoaXM7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMgPSBzaWdtYS51dGlscyB8fCB7fTtcblxuICAvKipcbiAgICogTUlTQyBVVElMUzpcbiAgICovXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XG4gICAqIHdoZW4gc2V2ZXJhbCBvYmplY3RzIGhhdmUga2V5cyBpbiBjb21tb24sIHRoZSBcImVhcmxpZXN0XCIgb2JqZWN0IHdpbnMuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHZhciBvMSA9IHtcbiAgICogID4gICAgICAgYTogMSxcbiAgICogID4gICAgICAgYjogMixcbiAgICogID4gICAgICAgYzogJzMnXG4gICAqICA+ICAgICB9LFxuICAgKiAgPiAgICAgbzIgPSB7XG4gICAqICA+ICAgICAgIGM6ICc0JyxcbiAgICogID4gICAgICAgZDogWyA1IF1cbiAgICogID4gICAgIH07XG4gICAqICA+IHNpZ21hLnV0aWxzLmV4dGVuZChvMSwgbzIpO1xuICAgKiAgPiAvLyBSZXR1cm5zOiB7XG4gICAqICA+IC8vICAgYTogMSxcbiAgICogID4gLy8gICBiOiAyLFxuICAgKiAgPiAvLyAgIGM6ICczJyxcbiAgICogID4gLy8gICBkOiBbIDUgXVxuICAgKiAgPiAvLyB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3QrfSBBbnkgbnVtYmVyIG9mIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gIFRoZSBtZXJnZWQgb2JqZWN0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGssXG4gICAgICAgIHJlcyA9IHt9LFxuICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGwgLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGZvciAoayBpbiBhcmd1bWVudHNbaV0pXG4gICAgICAgIHJlc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZGF0ZU5vdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAvKipcbiAgICogVGFrZXMgYSBwYWNrYWdlIG5hbWUgYXMgcGFyYW1ldGVyIGFuZCBjaGVja3MgYXQgZWFjaCBsZWJlbCBpZiBpdCBleGlzdHMsXG4gICAqIGFuZCBpZiBpdCBkb2VzIG5vdCwgY3JlYXRlcyBpdC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuYycpO1xuICAgKiAgPiBhLmIuYztcbiAgICogID4gLy8gT2JqZWN0IHt9O1xuICAgKiAgPlxuICAgKiAgPiBzaWdtYS51dGlscy5wa2coJ2EuYi5kJyk7XG4gICAqICA+IGEuYjtcbiAgICogID4gLy8gT2JqZWN0IHsgYzoge30sIGQ6IHt9IH07XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2cgPSBmdW5jdGlvbihwa2dOYW1lKSB7XG4gICAgcmV0dXJuIChwa2dOYW1lIHx8ICcnKS5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihjb250ZXh0LCBvYmpOYW1lKSB7XG4gICAgICByZXR1cm4gKG9iak5hbWUgaW4gY29udGV4dCkgP1xuICAgICAgICBjb250ZXh0W29iak5hbWVdIDpcbiAgICAgICAgKGNvbnRleHRbb2JqTmFtZV0gPSB7fSk7XG4gICAgfSwgX3Jvb3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIGluY3JlbWVudGFsIG51bWJlciBJRC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcbiAgICogID4gLy8gMTtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcbiAgICogID4gLy8gMjtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMuaWQoKTtcbiAgICogID4gLy8gMztcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwa2dOYW1lIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGNyZWF0ZS9maW5kLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHJlbGF0ZWQgcGFja2FnZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmlkID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKytpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gaGV4YSBjb2xvciAoZm9yIGluc3RhbmNlIFwiI2ZmY2MwMFwiIG9yIFwiI2ZjMFwiKSBvciBhXG4gICAqIHJnYiAvIHJnYmEgY29sb3IgKGxpa2UgXCJyZ2IoMjU1LDI1NSwxMilcIiBvciBcInJnYmEoMjU1LDI1NSwxMiwxKVwiKSBhbmRcbiAgICogcmV0dXJucyBhbiBpbnRlZ2VyIGVxdWFsIHRvIFwiciAqIDI1NSAqIDI1NSArIGcgKiAyNTUgKyBiXCIsIHRvIGdhaW4gc29tZVxuICAgKiBtZW1vcnkgaW4gdGhlIGRhdGEgZ2l2ZW4gdG8gV2ViR0wgc2hhZGVycy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBmdW5jdGlvbiBhY3R1YWxseSBjYWNoZXMgaXRzIHJlc3VsdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB2YWwgVGhlIGhleGEgb3IgcmdiYSBjb2xvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIG51bWJlciB2YWx1ZS5cbiAgICovXG4gIHZhciBmbG9hdENvbG9yQ2FjaGUgPSB7fTtcblxuICBzaWdtYS51dGlscy5mbG9hdENvbG9yID0gZnVuY3Rpb24odmFsKSB7XG5cbiAgICAvLyBJcyB0aGUgY29sb3IgYWxyZWFkeSBjb21wdXRlZD9cbiAgICBpZiAoZmxvYXRDb2xvckNhY2hlW3ZhbF0pXG4gICAgICByZXR1cm4gZmxvYXRDb2xvckNhY2hlW3ZhbF07XG5cbiAgICB2YXIgb3JpZ2luYWwgPSB2YWwsXG4gICAgICAgIHIgPSAwLFxuICAgICAgICBnID0gMCxcbiAgICAgICAgYiA9IDA7XG5cbiAgICBpZiAodmFsWzBdID09PSAnIycpIHtcbiAgICAgIHZhbCA9IHZhbC5zbGljZSgxKTtcblxuICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDApLCAxNik7XG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDMpLCAxNik7XG4gICAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDQpICsgdmFsLmNoYXJBdCg1KSwgMTYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsLm1hdGNoKC9eICpyZ2JhPyAqXFwoLykpIHtcbiAgICAgIHZhbCA9IHZhbC5tYXRjaChcbiAgICAgICAgL14gKnJnYmE/ICpcXCggKihbMC05XSopICosICooWzAtOV0qKSAqLCAqKFswLTldKikgKigsLiopP1xcKSAqJC9cbiAgICAgICk7XG4gICAgICByID0gK3ZhbFsxXTtcbiAgICAgIGcgPSArdmFsWzJdO1xuICAgICAgYiA9ICt2YWxbM107XG4gICAgfVxuXG4gICAgdmFyIGNvbG9yID0gKFxuICAgICAgciAqIDI1NiAqIDI1NiArXG4gICAgICBnICogMjU2ICtcbiAgICAgIGJcbiAgICApO1xuXG4gICAgLy8gQ2FjaGluZyB0aGUgY29sb3JcbiAgICBmbG9hdENvbG9yQ2FjaGVbb3JpZ2luYWxdID0gY29sb3I7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH07XG5cbiAgICAvKipcbiAgICogUGVyZm9ybSBhIHpvb20gaW50byBhIGNhbWVyYSwgd2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbiwgdG8gdGhlXG4gICAqIGNvb3JkaW5hdGVzIGluZGljYXRlZCB1c2luZyBhIHNwZWNpZmllZCByYXRpby5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBhbmltYXRpb25cbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/bnVtYmVyfSBkdXJhdGlvbiAgICAgQW4gYW1vdW50IG9mIHRpbWUgdGhhdCBtZWFucyB0aGUgZHVyYXRpb24gb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uIElmIHRoaXMgcGFyYW1ldGVyIGRvZXNuJ3QgZXhpc3QgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tIHdpbGwgYmUgcGVyZm9ybWVkIHdpdGhvdXQgYW5pbWF0aW9uLlxuICAgKiAgIHs/ZnVuY3Rpb259IG9uQ29tcGxldGUgQSBmdW5jdGlvbiB0byBwZXJmb3JtIGl0IGFmdGVyIHRoZSBhbmltYXRpb24uIEl0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHBlcmZvcm1lZCBldmVuIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2NhbWVyYX0gICAgIFRoZSBjYW1lcmEgd2hlcmUgcGVyZm9ybSB0aGUgem9vbS5cbiAgICogQHBhcmFtIHt4fSAgICAgICAgICBUaGUgWCBjb29yZGlhbnRpb24gd2hlcmUgdGhlIHpvb20gZ29lcy5cbiAgICogQHBhcmFtIHt5fSAgICAgICAgICBUaGUgWSBjb29yZGlhbnRpb24gd2hlcmUgdGhlIHpvb20gZ29lcy5cbiAgICogQHBhcmFtIHtyYXRpb30gICAgICBUaGUgcmF0aW8gdG8gYXBwbHkgaXQgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHJhdGlvLlxuICAgKiBAcGFyYW0gez9hbmltYXRpb259IEEgZGljdGlvbmFyeSB3aXRoIG9wdGlvbnMgZm9yIGEgcG9zc2libGUgYW5pbWF0aW9uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuem9vbVRvID0gZnVuY3Rpb24oY2FtZXJhLCB4LCB5LCByYXRpbywgYW5pbWF0aW9uKSB7XG4gICAgdmFyIHNldHRpbmdzID0gY2FtZXJhLnNldHRpbmdzLFxuICAgICAgICBjb3VudCxcbiAgICAgICAgbmV3UmF0aW8sXG4gICAgICAgIGFuaW1hdGlvblNldHRpbmdzLFxuICAgICAgICBjb29yZGluYXRlcztcblxuICAgIC8vIENyZWF0ZSB0aGUgbmV3UmF0aW8gZGVhbGluZyB3aXRoIG1pbiAvIG1heDpcbiAgICBuZXdSYXRpbyA9IE1hdGgubWF4KFxuICAgICAgc2V0dGluZ3MoJ3pvb21NaW4nKSxcbiAgICAgIE1hdGgubWluKFxuICAgICAgICBzZXR0aW5ncygnem9vbU1heCcpLFxuICAgICAgICBjYW1lcmEucmF0aW8gKiByYXRpb1xuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBuZXcgcmF0aW8gaXMgZGlmZmVyZW50IGZyb20gdGhlIGluaXRpYWwgb25lOlxuICAgIGlmIChuZXdSYXRpbyAhPT0gY2FtZXJhLnJhdGlvKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIGNvb3JkaW5hdGVzIHZhcmlhYmxlOlxuICAgICAgcmF0aW8gPSBuZXdSYXRpbyAvIGNhbWVyYS5yYXRpbztcbiAgICAgIGNvb3JkaW5hdGVzID0ge1xuICAgICAgICB4OiB4ICogKDEgLSByYXRpbykgKyBjYW1lcmEueCxcbiAgICAgICAgeTogeSAqICgxIC0gcmF0aW8pICsgY2FtZXJhLnksXG4gICAgICAgIHJhdGlvOiBuZXdSYXRpb1xuICAgICAgfTtcblxuICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uZHVyYXRpb24pIHtcbiAgICAgICAgLy8gQ29tcGxldGUgdGhlIGFuaW1hdGlvbiBzZXRpbmdzOlxuICAgICAgICBjb3VudCA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoY2FtZXJhKTtcbiAgICAgICAgYW5pbWF0aW9uID0gc2lnbWEudXRpbHMuZXh0ZW5kKFxuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmc6IGNvdW50ID8gJ3F1YWRyYXRpY091dCcgOiAncXVhZHJhdGljSW5PdXQnXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShjYW1lcmEsIGNvb3JkaW5hdGVzLCBhbmltYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FtZXJhLmdvVG8oY29vcmRpbmF0ZXMpO1xuICAgICAgICBpZiAoYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5vbkNvbXBsZXRlKVxuICAgICAgICAgIGFuaW1hdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvbnRyb2wgcG9pbnQgY29vcmRpbmF0ZXMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTIgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICogQHJldHVybiB7eCx5fSAgICAgICAgVGhlIGNvbnRyb2wgcG9pbnQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoeDEgKyB4MikgLyAyICsgKHkyIC0geTEpIC8gNCxcbiAgICAgIHk6ICh5MSArIHkyKSAvIDIgKyAoeDEgLSB4MikgLyA0XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgIEluIFswLDFdIHRoZSBzdGVwIHBlcmNlbnRhZ2UgdG8gcmVhY2hcbiAgICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvaW50IGluIHRoZSBjdXJ2ZSBmcm9tIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZGluZyBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geGkgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geWkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gICAge3gseX0uXG4gICovXG4gIHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSA9IGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCB4aSwgeWkpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NjM0NTI4XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGgucG93KDEgLSB0LCAyKSAqIHgxICsgMiAqICgxIC0gdCkgKiB0ICogeGkgKyBNYXRoLnBvdyh0LCAyKSAqIHgyLFxuICAgICAgeTogTWF0aC5wb3coMSAtIHQsIDIpICogeTEgKyAyICogKDEgLSB0KSAqIHQgKiB5aSArIE1hdGgucG93KHQsIDIpICogeTJcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgICogQ29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IHBvc2l0aW9uZWRcbiAgICAqIGF0IGxlbmd0aCB0IGluIHRoZSBjdWJpYyBiZXppZXIgY3VydmUuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAqIEByZXR1cm4ge29iamVjdH0gICAge3gseX0gVGhlIHBvaW50IGF0IHQuXG4gICovXG4gIHNpZ21hLnV0aWxzLmdldFBvaW50T25CZXppZXJDdXJ2ZSA9XG4gICAgZnVuY3Rpb24odCwgeDEsIHkxLCB4MiwgeTIsIGN4LCBjeSwgZHgsIGR5KSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTUzOTc1OTZcbiAgICAvLyBCbGVuZGluZyBmdW5jdGlvbnM6XG4gICAgdmFyIEIwX3QgPSBNYXRoLnBvdygxIC0gdCwgMyksXG4gICAgICAgIEIxX3QgPSAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKSxcbiAgICAgICAgQjJfdCA9IDMgKiBNYXRoLnBvdyh0LCAyKSAqICgxIC0gdCksXG4gICAgICAgIEIzX3QgPSBNYXRoLnBvdyh0LCAzKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoQjBfdCAqIHgxKSArIChCMV90ICogY3gpICsgKEIyX3QgKiBkeCkgKyAoQjNfdCAqIHgyKSxcbiAgICAgIHk6IChCMF90ICogeTEpICsgKEIxX3QgKiBjeSkgKyAoQjJfdCAqIGR5KSArIChCM190ICogeTIpXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzIGZvciBhIHNlbGYgbG9vcCAoaS5lLlxuICAgKiB3aGVyZSB0aGUgc3RhcnQgcG9pbnQgaXMgYWxzbyB0aGUgZW5kIHBvaW50KSBjb21wdXRlZCBhcyBhIGN1YmljIGJlemllclxuICAgKiBjdXJ2ZS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHNpemUgVGhlIG5vZGUgc2l6ZS5cbiAgICogQHJldHVybiB7eDEseTEseDIseTJ9IFRoZSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oeCAsIHksIHNpemUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHggLSBzaXplICogNyxcbiAgICAgIHkxOiB5LFxuICAgICAgeDI6IHgsXG4gICAgICB5MjogeSArIHNpemUgKiA3XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzIG9mIGEgcGxhbmVcbiAgICogd2l0aCBhbiBvcnRob25vcm1hbCBiYXNpcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEBwYXJhbSAge251bWJlcn0geTIgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIGV1Y2xpZGlhbiBkaXN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIG9mIHR3byBjaXJjbGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgwICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgZmlyc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkwICBUaGUgWSBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgZmlyc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHIwICBUaGUgcmFkaXVzIG9mIHRoZSBmaXJzdCBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBzZWNvbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSByMSAgVGhlIHJhZGl1cyBvZiB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgICogQHJldHVybiB7eGkseWl9ICAgICAgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0Q2lyY2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEyMjE5ODAyXG4gICAgdmFyIGEsIGR4LCBkeSwgZCwgaCwgcngsIHJ5LCB4MiwgeTI7XG5cbiAgICAvLyBkeCBhbmQgZHkgYXJlIHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgY2lyY2xlXG4gICAgLy8gY2VudGVyczpcbiAgICBkeCA9IHgxIC0geDA7XG4gICAgZHkgPSB5MSAtIHkwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzdHJhaWdodC1saW5lIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnM6XG4gICAgZCA9IE1hdGguc3FydCgoZHkgKiBkeSkgKyAoZHggKiBkeCkpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHNvbHZhYmlsaXR5OlxuICAgIGlmIChkID4gKHIwICsgcjEpKSB7XG4gICAgICAgIC8vIE5vIHNvbHV0aW9uLiBjaXJjbGVzIGRvIG5vdCBpbnRlcnNlY3QuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGQgPCBNYXRoLmFicyhyMCAtIHIxKSkge1xuICAgICAgICAvLyBObyBzb2x1dGlvbi4gb25lIGNpcmNsZSBpcyBjb250YWluZWQgaW4gdGhlIG90aGVyLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8ncG9pbnQgMicgaXMgdGhlIHBvaW50IHdoZXJlIHRoZSBsaW5lIHRocm91Z2ggdGhlIGNpcmNsZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHMgY3Jvc3NlcyB0aGUgbGluZSBiZXR3ZWVuIHRoZSBjaXJjbGUgY2VudGVycy5cblxuICAgIC8vIERldGVybWluZSB0aGUgZGlzdGFuY2UgZnJvbSBwb2ludCAwIHRvIHBvaW50IDI6XG4gICAgYSA9ICgocjAgKiByMCkgLSAocjEgKiByMSkgKyAoZCAqIGQpKSAvICgyLjAgKiBkKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgY29vcmRpbmF0ZXMgb2YgcG9pbnQgMjpcbiAgICB4MiA9IHgwICsgKGR4ICogYSAvIGQpO1xuICAgIHkyID0geTAgKyAoZHkgKiBhIC8gZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMiB0byBlaXRoZXIgb2YgdGhlIGludGVyc2VjdGlvblxuICAgIC8vIHBvaW50czpcbiAgICBoID0gTWF0aC5zcXJ0KChyMCAqIHIwKSAtIChhICogYSkpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvZmZzZXRzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZyb20gcG9pbnQgMjpcbiAgICByeCA9IC1keSAqIChoIC8gZCk7XG4gICAgcnkgPSBkeCAqIChoIC8gZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGFic29sdXRlIGludGVyc2VjdGlvbiBwb2ludHM6XG4gICAgdmFyIHhpID0geDIgKyByeDtcbiAgICB2YXIgeGlfcHJpbWUgPSB4MiAtIHJ4O1xuICAgIHZhciB5aSA9IHkyICsgcnk7XG4gICAgdmFyIHlpX3ByaW1lID0geTIgLSByeTtcblxuICAgIHJldHVybiB7eGk6IHhpLCB4aV9wcmltZTogeGlfcHJpbWUsIHlpOiB5aSwgeWlfcHJpbWU6IHlpX3ByaW1lfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBsaW5lIHNlZ21lbnQuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZXBzaWxvbiBUaGUgcHJlY2lzaW9uIChjb25zaWRlciB0aGUgbGluZSB0aGlja25lc3MpLlxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIFRydWUgaWYgcG9pbnQgaXMgXCJjbG9zZSB0b1wiIHRoZSBsaW5lXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuICBzaWdtYS51dGlscy5pc1BvaW50T25TZWdtZW50ID0gZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGVwc2lsb24pIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMjgxMjJcbiAgICB2YXIgY3Jvc3NQcm9kdWN0ID0gTWF0aC5hYnMoKHkgLSB5MSkgKiAoeDIgLSB4MSkgLSAoeCAtIHgxKSAqICh5MiAtIHkxKSksXG4gICAgICAgIGQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MiksXG4gICAgICAgIG5Dcm9zc1Byb2R1Y3QgPSBjcm9zc1Byb2R1Y3QgLyBkOyAvLyBub3JtYWxpemVkIGNyb3NzIHByb2R1Y3RcblxuICAgIHJldHVybiAobkNyb3NzUHJvZHVjdCA8IGVwc2lsb24gJiZcbiAgICAgTWF0aC5taW4oeDEsIHgyKSA8PSB4ICYmIHggPD0gTWF0aC5tYXgoeDEsIHgyKSAmJlxuICAgICBNYXRoLm1pbih5MSwgeTIpIDw9IHkgJiYgeSA8PSBNYXRoLm1heCh5MSwgeTIpKTtcbiAgfTtcblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIHNlZ21lbnQgd2l0aCBhIHRoaWNrbmVzcy5cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B4ICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmICh4LHkpIGlzIG9uIHRoZSBjdXJ2ZSBzZWdtZW50LFxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uUXVhZHJhdGljQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSwgZXBzaWxvbikge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxuICAgIHZhciBkUDFQMiA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoTWF0aC5hYnMoeCAtIHgxKSA+IGRQMVAyIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFQMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MSwgeTEpLFxuICAgICAgICBkUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MiwgeTIpLFxuICAgICAgICB0ID0gMC41LFxuICAgICAgICByID0gKGRQMSA8IGRQMikgPyAtMC4wMSA6IDAuMDEsXG4gICAgICAgIHJUaHJlc2hvbGQgPSAwLjAwMSxcbiAgICAgICAgaSA9IDEwMCxcbiAgICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUodCwgeDEsIHkxLCB4MiwgeTIsIGNweCwgY3B5KSxcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcbiAgICAgICAgb2xkX2R0O1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXG4gICAgLy8gcG9pbnQgb2YgdGhlIGN1cnZlLCBzdGFydGluZyBmcm9tIHQ9MC41LlxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxuICAgIHdoaWxlIChpLS0gPiAwICYmXG4gICAgICB0ID49IDAgJiYgdCA8PSAxICYmXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcbiAgICAgIG9sZF9kdCA9IGR0O1xuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUodCwgeDEsIHkxLCB4MiwgeTIsIGNweCwgY3B5KTtcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XG5cbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICByID0gLXIgLyAyO1xuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxuICAgICAgICByID0gciAvIDI7XG4gICAgICAgIGR0ID0gb2xkX2R0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2dyZXNzOlxuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcbiAgfTtcblxuXG4gIC8qKlxuICAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBvbiBhIGN1YmljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweDEgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgMXN0IGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweTEgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgMXN0IGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweDIgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgMm5kIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweTIgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgMm5kIGN1cnZlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmICh4LHkpIGlzIG9uIHRoZSBjdXJ2ZSBzZWdtZW50LFxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uQmV6aWVyQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBlcHNpbG9uKSB7XG4gICAgLy8gRmFpbHMgaWYgdGhlIHBvaW50IGlzIHRvbyBmYXIgZnJvbSB0aGUgZXh0cmVtaXRpZXMgb2YgdGhlIHNlZ21lbnQsXG4gICAgLy8gcHJldmVudGluZyBmb3IgbW9yZSBjb3N0bHkgY29tcHV0YXRpb246XG4gICAgdmFyIGRQMUNQMSA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgY3B4MSwgY3B5MSk7XG4gICAgaWYgKE1hdGguYWJzKHggLSB4MSkgPiBkUDFDUDEgfHwgTWF0aC5hYnMoeSAtIHkxKSA+IGRQMUNQMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MSwgeTEpLFxuICAgICAgICBkUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MiwgeTIpLFxuICAgICAgICB0ID0gMC41LFxuICAgICAgICByID0gKGRQMSA8IGRQMikgPyAtMC4wMSA6IDAuMDEsXG4gICAgICAgIHJUaHJlc2hvbGQgPSAwLjAwMSxcbiAgICAgICAgaSA9IDEwMCxcbiAgICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgICAgdCwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIpLFxuICAgICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpLFxuICAgICAgICBvbGRfZHQ7XG5cbiAgICAvLyBUaGlzIGFsZ29yaXRobSBtaW5pbWl6ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBjdXJ2ZS4gSXRcbiAgICAvLyBmaW5kIHRoZSBvcHRpbWFsIHQgdmFsdWUgd2hlcmUgdD0wIGlzIHRoZSBzdGFydCBwb2ludCBhbmQgdD0xIGlzIHRoZSBlbmRcbiAgICAvLyBwb2ludCBvZiB0aGUgY3VydmUsIHN0YXJ0aW5nIGZyb20gdD0wLjUuXG4gICAgLy8gSXQgdGVybWluYXRlcyBiZWNhdXNlIGl0IHJ1bnMgYSBtYXhpbXVtIG9mIGkgaW50ZXJhdGlvbnMuXG4gICAgd2hpbGUgKGktLSA+IDAgJiZcbiAgICAgIHQgPj0gMCAmJiB0IDw9IDEgJiZcbiAgICAgIChkdCA+IGVwc2lsb24pICYmXG4gICAgICAociA+IHJUaHJlc2hvbGQgfHwgciA8IC1yVGhyZXNob2xkKSkge1xuICAgICAgb2xkX2R0ID0gZHQ7XG4gICAgICBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25CZXppZXJDdXJ2ZShcbiAgICAgICAgdCwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIpO1xuICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KTtcblxuICAgICAgaWYgKGR0ID4gb2xkX2R0KSB7XG4gICAgICAgIC8vIG5vdCB0aGUgcmlnaHQgZGlyZWN0aW9uOlxuICAgICAgICAvLyBoYWxmc3RlcCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgIHIgPSAtciAvIDI7XG4gICAgICAgIHQgKz0gcjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHQgKyByIDwgMCB8fCB0ICsgciA+IDEpIHtcbiAgICAgICAgLy8gb29wcywgd2UndmUgZ29uZSB0b28gZmFyOlxuICAgICAgICAvLyByZXZlcnQgd2l0aCBhIGhhbGZzdGVwXG4gICAgICAgIHIgPSByIC8gMjtcbiAgICAgICAgZHQgPSBvbGRfZHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvZ3Jlc3M6XG4gICAgICAgIHQgKz0gcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZHQgPCBlcHNpbG9uO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKioqKlxuICAgKiBFVkVOVFMgVVRJTFM6XG4gICAqICoqKioqKioqKioqKlxuICAgKi9cbiAgLyoqXG4gICAqIEhlcmUgYXJlIHNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB0byB1bmlmeSBleHRyYWN0aW9uIG9mIHRoZSBpbmZvcm1hdGlvbiB3ZVxuICAgKiBuZWVkIHdpdGggbW91c2UgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMsIGZyb20gZGlmZmVyZW50IGJyb3dzZXJzOlxuICAgKi9cblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWCBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFggdmFsdWUgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0WCA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUub2Zmc2V0WCAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WCkgfHxcbiAgICAgIChlLmxheWVyWCAhPT0gdW5kZWZpbmVkICYmIGUubGF5ZXJYKSB8fFxuICAgICAgKGUuY2xpZW50WCAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WClcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBsb2NhbCBZIHBvc2l0aW9uIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgbG9jYWwgWSB2YWx1ZSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRZID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoZS5vZmZzZXRZICE9PSB1bmRlZmluZWQgJiYgZS5vZmZzZXRZKSB8fFxuICAgICAgKGUubGF5ZXJZICE9PSB1bmRlZmluZWQgJiYgZS5sYXllclkpIHx8XG4gICAgICAoZS5jbGllbnRZICE9PSB1bmRlZmluZWQgJiYgZS5jbGllbnRZKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgc2NyZWVuLiBUYWtpbmcgem9vbSBpbnRvIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgUGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlblxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByYXRpbyA9IDE7XG4gICAgaWYgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSA+IHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkpIHtcbiAgICAgICAgcmF0aW8gPSB3aW5kb3cuc2NyZWVuLnN5c3RlbVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIHJldHVybiByYXRpbztcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgd2lkdGggZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aWR0aCBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRXaWR0aCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdyA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XG4gICAgICAgICAgICAgIGUudGFyZ2V0LndpZHRoIDpcbiAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJTVkdFbGVtZW50LndpZHRoO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICh0eXBlb2YgdyA9PT0gJ251bWJlcicgJiYgdykgfHxcbiAgICAgICh3ICE9PSB1bmRlZmluZWQgJiYgdy5iYXNlVmFsICE9PSB1bmRlZmluZWQgJiYgdy5iYXNlVmFsLnZhbHVlKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGNlbnRlciBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNlbnRlciBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRDZW50ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHJhdGlvID0gZS50YXJnZXQubmFtZXNwYWNlVVJJLmluZGV4T2YoJ3N2ZycpICE9PSAtMSA/IDEgOlxuICAgICAgICBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHNpZ21hLnV0aWxzLmdldFdpZHRoKGUpIC8gKDIgKiByYXRpbyksXG4gICAgICB5OiBzaWdtYS51dGlscy5nZXRIZWlnaHQoZSkgLyAoMiAqIHJhdGlvKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgbW91c2UgY29vcmRzIHRvIHNpZ21hIGNvb3Jkc1xuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEBwYXJhbSAge251bWJlcj99IHggVGhlIHggY29vcmQgdG8gY29udmVydFxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB5IGNvb3JkIHRvIGNvbnZlcnRcbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICBUaGUgc3RhbmRhcmRpemVkIGV2ZW50XG4gICAqL1xuICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyA9IGZ1bmN0aW9uKGUsIHgsIHkpIHtcbiAgICB4ID0geCB8fCBzaWdtYS51dGlscy5nZXRYKGUpO1xuICAgIHkgPSB5IHx8IHNpZ21hLnV0aWxzLmdldFkoZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICB5OiB5IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAgICAgICAgYWx0S2V5OiBlLmFsdEtleSxcbiAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBoZWlnaHQgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBoZWlnaHQgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBoID0gKCFlLnRhcmdldC5vd25lclNWR0VsZW1lbnQpID9cbiAgICAgICAgICAgICAgZS50YXJnZXQuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJTVkdFbGVtZW50LmhlaWdodDtcblxuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIGggPT09ICdudW1iZXInICYmIGgpIHx8XG4gICAgICAoaCAhPT0gdW5kZWZpbmVkICYmIGguYmFzZVZhbCAhPT0gdW5kZWZpbmVkICYmIGguYmFzZVZhbC52YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIHdoZWVsIGRlbHRhIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldERlbHRhID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoXG4gICAgICAoZS53aGVlbERlbHRhICE9PSB1bmRlZmluZWQgJiYgZS53aGVlbERlbHRhKSB8fFxuICAgICAgKGUuZGV0YWlsICE9PSB1bmRlZmluZWQgJiYgLWUuZGV0YWlsKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldCBvZiBhIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb20gVGhlIGVsZW1lbnQgdG8gcmV0cmlldmUgdGhlIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIG9mZnNldCBvZiB0aGUgRE9NIGVsZW1lbnQgKHRvcCwgbGVmdCkuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXRPZmZzZXQgPSBmdW5jdGlvbihkb20pIHtcbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDA7XG5cbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICB0b3AgPSB0b3AgKyBwYXJzZUludChkb20ub2Zmc2V0VG9wKTtcbiAgICAgIGxlZnQgPSBsZWZ0ICsgcGFyc2VJbnQoZG9tLm9mZnNldExlZnQpO1xuICAgICAgZG9tID0gZG9tLm9mZnNldFBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogU2ltdWxhdGVzIGEgXCJkb3VibGUgY2xpY2tcIiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNsaWNrcyA9IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBoYW5kbGVycztcblxuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgfHwge307XG4gICAgdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXSB8fCBbXTtcbiAgICBoYW5kbGVycyA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdO1xuXG4gICAgaGFuZGxlcnMucHVzaChmdW5jdGlvbihlKSB7XG4gICAgICBjbGlja3MrKztcblxuICAgICAgaWYgKGNsaWNrcyA9PT0gMikge1xuICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICB9IGVsc2UgaWYgKGNsaWNrcyA9PT0gMSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNsaWNrcyA9IDA7XG4gICAgICAgIH0sIHNpZ21hLnNldHRpbmdzLmRvdWJsZUNsaWNrVGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyc1toYW5kbGVycy5sZW5ndGggLSAxXSwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmJpbmQgc2ltdWxhdGVkIFwiZG91YmxlIGNsaWNrXCIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgIHR5cGUgICAgIFRoZSBldmVudCB0eXBlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUpIHtcbiAgICB2YXIgaGFuZGxlcixcbiAgICAgICAgaGFuZGxlcnMgPSAodGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgfHwge30pW3R5cGVdIHx8IFtdO1xuXG4gICAgd2hpbGUgKChoYW5kbGVyID0gaGFuZGxlcnMucG9wKCkpKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICBkZWxldGUgKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogSGVyZSBhcmUganVzdCBzb21lIG9mIHRoZSBtb3N0IGJhc2ljIGVhc2luZyBmdW5jdGlvbnMsIHVzZWQgZm9yIHRoZVxuICAgKiBhbmltYXRlZCBjYW1lcmEgXCJnb1RvXCIgY2FsbHMuXG4gICAqXG4gICAqIElmIHlvdSBuZWVkIHNvbWUgbW9yZSBlYXNpbmdzIGZ1bmN0aW9ucywgZG9uJ3QgaGVzaXRhdGUgdG8gYWRkIHRoZW0gdG9cbiAgICogc2lnbWEudXRpbHMuZWFzaW5ncy4gQnV0IEkgd2lsbCBub3QgYWRkIHNvbWUgbW9yZSBoZXJlIG9yIG1lcmdlIFBSc1xuICAgKiBjb250YWluaW5nLCBiZWNhdXNlIEkgZG8gbm90IHdhbnQgc2lnbWEgc291cmNlcyBmdWxsIG9mIG92ZXJraWxsIGFuZCBuZXZlclxuICAgKiB1c2VkIHN0dWZmLi4uXG4gICAqL1xuICBzaWdtYS51dGlscy5lYXNpbmdzID0gc2lnbWEudXRpbHMuZWFzaW5ncyB8fCB7fTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5saW5lYXJOb25lID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNPdXQgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpXG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgcmV0dXJuIC0gMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY0luID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogayAqIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNPdXQgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5jdWJpY0luT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpXG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiAqKioqKioqKioqKipcbiAgICogV0VCR0wgVVRJTFM6XG4gICAqICoqKioqKioqKioqKlxuICAgKi9cbiAgLyoqXG4gICAqIExvYWRzIGEgV2ViR0wgc2hhZGVyIGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtXZWJHTENvbnRleHR9ICAgICAgICAgICBnbCAgICAgICAgICAgVGhlIFdlYkdMQ29udGV4dCB0byB1c2UuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZSBUaGUgc2hhZGVyIHNvdXJjZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgc2hhZGVyVHlwZSAgIFRoZSB0eXBlIG9mIHNoYWRlci5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oc3RyaW5nKTogdm9pZH0gZXJyb3IgICAgICAgIENhbGxiYWNrIGZvciBlcnJvcnMuXG4gICAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBzaGFkZXIuXG4gICAqL1xuICBzaWdtYS51dGlscy5sb2FkU2hhZGVyID0gZnVuY3Rpb24oZ2wsIHNoYWRlclNvdXJjZSwgc2hhZGVyVHlwZSwgZXJyb3IpIHtcbiAgICB2YXIgY29tcGlsZWQsXG4gICAgICAgIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcblxuICAgIC8vIExvYWQgdGhlIHNoYWRlciBzb3VyY2VcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgc2hhZGVyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGNvbXBpbGUgc3RhdHVzXG4gICAgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cbiAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZzpcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIGNvbXBpbGluZyBzaGFkZXIgXCInICsgc2hhZGVyICsgJ1wiOicgK1xuICAgICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwcm9ncmFtLCBhdHRhY2hlcyBzaGFkZXJzLCBiaW5kcyBhdHRyaWIgbG9jYXRpb25zLCBsaW5rcyB0aGVcbiAgICogcHJvZ3JhbSBhbmQgY2FsbHMgdXNlUHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXkuPFdlYkdMU2hhZGVyPn0gICAgc2hhZGVycyAgIFRoZSBzaGFkZXJzIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59ICAgICAgICAgYXR0cmlicyAgIFRoZSBhdHRyaWJzIG5hbWVzLlxuICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gICAgICAgICBsb2NhdGlvbnMgVGhlIGxvY2F0aW9ucyBmb3IgdGhlIGF0dHJpYnMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19ICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtID0gZnVuY3Rpb24oZ2wsIHNoYWRlcnMsIGF0dHJpYnMsIGxvYywgZXJyb3IpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbGlua2VkLFxuICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNoYWRlcnMubGVuZ3RoOyArK2kpXG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG5cbiAgICBpZiAoYXR0cmlicylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgKytpKVxuICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oXG4gICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICBsb2NhdGlvbnMgPyBsb2NhdGlvbnNbaV0gOiBpLFxuICAgICAgICAgIG9wdF9hdHRyaWJzW2ldXG4gICAgICAgICk7XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgIC8vIENoZWNrIHRoZSBsaW5rIHN0YXR1c1xuICAgIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuICAgIGlmICghbGlua2VkKSB7XG4gICAgICBpZiAoZXJyb3IpXG4gICAgICAgIGVycm9yKCdFcnJvciBpbiBwcm9ncmFtIGxpbmtpbmc6ICcgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG5cbiAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogKioqKioqKioqXG4gICAqIE1BVFJJQ0VTOlxuICAgKiAqKioqKioqKipcbiAgICogVGhlIGZvbGxvd2luZyB1dGlscyBhcmUganVzdCBoZXJlIHRvIGhlbHAgZ2VuZXJhdGluZyB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICogbWF0cmljZXMgZm9yIHRoZSBXZWJHTCByZW5kZXJlcnMuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnV0aWxzLm1hdHJpY2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIHRyYW5zbGF0aW9uIG1hdHJpeC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCB0cmFuc2xhdGlvbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBUaGUgWSB0cmFuc2xhdGlvbi5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbiA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgIHJldHVybiBbXG4gICAgICAxLCAwLCAwLFxuICAgICAgMCwgMSwgMCxcbiAgICAgIGR4LCBkeSwgMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIG9yIDJ4MiByb3RhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gIGFuZ2xlIFRoZSByb3RhdGlvbiBhbmdsZS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24gPSBmdW5jdGlvbihhbmdsZSwgbTIpIHtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICBjb3MsIC1zaW4sXG4gICAgICBzaW4sIGNvc1xuICAgIF0gOiBbXG4gICAgICBjb3MsIC1zaW4sIDAsXG4gICAgICBzaW4sIGNvcywgMCxcbiAgICAgIDAsIDAsIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgaG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gIHJhdGlvIFRoZSBzY2FsaW5nIHJhdGlvLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiAgICBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSAyeDIgbWF0cml4LlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy5zY2FsZSA9IGZ1bmN0aW9uKHJhdGlvLCBtMikge1xuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIHJhdGlvLCAwLFxuICAgICAgMCwgcmF0aW9cbiAgICBdIDogW1xuICAgICAgcmF0aW8sIDAsIDAsXG4gICAgICAwLCByYXRpbywgMCxcbiAgICAgIDAsIDAsIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgaG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIGEgIFRoZSBmaXJzdCBtYXRyaXguXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIGIgIFRoZSBzZWNvbmQgbWF0cml4LlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCBhc3N1bWUgYm90aCBtYXRyaWNlcyBhcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgMngyLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICBSZXR1cm5zIHRoZSBtYXRyaXguXG4gICAqL1xuICBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseSA9IGZ1bmN0aW9uKGEsIGIsIG0yKSB7XG4gICAgdmFyIGwgPSBtMiA/IDIgOiAzLFxuICAgICAgICBhMDAgPSBhWzAgKiBsICsgMF0sXG4gICAgICAgIGEwMSA9IGFbMCAqIGwgKyAxXSxcbiAgICAgICAgYTAyID0gYVswICogbCArIDJdLFxuICAgICAgICBhMTAgPSBhWzEgKiBsICsgMF0sXG4gICAgICAgIGExMSA9IGFbMSAqIGwgKyAxXSxcbiAgICAgICAgYTEyID0gYVsxICogbCArIDJdLFxuICAgICAgICBhMjAgPSBhWzIgKiBsICsgMF0sXG4gICAgICAgIGEyMSA9IGFbMiAqIGwgKyAxXSxcbiAgICAgICAgYTIyID0gYVsyICogbCArIDJdLFxuICAgICAgICBiMDAgPSBiWzAgKiBsICsgMF0sXG4gICAgICAgIGIwMSA9IGJbMCAqIGwgKyAxXSxcbiAgICAgICAgYjAyID0gYlswICogbCArIDJdLFxuICAgICAgICBiMTAgPSBiWzEgKiBsICsgMF0sXG4gICAgICAgIGIxMSA9IGJbMSAqIGwgKyAxXSxcbiAgICAgICAgYjEyID0gYlsxICogbCArIDJdLFxuICAgICAgICBiMjAgPSBiWzIgKiBsICsgMF0sXG4gICAgICAgIGIyMSA9IGJbMiAqIGwgKyAxXSxcbiAgICAgICAgYjIyID0gYlsyICogbCArIDJdO1xuXG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgYTAwICogYjAwICsgYTAxICogYjEwLFxuICAgICAgYTAwICogYjAxICsgYTAxICogYjExLFxuICAgICAgYTEwICogYjAwICsgYTExICogYjEwLFxuICAgICAgYTEwICogYjAxICsgYTExICogYjExXG4gICAgXSA6IFtcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCArIGEwMiAqIGIyMCxcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMSxcbiAgICAgIGEwMCAqIGIwMiArIGEwMSAqIGIxMiArIGEwMiAqIGIyMixcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCArIGExMiAqIGIyMCxcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMSArIGExMiAqIGIyMSxcbiAgICAgIGExMCAqIGIwMiArIGExMSAqIGIxMiArIGExMiAqIGIyMixcbiAgICAgIGEyMCAqIGIwMCArIGEyMSAqIGIxMCArIGEyMiAqIGIyMCxcbiAgICAgIGEyMCAqIGIwMSArIGEyMSAqIGIxMSArIGEyMiAqIGIyMSxcbiAgICAgIGEyMCAqIGIwMiArIGEyMSAqIGIxMiArIGEyMiAqIGIyMlxuICAgIF07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci5cbiAgICogZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuICAgKiBNSVQgbGljZW5zZVxuICAgKi9cbiAgdmFyIHgsXG4gICAgICBsYXN0VGltZSA9IDAsXG4gICAgICB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxuICBmb3IgKHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IHgrKykge1xuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICB9XG5cbiAgaWYgKCFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKSxcbiAgICAgICAgICBpZCA9IGdsb2JhbC5zZXRUaW1lb3V0KFxuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZVRvQ2FsbFxuICAgICAgICAgICk7XG5cbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG5cbiAgaWYgKCFnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUpXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgcG9seWZpbGwgZm91bmQgb24gTUROLlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kI0NvbXBhdGliaWxpdHlcbiAgICogUHVibGljIGRvbWFpblxuICAgKi9cbiAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZClcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG9UaGlzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIC8vIENsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlXG4gICAgICAgIC8vIGZ1bmN0aW9uOlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZSdcbiAgICAgICAgKTtcblxuICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICBmTk9QLFxuICAgICAgICAgIGZCb3VuZDtcblxuICAgICAgZk5PUCA9IGZ1bmN0aW9uKCkge307XG4gICAgICBmQm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZUb0JpbmQuYXBwbHkoXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGZOT1AgJiYgb1RoaXMgP1xuICAgICAgICAgICAgdGhpcyA6XG4gICAgICAgICAgICBvVGhpcyxcbiAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcblxuICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufSkodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBQYWNrYWdlcyBpbml0aWFsaXphdGlvbjpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zZXR0aW5ncycpO1xuXG4gIHZhciBzZXR0aW5ncyA9IHtcbiAgICAvKipcbiAgICAgKiBHUkFQSCBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBkYXRhIGhhdmUgdG8gYmUgY2xvbmVkIGluIG1ldGhvZHMgdG8gYWRkXG4gICAgLy8gICAgICAgICAgIG5vZGVzIG9yIGVkZ2VzLlxuICAgIGNsb25lOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLCBcInNvdXJjZVwiIGFuZFxuICAgIC8vICAgICAgICAgICBcInRhcmdldFwiIHZhbHVlcyBtdXN0IGJlIHNldCBhcyBpbW11dGFibGUuXG4gICAgaW1tdXRhYmxlOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgc2lnbWEgY2FuIGxvZyBpdHMgZXJyb3JzIGFuZCB3YXJuaW5ncy5cbiAgICB2ZXJib3NlOiBmYWxzZSxcblxuXG4gICAgLyoqXG4gICAgICogUkVOREVSRVJTIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7c3RyaW5nfVxuICAgIGNsYXNzUHJlZml4OiAnc2lnbWEnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdE5vZGVUeXBlOiAnZGVmJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlVHlwZTogJ2RlZicsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0TGFiZWxDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdE5vZGVDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsU2l6ZTogMTQsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGVkZ2VzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwic291cmNlXCIsIFwidGFyZ2V0XCIsIFwiZGVmYXVsdFwiXG4gICAgZWRnZUNvbG9yOiAnc291cmNlJyxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIHRoZSBtaW5pbWFsIGVkZ2UncyBhcnJvdyBkaXNwbGF5IHNpemUuXG4gICAgbWluQXJyb3dTaXplOiAwLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZm9udDogJ2FyaWFsJyxcbiAgICAvLyB7c3RyaW5nfSBFeGFtcGxlOiAnYm9sZCdcbiAgICBmb250U3R5bGU6ICcnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBsYWJlbHMgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxDb2xvcjogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBsYWJlbHMgc2l6ZS4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcImZpeGVkXCIsIFwicHJvcG9ydGlvbmFsXCJcbiAgICBsYWJlbFNpemU6ICdmaXhlZCcsXG4gICAgLy8ge3N0cmluZ30gVGhlIHJhdGlvIGJldHdlZW4gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgbGFiZWwgYW5kIHRoZSBub2RlIHNpemUuXG4gICAgbGFiZWxTaXplUmF0aW86IDEsXG4gICAgLy8ge251bWJlcn0gVGhlIG1pbmltdW0gc2l6ZSBhIG5vZGUgbXVzdCBoYXZlIHRvIHNlZSBpdHMgbGFiZWwgZGlzcGxheWVkLlxuICAgIGxhYmVsVGhyZXNob2xkOiA4LFxuICAgIC8vIHtudW1iZXJ9IFRoZSBvdmVyc2FtcGxpbmcgZmFjdG9yIHVzZWQgaW4gV2ViR0wgcmVuZGVyZXIuXG4gICAgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbzogMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgYm9yZGVyIG9mIGhvdmVyZWQgbm9kZXMuXG4gICAgYm9yZGVyU2l6ZTogMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBob3ZlcmVkIG5vZGUgYm9yZGVyJ3MgY29sb3IuXG4gICAgZGVmYXVsdE5vZGVCb3JkZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBob3ZlcmVkIG5vZGUncyBsYWJlbCBmb250LiBJZiBub3Qgc3BlY2lmaWVkLCB3aWxsIGhlcml0YXRlXG4gICAgLy8gICAgICAgICAgdGhlIFwiZm9udFwiIHZhbHVlLlxuICAgIGhvdmVyRm9udDogJycsXG4gICAgLy8ge2Jvb2xlYW59IElmIHRydWUsIHRoZW4gb25seSBvbmUgbm9kZSBjYW4gYmUgaG92ZXJlZCBhdCBhIHRpbWUuXG4gICAgc2luZ2xlSG92ZXI6IHRydWUsXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXG4gICAgaG92ZXJGb250U3R5bGU6ICcnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIHNoYWRvdyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyU2hhZG93OiAnZGVmYXVsdCcsXG4gICAgLy8ge3N0cmluZ31cbiAgICBsYWJlbEhvdmVyU2hhZG93Q29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBub2RlSG92ZXJDb2xvcjogJ25vZGUnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdE5vZGVIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgYmFja2dyb3VuZCBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyQkdDb2xvcjogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEhvdmVyTGFiZWxCR0NvbG9yOiAnI2ZmZicsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbGFiZWxzIGNvbG9yLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsSG92ZXJDb2xvcjogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBob3ZlciBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcImVkZ2VcIiwgXCJkZWZhdWx0XCJcbiAgICBlZGdlSG92ZXJDb2xvcjogJ2VkZ2UnLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBzaXplIG11bHRpcGxpY2F0b3Igb2YgaG92ZXJlZCBlZGdlcy5cbiAgICBlZGdlSG92ZXJTaXplUmF0aW86IDEsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZUhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlIGV4dHJlbWl0aWVzIG11c3QgYmUgaG92ZXJlZCB3aGVuIHRoZVxuICAgIC8vICAgICAgICAgICBlZGdlIGlzIGhvdmVyZWQuXG4gICAgZWRnZUhvdmVyRXh0cmVtaXRpZXM6IGZhbHNlLFxuICAgIC8vIHtib29sZWFuc30gVGhlIGRpZmZlcmVudCBkcmF3aW5nIG1vZGVzOlxuICAgIC8vICAgICAgICAgICBmYWxzZTogTGF5ZXJlZCBub3QgZGlzcGxheWVkLlxuICAgIC8vICAgICAgICAgICB0cnVlOiBMYXllcmVkIGRpc3BsYXllZC5cbiAgICBkcmF3RWRnZXM6IHRydWUsXG4gICAgZHJhd05vZGVzOiB0cnVlLFxuICAgIGRyYXdMYWJlbHM6IHRydWUsXG4gICAgZHJhd0VkZ2VMYWJlbHM6IGZhbHNlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2VzIG11c3QgYmUgZHJhd24gaW4gc2V2ZXJhbCBmcmFtZXMgb3IgaW5cbiAgICAvLyAgICAgICAgICAgb25lIGZyYW1lLCBhcyB0aGUgbm9kZXMgYW5kIGxhYmVscyBhcmUgZHJhd24uXG4gICAgYmF0Y2hFZGdlc0RyYXdpbmc6IGZhbHNlLFxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2VzIG11c3QgYmUgaGlkZGVuIGR1cmluZyBkcmFnZ2luZyBhbmRcbiAgICAvLyAgICAgICAgICAgYW5pbWF0aW9ucy5cbiAgICBoaWRlRWRnZXNPbk1vdmU6IGZhbHNlLFxuICAgIC8vIHtudW1iZXJzfSBUaGUgZGlmZmVyZW50IGJhdGNoIHNpemVzLCB3aGVuIGVsZW1lbnRzIGFyZSBkaXNwbGF5ZWQgaW5cbiAgICAvLyAgICAgICAgICAgc2V2ZXJhbCBmcmFtZXMuXG4gICAgY2FudmFzRWRnZXNCYXRjaFNpemU6IDUwMCxcbiAgICB3ZWJnbEVkZ2VzQmF0Y2hTaXplOiAxMDAwLFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogUkVTQ0FMRSBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBvZiB0byBzY2FsZSB0aGUgZ3JhcGggcmVsYXRpdmVseSB0byBpdHMgY29udGFpbmVyLlxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwiaW5zaWRlXCIsIFwib3V0c2lkZVwiXG4gICAgc2NhbGluZ01vZGU6ICdpbnNpZGUnLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXJnaW4gdG8ga2VlcCBhcm91bmQgdGhlIGdyYXBoLlxuICAgIHNpZGVNYXJnaW46IDAsXG4gICAgLy8ge251bWJlcn0gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBzbWFsbGVzdCBhbmQgdGhlIGJpZ2dlc3Qgbm9kZSAvIGVkZ2VzXG4gICAgLy8gICAgICAgICAgb24gdGhlIHNjcmVlbi4gVGhpcyBtYXBwaW5nIG1ha2VzIGVhc2llciB0byBkaXNwbGF5IHRoZSBncmFwaCxcbiAgICAvLyAgICAgICAgICBhdm9pZGluZyB0b28gYmlnIG5vZGVzIHRoYXQgdGFrZSBoYWxmIG9mIHRoZSBzY3JlZW4sIG9yIHRvb1xuICAgIC8vICAgICAgICAgIHNtYWxsIG9uZXMgdGhhdCBhcmUgbm90IHJlYWRhYmxlLiBJZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlXG4gICAgLy8gICAgICAgICAgZXF1YWxzLCB0aGVuIHRoZSBtaW5pbWFsIGRpc3BsYXkgc2l6ZSB3aWxsIGJlIDAuIEFuZCBpZiB0aGV5XG4gICAgLy8gICAgICAgICAgYXJlIGJvdGggZXF1YWwgdG8gMCwgdGhlbiB0aGVyZSBpcyBubyBtYXBwaW5nLCBhbmQgdGhlIHJhZGl1c1xuICAgIC8vICAgICAgICAgIG9mIHRoZSBub2RlcyB3aWxsIGJlIHRoZWlyIHNpemUuXG4gICAgbWluRWRnZVNpemU6IDAuNSxcbiAgICBtYXhFZGdlU2l6ZTogMSxcbiAgICBtaW5Ob2RlU2l6ZTogMSxcbiAgICBtYXhOb2RlU2l6ZTogOCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIENBUFRPUlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7Ym9vbGVhbn1cbiAgICB0b3VjaEVuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgbW91c2VFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIG1vdXNlV2hlZWxFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIGRvdWJsZUNsaWNrRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGVmaW5lcyB3aGV0aGVyIHRoZSBjdXN0b20gZXZlbnRzIHN1Y2ggYXMgXCJjbGlja05vZGVcIiBjYW4gYmVcbiAgICAvLyAgICAgICAgICAgdXNlZC5cbiAgICBldmVudHNFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtudW1iZXJ9IERlZmluZXMgYnkgaG93IG11Y2ggbXVsdGlwbGljYXRpbmcgdGhlIHpvb21pbmcgbGV2ZWwgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICB1c2VyIHpvb21zIHdpdGggdGhlIG1vdXNlLXdoZWVsLlxuICAgIHpvb21pbmdSYXRpbzogMS43LFxuICAgIC8vIHtudW1iZXJ9IERlZmluZXMgYnkgaG93IG11Y2ggbXVsdGlwbGljYXRpbmcgdGhlIHpvb21pbmcgbGV2ZWwgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICB1c2VyIHpvb21zIGJ5IGRvdWJsZSBjbGlja2luZy5cbiAgICBkb3VibGVDbGlja1pvb21pbmdSYXRpbzogMi4yLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHpvb21pbmcgbGV2ZWwuXG4gICAgem9vbU1pbjogMC4wNjI1LFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHpvb21pbmcgbGV2ZWwuXG4gICAgem9vbU1heDogMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBzY3JvbGxpbmcuXG4gICAgbW91c2Vab29tRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBkb3VibGUgY2xpY2suXG4gICAgZG91YmxlQ2xpY2tab29tRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBkcm9wcGluZy5cbiAgICBtb3VzZUluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyIChtb3VzZSBjYXB0b3IpLlxuICAgIG1vdXNlSW5lcnRpYVJhdGlvOiAzLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIHRvdWNoIGRyb3BwaW5nLlxuICAgIHRvdWNoSW5lcnRpYUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGluZXJ0aWEgcG93ZXIgKHRvdWNoIGNhcHRvcikuXG4gICAgdG91Y2hJbmVydGlhUmF0aW86IDMsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byBjbGlja3MgdG8gbWFrZSBpdCBhIGRvdWJsZSBjbGljay5cbiAgICBkb3VibGVDbGlja1RpbWVvdXQ6IDMwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gdHdvIHRhcHMgdG8gbWFrZSBpdCBhIGRvdWJsZSB0YXAuXG4gICAgZG91YmxlVGFwVGltZW91dDogMzAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgb2YgZHJhZ2dpbmcgdG8gdHJpZ2dlciBpbnRlcnRpYS5cbiAgICBkcmFnVGltZW91dDogMjAwLFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogR0xPQkFMIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBoYXMgdG8gcmVmcmVzaCBpdHNlbGZcbiAgICAvLyAgICAgICAgICAgYXV0b21hdGljYWxseSB3aGVuIGEgXCJyZXNpemVcIiBldmVudCBpcyBkaXNwYXRjaGVkIGZyb20gdGhlXG4gICAgLy8gICAgICAgICAgIHdpbmRvdyBvYmplY3QuXG4gICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBcInJlc2NhbGVcIiBtaWRkbGV3YXJlIGhhcyB0byBiZSBjYWxsZWRcbiAgICAvLyAgICAgICAgICAgYXV0b21hdGljYWxseSBmb3IgZWFjaCBjYW1lcmEgb24gcmVmcmVzaC5cbiAgICBhdXRvUmVzY2FsZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIGZhbHNlLCB0aGUgY2FtZXJhIG1ldGhvZCBcImdvVG9cIiB3aWxsIGJhc2ljYWxseSBkb1xuICAgIC8vICAgICAgICAgICBub3RoaW5nLlxuICAgIGVuYWJsZUNhbWVyYTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIGZhbHNlLCB0aGUgbm9kZXMgY2Fubm90IGJlIGhvdmVyZWQuXG4gICAgZW5hYmxlSG92ZXJpbmc6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgZWRnZXMgY2FuIGJlIGhvdmVyZWQuXG4gICAgZW5hYmxlRWRnZUhvdmVyaW5nOiBmYWxzZSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiB0aGUgYXJlYSBhcm91bmQgdGhlIGVkZ2VzIHRvIGFjdGl2YXRlIGhvdmVyaW5nLlxuICAgIGVkZ2VIb3ZlclByZWNpc2lvbjogNSxcbiAgICAvLyB7Ym9vbGVhbn0gSWYgc2V0IHRvIHRydWUsIHRoZSByZXNjYWxlIG1pZGRsZXdhcmUgd2lsbCBpZ25vcmUgbm9kZSBzaXplc1xuICAgIC8vICAgICAgICAgICB0byBkZXRlcm1pbmUgdGhlIGdyYXBocyBib3VuZGluZ3MuXG4gICAgcmVzY2FsZUlnbm9yZVNpemU6IGZhbHNlLFxuICAgIC8vIHtib29sZWFufSBEZXRlcm1pbmVzIGlmIHRoZSBjb3JlIGhhcyB0byB0cnkgdG8gY2F0Y2ggZXJyb3JzIG9uXG4gICAgLy8gICAgICAgICAgIHJlbmRlcmluZy5cbiAgICBza2lwRXJyb3JzOiBmYWxzZSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIENBTUVSQSBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge251bWJlcn0gVGhlIHBvd2VyIGRlZ3JlZXMgYXBwbGllZCB0byB0aGUgbm9kZXMvZWRnZXMgc2l6ZSByZWxhdGl2ZWx5IHRvXG4gICAgLy8gICAgICAgICAgdGhlIHpvb21pbmcgbGV2ZWwuIEJhc2ljYWxseTpcbiAgICAvLyAgICAgICAgICAgPiBvblNjcmVlblIgPSBNYXRoLnBvdyh6b29tLCBub2Rlc1Bvd1JhdGlvKSAqIFJcbiAgICAvLyAgICAgICAgICAgPiBvblNjcmVlblQgPSBNYXRoLnBvdyh6b29tLCBlZGdlc1Bvd1JhdGlvKSAqIFRcbiAgICBub2Rlc1Bvd1JhdGlvOiAwLjUsXG4gICAgZWRnZXNQb3dSYXRpbzogMC41LFxuXG5cblxuXG4gICAgLyoqXG4gICAgICogQU5JTUFUSU9OUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtudW1iZXJ9IFRoZSBkZWZhdWx0IGFuaW1hdGlvbiB0aW1lLlxuICAgIGFuaW1hdGlvbnNUaW1lOiAyMDBcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIHByZXZpb3VzbHkgZGVzaWduZWQgc2V0dGluZ3M6XG4gIHNpZ21hLnNldHRpbmdzID0gc2lnbWEudXRpbHMuZXh0ZW5kKHNpZ21hLnNldHRpbmdzIHx8IHt9LCBzZXR0aW5ncyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXIgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9IFRoZSBuZXcgZGlzcGF0Y2hlciBpbnN0YW5jZS5cbiAgICovXG4gIHZhciBkaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfaGFuZGxlcnMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheTtcblxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnXG4gICAgKVxuICAgICAgZm9yIChldmVudHMgaW4gYXJndW1lbnRzWzBdKVxuICAgICAgICB0aGlzLmJpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XG4gICAgZWxzZSBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgZXZlbnQgaXMgbm90ICcnOlxuICAgICAgICBpZiAoIWV2ZW50KVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnRdKVxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xuXG4gICAgICAgIC8vIFVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHRoZSBoYW5kbGVyIHdpbGwgbWFrZSBwb3NzaWJsZVxuICAgICAgICAvLyBsYXRlciB0byBhZGQgZmxhZ3NcbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyAnYmluZDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgaGFuZGxlciBmcm9tIGEgc3BlY2lmaWVkIGV2ZW50IChvciBzcGVjaWZpZWQgZXZlbnRzKS5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gIHs/ZnVuY3Rpb24ob2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byB1bmJpbmQuIElmIHVuZGVmaW5lZCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudCBvciB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4sXG4gICAgICAgIGosXG4gICAgICAgIG0sXG4gICAgICAgIGssXG4gICAgICAgIGEsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGsgaW4gdGhpcy5faGFuZGxlcnMpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1trXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgYSA9IFtdO1xuICAgICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBtOyBqICs9IDEpXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdLmhhbmRsZXIgIT09IGhhbmRsZXIpXG4gICAgICAgICAgICAgIGEucHVzaCh0aGlzLl9oYW5kbGVyc1tldmVudF1bal0pO1xuXG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5faGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSlcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2VBcnJheVtpXV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBldmVudHMgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzIHNlcGFyYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50cywgZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuLFxuICAgICAgICBqLFxuICAgICAgICBtLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGE7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbjsgaSArPSAxKSB7XG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XG5cbiAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIGV2ZW50ID0gc2VsZi5nZXRFdmVudChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICBhID0gW107XG5cbiAgICAgICAgZm9yIChqID0gMCwgbSA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBtOyBqICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2pdLmhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5vbmUpXG4gICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGFuIGV2ZW50IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtICB7P29iamVjdH0gZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUuZ2V0RXZlbnQgPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBldmVudCxcbiAgICAgIGRhdGE6IGRhdGEgfHwge30sXG4gICAgICB0YXJnZXQ6IHRoaXNcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHVzZWZ1bCBmdW5jdGlvbiB0byBkZWFsIHdpdGggaW5oZXJpdGFuY2UuIEl0IHdpbGwgbWFrZSB0aGUgdGFyZ2V0XG4gICAqIGluaGVyaXQgdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3MgZGlzcGF0Y2hlciBhcyB3ZWxsIGFzIGl0cyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0LlxuICAgKi9cbiAgZGlzcGF0Y2hlci5leHRlbmQgPSBmdW5jdGlvbih0YXJnZXQsIGFyZ3MpIHtcbiAgICB2YXIgaztcblxuICAgIGZvciAoayBpbiBkaXNwYXRjaGVyLnByb3RvdHlwZSlcbiAgICAgIGlmIChkaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgdGFyZ2V0W2tdID0gZGlzcGF0Y2hlci5wcm90b3R5cGVba107XG5cbiAgICBkaXNwYXRjaGVyLmFwcGx5KHRhcmdldCwgYXJncyk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGlzcGF0Y2hlcjtcbiAgICBleHBvcnRzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICB9IGVsc2VcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUaGlzIHV0aWxzIGFpbXMgdG8gZmFjaWxpdGF0ZSB0aGUgbWFuaXB1bGF0aW9uIG9mIGVhY2ggaW5zdGFuY2Ugc2V0dGluZy5cbiAgICogVXNpbmcgYSBmdW5jdGlvbiBpbnN0ZWFkIG9mIGFuIG9iamVjdCBicmluZ3MgdHdvIG1haW4gYWR2YW50YWdlczogRmlyc3QsXG4gICAqIGl0IHdpbGwgYmUgZWFzaWVyIGluIHRoZSBmdXR1cmUgdG8gY2F0Y2ggc2V0dGluZ3MgdXBkYXRlcyB0aHJvdWdoIGFcbiAgICogZnVuY3Rpb24gdGhhbiBhbiBvYmplY3QuIFNlY29uZCwgZ2l2aW5nIGl0IGEgZnVsbCBvYmplY3Qgd2lsbCBcIm1lcmdlXCIgaXRcbiAgICogdG8gdGhlIHNldHRpbmdzIG9iamVjdCBwcm9wZXJseSwga2VlcGluZyB1cyB0byBoYXZlIHRvIGFsd2F5cyBhZGQgYSBsb29wLlxuICAgKlxuICAgKiBAcmV0dXJuIHtjb25maWd1cmFibGV9IFRoZSBcInNldHRpbmdzXCIgZnVuY3Rpb24uXG4gICAqL1xuICB2YXIgY29uZmlndXJhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGRhdGEgPSB7fSxcbiAgICAgICAgZGF0YXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCB0byB1c2UgdG8gc2V0IG9yIGdldCBhbnkgcHJvcGVydHkgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9ICAgIGExIElmIGl0IGlzIGEgc3RyaW5nIGFuZCBpZiBhMiBpcyB1bmRlZmluZWQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBpdCB3aWxsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LiBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQsIHRoZW4gaXQgd2lsbCBzZXQgYTIgYXMgdGhlIHByb3BlcnR5XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZGluZyB0byBhMSwgYW5kIHJldHVybiB0aGlzLiBJZlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IGlzIGFuIG9iamVjdCwgdGhlbiBlYWNoIHBhaXIgc3RyaW5nICtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Qob3IgYW55IG90aGVyIHR5cGUpIHdpbGwgYmUgc2V0IGFzIGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gIHsqP30gICAgICAgICAgICAgICBhMiBUaGUgbmV3IHByb3BlcnR5IGNvcnJlc3BvbmRpbmcgdG8gYTEgaWYgYTFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHsqfGNvbmZpZ3VyYWJsZX0gICAgICBSZXR1cm5zIGl0c2VsZiBvciB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogUG9seW1vcnBoaXNtOlxuICAgICAqICoqKioqKioqKioqKipcbiAgICAgKiBIZXJlIGFyZSBzb21lIGJhc2ljIHVzZSBleGFtcGxlczpcbiAgICAgKlxuICAgICAqICA+IHNldHRpbmdzID0gbmV3IGNvbmZpZ3VyYWJsZSgpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnLCA0Mik7XG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycpOyAvLyBMb2dzOiA0MlxuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnLCAxMjMpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogMTIzXG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogNDU2fSk7XG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycpOyAvLyBMb2dzOiA0NTZcbiAgICAgKlxuICAgICAqIEFsc28sIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGUgZnVuY3Rpb24gYXMgYSBmYWxsYmFjazpcbiAgICAgKiAgPiBzZXR0aW5ncyh7bXlTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgIC8vIExvZ3M6ICdhYmMnXG4gICAgICogID4gc2V0dGluZ3Moe2hpc1NldHRpbmc6ICdhYmMnfSwgJ215U2V0dGluZycpOyAvLyBMb2dzOiA0NTZcbiAgICAgKi9cbiAgICB2YXIgc2V0dGluZ3MgPSBmdW5jdGlvbihhMSwgYTIpIHtcbiAgICAgIHZhciBvLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBrO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYTEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkYXRhW2ExXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybiBkYXRhW2ExXTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGRhdGFzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBpZiAoZGF0YXNbaV1bYTFdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZGF0YXNbaV1bYTFdO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhMiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIChhMSB8fCB7fSlbYTJdICE9PSB1bmRlZmluZWQgPyBhMVthMl0gOiBzZXR0aW5ncyhhMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvID0gKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgJiYgYTIgPT09IHVuZGVmaW5lZCkgPyBhMSA6IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYTEgPT09ICdzdHJpbmcnKVxuICAgICAgICAgIG9bYTFdID0gYTI7XG5cbiAgICAgICAgZm9yIChpID0gMCwgayA9IE9iamVjdC5rZXlzKG8pLCBsID0gay5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgZGF0YVtrW2ldXSA9IG9ba1tpXV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgY29uZmlndXJhYmxlIGZ1bmN0aW9uLCB3aXRoIG5ldyBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3QqfSAgQW55IG51bWJlciBvZiBvYmplY3RzIHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gUmV0dXJucyB0aGUgZnVuY3Rpb24uIENoZWNrIGl0cyBkb2N1bWVudGF0aW9uIHRvIGtub3dcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbW9yZSBhYm91dCBob3cgaXQgd29ya3MuXG4gICAgICovXG4gICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGRhdGFzLmNvbmNhdChcbiAgICAgICAgZGF0YVxuICAgICAgKS5jb25jYXQoXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY29uZmlndXJhYmxlLmFwcGx5KHt9LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6ZVxuICAgIGZvciAoaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgc2V0dGluZ3MoYXJndW1lbnRzW2ldKTtcblxuICAgIHJldHVybiBzZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29uZmlndXJhYmxlO1xuICAgIGV4cG9ydHMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xuICB9IGVsc2VcbiAgICB0aGlzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX21ldGhvZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX2luZGV4ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX2luaXRCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfbWV0aG9kQmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9kZWZhdWx0U2V0dGluZ3MgPSB7XG4gICAgICAgIGltbXV0YWJsZTogdHJ1ZSxcbiAgICAgICAgY2xvbmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0U2V0dGluZ3Nba2V5XTtcbiAgICAgIH07XG5cbiAgLyoqXG4gICAqIFRoZSBncmFwaCBjb25zdHJ1Y3Rvci4gSXQgaW5pdGlhbGl6ZXMgdGhlIGRhdGEgYW5kIHRoZSBpbmRleGVzLCBhbmQgYmluZHNcbiAgICogdGhlIGN1c3RvbSBpbmRleGVzIGFuZCBtZXRob2RzIHRvIGl0cyBvd24gc2NvcGUuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHtib29sZWFufSBjbG9uZSAgICAgSW5kaWNhdGVzIGlmIHRoZSBkYXRhIGhhdmUgdG8gYmUgY2xvbmVkIGluIG1ldGhvZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHRvIGFkZCBub2RlcyBvciBlZGdlcy5cbiAgICogICB7Ym9vbGVhbn0gaW1tdXRhYmxlIEluZGljYXRlcyBpZiBub2RlcyBcImlkXCIgdmFsdWVzIGFuZCBlZGdlcyBcImlkXCIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBcInNvdXJjZVwiIGFuZCBcInRhcmdldFwiIHZhbHVlcyBtdXN0IGJlIHNldCBhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBFdmVudHVhbGx5IGEgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2dyYXBofSAgICAgICAgICAgICAgICAgIFRoZSBuZXcgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICB2YXIgZ3JhcGggPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgIHZhciBrLFxuICAgICAgICBmbixcbiAgICAgICAgZGF0YTtcblxuICAgIC8qKlxuICAgICAqIERBVEE6XG4gICAgICogKioqKipcbiAgICAgKiBFdmVyeSBkYXRhIHRoYXQgaXMgY2FsbGFibGUgZnJvbSBncmFwaCBtZXRob2RzIGFyZSBzdG9yZWQgaW4gdGhpcyBcImRhdGFcIlxuICAgICAqIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSBzZXJ2ZWQgYXMgY29udGV4dCBmb3IgYWxsIHRoZXNlIG1ldGhvZHMsXG4gICAgICogYW5kIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBvdGhlciB0eXBlIG9mIGRhdGEgaW4gaXQuXG4gICAgICovXG4gICAgZGF0YSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogU0VUVElOR1MgRlVOQ1RJT046XG4gICAgICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICAgICAqL1xuICAgICAgc2V0dGluZ3M6IHNldHRpbmdzIHx8IF9kZWZhdWx0U2V0dGluZ3NGdW5jdGlvbixcblxuICAgICAgLyoqXG4gICAgICAgKiBNQUlOIERBVEE6XG4gICAgICAgKiAqKioqKioqKioqXG4gICAgICAgKi9cbiAgICAgIG5vZGVzQXJyYXk6IFtdLFxuICAgICAgZWRnZXNBcnJheTogW10sXG5cbiAgICAgIC8qKlxuICAgICAgICogR0xPQkFMIElOREVYRVM6XG4gICAgICAgKiAqKioqKioqKioqKioqKipcbiAgICAgICAqIFRoZXNlIGluZGV4ZXMganVzdCBpbmRleCBkYXRhIGJ5IGlkcy5cbiAgICAgICAqL1xuICAgICAgbm9kZXNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGVkZ2VzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgIC8qKlxuICAgICAgICogTE9DQUwgSU5ERVhFUzpcbiAgICAgICAqICoqKioqKioqKioqKioqXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIHJlZmVyIGZyb20gbm9kZSB0byBub2Rlcy4gRWFjaCBrZXkgaXMgYW4gaWQsIGFuZCBlYWNoXG4gICAgICAgKiB2YWx1ZSBpcyB0aGUgYXJyYXkgb2YgdGhlIGlkcyBvZiByZWxhdGVkIG5vZGVzLlxuICAgICAgICovXG4gICAgICBpbk5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgb3V0TmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBhbGxOZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgICAgaW5OZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG91dE5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYWxsTmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuXG4gICAgLy8gRXhlY3V0ZSBiaW5kaW5nczpcbiAgICBmb3IgKGsgaW4gX2luaXRCaW5kaW5ncylcbiAgICAgIF9pbml0QmluZGluZ3Nba10uY2FsbChkYXRhKTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGJvdGggdGhlIHNjb3BlIGFuZCB0aGUgZGF0YSBvYmplY3RzOlxuICAgIGZvciAoayBpbiBfbWV0aG9kcykge1xuICAgICAgZm4gPSBfX2JpbmRHcmFwaE1ldGhvZChrLCBkYXRhLCBfbWV0aG9kc1trXSk7XG4gICAgICB0aGlzW2tdID0gZm47XG4gICAgICBkYXRhW2tdID0gZm47XG4gICAgfVxuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSB0b29sIHRvIGJpbmQgbWV0aG9kcyBzdWNoIHRoYXQgZnVuY3Rpb24gdGhhdCBhcmUgYm91bmQgdG8gaXQgd2lsbFxuICAgKiBiZSBleGVjdXRlZCBhbnl0aW1lIHRoZSBtZXRob2QgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJpbmQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBzY29wZSAgICAgIFRoZSBzY29wZSB3aGVyZSB0aGUgbWV0aG9kIG11c3QgYmUgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmbiAgICAgICAgIFRoZSBtZXRob2QgaXRzZWxmLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgICBUaGUgbmV3IG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fYmluZEdyYXBoTWV0aG9kKG1ldGhvZE5hbWUsIHNjb3BlLCBmbikge1xuICAgIHZhciByZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrLFxuICAgICAgICAgIHJlcztcblxuICAgICAgLy8gRXhlY3V0ZSBcImJlZm9yZVwiIGJvdW5kIGZ1bmN0aW9uczpcbiAgICAgIGZvciAoayBpbiBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgIF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXVtrXS5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gQXBwbHkgdGhlIG1ldGhvZDpcbiAgICAgIHJlcyA9IGZuLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xuXG4gICAgICAvLyBFeGVjdXRlIGJvdW5kIGZ1bmN0aW9uczpcbiAgICAgIGZvciAoayBpbiBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXVtrXS5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gUmV0dXJuIHJlczpcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBjdXN0b20gdG9vbCBmdW5jdGlvbiByZW1vdmVzIGV2ZXJ5IHBhaXIga2V5L3ZhbHVlIGZyb20gYW4gaGFzaC4gVGhlXG4gICAqIGdvYWwgaXMgdG8gYXZvaWQgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHdoaWxlIHNvbWUgb3RoZXIgcmVmZXJlbmNlcyBhcmVcbiAgICogc3RpbGwgaGFuZ2luZyBpbiBzb21lIHNjb3Blcy4uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX19lbXB0eU9iamVjdChvYmopIHtcbiAgICB2YXIgaztcblxuICAgIGZvciAoayBpbiBvYmopXG4gICAgICBpZiAoISgnaGFzT3duUHJvcGVydHknIGluIG9iaikgfHwgb2JqLmhhc093blByb3BlcnR5KGspKVxuICAgICAgICBkZWxldGUgb2JqW2tdO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgYWRkcyBhIG1ldGhvZCB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhlIGZ1dHVybHkgY3JlYXRlZFxuICAgKiBncmFwaCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFNpbmNlIHRoZXNlIG1ldGhvZHMgd2lsbCBiZSBib3VuZCB0byB0aGVpciBzY29wZSB3aGVuIHRoZSBpbnN0YW5jZXMgYXJlXG4gICAqIGNyZWF0ZWQsIGl0IGRvZXMgbm90IHVzZSB0aGUgcHJvdG90eXBlLiBCZWNhdXNlIG9mIHRoYXQsIG1ldGhvZHMgaGF2ZSB0b1xuICAgKiBiZSBhZGRlZCBiZWZvcmUgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcbiAgICpcbiAgICogID4gZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIHRoaXMubm9kZXNBcnJheS5sZW5ndGg7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMFxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGZuKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG1ldGhvZE5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcbiAgICApXG4gICAgICB0aHJvdyAnYWRkTWV0aG9kOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSlcbiAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIF9tZXRob2RzW21ldGhvZE5hbWVdID0gZm47XG4gICAgX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIG1ldGhvZCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLCBhbmRcbiAgICogZmFsc2UgZWxzZS5cbiAgICpcbiAgICogSGVyZSBhcmUgc29tZSBleGFtcGxlczpcbiAgICpcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdhZGROb2RlJyk7IC8vIHJldHVybnMgdHJ1ZVxuICAgKiAgPiBncmFwaC5oYXNNZXRob2QoJ2hhc01ldGhvZCcpOyAvLyByZXR1cm5zIHRydWVcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCd1bmV4aXN0aW5nTWV0aG9kJyk7IC8vIHJldHVybnMgZmFsc2VcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgIFRoZSByZXN1bHQuXG4gICAqL1xuICBncmFwaC5oYXNNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuICEhKF9tZXRob2RzW21ldGhvZE5hbWVdIHx8IGdyYXBoW21ldGhvZE5hbWVdKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kcyBhdHRhY2hlcyBhIGZ1bmN0aW9uIHRvIGEgbWV0aG9kLiBBbnl0aW1lIHRoZSBzcGVjaWZpZWRcbiAgICogbWV0aG9kIGlzIGNhbGxlZCwgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBhZnRlciwgd2l0aCB0aGVcbiAgICogc2FtZSBhcmd1bWVudHMgYW5kIGluIHRoZSBzYW1lIHNjb3BlLiBUaGUgYXR0YWNoZWQgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAqIHJpZ2h0IGJlZm9yZSBpZiB0aGUgbGFzdCBhcmd1bWVudCBpcyB0cnVlLCB1bmxlc3MgdGhlIG1ldGhvZCBpcyB0aGUgZ3JhcGhcbiAgICogY29uc3RydWN0b3IuXG4gICAqXG4gICAqIFRvIGF0dGFjaCBhIGZ1bmN0aW9uIHRvIHRoZSBncmFwaCBjb25zdHJ1Y3RvciwgdXNlICdjb25zdHJ1Y3RvcicgYXMgdGhlXG4gICAqIG1ldGhvZCBuYW1lIChmaXJzdCBhcmd1bWVudCkuXG4gICAqXG4gICAqIFRoZSBtYWluIGlkZWEgaXMgdG8gaGF2ZSBhIGNsZWFuIHdheSB0byBrZWVwIGN1c3RvbSBpbmRleGVzIHVwIHRvIGRhdGUsXG4gICAqIGZvciBpbnN0YW5jZTpcbiAgICpcbiAgICogID4gdmFyIHRpbWVzQWRkTm9kZUNhbGxlZCA9IDA7XG4gICAqICA+IGdyYXBoLmF0dGFjaCgnYWRkTm9kZScsICd0aW1lc0FkZE5vZGVDYWxsZWRJbmMnLCBmdW5jdGlvbigpIHtcbiAgICogID4gICB0aW1lc0FkZE5vZGVDYWxsZWQrKztcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XG4gICAqICA+IGNvbnNvbGUubG9nKHRpbWVzQWRkTm9kZUNhbGxlZCk7IC8vIG91dHB1dHMgMFxuICAgKiAgPlxuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJzEnIH0pLmFkZE5vZGUoeyBpZDogJzInIH0pO1xuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDJcbiAgICpcbiAgICogVGhlIGlkZWEgZm9yIGNhbGxpbmcgYSBmdW5jdGlvbiBiZWZvcmUgaXMgdG8gcHJvdmlkZSBwcmUtcHJvY2Vzc29ycywgZm9yXG4gICAqIGluc3RhbmNlOlxuICAgKlxuICAgKiAgPiB2YXIgY29sb3JQYWxldHRlID0geyBQZXJzb246ICcjQzNDQkUxJywgUGxhY2U6ICcjOUJERUJEJyB9O1xuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAnYXBwbHlOb2RlQ29sb3JQYWxldHRlJywgZnVuY3Rpb24obikge1xuICAgKiAgPiAgIG4uY29sb3IgPSBjb2xvclBhbGV0dGVbbi5jYXRlZ29yeV07XG4gICAqICA+IH0sIHRydWUpO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJ24wJywgY2F0ZWdvcnk6ICdQZXJzb24nIH0pO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLm5vZGVzKCduMCcpLmNvbG9yKTsgLy8gb3V0cHV0cyAnI0MzQ0JFMSdcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlbGF0ZWQgbWV0aG9kIG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29uc3RydWN0b3JcIi5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIGtleSAgICAgICAgVGhlIGtleSB0byBpZGVudGlmeSB0aGUgZnVuY3Rpb24gdG8gYXR0YWNoLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGJlZm9yZSAgICAgSWYgdHJ1ZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIGdyYXBoLmF0dGFjaCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGtleSwgZm4sIGJlZm9yZSkge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDMgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiA0XG4gICAgKVxuICAgICAgdGhyb3cgJ2F0dGFjaDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICB2YXIgYmluZGluZ3M7XG5cbiAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJylcbiAgICAgIGJpbmRpbmdzID0gX2luaXRCaW5kaW5ncztcbiAgICBlbHNlIHtcbiAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgaWYgKCFfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgICAgICBiaW5kaW5ncyA9IF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoIV9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSlcbiAgICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJpbmRpbmdzW2tleV0pXG4gICAgICB0aHJvdyAnQSBmdW5jdGlvbiBcIicgKyBrZXkgKyAnXCIgaXMgYWxyZWFkeSBhdHRhY2hlZCAnICtcbiAgICAgICAgICAgICd0byB0aGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIuJztcblxuICAgIGJpbmRpbmdzW2tleV0gPSBmbjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbGlhcyBvZiBhdHRhY2gobWV0aG9kTmFtZSwga2V5LCBmbiwgdHJ1ZSkuXG4gICAqL1xuICBncmFwaC5hdHRhY2hCZWZvcmUgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgaXMganVzdCBhbiBoZWxwZXIgdG8gZGVhbCB3aXRoIGN1c3RvbSBpbmRleGVzLiBJdCB0YWtlcyBhc1xuICAgKiBhcmd1bWVudHMgdGhlIG5hbWUgb2YgdGhlIGluZGV4IGFuZCBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGRpZmZlcmVudFxuICAgKiBmdW5jdGlvbnMgdG8gYmluZCB0byB0aGUgbWV0aG9kcy5cbiAgICpcbiAgICogSGVyZSBpcyBhIGJhc2ljIGV4YW1wbGUsIHRoYXQgY3JlYXRlcyBhbiBpbmRleCB0byBrZWVwIHRoZSBudW1iZXIgb2Ygbm9kZXNcbiAgICogaW4gdGhlIGN1cnJlbnQgZ3JhcGguIEl0IGFsc28gYWRkcyBhIG1ldGhvZCB0byBwcm92aWRlIGEgZ2V0dGVyIG9uIHRoYXRcbiAgICogbmV3IGluZGV4OlxuICAgKlxuICAgKiAgPiBzaWdtYS5jbGFzc2VzLmdyYXBoLmFkZEluZGV4KCdub2Rlc0NvdW50Jywge1xuICAgKiAgPiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudCA9IDA7XG4gICAqICA+ICAgfSxcbiAgICogID4gICBhZGROb2RlOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudCsrO1xuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgZHJvcE5vZGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgICAgdGhpcy5ub2Rlc0NvdW50LS07XG4gICAqICA+ICAgfVxuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRNZXRob2QoJ2dldE5vZGVzQ291bnQnLCBmdW5jdGlvbigpIHtcbiAgICogID4gICByZXR1cm4gdGhpcy5ub2Rlc0NvdW50O1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMFxuICAgKiAgPlxuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJzEnIH0pLmFkZE5vZGUoeyBpZDogJzInIH0pO1xuICAgKiAgPiBjb25zb2xlLmxvZyhteUdyYXBoLmdldE5vZGVzQ291bnQoKSk7IC8vIG91dHB1dHMgMlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSBpbmRleC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBiaW5kaW5ncyBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZ1bmN0aW9ucyB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hZGRJbmRleCA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdzKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICBPYmplY3QoYmluZGluZ3MpICE9PSBiaW5kaW5ncyB8fFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMlxuICAgIClcbiAgICAgIHRocm93ICdhZGRJbmRleDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoX2luZGV4ZXNbbmFtZV0pXG4gICAgICB0aHJvdyAnVGhlIGluZGV4IFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIHZhciBrO1xuXG4gICAgLy8gU3RvcmUgdGhlIGJpbmRpbmdzOlxuICAgIF9pbmRleGVzW25hbWVdID0gYmluZGluZ3M7XG5cbiAgICAvLyBBdHRhY2ggdGhlIGJpbmRpbmdzOlxuICAgIGZvciAoayBpbiBiaW5kaW5ncylcbiAgICAgIGlmICh0eXBlb2YgYmluZGluZ3Nba10gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdUaGUgYmluZGluZ3MgbXVzdCBiZSBmdW5jdGlvbnMuJztcbiAgICAgIGVsc2VcbiAgICAgICAgZ3JhcGguYXR0YWNoKGssIG5hbWUsIGJpbmRpbmdzW2tdKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGEgbm9kZSB0byB0aGUgZ3JhcGguIFRoZSBub2RlIG11c3QgYmUgYW4gb2JqZWN0LCB3aXRoIGFcbiAgICogc3RyaW5nIHVuZGVyIHRoZSBrZXkgXCJpZFwiLiBFeGNlcHQgZm9yIHRoaXMsIGl0IGlzIHBvc3NpYmxlIHRvIGFkZCBhbnlcbiAgICogb3RoZXIgYXR0cmlidXRlLCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkIGFsbCBhbG9uZyB0aGUgbWFuaXB1bGF0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIGdyYXBoIG9wdGlvbiBcImNsb25lXCIgaGFzIGEgdHJ1dGh5IHZhbHVlLCB0aGUgbm9kZSB3aWxsIGJlIGNsb25lZFxuICAgKiB3aGVuIGFkZGVkIHRvIHRoZSBncmFwaC4gQWxzbywgaWYgdGhlIGdyYXBoIG9wdGlvbiBcImltbXV0YWJsZVwiIGhhcyBhXG4gICAqIHRydXRoeSB2YWx1ZSwgaXRzIGlkIHdpbGwgYmUgZGVmaW5lZCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gbm9kZSBUaGUgbm9kZSB0byBhZGQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2FkZE5vZGUnLCBmdW5jdGlvbihub2RlKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbm9kZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhbiBpZDpcbiAgICBpZiAoT2JqZWN0KG5vZGUpICE9PSBub2RlIHx8IGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnYWRkTm9kZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAodHlwZW9mIG5vZGUuaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBub2RlLmlkICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93ICdUaGUgbm9kZSBtdXN0IGhhdmUgYSBzdHJpbmcgb3IgbnVtYmVyIGlkLic7XG5cbiAgICBpZiAodGhpcy5ub2Rlc0luZGV4W25vZGUuaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIG5vZGUuaWQgKyAnXCIgYWxyZWFkeSBleGlzdHMuJztcblxuICAgIHZhciBrLFxuICAgICAgICBpZCA9IG5vZGUuaWQsXG4gICAgICAgIHZhbGlkTm9kZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xuICAgICAgZm9yIChrIGluIG5vZGUpXG4gICAgICAgIGlmIChrICE9PSAnaWQnKVxuICAgICAgICAgIHZhbGlkTm9kZVtrXSA9IG5vZGVba107XG4gICAgfSBlbHNlXG4gICAgICB2YWxpZE5vZGUgPSBub2RlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZE5vZGUsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB2YWxpZE5vZGUuaWQgPSBpZDtcblxuICAgIC8vIEFkZCBlbXB0eSBjb250YWluZXJzIGZvciBlZGdlcyBpbmRleGVzOlxuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbaWRdID0gMDtcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuXG4gICAgLy8gQWRkIHRoZSBub2RlIHRvIGluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc0FycmF5LnB1c2godmFsaWROb2RlKTtcbiAgICB0aGlzLm5vZGVzSW5kZXhbdmFsaWROb2RlLmlkXSA9IHZhbGlkTm9kZTtcblxuICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbnN0YW5jZTpcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGFkZHMgYW4gZWRnZSB0byB0aGUgZ3JhcGguIFRoZSBlZGdlIG11c3QgYmUgYW4gb2JqZWN0LCB3aXRoIGFcbiAgICogc3RyaW5nIHVuZGVyIHRoZSBrZXkgXCJpZFwiLCBhbmQgc3RyaW5ncyB1bmRlciB0aGUga2V5cyBcInNvdXJjZVwiIGFuZFxuICAgKiBcInRhcmdldFwiIHRoYXQgZGVzaWduIGV4aXN0aW5nIG5vZGVzLiBFeGNlcHQgZm9yIHRoaXMsIGl0IGlzIHBvc3NpYmxlIHRvXG4gICAqIGFkZCBhbnkgb3RoZXIgYXR0cmlidXRlLCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkIGFsbCBhbG9uZyB0aGVcbiAgICogbWFuaXB1bGF0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIGdyYXBoIG9wdGlvbiBcImNsb25lXCIgaGFzIGEgdHJ1dGh5IHZhbHVlLCB0aGUgZWRnZSB3aWxsIGJlIGNsb25lZFxuICAgKiB3aGVuIGFkZGVkIHRvIHRoZSBncmFwaC4gQWxzbywgaWYgdGhlIGdyYXBoIG9wdGlvbiBcImltbXV0YWJsZVwiIGhhcyBhXG4gICAqIHRydXRoeSB2YWx1ZSwgaXRzIGlkLCBzb3VyY2UgYW5kIHRhcmdldCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVkZ2UgVGhlIGVkZ2UgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGRFZGdlJywgZnVuY3Rpb24oZWRnZSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGVkZ2UgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XG4gICAgaWYgKE9iamVjdChlZGdlKSAhPT0gZWRnZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2FkZEVkZ2U6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKHR5cGVvZiBlZGdlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5pZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xuXG4gICAgaWYgKCh0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLnNvdXJjZSAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICF0aGlzLm5vZGVzSW5kZXhbZWRnZS5zb3VyY2VdKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIHNvdXJjZSBtdXN0IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBpZC4nO1xuXG4gICAgaWYgKCh0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBlZGdlLnRhcmdldCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgICF0aGlzLm5vZGVzSW5kZXhbZWRnZS50YXJnZXRdKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIHRhcmdldCBtdXN0IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBpZC4nO1xuXG4gICAgaWYgKHRoaXMuZWRnZXNJbmRleFtlZGdlLmlkXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBcIicgKyBlZGdlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgdmFsaWRFZGdlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIENoZWNrIHRoZSBcImNsb25lXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdjbG9uZScpKSB7XG4gICAgICBmb3IgKGsgaW4gZWRnZSlcbiAgICAgICAgaWYgKGsgIT09ICdpZCcgJiYgayAhPT0gJ3NvdXJjZScgJiYgayAhPT0gJ3RhcmdldCcpXG4gICAgICAgICAgdmFsaWRFZGdlW2tdID0gZWRnZVtrXTtcbiAgICB9IGVsc2VcbiAgICAgIHZhbGlkRWRnZSA9IGVkZ2U7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJpbW11dGFibGVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2ltbXV0YWJsZScpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRFZGdlLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLmlkLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ3NvdXJjZScsIHtcbiAgICAgICAgdmFsdWU6IGVkZ2Uuc291cmNlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ3RhcmdldCcsIHtcbiAgICAgICAgdmFsdWU6IGVkZ2UudGFyZ2V0LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRFZGdlLmlkID0gZWRnZS5pZDtcbiAgICAgIHZhbGlkRWRnZS5zb3VyY2UgPSBlZGdlLnNvdXJjZTtcbiAgICAgIHZhbGlkRWRnZS50YXJnZXQgPSBlZGdlLnRhcmdldDtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGVkZ2UgdG8gaW5kZXhlczpcbiAgICB0aGlzLmVkZ2VzQXJyYXkucHVzaCh2YWxpZEVkZ2UpO1xuICAgIHRoaXMuZWRnZXNJbmRleFt2YWxpZEVkZ2UuaWRdID0gdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0pXG4gICAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0gPVxuICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5vdXROZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSlcbiAgICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0gPVxuICAgICAgICBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0pXG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKHZhbGlkRWRnZS50YXJnZXQgIT09IHZhbGlkRWRnZS5zb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXSlcbiAgICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2Uuc291cmNlXSA9XG4gICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICAgIHZhbGlkRWRnZTtcbiAgICB9XG5cbiAgICAvLyBLZWVwIGNvdW50cyB1cCB0byBkYXRlOlxuICAgIHRoaXMuaW5OZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2UudGFyZ2V0XSsrO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnNvdXJjZV0rKztcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS50YXJnZXRdKys7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2Uuc291cmNlXSsrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkcm9wcyBhIG5vZGUgZnJvbSB0aGUgZ3JhcGguIEl0IGFsc28gcmVtb3ZlcyBlYWNoIGVkZ2UgdGhhdCBpc1xuICAgKiBib3VuZCB0byBpdCwgdGhyb3VnaCB0aGUgZHJvcEVkZ2UgbWV0aG9kLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIG5vZGVcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIG5vZGUgaWQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wTm9kZScsIGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdkcm9wTm9kZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIXRoaXMubm9kZXNJbmRleFtpZF0pXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgIHZhciBpLCBrLCBsO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gaW5kZXhlczpcbiAgICBkZWxldGUgdGhpcy5ub2Rlc0luZGV4W2lkXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLm5vZGVzQXJyYXlbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMubm9kZXNBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZXM6XG4gICAgZm9yIChpID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgaWYgKHRoaXMuZWRnZXNBcnJheVtpXS5zb3VyY2UgPT09IGlkIHx8IHRoaXMuZWRnZXNBcnJheVtpXS50YXJnZXQgPT09IGlkKVxuICAgICAgICB0aGlzLmRyb3BFZGdlKHRoaXMuZWRnZXNBcnJheVtpXS5pZCk7XG5cbiAgICAvLyBSZW1vdmUgcmVsYXRlZCBlZGdlIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtpZF07XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2lkXTtcblxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzQ291bnRbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0NvdW50W2lkXTtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtpZF07XG5cbiAgICBmb3IgKGsgaW4gdGhpcy5ub2Rlc0luZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4W2tdW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2tdW2lkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2tdW2lkXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGRyb3BzIGFuIGVkZ2UgZnJvbSB0aGUgZ3JhcGguIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgZWRnZVxuICAgKiBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCBUaGUgZWRnZSBpZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2Ryb3BFZGdlJywgZnVuY3Rpb24oaWQpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBhcmd1bWVudHMgYXJlIHZhbGlkOlxuICAgIGlmICgodHlwZW9mIGlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2Ryb3BFZGdlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghdGhpcy5lZGdlc0luZGV4W2lkXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBcIicgKyBpZCArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgdmFyIGksIGwsIGVkZ2U7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGVkZ2UgZnJvbSBpbmRleGVzOlxuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzSW5kZXhbaWRdO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMuZWRnZXNBcnJheVtpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5lZGdlc0FycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXSkubGVuZ3RoKVxuICAgICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdO1xuXG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XVtlZGdlLmlkXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XSkubGVuZ3RoKVxuICAgICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXhbZWRnZS5zb3VyY2VdW2VkZ2UudGFyZ2V0XTtcblxuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF07XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgIT09IGVkZ2Uuc291cmNlKSB7XG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdW2VkZ2UuaWRdO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV0pLmxlbmd0aClcbiAgICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXTtcbiAgICB9XG5cbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbZWRnZS50YXJnZXRdLS07XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtlZGdlLnNvdXJjZV0tLTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2VkZ2Uuc291cmNlXS0tO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbZWRnZS50YXJnZXRdLS07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGRlc3Ryb3lzIHRoZSBjdXJyZW50IGluc3RhbmNlLiBJdCBiYXNpY2FsbHkgZW1wdGllcyBlYWNoIGluZGV4XG4gICAqIGFuZCBtZXRob2RzIGF0dGFjaGVkIHRvIHRoZSBncmFwaC5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgIC8vIERlbGV0ZSBhcnJheXM6XG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgZGVsZXRlIHRoaXMubm9kZXNBcnJheTtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0FycmF5O1xuXG4gICAgLy8gRGVsZXRlIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNDb3VudDtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNDb3VudDtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNDb3VudDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGVtcHRpZXMgdGhlIG5vZGVzIGFuZCBlZGdlcyBhcnJheXMsIGFzIHdlbGwgYXMgdGhlIGRpZmZlcmVudFxuICAgKiBpbmRleGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnY2xlYXInLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoID0gMDtcbiAgICB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoID0gMDtcblxuICAgIC8vIER1ZSB0byBHQyBpc3N1ZXMsIEkgcHJlZmVyIG5vdCB0byBjcmVhdGUgbmV3IG9iamVjdC4gVGhlc2Ugb2JqZWN0cyBhcmVcbiAgICAvLyBvbmx5IGF2YWlsYWJsZSBmcm9tIHRoZSBtZXRob2RzIGFuZCBhdHRhY2hlZCBmdW5jdGlvbnMsIGJ1dCBzdGlsbCwgaXQgaXNcbiAgICAvLyBiZXR0ZXIgdG8gcHJldmVudCBnaG9zdCByZWZlcmVuY2VzIHRvIHVucmVsZXZhbnQgZGF0YS4uLlxuICAgIF9fZW1wdHlPYmplY3QodGhpcy5ub2Rlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuZWRnZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm5vZGVzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5pbk5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMub3V0TmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5hbGxOZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmluTmVpZ2hib3JzQ291bnQpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5vdXROZWlnaGJvcnNDb3VudCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmFsbE5laWdoYm9yc0NvdW50KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVhZHMgYW4gb2JqZWN0IGFuZCBhZGRzIHRoZSBub2RlcyBhbmQgZWRnZXMsIHRocm91Z2ggdGhlXG4gICAqIHByb3BlciBtZXRob2RzIFwiYWRkTm9kZVwiIGFuZCBcImFkZEVkZ2VcIi5cbiAgICpcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlOlxuICAgKlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBteUdyYXBoLnJlYWQoe1xuICAgKiAgPiAgIG5vZGVzOiBbXG4gICAqICA+ICAgICB7IGlkOiAnbjAnIH0sXG4gICAqICA+ICAgICB7IGlkOiAnbjEnIH1cbiAgICogID4gICBdLFxuICAgKiAgPiAgIGVkZ2VzOiBbXG4gICAqICA+ICAgICB7XG4gICAqICA+ICAgICAgIGlkOiAnZTAnLFxuICAgKiAgPiAgICAgICBzb3VyY2U6ICduMCcsXG4gICAqICA+ICAgICAgIHRhcmdldDogJ24xJ1xuICAgKiAgPiAgICAgfVxuICAgKiAgPiAgIF1cbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IGNvbnNvbGUubG9nKFxuICAgKiAgPiAgIG15R3JhcGgubm9kZXMoKS5sZW5ndGgsXG4gICAqICA+ICAgbXlHcmFwaC5lZGdlcygpLmxlbmd0aFxuICAgKiAgPiApOyAvLyBvdXRwdXRzIDIgMVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGcgVGhlIGdyYXBoIG9iamVjdC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgncmVhZCcsIGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgYSxcbiAgICAgICAgbDtcblxuICAgIGEgPSBnLm5vZGVzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkTm9kZShhW2ldKTtcblxuICAgIGEgPSBnLmVkZ2VzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkRWRnZShhW2ldKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgb25lIG9yIHNldmVyYWwgbm9kZXMsIGRlcGVuZGluZyBvbiBob3cgaXQgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBUbyBnZXQgdGhlIGFycmF5IG9mIG5vZGVzLCBjYWxsIFwibm9kZXNcIiB3aXRob3V0IGFyZ3VtZW50LiBUbyBnZXQgYVxuICAgKiBzcGVjaWZpYyBub2RlLCBjYWxsIGl0IHdpdGggdGhlIGlkIG9mIHRoZSBub2RlLiBUaGUgZ2V0IG11bHRpcGxlIG5vZGUsXG4gICAqIGNhbGwgaXQgd2l0aCBhbiBhcnJheSBvZiBpZHMsIGFuZCBpdCB3aWxsIHJldHVybiB0aGUgYXJyYXkgb2Ygbm9kZXMsIGluXG4gICAqIHRoZSBzYW1lIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xhcnJheSl9IHYgRXZlbnR1YWxseSBvbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cbiAgICogQHJldHVybiB7b2JqZWN0fGFycmF5fSAgICAgIFRoZSByZWxhdGVkIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ25vZGVzJywgZnVuY3Rpb24odikge1xuICAgIC8vIENsb25lIHRoZSBhcnJheSBvZiBub2RlcyBhbmQgcmV0dXJuIGl0OlxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkuc2xpY2UoMCk7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0luZGV4W3ZdO1xuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEgPSBbXTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodHlwZW9mIHZbaV0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2W2ldID09PSAnbnVtYmVyJylcbiAgICAgICAgICBhLnB1c2godGhpcy5ub2Rlc0luZGV4W3ZbaV1dKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdub2RlczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHRocm93ICdub2RlczogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyB0aGUgZGVncmVlIG9mIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93XG4gICAqIGl0IGlzIGNhbGxlZC4gSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgaW5jb21pbmcgb3Igb3V0Y29taW5nIGRlZ3JlZXNcbiAgICogaW5zdGVhZCBieSBzcGVjaWZ5aW5nICdpbicgb3IgJ291dCcgYXMgYSBzZWNvbmQgYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xhcnJheX0gdiAgICAgT25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgd2hpY2ggV2hpY2ggZGVncmVlIGlzIHJlcXVpcmVkLiBWYWx1ZXMgYXJlICdpbicsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ291dCcsIGFuZCBieSBkZWZhdWx0IHRoZSBub3JtYWwgZGVncmVlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8YXJyYXl9ICAgICAgIFRoZSByZWxhdGVkIGRlZ3JlZSBvciBhcnJheSBvZiBkZWdyZWVzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkZWdyZWUnLCBmdW5jdGlvbih2LCB3aGljaCkge1xuICAgIC8vIENoZWNrIHdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZDpcbiAgICB3aGljaCA9IHtcbiAgICAgICdpbic6IHRoaXMuaW5OZWlnaGJvcnNDb3VudCxcbiAgICAgICdvdXQnOiB0aGlzLm91dE5laWdoYm9yc0NvdW50XG4gICAgfVt3aGljaCB8fCAnJ10gfHwgdGhpcy5hbGxOZWlnaGJvcnNDb3VudDtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKVxuICAgICAgcmV0dXJuIHdoaWNoW3ZdO1xuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHdoaWNoW3ZbaV1dKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdkZWdyZWU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIGVkZ2VzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBlZGdlcywgY2FsbCBcImVkZ2VzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcbiAgICogc3BlY2lmaWMgZWRnZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgZWRnZS4gVGhlIGdldCBtdWx0aXBsZSBlZGdlLFxuICAgKiBjYWxsIGl0IHdpdGggYW4gYXJyYXkgb2YgaWRzLCBhbmQgaXQgd2lsbCByZXR1cm4gdGhlIGFycmF5IG9mIGVkZ2VzLCBpblxuICAgKiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8YXJyYXkpfSB2IEV2ZW50dWFsbHkgb25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBlZGdlIG9yIGFycmF5IG9mIGVkZ2VzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdlZGdlcycsIGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2YgZWRnZXMgYW5kIHJldHVybiBpdDpcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5lZGdlc0FycmF5LnNsaWNlKDApO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIGVkZ2U6XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNJbmRleFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBlZGdlOlxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHRoaXMuZWRnZXNJbmRleFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnZWRnZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnZWRnZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2Ygc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2lnbWEuY2xhc3NlcyA9IHNpZ21hLmNsYXNzZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBzaWdtYS5jbGFzc2VzLmdyYXBoID0gZ3JhcGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ3JhcGg7XG4gICAgZXhwb3J0cy5ncmFwaCA9IGdyYXBoO1xuICB9IGVsc2VcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jbGFzc2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBjYW1lcmEgY29uc3RydWN0b3IuIEl0IGp1c3QgaW5pdGlhbGl6ZXMgaXRzIGF0dHJpYnV0ZXMgYW5kIG1ldGhvZHMuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgaWQgICAgICAgVGhlIGlkLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgZ3JhcGggICAgVGhlIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICBvcHRpb25zICBFdmVudHVhbGx5IHNvbWUgb3ZlcnJpZGluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGZyZXNoIG5ldyBjYW1lcmEgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYSA9IGZ1bmN0aW9uKGlkLCBncmFwaCwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcbiAgICAgIHZhbHVlOiBncmFwaFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XG4gICAgICB2YWx1ZTogaWRcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWRQcmVmaXgnLCB7XG4gICAgICB2YWx1ZTogJ3JlYWRfY2FtJyArIGlkICsgJzonXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmVmaXgnLCB7XG4gICAgICB2YWx1ZTogJ2NhbScgKyBpZCArICc6J1xuICAgIH0pO1xuXG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMucmF0aW8gPSAxO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMuaXNBbmltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMpID9cbiAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0KG9wdGlvbnMpIDpcbiAgICAgIHNldHRpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYW1lcmEgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29vcmRpbmF0ZXMgVGhlIG5ldyBjb29yZGluYXRlcyBvYmplY3QuXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgICAgICAgUmV0dXJucyB0aGUgY2FtZXJhLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdvVG8gPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGlmICghdGhpcy5zZXR0aW5ncygnZW5hYmxlQ2FtZXJhJykpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBjID0gY29vcmRpbmF0ZXMgfHwge30sXG4gICAgICAgIGtleXMgPSBbJ3gnLCAneScsICdyYXRpbycsICdhbmdsZSddO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKGNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNba2V5c1tpXV0gPT09ICdudW1iZXInICYmICFpc05hTihjW2tleXNbaV1dKSlcbiAgICAgICAgICB0aGlzW2tleXNbaV1dID0gY1trZXlzW2ldXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93ICdWYWx1ZSBmb3IgXCInICsga2V5c1tpXSArICdcIiBpcyBub3QgYSBudW1iZXIuJztcbiAgICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnY29vcmRpbmF0ZXNVcGRhdGVkJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgZ3JhcGggYW5kIGNvbXB1dGVzIGZvciBlYWNoIG5vZGUgYW5kIGVkZ2VzIGl0c1xuICAgKiBjb29yZGluYXRlcyByZWxhdGl2ZWx5IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNhbWVyYS4gQmFzaWNhbGx5LCBpdCB3aWxsXG4gICAqIGNvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBncmFwaGljIHJlbmRlcmVycy5cbiAgICpcbiAgICogU2luY2UgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBkaWZmZXJlbnQgY2FtZXJhcyBhbmQgZGlmZmVyZW50XG4gICAqIHJlbmRlcmVycywgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeSBhIHByZWZpeCB0byBwdXQgYmVmb3JlIHRoZSBuZXdcbiAgICogY29vcmRpbmF0ZXMgKHRvIGdldCBzb21ldGhpbmcgbGlrZSBcIm5vZGUuY2FtZXJhMV94XCIpXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHJlYWQgICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gcmVhZC5cbiAgICogQHBhcmFtICB7P3N0cmluZ30gd3JpdGUgICBUaGUgcHJlZml4IG9mIHRoZSBjb29yZGluYXRlcyB0byB3cml0ZS5cbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLiBUaG9zZSBjYW4gYmU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHJlc3RyaWN0ZWQgbm9kZXMgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHJlc3RyaWN0ZWQgZWRnZXMgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHdpZHRoLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5hcHBseVZpZXcgPSBmdW5jdGlvbihyZWFkLCB3cml0ZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHdyaXRlID0gd3JpdGUgIT09IHVuZGVmaW5lZCA/IHdyaXRlIDogdGhpcy5wcmVmaXg7XG4gICAgcmVhZCA9IHJlYWQgIT09IHVuZGVmaW5lZCA/IHJlYWQgOiB0aGlzLnJlYWRQcmVmaXg7XG5cbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLm5vZGVzIHx8IHRoaXMuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgZWRnZXMgPSBvcHRpb25zLmVkZ2VzIHx8IHRoaXMuZ3JhcGguZWRnZXMoKTtcblxuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBub2RlLFxuICAgICAgICByZWxDb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXG4gICAgICAgIHJlbFNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpIC8gdGhpcy5yYXRpbyxcbiAgICAgICAgbm9kZVJhdGlvID0gTWF0aC5wb3codGhpcy5yYXRpbywgdGhpcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKSxcbiAgICAgICAgZWRnZVJhdGlvID0gTWF0aC5wb3codGhpcy5yYXRpbywgdGhpcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKSxcbiAgICAgICAgeE9mZnNldCA9IChvcHRpb25zLndpZHRoIHx8IDApIC8gMiAtIHRoaXMueCAqIHJlbENvcyAtIHRoaXMueSAqIHJlbFNpbixcbiAgICAgICAgeU9mZnNldCA9IChvcHRpb25zLmhlaWdodCB8fCAwKSAvIDIgLSB0aGlzLnkgKiByZWxDb3MgKyB0aGlzLnggKiByZWxTaW47XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBub2RlW3dyaXRlICsgJ3gnXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAneCddIHx8IDApICogcmVsQ29zICtcbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxTaW4gK1xuICAgICAgICB4T2Zmc2V0O1xuICAgICAgbm9kZVt3cml0ZSArICd5J10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3knXSB8fCAwKSAqIHJlbENvcyAtXG4gICAgICAgIChub2RlW3JlYWQgKyAneCddIHx8IDApICogcmVsU2luICtcbiAgICAgICAgeU9mZnNldDtcbiAgICAgIG5vZGVbd3JpdGUgKyAnc2l6ZSddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICdzaXplJ10gfHwgMCkgL1xuICAgICAgICBub2RlUmF0aW87XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZWRnZXNbaV1bd3JpdGUgKyAnc2l6ZSddID1cbiAgICAgICAgKGVkZ2VzW2ldW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cbiAgICAgICAgZWRnZVJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiBjYW1lcmEgdG8gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBwb2ludCBjb29yZGluYXRlcyBpbiB0aGUgZnJhbWUgb2YgdGhlIGdyYXBoLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdyYXBoUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcbiAgICB2YXIgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxuICAgIGlmICghdmVjdG9yKSB7XG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICh4ICogY29zICsgeSAqIHNpbikgLyB0aGlzLnJhdGlvICsgWCxcbiAgICAgIHk6ICh5ICogY29zIC0geCAqIHNpbikgLyB0aGlzLnJhdGlvICsgWVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWUgb2YgdGhlXG4gICAqIGdyYXBoIHRvIHRoZSBmcmFtZSBvZiB0aGUgY2FtZXJhLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgZ3JhcGguXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBncmFwaC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBwb2ludCBjb29yZGluYXRlcyBpbiB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5jYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHZlY3Rvcikge1xuICAgIHZhciBYID0gMCxcbiAgICAgICAgWSA9IDAsXG4gICAgICAgIGNvcyA9IE1hdGguY29zKHRoaXMuYW5nbGUpLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKTtcblxuICAgIC8vIFJldmVydCB0aGUgb3JpZ2luIGRpZmZlcmVudGlhbCB2ZWN0b3I6XG4gICAgaWYgKCF2ZWN0b3IpIHtcbiAgICAgIFggPSAtICh0aGlzLnggKiBjb3MgKyB0aGlzLnkgKiBzaW4pIC8gdGhpcy5yYXRpbztcbiAgICAgIFkgPSAtICh0aGlzLnkgKiBjb3MgLSB0aGlzLnggKiBzaW4pIC8gdGhpcy5yYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKCh4IC0gWCkgKiBjb3MgLSAoeSAtIFkpICogc2luKSAqIHRoaXMucmF0aW8sXG4gICAgICB5OiAoKHkgLSBZKSAqIGNvcyArICh4IC0gWCkgKiBzaW4pICogdGhpcy5yYXRpb1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgY2FtZXJhLiBUaGlzIGlzXG4gICAqIGVzcGVjaWFsbHkgdXNlZnVsIHRvIGFwcGx5IHRoZSBjYW1lcmEgdmlldyBkaXJlY3RseSBpbiBzaGFkZXJzLCBpbiBjYXNlIG9mXG4gICAqIFdlYkdMIHJlbmRlcmluZy5cbiAgICpcbiAgICogQHJldHVybiB7YXJyYXl9IFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUoMSAvIHRoaXMucmF0aW8pLFxuICAgICAgICByb3RhdGlvbiA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKHRoaXMuYW5nbGUpLFxuICAgICAgICB0cmFuc2xhdGlvbiA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnRyYW5zbGF0aW9uKC10aGlzLngsIC10aGlzLnkpLFxuICAgICAgICBtYXRyaXggPSBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcbiAgICAgICAgICB0cmFuc2xhdGlvbixcbiAgICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcbiAgICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgICAgc2NhbGVcbiAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICByZXR1cm4gbWF0cml4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtpbmcgYSB3aWR0aCBhbmQgYSBoZWlnaHQgYXMgcGFyYW1ldGVycywgdGhpcyBtZXRob2QgcmV0dXJucyB0aGVcbiAgICogY29vcmRpbmF0ZXMgb2YgdGhlIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhlIGNhbWVyYSBvbiBzY3JlZW4sIGluIHRoZVxuICAgKiBncmFwaCdzIHJlZmVyZW50aWVsLlxuICAgKlxuICAgKiBUbyBrZWVwIGRpc3BsYXlpbmcgbGFiZWxzIG9mIG5vZGVzIGdvaW5nIG91dCBvZiB0aGUgc2NyZWVuLCB0aGUgbWV0aG9kXG4gICAqIGtlZXBzIGEgbWFyZ2luIGFyb3VuZCB0aGUgc2NyZWVuIGluIHRoZSByZXR1cm5lZCByZWN0YW5nbGUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGggIFRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzY3JlZW4uXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSByZWN0YW5nbGUgYXMgeDEsIHkxLCB4MiBhbmQgeTIsIHJlcHJlc2VudGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0d28gb3Bwb3NpdGUgcG9pbnRzLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgd2lkdGhWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCwgMCwgdHJ1ZSksXG4gICAgICAgIGhlaWdodFZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCwgdHJ1ZSksXG4gICAgICAgIGNlbnRlclZlY3QgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgdHJ1ZSksXG4gICAgICAgIG1hcmdpblggPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoIC8gNCwgMCwgdHJ1ZSkueCxcbiAgICAgICAgbWFyZ2luWSA9IHRoaXMuY2FtZXJhUG9zaXRpb24oMCwgaGVpZ2h0IC8gNCwgdHJ1ZSkueTtcblxuICAgIHJldHVybiB7XG4gICAgICB4MTogdGhpcy54IC0gY2VudGVyVmVjdC54IC0gbWFyZ2luWCxcbiAgICAgIHkxOiB0aGlzLnkgLSBjZW50ZXJWZWN0LnkgLSBtYXJnaW5ZLFxuICAgICAgeDI6IHRoaXMueCAtIGNlbnRlclZlY3QueCArIG1hcmdpblggKyB3aWR0aFZlY3QueCxcbiAgICAgIHkyOiB0aGlzLnkgLSBjZW50ZXJWZWN0LnkgLSBtYXJnaW5ZICsgd2lkdGhWZWN0LnksXG4gICAgICBoZWlnaHQ6IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coaGVpZ2h0VmVjdC54LCAyKSArXG4gICAgICAgIE1hdGgucG93KGhlaWdodFZlY3QueSArIDIgKiBtYXJnaW5ZLCAyKVxuICAgICAgKVxuICAgIH07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWR0cmVlIE1vZHVsZVxuICAgKiA9PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBHdWlsbGF1bWUgUGxpcXVlIChZb21ndWl0aGVyZWFsKVxuICAgKiBWZXJzaW9uOiAwLjJcbiAgICovXG5cblxuXG4gIC8qKlxuICAgKiBRdWFkIEdlb21ldHJpYyBPcGVyYXRpb25zXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogQSB1c2VmdWwgYmF0Y2ggb2YgZ2VvbWV0cmljIG9wZXJhdGlvbnMgdXNlZCBieSB0aGUgcXVhZHRyZWUuXG4gICAqL1xuXG4gIHZhciBfZ2VvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBub2RlIHdpdGggeCwgeSBhbmQgc2l6ZSBpbnRvIGFuXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBub2RlIHdpdGggYXQgbGVhc3QgYSBwb2ludCAoeCwgeSkgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHBvaW50VG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBuLnggLSBuLnNpemUsXG4gICAgICAgIHkxOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIHgyOiBuLnggKyBuLnNpemUsXG4gICAgICAgIHkyOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIGhlaWdodDogbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICovXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIueDEgPT09IHIueDIgfHwgci55MSA9PT0gci55MjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXG4gICAgICogbGF0ZXIgb3BlcmF0aW9ucyBuZWVkIHRvIGtub3cgdGhlIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGF4aXNBbGlnbmVkVG9wUG9pbnRzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgIC8vIEJhc2ljXG4gICAgICBpZiAoci55MSA9PT0gci55MiAmJiByLngxIDwgci54MilcbiAgICAgICAgcmV0dXJuIHI7XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gcmlnaHRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxIC0gci5oZWlnaHQsIHkxOiByLnkxLFxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA8IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxuICAgICAgICAgIHgyOiByLngyICsgci5oZWlnaHQsIHkyOiByLnkyLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gQm90dG9tJ3MgdXBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiByLngyLCB5MTogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyTGVmdENvb3I6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB3aWR0aCA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHIueDIgLSByLngxLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coci55MiAtIHIueTEsIDIpXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcbiAgICAgICAgeTogci55MSArIChyLngyIC0gci54MSkgKiByLmhlaWdodCAvIHdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xuICAgICAqIGFuZCBpdHMgbG93ZXIgbGVmdCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGNvcm5lcidzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyUmlnaHRDb29yOiBmdW5jdGlvbihyLCBsbGMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXG4gICAgICAgIHk6IGxsYy55IC0gci55MSArIHIueTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxuICAgICAgICAgIGxyYyA9IHRoaXMubG93ZXJSaWdodENvb3IociwgbGxjKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHIueDEsIHk6IHIueTF9LFxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxuICAgICAgICB7eDogbHJjLngsIHk6IGxyYy55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXG4gICAgICogICAgICAgICAgICAgICAgICBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHRoZWlyIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICovXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXG4gICAgICogcmVjdGFuZ2xlIEIuIFRoaXMgaXMgbmVlZGVkIGxhdGVyIHRvIGNoZWNrIGFuIGV2ZW50dWFsIGNvbGxpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBCJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXG4gICAgICovXG4gICAgYXhpczogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVszXS54LCB5OiBjMVsxXS55IC0gYzFbM10ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIGNvcm5lciAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcbiAgICAgIHZhciBsID0gKFxuICAgICAgICAoYy54ICogYS54ICsgYy55ICogYS55KSAvXG4gICAgICAgIChNYXRoLnBvdyhhLngsIDIpICsgTWF0aC5wb3coYS55LCAyKSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGwgKiBhLngsXG4gICAgICAgIHk6IGwgKiBhLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgIEFuIGF4aXMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZSBvbiB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcbiAgICAgIHZhciBzYzEgPSBbXSxcbiAgICAgICAgICBzYzIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IDQ7IGNpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xuXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1heGMyID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MyKSxcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xuXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcbiAgICAgKiBhbGwgYXhpcyBjb2xsaWRlLCB0aGVuIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBjb2xsaWRlIG9uIHRoZSBwbGFuZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxuICAgICAgICAgIGNvbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XG5cbiAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFF1YWQgRnVuY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxuICAgKiBpbmRleCBvZiBlYWNoIG5vZGUgaXMgdGhlIGZvbGxvd2luZzpcbiAgICogMDogdG9wIGxlZnRcbiAgICogMTogdG9wIHJpZ2h0XG4gICAqIDI6IGJvdHRvbSBsZWZ0XG4gICAqIDM6IGJvdHRvbSByaWdodFxuICAgKlxuICAgKiBNb3Jlb3ZlciwgdGhlIGhlcmVhZnRlciBxdWFkJ3MgcGhpbG9zb3BoeSBpcyB0byBjb25zaWRlciB0aGF0IGlmIGFuIGVsZW1lbnRcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQgaW4gdGhlIHF1YWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkQm91bmRzIEJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgKHgsIHksIHdpZHRoLCBoZWlndGgpLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXgocG9pbnQsIHF1YWRCb3VuZHMpIHtcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcbiAgICAgICAgdG9wID0gKHBvaW50LnkgPCB5bXApLFxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xuXG4gICAgaWYgKHRvcCkge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxICsgcmVjdGFuZ2xlLmhlaWdodCA+PSBxdWFkQ29ybmVyc1tpXVswXS55KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7YXJyYXl9ICBxdWFkQ29ybmVycyAgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoX2dlb20uY29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzW2ldKSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIEEgbmV3IHF1YWQgcmVwcmVzZW50aW5nIHRoZSBub2RlIGNyZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xuICAgIHZhciBuZXh0ID0gcXVhZC5sZXZlbCArIDEsXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICBxeCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueCksXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1YWRUcmVlKFxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxuICAgICAgbmV4dCxcbiAgICAgIHF1YWQubWF4RWxlbWVudHMsXG4gICAgICBxdWFkLm1heExldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBpbnRvIHRoZSBxdWFkdHJlZS4gT25seSBwb2ludHNcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcblxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICAvLyBJdGVyYXRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID0gX3F1YWRTdWJkaXZpZGUoaW5kZXhlc1tpXSwgcXVhZCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaW9uXG4gICAgICAgIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcbiAgICAgIHF1YWQuZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IF9xdWFkSW5kZXgocG9pbnQsIHF1YWQuYm91bmRzKTtcblxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxuICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYXNlIG9mIGEgbm9uLWF4aXMtYWxpZ25lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHF1YWQgICAgICAgICAgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxuICAgKiBAcGFyYW0gIHthcnJheT99ICAgICAgIGVscyAgICAgICAgICAgIFRoZSByZXRyaWV2ZWQgZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XG4gICAgZWxzID0gZWxzIHx8IHt9O1xuXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICAgICAgZWxzXG4gICAgICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPSBxdWFkLmVsZW1lbnRzW2pdO1xuXG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBxdWFkdHJlZSBvYmplY3QgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gKHgsIHkpLCB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4TGV2ZWwgICAgIFRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFRyZWUoYm91bmRzLCBsZXZlbCwgbWF4RWxlbWVudHMsIG1heExldmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDIwLFxuICAgICAgbWF4TGV2ZWw6IG1heExldmVsIHx8IDQsXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBub2RlczogW11cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBxdWFkIEFQSSBhcyBleHBvc2VkIHRvIHNpZ21hLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIHF1YWQgY29yZSB0aGF0IHdpbGwgYmVjb21lIHRoZSBzaWdtYSBpbnRlcmZhY2Ugd2l0aCB0aGUgcXVhZHRyZWUuXG4gICAqXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF90cmVlICBQcm9wZXJ0eSBob2xkaW5nIHRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9nZW9tICBFeHBvc2l0aW9uIG9mIHRoZSBfZ2VvbSBuYW1lc3BhY2UgZm9yIHRlc3RpbmcuXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9jYWNoZSBDYWNoZSBmb3IgdGhlIGFyZWEgbWV0aG9kLlxuICAgKi9cbiAgdmFyIHF1YWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW9tID0gX2dlb207XG4gICAgdGhpcy5fdHJlZSA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW5kZXggYSBncmFwaCBieSBpbnNlcnRpbmcgaXRzIG5vZGVzIGludG8gdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gIG5vZGVzICAgQW4gYXJyYXkgb2Ygbm9kZXMgdG8gaW5kZXguXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAtLS0tLS0tLS0tXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3Igbm9kZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXG4gICAqIG1heExldmVsOiAgICB7aW50ZWdlcj99IHRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihub2RlcywgcGFyYW1zKSB7XG5cbiAgICAvLyBFbmZvcmNpbmcgcHJlc2VuY2Ugb2YgYm91bmRhcmllc1xuICAgIGlmICghcGFyYW1zLmJvdW5kcylcbiAgICAgIHRocm93ICdzaWdtYS5jbGFzc2VzLnF1YWQuaW5kZXg6IGJvdW5kcyBpbmZvcm1hdGlvbiBub3QgZ2l2ZW4uJztcblxuICAgIC8vIFByZWZpeFxuICAgIHZhciBwcmVmaXggPSBwYXJhbXMucHJlZml4IHx8ICcnO1xuXG4gICAgLy8gQnVpbGRpbmcgdGhlIHRyZWVcbiAgICB0aGlzLl90cmVlID0gX3F1YWRUcmVlKFxuICAgICAgcGFyYW1zLmJvdW5kcyxcbiAgICAgIDAsXG4gICAgICBwYXJhbXMubWF4RWxlbWVudHMsXG4gICAgICBwYXJhbXMubWF4TGV2ZWxcbiAgICApO1xuXG4gICAgLy8gSW5zZXJ0aW5nIGdyYXBoIG5vZGVzIGludG8gdGhlIHRyZWVcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAvLyBJbnNlcnRpbmcgbm9kZVxuICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgIG5vZGVzW2ldLFxuICAgICAgICBfZ2VvbS5wb2ludFRvU3F1YXJlKHtcbiAgICAgICAgICB4OiBub2Rlc1tpXVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHk6IG5vZGVzW2ldW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgc2l6ZTogbm9kZXNbaV1bcHJlZml4ICsgJ3NpemUnXVxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5fdHJlZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBjYWNoZTpcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlP1xuICAgIHJldHVybiB0aGlzLl90cmVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBub2RlcyBoZWxkIGJ5IHRoZSBxdWFkdHJlZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb2YgdGhlIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgb2YgdGhlIHBvaW50LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIG5vZGVzIHJldHJpZXZlZC5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVQb2ludCh7eDogeCwgeTogeX0sIHRoaXMuX3RyZWUpIHx8IFtdIDpcbiAgICAgIFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBub2RlcyB3aXRoaW4gYSByZWN0YW5ndWxhciBhcmVhLiBUaGUgbWV0aG9kcyBrZWVwIHRoZVxuICAgKiBsYXN0IGFyZWEgcXVlcmllZCBpbiBjYWNoZSBmb3Igb3B0aW1pemF0aW9uIHJlYXNvbiBhbmQgd2lsbCBhY3QgZGlmZmVyZW50bHlcbiAgICogZm9yIHRoZSBzYW1lIHJlYXNvbiBpZiB0aGUgYXJlYSBpcyBheGlzLWFsaWduZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpXG4gICAqICAgICAgICAgICAgICAgICAgYW5kIGhlaWdodC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgIHJlY3REYXRhO1xuXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xuICAgIGlmICh0aGlzLl9jYWNoZS5xdWVyeSA9PT0gc2VyaWFsaXplZClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XG5cbiAgICAvLyBBeGlzIGFsaWduZWQgP1xuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5heGlzQWxpZ25lZFRvcFBvaW50cyhyZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRDb2xsaXNpb247XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmluZyBub2Rlc1xuICAgIHZhciBub2RlcyA9IHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgIHJlY3REYXRhLFxuICAgICAgICB0aGlzLl90cmVlLFxuICAgICAgICBjb2xsaXNpb25GdW5jXG4gICAgICApIDpcbiAgICAgIFtdO1xuXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XG4gICAgdmFyIG5vZGVzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG5vZGVzKVxuICAgICAgbm9kZXNBcnJheS5wdXNoKG5vZGVzW2ldKTtcblxuICAgIC8vIENhY2hpbmdcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XG4gICAgdGhpcy5fY2FjaGUucmVzdWx0ID0gbm9kZXNBcnJheTtcblxuICAgIHJldHVybiBub2Rlc0FycmF5O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMucXVhZCA9IHF1YWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcXVhZDtcbiAgICBleHBvcnRzLnF1YWQgPSBxdWFkO1xuICB9IGVsc2VcbiAgICB0aGlzLnF1YWQgPSBxdWFkO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGUgZm9yIGVkZ2VzXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBTw6liYXN0aWVuIEhleW1hbm4sXG4gICAqICAgZnJvbSB0aGUgcXVhZCBvZiBHdWlsbGF1bWUgUGxpcXVlIChZb21ndWl0aGVyZWFsKVxuICAgKiBWZXJzaW9uOiAwLjJcbiAgICovXG5cblxuXG4gIC8qKlxuICAgKiBRdWFkIEdlb21ldHJpYyBPcGVyYXRpb25zXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogQSB1c2VmdWwgYmF0Y2ggb2YgZ2VvbWV0cmljIG9wZXJhdGlvbnMgdXNlZCBieSB0aGUgcXVhZHRyZWUuXG4gICAqL1xuXG4gIHZhciBfZ2VvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBub2RlIHdpdGggeCwgeSBhbmQgc2l6ZSBpbnRvIGFuXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBub2RlIHdpdGggYXQgbGVhc3QgYSBwb2ludCAoeCwgeSkgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHBvaW50VG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBuLnggLSBuLnNpemUsXG4gICAgICAgIHkxOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIHgyOiBuLnggKyBuLnNpemUsXG4gICAgICAgIHkyOiBuLnkgLSBuLnNpemUsXG4gICAgICAgIGhlaWdodDogbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIGVkZ2Ugd2l0aCB4MSwgeTEsIHgyLCB5MiBhbmQgc2l6ZSBpbnRvIGFuXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBncmFwaCBlZGdlIHdpdGggYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBsaW5lVG9TcXVhcmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnkxIDwgZS55Mikge1xuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gdG9wXG4gICAgICAgIGlmIChlLngxIDwgZS54Mikge1xuICAgICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiBsZWZ0XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBlLngxIC0gZS5zaXplLFxuICAgICAgICAgICAgeTE6IGUueTEgLSBlLnNpemUsXG4gICAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcbiAgICAgICAgICAgIHkyOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBlLnkyIC0gZS55MSArIGUuc2l6ZSAqIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiByaWdodFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBlLngyIC0gZS5zaXplLFxuICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxuICAgICAgICAgIHkyOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIChlLngyLCBlLnkyKSBvbiB0b3BcbiAgICAgIGlmIChlLngxIDwgZS54Mikge1xuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBlLngxIC0gZS5zaXplLFxuICAgICAgICAgIHkxOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICAgIHgyOiBlLngyICsgZS5zaXplLFxuICAgICAgICAgIHkyOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICAgIGhlaWdodDogZS55MSAtIGUueTIgKyBlLnNpemUgKiAyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gcmlnaHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBlLngyIC0gZS5zaXplLFxuICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgeDI6IGUueDEgKyBlLnNpemUsXG4gICAgICAgIHkyOiBlLnkyIC0gZS5zaXplLFxuICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIGVkZ2Ugb2YgdHlwZSAnY3VydmUnIHdpdGggeDEsIHkxLCB4MiwgeTIsXG4gICAgICogY29udHJvbCBwb2ludCBhbmQgc2l6ZSBpbnRvIGFuIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgIEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgYSBzaXplLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gY3AgQSBjb250cm9sIHBvaW50ICh4LHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgcXVhZHJhdGljQ3VydmVUb1NxdWFyZTogZnVuY3Rpb24oZSwgY3ApIHtcbiAgICAgIHZhciBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZShcbiAgICAgICAgMC41LFxuICAgICAgICBlLngxLFxuICAgICAgICBlLnkxLFxuICAgICAgICBlLngyLFxuICAgICAgICBlLnkyLFxuICAgICAgICBjcC54LFxuICAgICAgICBjcC55XG4gICAgICApO1xuXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHR3byBwb2ludHMgYW5kIHRoZSBwb2ludCBhdCB0aGUgbWlkZGxlIG9mIHRoZVxuICAgICAgLy8gY3VydmU6XG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKGUueDEsIGUueDIsIHB0LngpLFxuICAgICAgICAgIG1heFggPSBNYXRoLm1heChlLngxLCBlLngyLCBwdC54KSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4oZS55MSwgZS55MiwgcHQueSksXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KGUueTEsIGUueTIsIHB0LnkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbWluWCAtIGUuc2l6ZSxcbiAgICAgICAgeTE6IG1pblkgLSBlLnNpemUsXG4gICAgICAgIHgyOiBtYXhYICsgZS5zaXplLFxuICAgICAgICB5MjogbWluWSAtIGUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWSArIGUuc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBzZWxmIGxvb3AgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBuIEEgZ3JhcGggbm9kZSB3aXRoIGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHNlbGZMb29wVG9TcXVhcmU6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIEZpdHRpbmcgdG8gdGhlIGN1cnZlIGlzIHRvbyBjb3N0bHksIHdlIGNvbXB1dGUgYSBsYXJnZXIgYm91bmRpbmcgYm94XG4gICAgICAvLyB1c2luZyB0aGUgY29udHJvbCBwb2ludHM6XG4gICAgICB2YXIgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMobi54LCBuLnksIG4uc2l6ZSk7XG5cbiAgICAgIC8vIEJvdW5kaW5nIGJveCBvZiB0aGUgcG9pbnQgYW5kIHRoZSB0d28gY29udHJvbCBwb2ludHM6XG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKG4ueCwgY3AueDEsIGNwLngyKSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobi54LCBjcC54MSwgY3AueDIpLFxuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihuLnksIGNwLnkxLCBjcC55MiksXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG4ueSwgY3AueTEsIGNwLnkyKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG1pblggLSBuLnNpemUsXG4gICAgICAgIHkxOiBtaW5ZIC0gbi5zaXplLFxuICAgICAgICB4MjogbWF4WCArIG4uc2l6ZSxcbiAgICAgICAgeTI6IG1pblkgLSBuLnNpemUsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBuLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKi9cbiAgICBpc0F4aXNBbGlnbmVkOiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gci54MSA9PT0gci54MiB8fCByLnkxID09PSByLnkyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRvcCBwb2ludHMgb2YgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZS4gVGhpcyBpcyB1c2VmdWwgaW5cbiAgICAgKiBjYXNlcyB3aGVuIHRoZSByZWN0YW5nbGUgaGFzIGJlZW4gcm90YXRlZCAobGVmdCwgcmlnaHQgb3IgYm90dG9tIHVwKSBhbmRcbiAgICAgKiBsYXRlciBvcGVyYXRpb25zIG5lZWQgdG8ga25vdyB0aGUgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSByZWN0YW5nbGU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgYXhpc0FsaWduZWRUb3BQb2ludHM6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgLy8gQmFzaWNcbiAgICAgIGlmIChyLnkxID09PSByLnkyICYmIHIueDEgPCByLngyKVxuICAgICAgICByZXR1cm4gcjtcblxuICAgICAgLy8gUm90YXRlZCB0byByaWdodFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA+IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEgLSByLmhlaWdodCwgeTE6IHIueTEsXG4gICAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gUm90YXRlZCB0byBsZWZ0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyIDwgci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSwgeTE6IHIueTIsXG4gICAgICAgICAgeDI6IHIueDIgKyByLmhlaWdodCwgeTI6IHIueTIsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBCb3R0b20ncyB1cFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHIueDIsIHkxOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIHgyOiByLngxLCB5Mjogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciBsZWZ0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lciAoeCwgeSkuXG4gICAgICovXG4gICAgbG93ZXJMZWZ0Q29vcjogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIHdpZHRoID0gKFxuICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3coci54MiAtIHIueDEsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhyLnkyIC0gci55MSwgMilcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogci54MSAtIChyLnkyIC0gci55MSkgKiByLmhlaWdodCAvIHdpZHRoLFxuICAgICAgICB5OiByLnkxICsgKHIueDIgLSByLngxKSAqIHIuaGVpZ2h0IC8gd2lkdGhcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIHJpZ2h0IGNvcm5lciBmcm9tIGl0cyB0b3AgcG9pbnRzXG4gICAgICogYW5kIGl0cyBsb3dlciBsZWZ0IGNvcm5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgY29ybmVyJ3MgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lciAoeCwgeSkuXG4gICAgICovXG4gICAgbG93ZXJSaWdodENvb3I6IGZ1bmN0aW9uKHIsIGxsYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbGxjLnggLSByLngxICsgci54MixcbiAgICAgICAgeTogbGxjLnkgLSByLnkxICsgci55MlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb29yZGluYXRlcyBvZiBhbGwgdGhlIGNvcm5lcnMgb2YgYSByZWN0YW5nbGUgZnJvbSBpdHMgdG9wIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgdGhlIGZvdXIgY29ybmVycycgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHJlY3RhbmdsZUNvcm5lcnM6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBsbGMgPSB0aGlzLmxvd2VyTGVmdENvb3IociksXG4gICAgICAgICAgbHJjID0gdGhpcy5sb3dlclJpZ2h0Q29vcihyLCBsbGMpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogci54MSwgeTogci55MX0sXG4gICAgICAgIHt4OiByLngyLCB5OiByLnkyfSxcbiAgICAgICAge3g6IGxsYy54LCB5OiBsbGMueX0sXG4gICAgICAgIHt4OiBscmMueCwgeTogbHJjLnl9XG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIHNxdWFyZSBkZWZpbmVkIGJ5IGl0cyBib3VuZGFyaWVzIGludG8gZm91ci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQm91bmRhcmllcyBvZiB0aGUgc3F1YXJlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZvdXIgbmV3IHNxdWFyZXMsIHRoZW1zZWx2ZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgdGhlaXIgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKi9cbiAgICBzcGxpdFNxdWFyZTogZnVuY3Rpb24oYikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGZvdXIgYXhpcyBiZXR3ZWVuIGNvcm5lcnMgb2YgcmVjdGFuZ2xlIEEgYW5kIGNvcm5lcnMgb2ZcbiAgICAgKiByZWN0YW5nbGUgQi4gVGhpcyBpcyBuZWVkZWQgbGF0ZXIgdG8gY2hlY2sgYW4gZXZlbnR1YWwgY29sbGlzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBBJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEIncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBmb3VyIGF4aXMgZGVmaW5lZCBieSB0aGVpciBjb29yZGluYXRlcyAoeCx5KS5cbiAgICAgKi9cbiAgICBheGlzOiBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbMF0ueCwgeTogYzFbMV0ueSAtIGMxWzBdLnl9LFxuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzNdLngsIHk6IGMxWzFdLnkgLSBjMVszXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsyXS54LCB5OiBjMlswXS55IC0gYzJbMl0ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMV0ueCwgeTogYzJbMF0ueSAtIGMyWzFdLnl9XG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IGEgcmVjdGFuZ2xlJ3MgY29ybmVyIG9uIGFuIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgY29ybmVyICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGFuIGF4aXMgKHgsIHkpLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHByb2plY3Rpb24gZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcHJvamVjdGlvbjogZnVuY3Rpb24oYywgYSkge1xuICAgICAgdmFyIGwgPSAoXG4gICAgICAgIChjLnggKiBhLnggKyBjLnkgKiBhLnkpIC9cbiAgICAgICAgKE1hdGgucG93KGEueCwgMikgKyBNYXRoLnBvdyhhLnksIDIpKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbCAqIGEueCxcbiAgICAgICAgeTogbCAqIGEueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIG9uZSBwYXJ0aWN1bGFyIGF4aXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgQW4gYXhpcycgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIHRoZSBheGlzLlxuICAgICAqL1xuICAgIGF4aXNDb2xsaXNpb246IGZ1bmN0aW9uKGEsIGMxLCBjMikge1xuICAgICAgdmFyIHNjMSA9IFtdLFxuICAgICAgICAgIHNjMiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgNDsgY2krKykge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnByb2plY3Rpb24oYzFbY2ldLCBhKSxcbiAgICAgICAgICAgIHAyID0gdGhpcy5wcm9qZWN0aW9uKGMyW2NpXSwgYSk7XG5cbiAgICAgICAgc2MxLnB1c2gocDEueCAqIGEueCArIHAxLnkgKiBhLnkpO1xuICAgICAgICBzYzIucHVzaChwMi54ICogYS54ICsgcDIueSAqIGEueSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhjMSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWF4YzIgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzIpLFxuICAgICAgICAgIG1pbmMxID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtaW5jMiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMik7XG5cbiAgICAgIHJldHVybiAobWluYzIgPD0gbWF4YzEgJiYgbWF4YzIgPj0gbWluYzEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gZWFjaCBvbmUgb2YgdGhlaXIgZm91ciBheGlzLiBJZlxuICAgICAqIGFsbCBheGlzIGNvbGxpZGUsIHRoZW4gdGhlIHR3byByZWN0YW5nbGVzIGRvIGNvbGxpZGUgb24gdGhlIHBsYW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUuXG4gICAgICovXG4gICAgY29sbGlzaW9uOiBmdW5jdGlvbihjMSwgYzIpIHtcbiAgICAgIHZhciBheGlzID0gdGhpcy5heGlzKGMxLCBjMiksXG4gICAgICAgICAgY29sID0gdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgIGNvbCA9IGNvbCAmJiB0aGlzLmF4aXNDb2xsaXNpb24oYXhpc1tpXSwgYzEsIGMyKTtcblxuICAgICAgcmV0dXJuIGNvbDtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogUXVhZCBGdW5jdGlvbnNcbiAgICogLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBRdWFkdHJlZSBmdW5jdGlvbnMgdGhlbXNlbHZlcy5cbiAgICogRm9yIGVhY2ggb2YgdGhvc2UgZnVuY3Rpb25zLCB3ZSBjb25zaWRlciB0aGF0IGluIGEgc3BsaXR0ZWQgcXVhZCwgdGhlXG4gICAqIGluZGV4IG9mIGVhY2ggbm9kZSBpcyB0aGUgZm9sbG93aW5nOlxuICAgKiAwOiB0b3AgbGVmdFxuICAgKiAxOiB0b3AgcmlnaHRcbiAgICogMjogYm90dG9tIGxlZnRcbiAgICogMzogYm90dG9tIHJpZ2h0XG4gICAqXG4gICAqIE1vcmVvdmVyLCB0aGUgaGVyZWFmdGVyIHF1YWQncyBwaGlsb3NvcGh5IGlzIHRvIGNvbnNpZGVyIHRoYXQgaWYgYW4gZWxlbWVudFxuICAgKiBjb2xsaWRlcyB3aXRoIG1vcmUgdGhhbiBvbmUgbm9kZXMsIHRoaXMgZWxlbWVudCBiZWxvbmdzIHRvIGVhY2ggb2YgdGhlXG4gICAqIG5vZGVzIGl0IGNvbGxpZGVzIHdpdGggd2hlcmUgb3RoZXIgd291bGQgbGV0IGl0IGxpZSBvbiBhIGhpZ2hlciBub2RlLlxuICAgKi9cblxuICAvKipcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludCBpbiB0aGUgcXVhZFxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCAgICAgIEEgcG9pbnQgZGVmaW5lZCBieSBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWRCb3VuZHMgQm91bmRhcmllcyBvZiB0aGUgcXVhZCAoeCwgeSwgd2lkdGgsIGhlaWd0aCkuXG4gICAqIEByZXR1cm4ge2ludGVnZXJ9ICAgICAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbmRleChwb2ludCwgcXVhZEJvdW5kcykge1xuICAgIHZhciB4bXAgPSBxdWFkQm91bmRzLnggKyBxdWFkQm91bmRzLndpZHRoIC8gMixcbiAgICAgICAgeW1wID0gcXVhZEJvdW5kcy55ICsgcXVhZEJvdW5kcy5oZWlnaHQgLyAyLFxuICAgICAgICB0b3AgPSAocG9pbnQueSA8IHltcCksXG4gICAgICAgIGxlZnQgPSAocG9pbnQueCA8IHhtcCk7XG5cbiAgICBpZiAodG9wKSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMjtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcmVjdGFuZ2xlICAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBxdWFkQ29ybmVycyBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbmRleGVzKHJlY3RhbmdsZSwgcXVhZENvcm5lcnMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGlmICgocmVjdGFuZ2xlLngyID49IHF1YWRDb3JuZXJzW2ldWzBdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS54MSA8PSBxdWFkQ29ybmVyc1tpXVsxXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgKyByZWN0YW5nbGUuaGVpZ2h0ID49IHF1YWRDb3JuZXJzW2ldWzBdLnkpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSA8PSBxdWFkQ29ybmVyc1tpXVsyXS55KSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYSBub24tYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gIGNvcm5lcnMgICAgICBBbiBhcnJheSBjb250YWluaW5nIGVhY2ggY29ybmVyIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgZGVmaW5lZCBieSBpdHMgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHthcnJheX0gIHF1YWRDb3JuZXJzICBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgaW5kZXhlcyBjb250YWluaW5nIG9uZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRDb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnMpIHtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0aW5nIHRocm91Z2ggcXVhZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgIGlmIChfZ2VvbS5jb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnNbaV0pKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJkaXZpZGUgYSBxdWFkIGJ5IGNyZWF0aW5nIGEgbm9kZSBhdCBhIHByZWNpc2UgaW5kZXguIFRoZSBmdW5jdGlvbiBkb2VzXG4gICAqIG5vdCBnZW5lcmF0ZSBhbGwgZm91ciBub2RlcyBub3QgdG8gcG90ZW50aWFsbHkgY3JlYXRlIHVudXNlZCBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBxdWFkICBUaGUgcXVhZCBvYmplY3QgdG8gc3ViZGl2aWRlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgQSBuZXcgcXVhZCByZXByZXNlbnRpbmcgdGhlIG5vZGUgY3JlYXRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkU3ViZGl2aWRlKGluZGV4LCBxdWFkKSB7XG4gICAgdmFyIG5leHQgPSBxdWFkLmxldmVsICsgMSxcbiAgICAgICAgc3VidyA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMud2lkdGggLyAyKSxcbiAgICAgICAgc3ViaCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMuaGVpZ2h0IC8gMiksXG4gICAgICAgIHF4ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy54KSxcbiAgICAgICAgcXkgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLnkpLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHggPSBxeCArIHN1Ync7XG4gICAgICAgIHkgPSBxeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHggPSBxeCArIHN1Ync7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVhZFRyZWUoXG4gICAgICB7eDogeCwgeTogeSwgd2lkdGg6IHN1YncsIGhlaWdodDogc3ViaH0sXG4gICAgICBuZXh0LFxuICAgICAgcXVhZC5tYXhFbGVtZW50cyxcbiAgICAgIHF1YWQubWF4TGV2ZWxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGluc2VydCBhbiBlbGVtZW50IGludG8gdGhlIHF1YWR0cmVlLiBPbmx5IHBvaW50c1xuICAgKiB3aXRoIHNpemUsIGkuZS4gYXhpcy1hbGlnbmVkIHNxdWFyZXMsIG1heSBiZSBpbnNlcnRlZCB3aXRoIHRoaXNcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBlbCAgICAgICAgIFRoZSBlbGVtZW50IHRvIGluc2VydCBpbiB0aGUgcXVhZHRyZWUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHNpemVkUG9pbnQgQSBzaXplZCBwb2ludCBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgICAgICAgVGhlIHF1YWQgaW4gd2hpY2ggdG8gaW5zZXJ0IHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgICAgIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZCkge1xuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuXG4gICAgICAvLyBTZWFyY2hpbmcgYXBwcm9wcmlhdGUgcXVhZHNcbiAgICAgIHZhciBpbmRleGVzID0gX3F1YWRJbmRleGVzKHNpemVkUG9pbnQsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZ1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgIC8vIFN1YmRpdmlkaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPSBfcXVhZFN1YmRpdmlkZShpbmRleGVzW2ldLCBxdWFkKTtcblxuICAgICAgICAvLyBSZWN1cnNpb25cbiAgICAgICAgX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgLy8gUHVzaGluZyB0aGUgZWxlbWVudCBpbiBhIGxlYWYgbm9kZVxuICAgICAgcXVhZC5lbGVtZW50cy5wdXNoKGVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgaGVsZCBieSB0aGUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgVGhlIHNlYXJjaGVkIHBvaW50ICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgVGhlIHNlYXJjaGVkIHF1YWQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgcmVsZXZhbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZCkge1xuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ID0gX3F1YWRJbmRleChwb2ludCwgcXVhZC5ib3VuZHMpO1xuXG4gICAgICAvLyBJZiBub2RlIGRvZXMgbm90IGV4aXN0IHdlIHJldHVybiBhbiBlbXB0eSBsaXN0XG4gICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkLm5vZGVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBxdWFkLmVsZW1lbnRzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBjb250YWluZWQgd2l0aGluIGFuIHJlY3Rhbmd1bGFyIGFyZWFcbiAgICogdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBheGlzLWFsaWduZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdHxhcnJheX0gcmVjdERhdGEgICAgICAgVGhlIHNlYXJjaGVkIGFyZWEgZGVmaW5lZCBlaXRoZXIgYnlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbiBhcnJheSBvZiBmb3VyIGNvcm5lcnMgKHgsIHkpIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNhc2Ugb2YgYSBub24tYXhpcy1hbGlnbmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIG9yIGFuIG9iamVjdCB3aXRoIHR3byB0b3BcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgcXVhZCAgICAgICAgICAgVGhlIHNlYXJjaGVkIHF1YWQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICAgY29sbGlzaW9uRnVuYyAgVGhlIGNvbGxpc2lvbiBmdW5jdGlvbiB1c2VkIHRvIHNlYXJjaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBub2RlIGluZGV4ZXMuXG4gICAqIEBwYXJhbSAge2FycmF5P30gICAgICAgZWxzICAgICAgICAgICAgVGhlIHJldHJpZXZlZCBlbGVtZW50cy5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlYS5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkUmV0cmlldmVBcmVhKHJlY3REYXRhLCBxdWFkLCBjb2xsaXNpb25GdW5jLCBlbHMpIHtcbiAgICBlbHMgPSBlbHMgfHwge307XG5cbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleGVzID0gY29sbGlzaW9uRnVuYyhyZWN0RGF0YSwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBfcXVhZFJldHJpZXZlQXJlYShcbiAgICAgICAgICAgIHJlY3REYXRhLFxuICAgICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgICAgICBlbHNcbiAgICAgICAgICApO1xuICAgIH0gZWxzZVxuICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBxdWFkLmVsZW1lbnRzLmxlbmd0aDsgaiA8IG07IGorKylcbiAgICAgICAgaWYgKGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9IHF1YWQuZWxlbWVudHNbal07XG5cbiAgICByZXR1cm4gZWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIHF1YWR0cmVlIG9iamVjdCBpdHNlbGYuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICBib3VuZHMgICAgICAgVGhlIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiAoeCwgeSksIHdpZHRoIGFuZCBoZWlndGguXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBsZXZlbCAgICAgICAgVGhlIGxldmVsIG9mIHRoZSBxdWFkIGluIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4RWxlbWVudHMgIFRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhMZXZlbCAgICAgVGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkVHJlZShib3VuZHMsIGxldmVsLCBtYXhFbGVtZW50cywgbWF4TGV2ZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IGxldmVsIHx8IDAsXG4gICAgICBib3VuZHM6IGJvdW5kcyxcbiAgICAgIGNvcm5lcnM6IF9nZW9tLnNwbGl0U3F1YXJlKGJvdW5kcyksXG4gICAgICBtYXhFbGVtZW50czogbWF4RWxlbWVudHMgfHwgNDAsXG4gICAgICBtYXhMZXZlbDogbWF4TGV2ZWwgfHwgOCxcbiAgICAgIGVsZW1lbnRzOiBbXSxcbiAgICAgIG5vZGVzOiBbXVxuICAgIH07XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkIENvbnN0cnVjdG9yXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIGVkZ2VxdWFkIEFQSSBhcyBleHBvc2VkIHRvIHNpZ21hLlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGVkZ2VxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfdHJlZSAgICAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfZ2VvbSAgICAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nLlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfY2FjaGUgICAgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZC5cbiAgICogcHJvcGVydHkge2Jvb2xlYW59IF9lbmFibGVkIENhbiBpbmRleCBhbmQgcmV0cmVpdmUgZWxlbWVudHMuXG4gICAqL1xuICB2YXIgZWRnZXF1YWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9nZW9tID0gX2dlb207XG4gICAgdGhpcy5fdHJlZSA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogSW5kZXggYSBncmFwaCBieSBpbnNlcnRpbmcgaXRzIGVkZ2VzIGludG8gdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGdyYXBoICAgQSBncmFwaCBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXJzIHdpdGggYXQgbGVhc3QgdGhlIHF1YWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqXG4gICAqIFBhcmFtZXRlcnM6XG4gICAqIC0tLS0tLS0tLS1cbiAgICogYm91bmRzOiAgICAgIHtvYmplY3R9ICAgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGl0cyBvcmlnaW4gKHgsIHkpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIGFuZCBoZWlndGguXG4gICAqIHByZWZpeDogICAgICB7c3RyaW5nP30gIGEgcHJlZml4IGZvciBlZGdlIGdlb21ldHJpYyBhdHRyaWJ1dGVzLlxuICAgKiBtYXhFbGVtZW50czoge2ludGVnZXI/fSB0aGUgbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiBhIGxlYWYgbm9kZS5cbiAgICogbWF4TGV2ZWw6ICAgIHtpbnRlZ2VyP30gdGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihncmFwaCwgcGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG5cbiAgICAvLyBFbmZvcmNpbmcgcHJlc2VuY2Ugb2YgYm91bmRhcmllc1xuICAgIGlmICghcGFyYW1zLmJvdW5kcylcbiAgICAgIHRocm93ICdzaWdtYS5jbGFzc2VzLmVkZ2VxdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XG5cbiAgICAvLyBQcmVmaXhcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJyxcbiAgICAgICAgY3AsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBuLFxuICAgICAgICBlO1xuXG4gICAgLy8gQnVpbGRpbmcgdGhlIHRyZWVcbiAgICB0aGlzLl90cmVlID0gX3F1YWRUcmVlKFxuICAgICAgcGFyYW1zLmJvdW5kcyxcbiAgICAgIDAsXG4gICAgICBwYXJhbXMubWF4RWxlbWVudHMsXG4gICAgICBwYXJhbXMubWF4TGV2ZWxcbiAgICApO1xuXG4gICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXMoKTtcblxuICAgIC8vIEluc2VydGluZyBncmFwaCBlZGdlcyBpbnRvIHRoZSB0cmVlXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGdyYXBoLm5vZGVzKGVkZ2VzW2ldLnNvdXJjZSk7XG4gICAgICB0YXJnZXQgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS50YXJnZXQpO1xuICAgICAgZSA9IHtcbiAgICAgICAgeDE6IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICB5MTogc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHgyOiB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgeTI6IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBzaXplOiBlZGdlc1tpXVtwcmVmaXggKyAnc2l6ZSddIHx8IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIEluc2VydGluZyBlZGdlXG4gICAgICBpZiAoZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlJyB8fCBlZGdlc1tpXS50eXBlID09PSAnY3VydmVkQXJyb3cnKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgICAgIG4gPSB7XG4gICAgICAgICAgICB4OiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgIHk6IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgc2l6ZTogc291cmNlW3ByZWZpeCArICdzaXplJ10gfHwgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICAgIF9nZW9tLnNlbGZMb29wVG9TcXVhcmUobiksXG4gICAgICAgICAgICB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChlLngxLCBlLnkxLCBlLngyLCBlLnkyKTtcbiAgICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICAgIGVkZ2VzW2ldLFxuICAgICAgICAgICAgX2dlb20ucXVhZHJhdGljQ3VydmVUb1NxdWFyZShlLCBjcCksXG4gICAgICAgICAgICB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgIGVkZ2VzW2ldLFxuICAgICAgICAgIF9nZW9tLmxpbmVUb1NxdWFyZShlKSxcbiAgICAgICAgICB0aGlzLl90cmVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNldCBjYWNoZTpcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcbiAgICAgIHJlc3VsdDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlP1xuICAgIHJldHVybiB0aGlzLl90cmVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBlZGdlcyBoZWxkIGJ5IHRoZSBxdWFkdHJlZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb2YgdGhlIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgb2YgdGhlIHBvaW50LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIGVkZ2VzIHJldHJpZXZlZC5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpXG4gICAgICByZXR1cm4gW107XG5cbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlUG9pbnQoe3g6IHgsIHk6IHl9LCB0aGlzLl90cmVlKSB8fCBbXSA6XG4gICAgICBbXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggZWRnZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcbiAgICogbGFzdCBhcmVhIHF1ZXJpZWQgaW4gY2FjaGUgZm9yIG9wdGltaXphdGlvbiByZWFzb24gYW5kIHdpbGwgYWN0IGRpZmZlcmVudGx5XG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKVxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2YgZWRnZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShyZWN0KSxcbiAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgcmVjdERhdGE7XG5cbiAgICAvLyBSZXR1cm5pbmcgY2FjaGU/XG4gICAgaWYgKHRoaXMuX2NhY2hlLnF1ZXJ5ID09PSBzZXJpYWxpemVkKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnJlc3VsdDtcblxuICAgIC8vIEF4aXMgYWxpZ25lZCA/XG4gICAgaWYgKF9nZW9tLmlzQXhpc0FsaWduZWQocmVjdCkpIHtcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZEluZGV4ZXM7XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLmF4aXNBbGlnbmVkVG9wUG9pbnRzKHJlY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZENvbGxpc2lvbjtcbiAgICAgIHJlY3REYXRhID0gX2dlb20ucmVjdGFuZ2xlQ29ybmVycyhyZWN0KTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2aW5nIGVkZ2VzXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlQXJlYShcbiAgICAgICAgcmVjdERhdGEsXG4gICAgICAgIHRoaXMuX3RyZWUsXG4gICAgICAgIGNvbGxpc2lvbkZ1bmNcbiAgICAgICkgOlxuICAgICAgW107XG5cbiAgICAvLyBPYmplY3QgdG8gYXJyYXlcbiAgICB2YXIgZWRnZXNBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgaW4gZWRnZXMpXG4gICAgICBlZGdlc0FycmF5LnB1c2goZWRnZXNbaV0pO1xuXG4gICAgLy8gQ2FjaGluZ1xuICAgIHRoaXMuX2NhY2hlLnF1ZXJ5ID0gc2VyaWFsaXplZDtcbiAgICB0aGlzLl9jYWNoZS5yZXN1bHQgPSBlZGdlc0FycmF5O1xuXG4gICAgcmV0dXJuIGVkZ2VzQXJyYXk7XG4gIH07XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xuICAgIHRoaXMuc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCA9IGVkZ2VxdWFkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGVkZ2VxdWFkO1xuICAgIGV4cG9ydHMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbiAgfSBlbHNlXG4gICAgdGhpcy5lZGdlcXVhZCA9IGVkZ2VxdWFkO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FwdG9ycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgdXNlciBpbnB1dHMgZGVmYXVsdCBjYXB0b3IuIEl0IGRlYWxzIHdpdGggbW91c2UgZXZlbnRzLCBrZXlib2FyZHNcbiAgICogZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgdGFyZ2V0ICAgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kLlxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEgcmVsYXRlZCB0byB0aGUgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7c2lnbWEuY2FwdG9yfSAgICAgICAgICBUaGUgZnJlc2ggbmV3IGNhcHRvciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLmNhcHRvcnMubW91c2UgPSBmdW5jdGlvbih0YXJnZXQsIGNhbWVyYSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfdGFyZ2V0ID0gdGFyZ2V0LFxuICAgICAgICBfY2FtZXJhID0gY2FtZXJhLFxuICAgICAgICBfc2V0dGluZ3MgPSBzZXR0aW5ncyxcblxuICAgICAgICAvLyBDQU1FUkEgTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRoZSBjYW1lcmEgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydENhbWVyYVgsXG4gICAgICAgIF9zdGFydENhbWVyYVksXG4gICAgICAgIF9zdGFydENhbWVyYUFuZ2xlLFxuXG4gICAgICAgIC8vIFRoZSBsYXRlc3Qgc3RhZ2UgcG9zaXRpb246XG4gICAgICAgIF9sYXN0Q2FtZXJhWCxcbiAgICAgICAgX2xhc3RDYW1lcmFZLFxuICAgICAgICBfbGFzdENhbWVyYUFuZ2xlLFxuICAgICAgICBfbGFzdENhbWVyYVJhdGlvLFxuXG4gICAgICAgIC8vIE1PVVNFIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRoZSBtb3VzZSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcbiAgICAgICAgX3N0YXJ0TW91c2VYLFxuICAgICAgICBfc3RhcnRNb3VzZVksXG5cbiAgICAgICAgX2lzTW91c2VEb3duLFxuICAgICAgICBfaXNNb3ZpbmcsXG4gICAgICAgIF9oYXNEcmFnZ2VkLFxuICAgICAgICBfZG93blN0YXJ0VGltZSxcbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZDtcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snLCBfZG91YmxlQ2xpY2tIYW5kbGVyKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgX3doZWVsSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9tb3ZlSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Rvd25IYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgX291dEhhbmRsZXIsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3VwSGFuZGxlciwgZmFsc2UpO1xuXG5cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdW5iaW5kcyBldmVyeSBoYW5kbGVycyB0aGF0IG1ha2VzIHRoZSBjYXB0b3Igd29yay5cbiAgICAgKi9cbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrKF90YXJnZXQsICdjbGljaycpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIF93aGVlbEhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgX3doZWVsSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9tb3ZlSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9kb3duSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2NsaWNrSGFuZGxlcik7XG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgX291dEhhbmRsZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF91cEhhbmRsZXIpO1xuICAgIH07XG5cblxuXG5cbiAgICAvLyBNT1VTRSBFVkVOVFM6XG4gICAgLy8gKioqKioqKioqKioqKlxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnbW92ZScgbW91c2UgZXZlbnQuIEl0IHdpbGwgZWZmZWN0aXZlbHlcbiAgICAgKiBkcmFnIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbW92ZUhhbmRsZXIoZSkge1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBwb3M7XG5cbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50OlxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vtb3ZlJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XG5cbiAgICAgICAgaWYgKF9pc01vdXNlRG93bikge1xuICAgICAgICAgIF9pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgX2hhc0RyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG5cbiAgICAgICAgICBfbW92aW5nVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgIH0sIF9zZXR0aW5ncygnZHJhZ1RpbWVvdXQnKSk7XG5cbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKF9jYW1lcmEpO1xuXG4gICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBfc3RhcnRNb3VzZVgsXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRZKGUpIC0gX3N0YXJ0TW91c2VZLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB4ID0gX3N0YXJ0Q2FtZXJhWCAtIHBvcy54O1xuICAgICAgICAgIHkgPSBfc3RhcnRDYW1lcmFZIC0gcG9zLnk7XG5cbiAgICAgICAgICBpZiAoeCAhPT0gX2NhbWVyYS54IHx8IHkgIT09IF9jYW1lcmEueSkge1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xuICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3VwJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdG9wIGRyYWdnaW5nIHRoZVxuICAgICAqIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF91cEhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykgJiYgX2lzTW91c2VEb3duKSB7XG4gICAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG5cbiAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xuXG4gICAgICAgIHZhciB4ID0gc2lnbWEudXRpbHMuZ2V0WChlKSxcbiAgICAgICAgICAgIHkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xuXG4gICAgICAgIGlmIChfaXNNb3ZpbmcpIHtcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKF9jYW1lcmEpO1xuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcbiAgICAgICAgICAgIF9jYW1lcmEsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXG4gICAgICAgICAgICAgICAgX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFSYXRpbycpICogKF9jYW1lcmEueCAtIF9sYXN0Q2FtZXJhWCksXG4gICAgICAgICAgICAgIHk6IF9jYW1lcmEueSArXG4gICAgICAgICAgICAgICAgX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFSYXRpbycpICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlSW5lcnRpYUR1cmF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIF9zdGFydE1vdXNlWCAhPT0geCB8fFxuICAgICAgICAgIF9zdGFydE1vdXNlWSAhPT0geVxuICAgICAgICApXG4gICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgIHg6IF9jYW1lcmEueCxcbiAgICAgICAgICAgIHk6IF9jYW1lcmEueVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNldXAnLFxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpKTtcblxuICAgICAgICAvLyBVcGRhdGUgX2lzTW92aW5nIGZsYWc6XG4gICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ2Rvd24nIG1vdXNlIGV2ZW50LiBJdCB3aWxsIHN0YXJ0IG9ic2VydmluZ1xuICAgICAqIHRoZSBtb3VzZSBwb3NpdGlvbiBmb3IgZHJhZ2dpbmcgdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9kb3duSGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICBfc3RhcnRDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgIF9zdGFydE1vdXNlWCA9IHNpZ21hLnV0aWxzLmdldFgoZSk7XG4gICAgICAgIF9zdGFydE1vdXNlWSA9IHNpZ21hLnV0aWxzLmdldFkoZSk7XG5cbiAgICAgICAgX2hhc0RyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgX2Rvd25TdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIE1pZGRsZSBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIC8vIFJpZ2h0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodGNsaWNrJyxcbiAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIGNhc2UgMTpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTGVmdCBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgX2lzTW91c2VEb3duID0gdHJ1ZTtcblxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ291dCcgbW91c2UgZXZlbnQuIEl0IHdpbGwganVzdCByZWRpc3BhdGNoXG4gICAgICogdGhlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9vdXRIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKVxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW91dCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ2NsaWNrJyBtb3VzZSBldmVudC4gSXQgd2lsbCByZWRpc3BhdGNoIHRoZVxuICAgICAqIGNsaWNrIGV2ZW50LCBidXQgd2l0aCBub3JtYWxpemVkIFggYW5kIFkgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2NsaWNrSGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgZXZlbnQuaXNEcmFnZ2luZyA9XG4gICAgICAgICAgKCgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gX2Rvd25TdGFydFRpbWUpID4gMTAwKSAmJiBfaGFzRHJhZ2dlZDtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlbHNlXG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSBjbGljayBjdXN0b20gZXZlbnQuIEl0IHdpbGxcbiAgICAgKiBiYXNpY2FsbHkgem9vbSBpbnRvIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG91YmxlQ2xpY2tIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MsXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgYW5pbWF0aW9uO1xuXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xuICAgICAgICByYXRpbyA9IDEgLyBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbWluZ1JhdGlvJyk7XG5cbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlY2xpY2snLFxuICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzKCdkb3VibGVDbGlja0VuYWJsZWQnKSkge1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRZKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJylcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3doZWVsJyBtb3VzZSBldmVudC4gSXQgd2lsbCBiYXNpY2FsbHkgem9vbVxuICAgICAqIGluIG9yIG5vdCBpbnRvIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfd2hlZWxIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MsXG4gICAgICAgICAgcmF0aW8sXG4gICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgIHdoZWVsRGVsdGEgPSBzaWdtYS51dGlscy5nZXREZWx0YShlKTtcblxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykgJiYgX3NldHRpbmdzKCdtb3VzZVdoZWVsRW5hYmxlZCcpICYmIHdoZWVsRGVsdGEgIT09IDApIHtcbiAgICAgICAgcmF0aW8gPSB3aGVlbERlbHRhID4gMCA/XG4gICAgICAgICAgMSAvIF9zZXR0aW5ncygnem9vbWluZ1JhdGlvJykgOlxuICAgICAgICAgIF9zZXR0aW5ncygnem9vbWluZ1JhdGlvJyk7XG5cbiAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnbW91c2Vab29tRHVyYXRpb24nKVxuICAgICAgICB9O1xuXG4gICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FwdG9ycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgdXNlciBpbnB1dHMgZGVmYXVsdCBjYXB0b3IuIEl0IGRlYWxzIHdpdGggbW91c2UgZXZlbnRzLCBrZXlib2FyZHNcbiAgICogZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgdGFyZ2V0ICAgVGhlIERPTSBlbGVtZW50IHdoZXJlIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kLlxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEgcmVsYXRlZCB0byB0aGUgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7c2lnbWEuY2FwdG9yfSAgICAgICAgICBUaGUgZnJlc2ggbmV3IGNhcHRvciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLmNhcHRvcnMudG91Y2ggPSBmdW5jdGlvbih0YXJnZXQsIGNhbWVyYSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfdGFyZ2V0ID0gdGFyZ2V0LFxuICAgICAgICBfY2FtZXJhID0gY2FtZXJhLFxuICAgICAgICBfc2V0dGluZ3MgPSBzZXR0aW5ncyxcblxuICAgICAgICAvLyBDQU1FUkEgTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFRoZSBjYW1lcmEgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydENhbWVyYVgsXG4gICAgICAgIF9zdGFydENhbWVyYVksXG4gICAgICAgIF9zdGFydENhbWVyYUFuZ2xlLFxuICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxuICAgICAgICBfbGFzdENhbWVyYVgsXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBUT1VDSCBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUb3VjaGVzIHRoYXQgYXJlIGRvd246XG4gICAgICAgIF9kb3duVG91Y2hlcyA9IFtdLFxuXG4gICAgICAgIF9zdGFydFRvdWNoWDAsXG4gICAgICAgIF9zdGFydFRvdWNoWTAsXG4gICAgICAgIF9zdGFydFRvdWNoWDEsXG4gICAgICAgIF9zdGFydFRvdWNoWTEsXG4gICAgICAgIF9zdGFydFRvdWNoQW5nbGUsXG4gICAgICAgIF9zdGFydFRvdWNoRGlzdGFuY2UsXG5cbiAgICAgICAgX3RvdWNoTW9kZSxcblxuICAgICAgICBfaXNNb3ZpbmcsXG4gICAgICAgIF9kb3VibGVUYXAsXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnLCBfZG91YmxlVGFwSGFuZGxlcik7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2hhbmRsZVN0YXJ0LCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIF9oYW5kbGVMZWF2ZSwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9oYW5kbGVNb3ZlLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBwb3NpdGlvbihlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc2lnbWEudXRpbHMuZ2V0T2Zmc2V0KF90YXJnZXQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQsXG4gICAgICAgIHk6IGUucGFnZVkgLSBvZmZzZXQudG9wXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVuYmluZHMgZXZlcnkgaGFuZGxlcnMgdGhhdCBtYWtlcyB0aGUgY2FwdG9yIHdvcmsuXG4gICAgICovXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayhfdGFyZ2V0LCAndG91Y2hzdGFydCcpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2hhbmRsZVN0YXJ0KTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF9oYW5kbGVMZWF2ZSk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSk7XG4gICAgfTtcblxuICAgIC8vIFRPVUNIIEVWRU5UUzpcbiAgICAvLyAqKioqKioqKioqKioqXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hzdGFydCcgZXZlbnQuIEl0IHdpbGwgc2V0IHRoZSB0b3VjaFxuICAgICAqIG1vZGUgKFwiX3RvdWNoTW9kZVwiKSBhbmQgc3RhcnQgb2JzZXJ2aW5nIHRoZSB1c2VyIHRvdWNoIG1vdmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9oYW5kbGVTdGFydChlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICB2YXIgeDAsXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkwLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBwb3MwLFxuICAgICAgICAgICAgcG9zMTtcblxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG5cbiAgICAgICAgc3dpdGNoIChfZG93blRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICBfdG91Y2hNb2RlID0gMTtcblxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0gcG9zMC54O1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMCA9IHBvczAueTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XG4gICAgICAgICAgICBfdG91Y2hNb2RlID0gMjtcblxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG4gICAgICAgICAgICB4MSA9IHBvczEueDtcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xuXG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVJhdGlvID0gX2NhbWVyYS5yYXRpbztcblxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9zdGFydENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDAgPSB4MDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSB5MDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDEgPSB4MTtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTEgPSB5MTtcblxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hBbmdsZSA9IE1hdGguYXRhbjIoXG4gICAgICAgICAgICAgIF9zdGFydFRvdWNoWTEgLSBfc3RhcnRUb3VjaFkwLFxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFgxIC0gX3N0YXJ0VG91Y2hYMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCkgKlxuICAgICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCkgK1xuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDApICpcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcgYW5kICd0b3VjaGxlYXZlJ1xuICAgICAqIGV2ZW50LiBJdCB3aWxsIHVwZGF0ZSB0aGUgdG91Y2ggbW9kZSBpZiB0aGVyZSBhcmUgc3RpbGwgYXQgbGVhc3Qgb25lXG4gICAgICogZmluZ2VyLCBhbmQgc3RvcCBkcmFnZ2luZyBlbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9oYW5kbGVMZWF2ZShlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIHZhciBpbmVydGlhUmF0aW8gPSBfc2V0dGluZ3MoJ3RvdWNoSW5lcnRpYVJhdGlvJyk7XG5cbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKF90b3VjaE1vZGUpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBfaGFuZGxlU3RhcnQoZSk7XG5cbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdzdG9wRHJhZycpO1xuXG4gICAgICAgICAgICBpZiAoX2lzTW92aW5nKSB7XG4gICAgICAgICAgICAgIF9kb3VibGVUYXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhKFxuICAgICAgICAgICAgICAgIF9jYW1lcmEsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgeDogX2NhbWVyYS54ICtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueCAtIF9sYXN0Q2FtZXJhWCksXG4gICAgICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xuICAgICAgICAgICAgICAgICAgICBpbmVydGlhUmF0aW8gKiAoX2NhbWVyYS55IC0gX2xhc3RDYW1lcmFZKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWFzaW5nOiAncXVhZHJhdGljT3V0JyxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ3RvdWNoSW5lcnRpYUR1cmF0aW9uJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNobW92ZScgZXZlbnQuIEl0IHdpbGwgZWZmZWN0aXZlbHkgZHJhZ1xuICAgICAqIHRoZSBncmFwaCwgYW5kIGV2ZW50dWFsbHkgem9vbXMgYW5kIHR1cm4gaXQgaWYgdGhlIHVzZXIgaXMgdXNpbmcgdHdvXG4gICAgICogZmluZ2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlTW92ZShlKSB7XG4gICAgICBpZiAoIV9kb3VibGVUYXAgJiYgX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xuICAgICAgICB2YXIgeDAsXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkwLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjb3MsXG4gICAgICAgICAgICBzaW4sXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBwb3MwLFxuICAgICAgICAgICAgcG9zMSxcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGRBbmdsZSxcbiAgICAgICAgICAgIGRSYXRpbyxcbiAgICAgICAgICAgIG5ld1N0YWdlWCxcbiAgICAgICAgICAgIG5ld1N0YWdlWSxcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8sXG4gICAgICAgICAgICBuZXdTdGFnZUFuZ2xlO1xuXG4gICAgICAgIF9kb3duVG91Y2hlcyA9IGUudG91Y2hlcztcbiAgICAgICAgX2lzTW92aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoX21vdmluZ1RpbWVvdXRJZClcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XG5cbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIF9zZXR0aW5ncygnZHJhZ1RpbWVvdXQnKSk7XG5cbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuXG4gICAgICAgICAgICBkaWZmID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgeDAgLSBfc3RhcnRUb3VjaFgwLFxuICAgICAgICAgICAgICB5MCAtIF9zdGFydFRvdWNoWTAsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIG5ld1N0YWdlWCA9IF9zdGFydENhbWVyYVggLSBkaWZmLng7XG4gICAgICAgICAgICBuZXdTdGFnZVkgPSBfc3RhcnRDYW1lcmFZIC0gZGlmZi55O1xuXG4gICAgICAgICAgICBpZiAobmV3U3RhZ2VYICE9PSBfY2FtZXJhLnggfHwgbmV3U3RhZ2VZICE9PSBfY2FtZXJhLnkpIHtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zMC54LCBwb3MwLnkpKTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwb3MwID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHBvczEgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMV0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcbiAgICAgICAgICAgIHgxID0gcG9zMS54O1xuICAgICAgICAgICAgeTEgPSBwb3MxLnk7XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDAgKyBfc3RhcnRUb3VjaFgxKSAvIDIgLVxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMCArIF9zdGFydFRvdWNoWTEpIC8gMiAtXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlbmQgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgICAoeDAgKyB4MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXG4gICAgICAgICAgICAgICh5MCArIHkxKSAvIDIgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZEFuZ2xlID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKSAtIF9zdGFydFRvdWNoQW5nbGU7XG4gICAgICAgICAgICBkUmF0aW8gPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICh5MSAtIHkwKSAqICh5MSAtIHkwKSArICh4MSAtIHgwKSAqICh4MSAtIHgwKVxuICAgICAgICAgICAgKSAvIF9zdGFydFRvdWNoRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zbGF0aW9uOlxuICAgICAgICAgICAgeDAgPSBzdGFydC54O1xuICAgICAgICAgICAgeTAgPSBzdGFydC55O1xuXG4gICAgICAgICAgICAvLyBIb21vdGhldGljIHRyYW5zZm9ybWF0aW9uOlxuICAgICAgICAgICAgbmV3U3RhZ2VSYXRpbyA9IF9zdGFydENhbWVyYVJhdGlvIC8gZFJhdGlvO1xuICAgICAgICAgICAgeDAgPSB4MCAqIGRSYXRpbztcbiAgICAgICAgICAgIHkwID0geTAgKiBkUmF0aW87XG5cbiAgICAgICAgICAgIC8vIFJvdGF0aW9uOlxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSA9IF9zdGFydENhbWVyYUFuZ2xlIC0gZEFuZ2xlO1xuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoLWRBbmdsZSk7XG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbigtZEFuZ2xlKTtcbiAgICAgICAgICAgIHgxID0geDAgKiBjb3MgKyB5MCAqIHNpbjtcbiAgICAgICAgICAgIHkxID0geTAgKiBjb3MgLSB4MCAqIHNpbjtcbiAgICAgICAgICAgIHgwID0geDE7XG4gICAgICAgICAgICB5MCA9IHkxO1xuXG4gICAgICAgICAgICAvLyBGaW5hbGl6ZTpcbiAgICAgICAgICAgIG5ld1N0YWdlWCA9IHgwIC0gZW5kLnggKyBfc3RhcnRDYW1lcmFYO1xuICAgICAgICAgICAgbmV3U3RhZ2VZID0geTAgLSBlbmQueSArIF9zdGFydENhbWVyYVk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbmV3U3RhZ2VSYXRpbyAhPT0gX2NhbWVyYS5yYXRpbyB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZUFuZ2xlICE9PSBfY2FtZXJhLmFuZ2xlIHx8XG4gICAgICAgICAgICAgIG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8XG4gICAgICAgICAgICAgIG5ld1N0YWdlWSAhPT0gX2NhbWVyYS55XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUgPSBfY2FtZXJhLmFuZ2xlO1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYVJhdGlvID0gX2NhbWVyYS5yYXRpbztcblxuICAgICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xuICAgICAgICAgICAgICAgIHg6IG5ld1N0YWdlWCxcbiAgICAgICAgICAgICAgICB5OiBuZXdTdGFnZVksXG4gICAgICAgICAgICAgICAgYW5nbGU6IG5ld1N0YWdlQW5nbGUsXG4gICAgICAgICAgICAgICAgcmF0aW86IG5ld1N0YWdlUmF0aW9cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgZG91YmxlIHRhcCBjdXN0b20gZXZlbnQuIEl0IHdpbGxcbiAgICAgKiBiYXNpY2FsbHkgem9vbSBpbnRvIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG91YmxlVGFwSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbjtcblxuICAgICAgaWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID09PSAxICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgX2RvdWJsZVRhcCA9IHRydWU7XG5cbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIHBvcyA9IHBvc2l0aW9uKGUudG91Y2hlc1swXSk7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBwb3MueCwgcG9zLnkpKTtcblxuICAgICAgICBpZiAoX3NldHRpbmdzKCdkb3VibGVDbGlja0VuYWJsZWQnKSkge1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBwb3MueCAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgcG9zLnkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29tRHVyYXRpb24nKSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgaWYgKHR5cGVvZiBjb25yYWQgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdjb25yYWQgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY2FudmFzIHNpZ21hJ3MgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgICAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIG9iamVjdCAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcyA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMuY2FudmFzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICghKG9wdGlvbnMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKVxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcblxuICAgIHZhciBrLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBhLFxuICAgICAgICBmbixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25yYWRJZCcsIHtcbiAgICAgIHZhbHVlOiBzaWdtYS51dGlscy5pZCgpXG4gICAgfSk7XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIE5vZGUgaW5kZXhlczpcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcblxuICAgIC8vIENvbnJhZCByZWxhdGVkIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5qb2JzID0ge307XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyB0aGlzLmNvbnJhZElkICsgJzonO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxuICAgIGlmIChcbiAgICAgICF0aGlzLnNldHRpbmdzKCdiYXRjaEVkZ2VzRHJhd2luZycpXG4gICAgKSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnZWRnZXMnKTtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ3NjZW5lJyk7XG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdtb3VzZScpO1xuICAgIHRoaXMuY29udGV4dHMuaG92ZXIgPSB0aGlzLmNvbnRleHRzLm1vdXNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcbiAgICAgICAgbmV3IGZuKFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubW91c2UsXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XG4gICAgc2lnbWEubWlzYy5iaW5kRXZlbnRzLmNhbGwodGhpcywgdGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5vcHRpb25zLnByZWZpeCk7XG5cbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBjYW52YXNlcy5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBrLFxuICAgICAgICBsLFxuICAgICAgICBvLFxuICAgICAgICBpZCxcbiAgICAgICAgZW5kLFxuICAgICAgICBqb2IsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgcmVuZGVyZXJzLFxuICAgICAgICByZW5kZXJlclR5cGUsXG4gICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgdGVtcEdDTyxcbiAgICAgICAgaW5kZXggPSB7fSxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMsXG4gICAgICAgIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXggfHwgJycsXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKSxcbiAgICAgICAgZHJhd0xhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdMYWJlbHMnKSxcbiAgICAgICAgZHJhd0VkZ2VMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZUxhYmVscycpLFxuICAgICAgICBlbWJlZFNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucywge1xuICAgICAgICAgIHByZWZpeDogdGhpcy5vcHRpb25zLnByZWZpeFxuICAgICAgICB9KTtcblxuICAgIC8vIENhbGwgdGhlIHJlc2l6ZSBmdW5jdGlvbjpcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBDbGVhciBjYW52YXNlczpcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAvLyBLaWxsIHJ1bm5pbmcgam9iczpcbiAgICBmb3IgKGsgaW4gdGhpcy5qb2JzKVxuICAgICAgaWYgKGNvbnJhZC5oYXNKb2IoaykpXG4gICAgICAgIGNvbnJhZC5raWxsSm9iKGspO1xuXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuOlxuICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IFtdO1xuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXG4gICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgKTtcblxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcblxuICAgIC8vIERyYXcgZWRnZXM6XG4gICAgLy8gLSBJZiBzZXR0aW5ncygnYmF0Y2hFZGdlc0RyYXdpbmcnKSBpcyB0cnVlLCB0aGUgZWRnZXMgYXJlIGRpc3BsYXllZCBwZXJcbiAgICAvLyAgIGJhdGNoZXMuIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lLlxuICAgIGlmIChkcmF3RWRnZXMpIHtcbiAgICAgIC8vIEZpcnN0LCBsZXQncyBpZGVudGlmeSB3aGljaCBlZGdlcyB0byBkcmF3LiBUbyBkbyB0aGlzLCB3ZSBqdXN0IGtlZXBcbiAgICAgIC8vIGV2ZXJ5IGVkZ2VzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgZXh0cmVtaXR5IGRpc3BsYXllZCBhY2NvcmRpbmcgdG9cbiAgICAgIC8vIHRoZSBxdWFkdHJlZSBhbmQgdGhlIFwiaGlkZGVuXCIgYXR0cmlidXRlLiBXZSBhbHNvIGRvIG5vdCBrZWVwIGhpZGRlblxuICAgICAgLy8gZWRnZXMuXG4gICAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG8gPSBhW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKGluZGV4W28uc291cmNlXSB8fCBpbmRleFtvLnRhcmdldF0pICYmXG4gICAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcbiAgICAgICAgKVxuICAgICAgICAgIHRoaXMuZWRnZXNPblNjcmVlbi5wdXNoKG8pO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgXCJiYXRjaEVkZ2VzRHJhd2luZ1wiIHNldHRpbmdzIGlzIHRydWUsIGVkZ2VzIGFyZSBiYXRjaGVkOlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpIHtcbiAgICAgICAgaWQgPSAnZWRnZXNfJyArIHRoaXMuY29ucmFkSWQ7XG4gICAgICAgIGJhdGNoU2l6ZSA9IGVtYmVkU2V0dGluZ3MoJ2NhbnZhc0VkZ2VzQmF0Y2hTaXplJyk7XG5cbiAgICAgICAgZWRnZXMgPSB0aGlzLmVkZ2VzT25TY3JlZW47XG4gICAgICAgIGwgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcblxuICAgICAgICBqb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZW1wR0NPID0gdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG5cbiAgICAgICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZXM7XG4gICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgbyA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgICBvLFxuICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8udGFyZ2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEcmF3IGVkZ2UgbGFiZWxzOlxuICAgICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xuICAgICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzLmxhYmVscztcbiAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgbyA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgICBpZiAoIW8uaGlkZGVuKVxuICAgICAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgICAgICBvLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8uc291cmNlKSxcbiAgICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8udGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dHMubGFiZWxzLFxuICAgICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246XG4gICAgICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0ZW1wR0NPO1xuXG4gICAgICAgICAgLy8gQ2F0Y2ggam9iJ3MgZW5kOlxuICAgICAgICAgIGlmIChlbmQgPT09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuam9ic1tpZF07XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnQgPSBlbmQgKyAxO1xuICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVkZ2VzLmxlbmd0aCwgc3RhcnQgKyBiYXRjaFNpemUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuam9ic1tpZF0gPSBqb2I7XG4gICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gSWYgbm90LCB0aGV5IGFyZSBkcmF3biBpbiBvbmUgZnJhbWU6XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZXM7XG4gICAgICAgIGZvciAoYSA9IHRoaXMuZWRnZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG8gPSBhW2ldO1xuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBvLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgbyxcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8uc291cmNlKSxcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzKG8udGFyZ2V0KSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgZWRnZSBsYWJlbHM6XG4gICAgICAgIC8vIC0gTm8gYmF0Y2hpbmdcbiAgICAgICAgaWYgKGRyYXdFZGdlTGFiZWxzKSB7XG4gICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzLmxhYmVscztcbiAgICAgICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IG5vZGVzOlxuICAgIC8vIC0gTm8gYmF0Y2hpbmdcbiAgICBpZiAoZHJhd05vZGVzKSB7XG4gICAgICByZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMubm9kZXM7XG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIERyYXcgbGFiZWxzOlxuICAgIC8vIC0gTm8gYmF0Y2hpbmdcbiAgICBpZiAoZHJhd0xhYmVscykge1xuICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmxhYmVscztcbiAgICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgYVtpXS50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHROb2RlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdGFnIFRoZSBsYWJlbCB0YWcuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgIFRoZSBpZCBvZiB0aGUgZWxlbWVudCAodG8gc3RvcmUgaXQgaW4gXCJkb21FbGVtZW50c1wiKS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcsIGlkKSB7XG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lnbWEtJyArIGlkKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudHNbaWRdID0gZG9tO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICBpZiAodGFnLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKVxuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCgnMmQnKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xuICAgKiBkaW1lbnNpb25zLiBUaGVuLCBpdCByZW5kZXJzIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XG5cbiAgICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB3ID0gdGhpcy53aWR0aDtcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzW2tdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChoICogcGl4ZWxSYXRpbykgKyAncHgnKTtcblxuICAgICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0c1trXS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjbGVhcnMgZWFjaCBjYW52YXMuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLmNvbnRleHRzKSB7XG4gICAgICB0aGlzLmNvbnRleHRzW2tdLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGNvbnRleHRzIGFuZCBvdGhlciBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLFxuICAgICAgICBjYXB0b3I7XG5cbiAgICAvLyBLaWxsIGNhcHRvcnM6XG4gICAgd2hpbGUgKChjYXB0b3IgPSB0aGlzLmNhcHRvcnMucG9wKCkpKVxuICAgICAgY2FwdG9yLmtpbGwoKTtcbiAgICBkZWxldGUgdGhpcy5jYXB0b3JzO1xuXG4gICAgLy8gS2lsbCBjb250ZXh0czpcbiAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xuICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNba10pO1xuICAgICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHNba107XG4gICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1trXTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuY29udGV4dHM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBsYWJlbHMsIG5vZGVzIGFuZCBlZGdlcyByZW5kZXJlcnMgYXJlIHN0b3JlZCBpbiB0aGUgdGhyZWUgZm9sbG93aW5nXG4gICAqIG9iamVjdHMuIFdoZW4gYW4gZWxlbWVudCBpcyBkcmF3biwgaXRzIHR5cGUgd2lsbCBiZSBjaGVja2VkIGFuZCBpZiBhXG4gICAqIHJlbmRlcmVyIHdpdGggdGhlIHNhbWUgbmFtZSBleGlzdHMsIGl0IHdpbGwgYmUgdXNlZC4gSWYgbm90IGZvdW5kLCB0aGVcbiAgICogZGVmYXVsdCByZW5kZXJlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICpcbiAgICogVGhleSBhcmUgc3RvcmVkIGluIGRpZmZlcmVudCBmaWxlcywgaW4gdGhlIFwiLi9jYW52YXNcIiBmb2xkZXIuXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ub2RlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnJlbmRlcmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY2FudmFzIHNpZ21hJ3MgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgICAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhLlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2lnbWEgaW5zdGFuY2Ugc2V0dGluZ3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIG9iamVjdCAgIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICAgVGhlIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy53ZWJnbDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIF9zZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuam9icyA9IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25yYWRJZCcsIHtcbiAgICAgIHZhbHVlOiBzaWdtYS51dGlscy5pZCgpXG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuZG9tRWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSB0aGlzLmNhbWVyYS5yZWFkUHJlZml4O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBwcm9ncmFtcyBoYXNoXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub2RlUHJvZ3JhbXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VQcm9ncmFtcycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZUZsb2F0QXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlRmxvYXRBcnJheXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VJbmRpY2VzQXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHM6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJywgdHJ1ZSk7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdub2RlcycsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScsIHRydWUpO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdsYWJlbHMnKTtcbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdtb3VzZScpO1xuICAgIHRoaXMuY29udGV4dHMuaG92ZXIgPSB0aGlzLmNvbnRleHRzLm1vdXNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcbiAgICAgICAgbmV3IGZuKFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubW91c2UsXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XG4gICAgc2lnbWEubWlzYy5iaW5kRXZlbnRzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcbiAgICBzaWdtYS5taXNjLmRyYXdIb3ZlcnMuY2FsbCh0aGlzLCB0aGlzLmNhbWVyYS5wcmVmaXgpO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBnZW5lcmF0ZSB0aGUgbm9kZXMgYW5kIGVkZ2VzIGZsb2F0IGFycmF5cy4gVGhpcyBzdGVwIGlzXG4gICAqIHNlcGFyYXRlZCBmcm9tIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYmVjYXVzZSB0byBrZWVwIFdlYkdMIGVmZmljaWVudCwgc2luY2VcbiAgICogYWxsIHRoZSBjYW1lcmEgYW5kIG1pZGRsZXdhcmVzIGFyZSBtb2RlbGlzZWQgYXMgbWF0cmljZXMgYW5kIHRoZXkgZG8gbm90XG4gICAqIHJlcXVpcmUgdGhlIGZsb2F0IGFycmF5cyB0byBiZSByZWdlbmVyYXRlZC5cbiAgICpcbiAgICogQmFzaWNhbGx5LCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBjYW1lcmEgb3IgYXBwbGllcyBzb21lIHNwZWNpZmljIGxpbmVhclxuICAgKiB0cmFuc2Zvcm1hdGlvbnMsIHRoaXMgcHJvY2VzcyBzdGVwIHdpbGwgYmUgc2tpcHBlZCwgYW5kIHRoZSBcInJlbmRlclwiXG4gICAqIG1ldGhvZCB3aWxsIGVmZmljaWVudGx5IHJlZnJlc2ggdGhlIHJlbmRlcmluZy5cbiAgICpcbiAgICogQW5kIHdoZW4gdGhlIHVzZXIgbW9kaWZpZXMgdGhlIGdyYXBoIGNvbG9ycyBvciBwb3NpdGlvbnMgKGFwcGx5aW5nIGEgbmV3XG4gICAqIGxheW91dCBvciBmaWx0ZXJpbmcgdGhlIGNvbG9ycywgZm9yIGluc3RhbmNlKSwgdGhpcyBcInByb2Nlc3NcIiBzdGVwIHdpbGwgYmVcbiAgICogcmVxdWlyZWQgdG8gcmVnZW5lcmF0ZSB0aGUgZmxvYXQgYXJyYXlzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBvcHRpb25zID0gc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMsIHRoaXMub3B0aW9ucyksXG4gICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpLFxuICAgICAgICBkZWZhdWx0Tm9kZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKTtcblxuICAgIC8vIEVtcHR5IGZsb2F0IGFycmF5czpcbiAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5ub2RlRmxvYXRBcnJheXNba107XG5cbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5lZGdlRmxvYXRBcnJheXNba107XG5cbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlSW5kaWNlc0FycmF5cylcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2tdO1xuXG4gICAgLy8gU29ydCBlZGdlcyBhbmQgbm9kZXMgcGVyIHR5cGVzOlxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdEVkZ2VUeXBlO1xuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLmVkZ2VzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcblxuICAgICAgaWYgKCF0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSlcbiAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10gPSB7XG4gICAgICAgICAgZWRnZXM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmVkZ2VzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgZm9yIChhID0gZ3JhcGgubm9kZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdHlwZSA9IGFbaV0udHlwZSB8fCBkZWZhdWx0Tm9kZVR5cGU7XG4gICAgICBrID0gKHR5cGUgJiYgc2lnbWEud2ViZ2wubm9kZXNbdHlwZV0pID8gdHlwZSA6ICdkZWYnO1xuXG4gICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdKVxuICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXSA9IHtcbiAgICAgICAgICBub2RlczogW11cbiAgICAgICAgfTtcblxuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10ubm9kZXMucHVzaChhW2ldKTtcbiAgICB9XG5cbiAgICAvLyBQdXNoIGVkZ2VzOlxuICAgIGZvciAoayBpbiB0aGlzLmVkZ2VGbG9hdEFycmF5cykge1xuICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1trXTtcbiAgICAgIGEgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcztcblxuICAgICAgLy8gQ3JlYXRpbmcgdGhlIG5lY2Vzc2FyeSBhcnJheXNcbiAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICApO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBKdXN0IGNoZWNrIHRoYXQgdGhlIGVkZ2UgYW5kIGJvdGggaXRzIGV4dHJlbWl0aWVzIGFyZSB2aXNpYmxlOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWFbaV0uaGlkZGVuICYmXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0uc291cmNlKS5oaWRkZW4gJiZcbiAgICAgICAgICAhZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLmhpZGRlblxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyZXIuYWRkRWRnZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSksXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXG4gICAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlci5jb21wdXRlSW5kaWNlcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXSA9IHJlbmRlcmVyLmNvbXB1dGVJbmRpY2VzKFxuICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBub2RlczpcbiAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wubm9kZXNba107XG4gICAgICBhID0gdGhpcy5ub2RlRmxvYXRBcnJheXNba10ubm9kZXM7XG5cbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXG4gICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkpXG4gICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgKTtcblxuICAgICAgICAvLyBKdXN0IGNoZWNrIHRoYXQgdGhlIGVkZ2UgYW5kIGJvdGggaXRzIGV4dHJlbWl0aWVzIGFyZSB2aXNpYmxlOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWFbaV0uaGlkZGVuXG4gICAgICAgIClcbiAgICAgICAgICByZW5kZXJlci5hZGROb2RlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgaSAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVMsXG4gICAgICAgICAgICBvcHRpb25zLnByZWZpeCxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaC4gSXQgYmFzaWNhbGx5IGNhbGxzIGVhY2ggcHJvZ3JhbSAoYW5kXG4gICAqIGdlbmVyYXRlIHRoZW0gaWYgdGhleSBkbyBub3QgZXhpc3QgeWV0KSB0byByZW5kZXIgbm9kZXMgYW5kIGVkZ2VzLCBiYXRjaGVkXG4gICAqIHBlciByZW5kZXJlci5cbiAgICpcbiAgICogQXMgaW4gdGhlIGNhbnZhcyByZW5kZXJlciwgaXQgaXMgcG9zc2libGUgdG8gZGlzcGxheSBlZGdlcywgbm9kZXMgYW5kIC8gb3JcbiAgICogbGFiZWxzIGluIGJhdGNoZXMsIHRvIG1ha2UgdGhlIHdob2xlIHRoaW5nIHdheSBtb3JlIHNjYWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICAgICAgICAgICAgIHBhcmFtcyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9ICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBvLFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXNHbCA9IHRoaXMuY29udGV4dHMubm9kZXMsXG4gICAgICAgIGVkZ2VzR2wgPSB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICBtYXRyaXggPSB0aGlzLmNhbWVyYS5nZXRNYXRyaXgoKSxcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChwYXJhbXMsIHRoaXMub3B0aW9ucyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKTtcblxuICAgIC8vIENhbGwgdGhlIHJlc2l6ZSBmdW5jdGlvbjpcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBDbGVhciBjYW52YXNlczpcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAvLyBUcmFuc2xhdGUgbWF0cml4IHRvIFt3aWR0aC8yLCBoZWlnaHQvMl06XG4gICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICBtYXRyaXgsXG4gICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbih0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKVxuICAgICk7XG5cbiAgICAvLyBLaWxsIHJ1bm5pbmcgam9iczpcbiAgICBmb3IgKGsgaW4gdGhpcy5qb2JzKVxuICAgICAgaWYgKGNvbnJhZC5oYXNKb2IoaykpXG4gICAgICAgIGNvbnJhZC5raWxsSm9iKGspO1xuXG4gICAgaWYgKGRyYXdFZGdlcykge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYSxcbiAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIGpvYixcbiAgICAgICAgICAgICAgYXJyLFxuICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICBpbmRpY2VzLFxuICAgICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgICAgYmF0Y2hTaXplLFxuICAgICAgICAgICAgICBjdXJyZW50UHJvZ3JhbTtcblxuICAgICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xuICAgICAgICAgIGJhdGNoU2l6ZSA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsRWRnZXNCYXRjaFNpemUnKTtcbiAgICAgICAgICBhID0gT2JqZWN0LmtleXModGhpcy5lZGdlRmxvYXRBcnJheXMpO1xuXG4gICAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2FbaV1dO1xuICAgICAgICAgIGFyciA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2FbaV1dLmFycmF5O1xuICAgICAgICAgIGluZGljZXMgPSB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2FbaV1dO1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgam9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICAgICAgaWYgKCF0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSlcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGVkZ2VzR2wudXNlUHJvZ3JhbSh0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSk7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgICBlZGdlc0dsLFxuICAgICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dLFxuICAgICAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbydcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICBjb3VudDogZW5kIC0gc3RhcnQsXG4gICAgICAgICAgICAgICAgICBpbmRpY2VzRGF0YTogaW5kaWNlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2F0Y2ggam9iJ3MgZW5kOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMgJiZcbiAgICAgICAgICAgICAgaSA9PT0gYS5sZW5ndGggLSAxXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuam9ic1tpZF07XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVuZCA+PSBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFUykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGFyciA9IHRoaXMuZWRnZUZsb2F0QXJyYXlzW2FbaV1dLmFycmF5O1xuICAgICAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2FbaV1dO1xuICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgc3RhcnQgKyBiYXRjaFNpemUgKiByZW5kZXJlci5QT0lOVFMsXG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuam9ic1tpZF0gPSBqb2I7XG4gICAgICAgICAgY29ucmFkLmFkZEpvYihpZCwgam9iLmJpbmQodGhpcykpO1xuICAgICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoayBpbiB0aGlzLmVkZ2VGbG9hdEFycmF5cykge1xuICAgICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XG5cbiAgICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNba10pXG4gICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1trXSA9IHJlbmRlcmVyLmluaXRQcm9ncmFtKGVkZ2VzR2wpO1xuXG4gICAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgICAgaWYgKHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdKSB7XG4gICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNba10pO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgICBlZGdlc0dsLFxuICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1trXSxcbiAgICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSxcbiAgICAgICAgICAgICAgICBpbmRpY2VzRGF0YTogdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkcmF3Tm9kZXMpIHtcbiAgICAgIC8vIEVuYWJsZSBibGVuZGluZzpcbiAgICAgIG5vZGVzR2wuYmxlbmRGdW5jKG5vZGVzR2wuU1JDX0FMUEhBLCBub2Rlc0dsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgbm9kZXNHbC5lbmFibGUobm9kZXNHbC5CTEVORCk7XG5cbiAgICAgIGZvciAoayBpbiB0aGlzLm5vZGVGbG9hdEFycmF5cykge1xuICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xuXG4gICAgICAgIC8vIENoZWNrIHByb2dyYW06XG4gICAgICAgIGlmICghdGhpcy5ub2RlUHJvZ3JhbXNba10pXG4gICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShub2Rlc0dsKTtcblxuICAgICAgICAvLyBSZW5kZXJcbiAgICAgICAgaWYgKHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdKSB7XG4gICAgICAgICAgbm9kZXNHbC51c2VQcm9ncmFtKHRoaXMubm9kZVByb2dyYW1zW2tdKTtcbiAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICBub2Rlc0dsLFxuICAgICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba10sXG4gICAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgcmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICAgICAgICBzY2FsaW5nUmF0aW86IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhd0xhYmVscykge1xuICAgICAgYSA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXG4gICAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICAgICk7XG5cbiAgICAgIC8vIEFwcGx5IGNhbWVyYSB2aWV3IHRvIHRoZXNlIG5vZGVzOlxuICAgICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAge1xuICAgICAgICAgIG5vZGVzOiBhLFxuICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIG8gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc2V0dGluZ3Moe1xuICAgICAgICAgIHByZWZpeDogc2VsZi5jYW1lcmEucHJlZml4XG4gICAgICAgIH0sIGtleSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKFxuICAgICAgICAgICAgc2lnbWEuY2FudmFzLmxhYmVsc1tcbiAgICAgICAgICAgICAgYVtpXS50eXBlIHx8XG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHROb2RlVHlwZScpXG4gICAgICAgICAgICBdIHx8IHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmXG4gICAgICAgICAgKShhW2ldLCB0aGlzLmNvbnRleHRzLmxhYmVscywgbyk7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIHRhZyAgIFRoZSBsYWJlbCB0YWcuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBpZCAgICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBcImRvbUVsZW1lbnRzXCIpLlxuICAgKiBAcGFyYW0gIHs/Ym9vbGVhbn0gd2ViZ2wgV2lsbCBpbml0IHRoZSBXZWJHTCBjb250ZXh0IGlmIHRydWUuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcsIGlkLCB3ZWJnbCkge1xuICAgIHZhciBnbCxcbiAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lnbWEtJyArIGlkKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudHNbaWRdID0gZG9tO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICBpZiAodGFnLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICB0aGlzLmNvbnRleHRzW2lkXSA9IGRvbS5nZXRDb250ZXh0KHdlYmdsID8gJ2V4cGVyaW1lbnRhbC13ZWJnbCcgOiAnMmQnLCB7XG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZGluZyB3ZWJnbCBjb250ZXh0IGxvc3MgbGlzdGVuZXJzXG4gICAgICBpZiAod2ViZ2wpIHtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XG5cbiAgICBpZiAodyAhPT0gdW5kZWZpbmVkICYmIGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHc7XG4gICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICB3ID0gdGhpcy53aWR0aDtcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzW2tdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAvLyBJZiBzaW1wbGUgMkQgY2FudmFzOlxuICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRzW2tdICYmIHRoaXMuY29udGV4dHNba10uc2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykgKyAncHgnKTtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKVxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgKHcgKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJykpICsgJ3B4J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICAnaGVpZ2h0JyxcbiAgICAgICAgICAgICAgKGggKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJykpICsgJ3B4J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTY2FsZTpcbiAgICBmb3IgKGsgaW4gdGhpcy5jb250ZXh0cylcbiAgICAgIGlmICh0aGlzLmNvbnRleHRzW2tdICYmIHRoaXMuY29udGV4dHNba10udmlld3BvcnQpXG4gICAgICAgIHRoaXMuY29udGV4dHNba10udmlld3BvcnQoXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXG4gICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcbiAgICAgICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjbGVhcnMgZWFjaCBjYW52YXMuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dHMubGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5jb250ZXh0cy5ub2Rlcy5jbGVhcih0aGlzLmNvbnRleHRzLm5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIHRoaXMuY29udGV4dHMuZWRnZXMuY2xlYXIodGhpcy5jb250ZXh0cy5lZGdlcy5DT0xPUl9CVUZGRVJfQklUKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrLFxuICAgICAgICBjYXB0b3I7XG5cbiAgICAvLyBLaWxsIGNhcHRvcnM6XG4gICAgd2hpbGUgKChjYXB0b3IgPSB0aGlzLmNhcHRvcnMucG9wKCkpKVxuICAgICAgY2FwdG9yLmtpbGwoKTtcbiAgICBkZWxldGUgdGhpcy5jYXB0b3JzO1xuXG4gICAgLy8gS2lsbCBjb250ZXh0czpcbiAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xuICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNba10pO1xuICAgICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHNba107XG4gICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1trXTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZG9tRWxlbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuY29udGV4dHM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgXCJzaWdtYS53ZWJnbC5ub2Rlc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnQgV2ViR0wgbm9kZVxuICAgKiByZW5kZXJlcnMuIFRoZSBkZWZhdWx0IG9uZSBkcmF3IG5vZGVzIGFzIGRpc2NzLiBIZXJlIGFyZSB0aGUgYXR0cmlidXRlc1xuICAgKiBhbnkgbm9kZSByZW5kZXJlciBtdXN0IGhhdmU6XG4gICAqXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhIG5vZGUuXG4gICAqIHtudW1iZXJ9ICAgQVRUUklCVVRFUyAgVGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIG5lZWRlZCB0byBkcmF3IG9uZSBwb2ludC5cbiAgICoge2Z1bmN0aW9ufSBhZGROb2RlICAgICBBIGZ1bmN0aW9uIHRoYXQgYWRkcyBhIG5vZGUgdG8gdGhlIGRhdGEgc3RhY2sgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGJ1ZmZlci4gSGVyZSBpcyB0aGUgYXJndW1lbnRzOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgbm9kZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge251bWJlcn0gICAgICAgaW5kZXggICBUaGUgbm9kZSBpbmRleCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgYXJyYXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjay5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG9wdGlvbnMgU29tZSBvcHRpb25zLlxuICAgKiB7ZnVuY3Rpb259IHJlbmRlciAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZWZmZWN0aXZlbHkgcmVuZGVyIHRoZSBub2Rlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICBwcm9ncmFtXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjayB0byBnaXZlIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBwYXJhbXMgIEFuIG9iamVjdCBjb250YWluaW5nIHNvbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgbGlrZSB3aWR0aCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LCB0aGUgY2FtZXJhIHJhdGlvLlxuICAgKiB7ZnVuY3Rpb259IGluaXRQcm9ncmFtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgaW5pdGlhdGUgdGhlIHByb2dyYW0sIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVsZXZhbnQgc2hhZGVycyBhbmQgcGFyYW1ldGVycy4gSXQgbXVzdCByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3bHkgY3JlYXRlZCBwcm9ncmFtLlxuICAgKlxuICAgKiBDaGVjayBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgb3Igc2lnbWEud2ViZ2wubm9kZXMuZmFzdCB0byBzZWUgaG93IGl0XG4gICAqIHdvcmtzIG1vcmUgcHJlY2lzZWx5LlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5ub2RlcycpO1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wuZWRnZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIGVkZ2VcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBlZGdlcyBhcyBkaXJlY3QgbGluZXMuIEhlcmUgYXJlIHRoZVxuICAgKiBhdHRyaWJ1dGVzIGFueSBlZGdlIHJlbmRlcmVyIG11c3QgaGF2ZTpcbiAgICpcbiAgICoge251bWJlcn0gICBQT0lOVFMgICAgICBUaGUgbnVtYmVyIG9mIHBvaW50cyByZXF1aXJlZCB0byBkcmF3IGFuIGVkZ2UuXG4gICAqIHtudW1iZXJ9ICAgQVRUUklCVVRFUyAgVGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIG5lZWRlZCB0byBkcmF3IG9uZSBwb2ludC5cbiAgICoge2Z1bmN0aW9ufSBhZGRFZGdlICAgICBBIGZ1bmN0aW9uIHRoYXQgYWRkcyBhbiBlZGdlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIGVkZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHNvdXJjZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgdGFyZ2V0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjay5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG9wdGlvbnMgU29tZSBvcHRpb25zLlxuICAgKiB7ZnVuY3Rpb259IHJlbmRlciAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZWZmZWN0aXZlbHkgcmVuZGVyIHRoZSBlZGdlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGJ1ZmZlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICBwcm9ncmFtXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjayB0byBnaXZlIHRvIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBwYXJhbXMgIEFuIG9iamVjdCBjb250YWluaW5nIHNvbWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgbGlrZSB3aWR0aCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LCB0aGUgY2FtZXJhIHJhdGlvLlxuICAgKiB7ZnVuY3Rpb259IGluaXRQcm9ncmFtIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgaW5pdGlhdGUgdGhlIHByb2dyYW0sIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVsZXZhbnQgc2hhZGVycyBhbmQgcGFyYW1ldGVycy4gSXQgbXVzdCByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3bHkgY3JlYXRlZCBwcm9ncmFtLlxuICAgKlxuICAgKiBDaGVjayBzaWdtYS53ZWJnbC5lZGdlcy5kZWYgb3Igc2lnbWEud2ViZ2wuZWRnZXMuZmFzdCB0byBzZWUgaG93IGl0XG4gICAqIHdvcmtzIG1vcmUgcHJlY2lzZWx5LlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEuY2FudmFzLmxhYmVsc1wiIGNvbnRhaW5zIHRoZSBkaWZmZXJlbnRcbiAgICogbGFiZWwgcmVuZGVyZXJzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXIuIFNpbmNlIGRpc3BsYXlpbmcgdGV4dHMgaW4gV2ViR0wgaXNcbiAgICogZGVmaW5pdGVseSBwYWluZnVsIGFuZCBzaW5jZSB0aGVyZSBhIHdheSBsZXNzIGxhYmVscyB0byBkaXNwbGF5IHRoYW4gbm9kZXNcbiAgICogb3IgZWRnZXMsIHRoZSBkZWZhdWx0IHJlbmRlcmVyIHNpbXBseSByZW5kZXJzIHRoZW0gaW4gYSBjYW52YXMuXG4gICAqXG4gICAqIEEgbGFiZWxzIHJlbmRlcmVyIGlzIGEgc2ltcGxlIGZ1bmN0aW9uLCB0YWtpbmcgYXMgYXJndW1lbnRzIHRoZSByZWxhdGVkXG4gICAqIG5vZGUsIHRoZSByZW5kZXJlciBhbmQgYSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIGlmICh0eXBlb2YgY29ucmFkID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIHN2ZyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLnN2ZzogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge1xuICAgICAgZ3JhcGg6IG51bGwsXG4gICAgICBncm91cHM6IHt9LFxuICAgICAgbm9kZXM6IHt9LFxuICAgICAgZWRnZXM6IHt9LFxuICAgICAgbGFiZWxzOiB7fSxcbiAgICAgIGhvdmVyczoge31cbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZW1lbnRDYW52YXMgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBJcyB0aGUgcmVuZGVyZXIgbWVhbnQgdG8gYmUgZnJlZXN0eWxlP1xuICAgIHRoaXMuc2V0dGluZ3MoJ2ZyZWVTdHlsZScsICEhdGhpcy5vcHRpb25zLmZyZWVTdHlsZSk7XG5cbiAgICAvLyBTVkcgeG1sbnNcbiAgICB0aGlzLnNldHRpbmdzKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuXG4gICAgLy8gSW5kZXhlczpcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gJ3JlbmRlcmVyJyArIHNpZ21hLnV0aWxzLmlkKCkgKyAnOic7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHNcbiAgICB0aGlzLmluaXRET00oJ3N2ZycpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcbiAgICAgICAgbmV3IGZuKFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgsXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJpbmQgcmVzaXplOlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYucmVzaXplKCk7XG4gICAgfSk7XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIC8vIFRPRE86IGtlZXAgYW4gb3B0aW9uIHRvIG92ZXJyaWRlIHRoZSBET00gZXZlbnRzP1xuICAgIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgpO1xuICAgIHRoaXMuYmluZEhvdmVycyh0aGlzLm9wdGlvbnMucHJlZml4KTtcblxuICAgIC8vIFJlc2l6ZVxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGggb24gdGhlIHN2ZyBzY2VuZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBhLFxuICAgICAgICBpLFxuICAgICAgICBrLFxuICAgICAgICBlLFxuICAgICAgICBsLFxuICAgICAgICBvLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVkZ2VzLFxuICAgICAgICByZW5kZXJlcnMsXG4gICAgICAgIHN1YnJlbmRlcmVycyxcbiAgICAgICAgaW5kZXggPSB7fSxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMsXG4gICAgICAgIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXggfHwgJycsXG4gICAgICAgIGRyYXdFZGdlcyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdFZGdlcycpLFxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKSxcbiAgICAgICAgZHJhd0xhYmVscyA9IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RyYXdMYWJlbHMnKSxcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgZm9yY2VMYWJlbHM6IHRoaXMub3B0aW9ucy5mb3JjZUxhYmVsc1xuICAgICAgICB9KTtcblxuICAgIC8vIENoZWNrIHRoZSAnaGlkZUVkZ2VzT25Nb3ZlJyBzZXR0aW5nOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdoaWRlRWRnZXNPbk1vdmUnKSlcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxuICAgICAgICBkcmF3RWRnZXMgPSBmYWxzZTtcblxuICAgIC8vIEFwcGx5IHRoZSBjYW1lcmEncyB2aWV3OlxuICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRoaXMub3B0aW9ucy5wcmVmaXgsXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIEhpZGluZyBldmVyeXRoaW5nXG4gICAgLy8gVE9ETzogZmluZCBhIG1vcmUgc2Vuc2libGUgd2F5IHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb25cbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLm5vZGVzKTtcbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzKTtcbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLmxhYmVscyk7XG5cbiAgICAvLyBGaW5kIHdoaWNoIG5vZGVzIGFyZSBvbiBzY3JlZW5cbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICk7XG5cbiAgICAvLyBOb2RlIGluZGV4XG4gICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xuXG4gICAgLy8gRmluZCB3aGljaCBlZGdlcyBhcmUgb24gc2NyZWVuXG4gICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbyA9IGFbaV07XG4gICAgICBpZiAoXG4gICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxuICAgICAgICAoIW8uaGlkZGVuICYmICFub2RlcyhvLnNvdXJjZSkuaGlkZGVuICYmICFub2RlcyhvLnRhcmdldCkuaGlkZGVuKVxuICAgICAgKVxuICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IG5vZGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcubm9kZXM7XG4gICAgc3VicmVuZGVyZXJzID0gc2lnbWEuc3ZnLmxhYmVscztcblxuICAgIC8vLS0gRmlyc3Qgd2UgY3JlYXRlIHRoZSBub2RlcyB3aGljaCBhcmUgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgIGlmIChkcmF3Tm9kZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbiAmJiAhdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSkge1xuXG4gICAgICAgICAgLy8gTm9kZVxuICAgICAgICAgIGUgPSAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSA9IGU7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoZSk7XG5cbiAgICAgICAgICAvLyBMYWJlbFxuICAgICAgICAgIGUgPSAoc3VicmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgc3VicmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5sYWJlbHNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmxhYmVscy5hcHBlbmRDaGlsZChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBub2Rlc1xuICAgIGlmIChkcmF3Tm9kZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICBpZiAoYVtpXS5oaWRkZW4pXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gTm9kZVxuICAgICAgICAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikudXBkYXRlKFxuICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gTGFiZWxcbiAgICAgICAgKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgIC8vIERpc3BsYXkgZWRnZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5lZGdlcztcblxuICAgIC8vLS0gRmlyc3Qgd2UgY3JlYXRlIHRoZSBlZGdlcyB3aGljaCBhcmUgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgIGlmIChkcmF3RWRnZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzW2FbaV0uaWRdKSB7XG4gICAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IG5vZGVzKGFbaV0udGFyZ2V0KTtcblxuICAgICAgICAgIGUgPSAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSA9IGU7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMuZWRnZXMuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgICB9XG5cbiAgICAvLy0tIFNlY29uZCB3ZSB1cGRhdGUgdGhlIGVkZ2VzXG4gICAgaWYgKGRyYXdFZGdlcylcbiAgICAgIGZvciAoYSA9IHRoaXMuZWRnZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzb3VyY2UgPSBub2RlcyhhW2ldLnNvdXJjZSk7XG4gICAgICAgIHRhcmdldCA9IG5vZGVzKGFbaV0udGFyZ2V0KTtcblxuICAgICAgICAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikudXBkYXRlKFxuICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgKTtcbiAgICAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnKSB7XG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnNldHRpbmdzKCd4bWxucycpLCB0YWcpLFxuICAgICAgICBjID0gdGhpcy5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSxcbiAgICAgICAgZyxcbiAgICAgICAgbCxcbiAgICAgICAgaTtcblxuICAgIGRvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjICsgJy1zdmcnKTtcblxuICAgIC8vIFNldHRpbmcgU1ZHIG5hbWVzcGFjZVxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgdGhpcy5zZXR0aW5ncygneG1sbnMnKSk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCAnMS4xJyk7XG5cbiAgICAvLyBDcmVhdGluZyB0aGUgbWVhc3VyZW1lbnQgY2FudmFzXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctbWVhc3VyZW1lbnQtY2FudmFzJyk7XG5cbiAgICAvLyBBcHBlbmRpbmcgZWxlbWVudHNcbiAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoID0gdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTtcblxuICAgIC8vIENyZWF0aW5nIGdyb3Vwc1xuICAgIHZhciBncm91cHMgPSBbJ2VkZ2VzJywgJ25vZGVzJywgJ2xhYmVscycsICdob3ZlcnMnXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnNldHRpbmdzKCd4bWxucycpLCAnZycpO1xuXG4gICAgICBnLnNldEF0dHJpYnV0ZU5TKG51bGwsICdpZCcsIGMgKyAnLWdyb3VwLScgKyBncm91cHNbaV0pO1xuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBjICsgJy1ncm91cCcpO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwc1tncm91cHNbaV1dID1cbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5hcHBlbmRDaGlsZChnKTtcbiAgICB9XG5cbiAgICAvLyBBcHBlbmRpbmcgbWVhc3VyZW1lbnQgY2FudmFzXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FudmFzID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGhpZGVzIGEgYmF0Y2ggb2YgU1ZHIERPTSBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICAgICAgICAgICAgICAgICAgZWxlbWVudHMgIEFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIGhpZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgIHJlbmRlcmVyICBUaGUgcmVuZGVyZXIgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaGlkZURPTUVsZW1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgbyxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSBpbiBlbGVtZW50cykge1xuICAgICAgbyA9IGVsZW1lbnRzW2ldO1xuICAgICAgc2lnbWEuc3ZnLnV0aWxzLmhpZGUobyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGJpbmRzIHRoZSBob3ZlciBldmVudHMgdG8gdGhlIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHByZWZpeCBUaGUgcmVuZGVyZXIgcHJlZml4LlxuICAgKi9cbiAgLy8gVE9ETzogYWRkIG9wdGlvbiBhYm91dCB3aGV0aGVyIHRvIGRpc3BsYXkgaG92ZXJzIG9yIG5vdFxuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5iaW5kSG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5ob3ZlcnMsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBob3ZlcmVkTm9kZTtcblxuICAgIGZ1bmN0aW9uIG92ZXJOb2RlKGUpIHtcbiAgICAgIHZhciBub2RlID0gZS5kYXRhLm5vZGUsXG4gICAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIGlmICghZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW25vZGUudHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICBub2RlLFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLm5vZGVzW25vZGUuaWRdLFxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxuICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICApO1xuXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXSA9IGhvdmVyO1xuXG4gICAgICAvLyBJbnNlcnRpbmcgdGhlIGhvdmVyIGluIHRoZSBkb21cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5hcHBlbmRDaGlsZChob3Zlcik7XG4gICAgICBob3ZlcmVkTm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3V0Tm9kZShlKSB7XG4gICAgICB2YXIgbm9kZSA9IGUuZGF0YS5ub2RlLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgLy8gRGVsZXRpbmcgZWxlbWVudFxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXVxuICAgICAgKTtcbiAgICAgIGhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tub2RlLmlkXTtcblxuICAgICAgLy8gUmVpbnN0YXRlXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ub2Rlcy5hcHBlbmRDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBPUFRJTUlaRTogcGVyZm9ybSBhIHJlYWwgdXBkYXRlIHJhdGhlciB0aGFuIGEgZGVsZXRpb25cbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBpZiAoIWhvdmVyZWROb2RlKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gRGVsZXRpbmcgZWxlbWVudCBiZWZvcmUgdXBkYXRlXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMucmVtb3ZlQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXVxuICAgICAgKTtcbiAgICAgIGRlbGV0ZSBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF07XG5cbiAgICAgIHZhciBob3ZlciA9IChyZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxuICAgICAgICBob3ZlcmVkTm9kZSxcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tob3ZlcmVkTm9kZS5pZF0sXG4gICAgICAgIHNlbGYubWVhc3VyZW1lbnRDYW52YXMsXG4gICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICk7XG5cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXSA9IGhvdmVyO1xuXG4gICAgICAvLyBJbnNlcnRpbmcgdGhlIGhvdmVyIGluIHRoZSBkb21cbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5hcHBlbmRDaGlsZChob3Zlcik7XG4gICAgfVxuXG4gICAgLy8gQmluZGluZyBldmVudHNcbiAgICB0aGlzLmJpbmQoJ292ZXJOb2RlJywgb3Zlck5vZGUpO1xuICAgIHRoaXMuYmluZCgnb3V0Tm9kZScsIG91dE5vZGUpO1xuXG4gICAgLy8gVXBkYXRlIG9uIHJlbmRlclxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgdXBkYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xuICAgKiBkaW1lbnNpb25zLiBUaGVuLCBpdCByZW5kZXJzIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW8gPSAxO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG5cbiAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vc3ZnXCIgZm9sZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvLyBDaGVjayBpZiBXZWJHTCBpcyBlbmFibGVkOlxuICB2YXIgY2FudmFzLFxuICAgICAgd2ViZ2wgPSAhIWdsb2JhbC5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gIGlmICh3ZWJnbCkge1xuICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRyeSB7XG4gICAgICB3ZWJnbCA9ICEhKFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fFxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJylcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2ViZ2wgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBDb3B5IHRoZSBnb29kIHJlbmRlcmVyOlxuICBzaWdtYS5yZW5kZXJlcnMuZGVmID0gd2ViZ2wgP1xuICAgIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA6XG4gICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcztcbn0pKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG5vZGUgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IG5vZGVzIGFzIGRpc2NzLCBzaGFwZWQgaW4gdHJpYW5nbGVzIHdpdGhcbiAgICogdGhlIGdsLlRSSUFOR0xFUyBkaXNwbGF5IG1vZGUuIFNvLCB0byBiZSBtb3JlIHByZWNpc2UsIHRvIGRyYXcgb25lIG5vZGUsXG4gICAqIGl0IHdpbGwgc3RvcmUgdGhyZWUgdGltZXMgdGhlIGNlbnRlciBvZiBub2RlLCB3aXRoIHRoZSBjb2xvciBhbmQgdGhlIHNpemUsXG4gICAqIGFuZCBhbiBhbmdsZSBpbmRpY2F0aW5nIHdoaWNoIFwiY29ybmVyXCIgb2YgdGhlIHRyaWFuZ2xlIHRvIGRyYXcuXG4gICAqXG4gICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZG9lcyBub3QgZGVhbCB3aXRoIGFudGktYWxpYXNpbmcsIHNvIG1ha2Ugc3VyZSB0aGF0XG4gICAqIHlvdSBkZWFsIHdpdGggaXQgc29tZXdoZXJlIGVsc2UgaW4gdGhlIGNvZGUgKGJ5IGRlZmF1bHQsIHRoZSBXZWJHTFxuICAgKiByZW5kZXJlciB3aWxsIG92ZXJzYW1wbGUgdGhlIHJlbmRlcmluZyB0aHJvdWdoIHRoZSB3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvXG4gICAqIHZhbHVlKS5cbiAgICovXG4gIHNpZ21hLndlYmdsLm5vZGVzLmRlZiA9IHtcbiAgICBQT0lOVFM6IDMsXG4gICAgQVRUUklCVVRFUzogNSxcbiAgICBhZGROb2RlOiBmdW5jdGlvbihub2RlLCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKFxuICAgICAgICBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJylcbiAgICAgICk7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gMDtcblxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgICBkYXRhW2krK10gPSAyICogTWF0aC5QSSAvIDM7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gNCAqIE1hdGguUEkgLyAzO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyksXG4gICAgICAgICAgc2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3NpemUnKSxcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgYW5nbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9hbmdsZScpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGFuZ2xlTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIHNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTJcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBhbmdsZUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcbiAgICAgICAgICAndmFyeWluZyB2ZWMyIGNlbnRlcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHJhZGl1czsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XG4gICAgICAgICAgICAncmFkaXVzID0gYV9zaXplICogdV9yYXRpbzsnLFxuXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eTsnLFxuICAgICAgICAgICAgLy8gJ2NlbnRlciA9IChwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKTsnLFxuICAgICAgICAgICAgJ2NlbnRlciA9IHBvc2l0aW9uICogdV9zY2FsZTsnLFxuICAgICAgICAgICAgJ2NlbnRlciA9IHZlYzIoY2VudGVyLngsIHVfc2NhbGUgKiB1X3Jlc29sdXRpb24ueSAtIGNlbnRlci55KTsnLFxuXG4gICAgICAgICAgICAncG9zaXRpb24gPSBwb3NpdGlvbiArJyxcbiAgICAgICAgICAgICAgJzIuMCAqIHJhZGl1cyAqIHZlYzIoY29zKGFfYW5nbGUpLCBzaW4oYV9hbmdsZSkpOycsXG4gICAgICAgICAgICAncG9zaXRpb24gPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcblxuICAgICAgICAgICAgJ3JhZGl1cyA9IHJhZGl1cyAqIHVfc2NhbGU7JyxcblxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMCwgMSk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAndmVjNCBjb2xvcjAgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7JyxcblxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX0ZyYWdDb29yZC54eSAtIGNlbnRlcjsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGRpZmYgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcblxuICAgICAgICAgICAgLy8gSGVyZSBpcyBob3cgd2UgZHJhdyBhIGRpc2MgaW5zdGVhZCBvZiBhIHNxdWFyZTpcbiAgICAgICAgICAgICdpZiAoZGlmZiA+IDAuMCknLFxuICAgICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAgICdlbHNlJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBpbiB0aGUgZmFzdGVzdCB3YXk6IE5vZGVzIGFyZSBiYXNpY1xuICAgKiBzcXVhcmVzLCBkcmF3biB0aHJvdWdoIHRoZSBnbC5QT0lOVFMgZHJhd2luZyBtZXRob2QuIFRoZSBzaXplIG9mIHRoZSBub2Rlc1xuICAgKiBhcmUgcmVwcmVzZW50ZWQgd2l0aCB0aGUgXCJnbF9Qb2ludFNpemVcIiB2YWx1ZSBpbiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICpcbiAgICogSXQgaXMgdGhlIGZhc3Rlc3Qgbm9kZSByZW5kZXJlciBoZXJlIHNpbmNlIHRoZSBidWZmZXIganVzdCB0YWtlcyBvbmUgbGluZVxuICAgKiB0byBkcmF3IGVhY2ggbm9kZSAod2l0aCBhdHRyaWJ1dGVzIFwieFwiLCBcInlcIiwgXCJzaXplXCIgYW5kIFwiY29sb3JcIikuXG4gICAqXG4gICAqIE5ldmVydGhlbGVzcywgdGhpcyBtZXRob2QgaGFzIHNvbWUgcHJvYmxlbXMsIGVzcGVjaWFsbHkgZHVlIHRvIHNvbWUgaXNzdWVzXG4gICAqIHdpdGggdGhlIGdsLlBPSU5UUzpcbiAgICogIC0gRmlyc3QsIGlmIHRoZSBjZW50ZXIgb2YgYSBub2RlIGlzIG91dHNpZGUgdGhlIHNjZW5lLCB0aGUgcG9pbnQgd2lsbCBub3RcbiAgICogICAgYmUgZHJhd24sIGV2ZW4gaWYgaXQgc2hvdWxkIGJlIHBhcnRseSBvbiBzY3JlZW4uXG4gICAqICAtIEkgdHJpZWQgYXBwbHlpbmcgYSBmcmFnbWVudCBzaGFkZXIgc2ltaWxhciB0byB0aGUgb25lIGluIHRoZSBkZWZhdWx0XG4gICAqICAgIG5vZGUgcmVuZGVyZXIgdG8gZGlzcGxheSB0aGVtIGFzIGRpc2NzLCBidXQgaXQgZGlkIG5vdCB3b3JrIGZpbmUgb25cbiAgICogICAgc29tZSBjb21wdXRlcnMgc2V0dGluZ3MsIGZpbGxpbmcgdGhlIGRpc2NzIHdpdGggd2VpcmQgZ3JhZGllbnRzIG5vdFxuICAgKiAgICBkZXBlbmRpbmcgb24gdGhlIGFjdHVhbCBjb2xvci5cbiAgICovXG4gIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgPSB7XG4gICAgUE9JTlRTOiAxLFxuICAgIEFUVFJJQlVURVM6IDQsXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneSddO1xuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgZGF0YVtpKytdID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXG4gICAgICApO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyksXG4gICAgICAgICAgc2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3NpemUnKSxcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICAxIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG5cbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXG4gICAgICAgIHNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTJcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlBPSU5UUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSB0aGUgcG9pbnQgc2l6ZSB0d2ljZTpcbiAgICAgICAgICAgIC8vICAtIHggU0NBTElOR19SQVRJTyB0byBjb3JyZWN0IHRoZSBjYW52YXMgc2NhbGluZ1xuICAgICAgICAgICAgLy8gIC0geCAyIHRvIGNvcnJlY3QgdGhlIGZvcm11bGFlXG4gICAgICAgICAgICAnZ2xfUG9pbnRTaXplID0gYV9zaXplICogdV9yYXRpbyAqIHVfc2NhbGUgKiAyLjA7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGJvcmRlciA9IDAuMDE7JyxcbiAgICAgICAgICAgICdmbG9hdCByYWRpdXMgPSAwLjU7JyxcblxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXG4gICAgICAgICAgICAndmVjMiBtID0gZ2xfUG9pbnRDb29yZCAtIHZlYzIoMC41LCAwLjUpOycsXG4gICAgICAgICAgICAnZmxvYXQgZGlzdCA9IHJhZGl1cyAtIHNxcnQobS54ICogbS54ICsgbS55ICogbS55KTsnLFxuXG4gICAgICAgICAgICAnZmxvYXQgdCA9IDAuMDsnLFxuICAgICAgICAgICAgJ2lmIChkaXN0ID4gYm9yZGVyKScsXG4gICAgICAgICAgICAgICd0ID0gMS4wOycsXG4gICAgICAgICAgICAnZWxzZSBpZiAoZGlzdCA+IDAuMCknLFxuICAgICAgICAgICAgICAndCA9IGRpc3QgLyBib3JkZXI7JyxcblxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IG1peChjb2xvcjAsIGNvbG9yLCB0KTsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5GUkFHTUVOVF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIHByb2dyYW0gPSBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbShnbCwgW3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJdKTtcblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBsaW5lcyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcbiAgICogdHdvIHRyaWFuZ2xlcyBmb3JtaW5nIHJlY3RhbmdsZXMsIHdpdGggdGhlIGdsLlRSSUFOR0xFUyBkcmF3aW5nIG1vZGUuXG4gICAqXG4gICAqIEl0IGlzIGV4cGVuc2l2ZSwgc2luY2UgZHJhd2luZyBhIHNpbmdsZSBlZGdlIHJlcXVpcmVzIDYgcG9pbnRzLCBlYWNoXG4gICAqIGhhdmluZyA3IGF0dHJpYnV0ZXMgKHNvdXJjZSBwb3NpdGlvbiwgdGFyZ2V0IHBvc2l0aW9uLCB0aGlja25lc3MsIGNvbG9yXG4gICAqIGFuZCBhIGZsYWcgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlIG9mIHRoZSByZWN0YW5nbGUgaXQgaXMpLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wuZWRnZXMuZGVmID0ge1xuICAgIFBPSU5UUzogNixcbiAgICBBVFRSSUJVVEVTOiA3LFxuICAgIGFkZEVkZ2U6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTEgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgY29sb3IgPSBlZGdlLmNvbG9yO1xuXG4gICAgICBpZiAoIWNvbG9yKVxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzKCdlZGdlQ29sb3InKSkge1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIGNvbG9yOlxuICAgICAgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKGNvbG9yKTtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24xID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uMScpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24yID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uMicpLFxuICAgICAgICAgIHRoaWNrbmVzc0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RoaWNrbmVzcycpLFxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgcGFyYW1zLnJhdGlvIC8gTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKE1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXG4gICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbigtTWF0aC5QSSAvIDIsIHRydWUpXG4gICAgICApO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24xKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24yKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaWNrbmVzc0xvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG1pbnVzTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24xLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjIsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlja25lc3NMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihtaW51c0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyNFxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjE7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjI7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdGhpY2tuZXNzOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX21pbnVzOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfcmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XG4gICAgICAgICAgICAndmVjMiBwb3NpdGlvbiA9IGFfdGhpY2tuZXNzICogdV9yYXRpbyAqJyxcbiAgICAgICAgICAgICAgJ25vcm1hbGl6ZShhX3Bvc2l0aW9uMiAtIGFfcG9zaXRpb24xKTsnLFxuXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSBhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcbiAgICAgICAgICAgICAgJygxLjAgLSBhX21pbnVzKSAqIHVfbWF0cml4SGFsZlBpOycsXG5cbiAgICAgICAgICAgICdwb3NpdGlvbiA9IG1hdHJpeCAqIHBvc2l0aW9uICsgYV9wb3NpdGlvbjE7JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgd2l0aCB0aGUgZ2wuTElORVMgZGlzcGxheVxuICAgKiBtb2RlLiBTaW5jZSB0aGlzIG1vZGUgZG9lcyBub3Qgc3VwcG9ydCB3ZWxsIHRoaWNrbmVzcywgZWRnZXMgYXJlIGFsbCBkcmF3blxuICAgKiB3aXRoIHRoZSBzYW1lIHRoaWNrbmVzcyAoM3B4KSwgaW5kZXBlbmRhbnRseSBvZiB0aGUgZWRnZSBhdHRyaWJ1dGVzIG9yIHRoZVxuICAgKiB6b29taW5nIHJhdGlvLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wuZWRnZXMuZmFzdCA9IHtcbiAgICBQT0lOVFM6IDIsXG4gICAgQVRUUklCVVRFUzogMyxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XG4gICAgICB2YXIgYnVmZmVyO1xuXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcbiAgICAgIHZhciBjb2xvckxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5EWU5BTUlDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNvbG9yTG9jYXRpb24pO1xuXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcblxuICAgICAgZ2wubGluZVdpZHRoKDMpO1xuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuTElORVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXG5cbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqIHRvIHRoZSB0YXJnZXQgbm9kZS4gVG8gZGVhbCB3aXRoIGVkZ2UgdGhpY2tuZXNzZXMsIHRoZSBsaW5lcyBhcmUgbWFkZSBvZlxuICAgKiB0aHJlZSB0cmlhbmdsZXM6IHR3byBmb3JtaW5nIHJlY3RhbmdsZXMsIHdpdGggdGhlIGdsLlRSSUFOR0xFUyBkcmF3aW5nXG4gICAqIG1vZGUuXG4gICAqXG4gICAqIEl0IGlzIGV4cGVuc2l2ZSwgc2luY2UgZHJhd2luZyBhIHNpbmdsZSBlZGdlIHJlcXVpcmVzIDkgcG9pbnRzLCBlYWNoXG4gICAqIGhhdmluZyBhIGxvdCBvZiBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgc2lnbWEud2ViZ2wuZWRnZXMuYXJyb3cgPSB7XG4gICAgUE9JTlRTOiA5LFxuICAgIEFUVFJJQlVURVM6IDExLFxuICAgIGFkZEVkZ2U6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgdyA9IChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSkgLyAyLFxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTEgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB4MiA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgdGFyZ2V0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIC8vIEFycm93IGhlYWQ6XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gLTEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbjEgPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zMScpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24yID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczInKSxcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcbiAgICAgICAgICB0YXJnZXRTaXplTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdFNpemUnKSxcbiAgICAgICAgICBkZWxheUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2RlbGF5JyksXG4gICAgICAgICAgbWludXNMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9taW51cycpLFxuICAgICAgICAgIGhlYWRMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9oZWFkJyksXG4gICAgICAgICAgaGVhZFBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZFBvc2l0aW9uJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpJyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpTWludXMnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIG5vZGVSYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9ub2RlUmF0aW8nKSxcbiAgICAgICAgICBhcnJvd0hlYWRMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfYXJyb3dIZWFkJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbixcbiAgICAgICAgTWF0aC5wb3cocGFyYW1zLnJhdGlvLCBwYXJhbXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSkgL1xuICAgICAgICBwYXJhbXMucmF0aW9cbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtMWYoYXJyb3dIZWFkTG9jYXRpb24sIDUuMCk7XG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbixcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKE1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXG4gICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbigtTWF0aC5QSSAvIDIsIHRydWUpXG4gICAgICApO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0YXJnZXRTaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoZGVsYXlMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGhlYWRMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShoZWFkUG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGFyZ2V0U2l6ZUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbGF5TG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyNFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDI4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihoZWFkTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAzMlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZFBvc2l0aW9uTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAzNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDQwXG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3BvczE7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MyOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90U2l6ZTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9kZWxheTsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2hlYWRQb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9ub2RlUmF0aW87JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X2Fycm93SGVhZDsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGlNaW51czsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAgICAgLy8gRmluZCB0aGUgZ29vZCBwb2ludDpcbiAgICAgICAgICAgICd2ZWMyIHBvcyA9IG5vcm1hbGl6ZShhX3BvczIgLSBhX3BvczEpOycsXG5cbiAgICAgICAgICAgICdtYXQyIG1hdHJpeCA9ICgxLjAgLSBhX2hlYWQpIConLFxuICAgICAgICAgICAgICAnKCcsXG4gICAgICAgICAgICAgICAgJ2FfbWludXMgKiB1X21hdHJpeEhhbGZQaU1pbnVzICsnLFxuICAgICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaScsXG4gICAgICAgICAgICAgICcpICsgYV9oZWFkICogKCcsXG4gICAgICAgICAgICAgICAgJ2FfaGVhZFBvc2l0aW9uICogdV9tYXRyaXhIYWxmUGlNaW51cyAqIDAuNiArJyxcbiAgICAgICAgICAgICAgICAnKGFfaGVhZFBvc2l0aW9uICogYV9oZWFkUG9zaXRpb24gLSAxLjApICogbWF0MigxLjApJyxcbiAgICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgJ3BvcyA9IGFfcG9zMSArICgnLFxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggYm9keTpcbiAgICAgICAgICAgICAgJygxLjAgLSBhX2hlYWQpICogYV90aGlja25lc3MgKiB1X3JhdGlvICogbWF0cml4ICogcG9zICsnLFxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggaGVhZDpcbiAgICAgICAgICAgICAgJ2FfaGVhZCAqIHVfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvICogbWF0cml4ICogcG9zICsnLFxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggZGVsYXk6XG4gICAgICAgICAgICAgICdhX2RlbGF5ICogcG9zICogKCcsXG4gICAgICAgICAgICAgICAgJ2FfdFNpemUgLyB1X25vZGVSYXRpbyArJyxcbiAgICAgICAgICAgICAgICAndV9hcnJvd0hlYWQgKiBhX3RoaWNrbmVzcyAqIHVfcmF0aW8nLFxuICAgICAgICAgICAgICAnKScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMocG9zLCAxKSkueHkgLycsXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxuICAgICAgICAgICAgICAnMCwnLFxuICAgICAgICAgICAgICAnMScsXG4gICAgICAgICAgICAnKTsnLFxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcbiAgICAgICk7XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcblxuICAvKipcbiAgICogVGhpcyBsYWJlbCByZW5kZXJlciB3aWxsIGp1c3QgZGlzcGxheSB0aGUgbGFiZWwgb24gdGhlIHJpZ2h0IG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmxhYmVscy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBmb250U2l6ZSxcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgaWYgKHNpemUgPCBzZXR0aW5ncygnbGFiZWxUaHJlc2hvbGQnKSlcbiAgICAgIHJldHVybjtcblxuICAgIGlmICghbm9kZS5sYWJlbCB8fCB0eXBlb2Ygbm9kZS5sYWJlbCAhPT0gJ3N0cmluZycpXG4gICAgICByZXR1cm47XG5cbiAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgY29udGV4dC5mb250ID0gKHNldHRpbmdzKCdmb250U3R5bGUnKSA/IHNldHRpbmdzKCdmb250U3R5bGUnKSArICcgJyA6ICcnKSArXG4gICAgICBmb250U2l6ZSArICdweCAnICsgc2V0dGluZ3MoJ2ZvbnQnKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IChzZXR0aW5ncygnbGFiZWxDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxDb2xvcicpO1xuXG4gICAgY29udGV4dC5maWxsVGV4dChcbiAgICAgIG5vZGUubGFiZWwsXG4gICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSxcbiAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKVxuICAgICk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBiYXNpY2FsbHkgZGlzcGxheSB0aGUgbGFiZWwgd2l0aCBhIGJhY2tncm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIHgsXG4gICAgICAgIHksXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIGUsXG4gICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAvLyBMYWJlbCBiYWNrZ3JvdW5kOlxuICAgIGNvbnRleHQuZm9udCA9IChmb250U3R5bGUgPyBmb250U3R5bGUgKyAnICcgOiAnJykgK1xuICAgICAgZm9udFNpemUgKyAncHggJyArIChzZXR0aW5ncygnaG92ZXJGb250JykgfHwgc2V0dGluZ3MoJ2ZvbnQnKSk7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MoJ2xhYmVsSG92ZXJCR0NvbG9yJykgPT09ICdub2RlJyA/XG4gICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdEhvdmVyTGFiZWxCR0NvbG9yJyk7XG5cbiAgICBpZiAobm9kZS5sYWJlbCAmJiBzZXR0aW5ncygnbGFiZWxIb3ZlclNoYWRvdycpKSB7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDg7XG4gICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gc2V0dGluZ3MoJ2xhYmVsSG92ZXJTaGFkb3dDb2xvcicpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICB5ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcbiAgICAgIHcgPSBNYXRoLnJvdW5kKFxuICAgICAgICBjb250ZXh0Lm1lYXN1cmVUZXh0KG5vZGUubGFiZWwpLndpZHRoICsgZm9udFNpemUgLyAyICsgc2l6ZSArIDdcbiAgICAgICk7XG4gICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xuICAgICAgZSA9IE1hdGgucm91bmQoZm9udFNpemUgLyAyICsgMik7XG5cbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkgKyBlKTtcbiAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSwgeCArIGUsIHksIGUpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIHcsIHkpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIHcsIHkgKyBoKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyBlLCB5ICsgaCk7XG4gICAgICBjb250ZXh0LmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIGUsIGUpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCwgeSArIGUpO1xuXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG5cbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcbiAgICB9XG5cbiAgICAvLyBOb2RlIGJvcmRlcjpcbiAgICBpZiAoc2V0dGluZ3MoJ2JvcmRlclNpemUnKSA+IDApIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdE5vZGVCb3JkZXJDb2xvcicpO1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgbm9kZVtwcmVmaXggKyAneSddLFxuICAgICAgICBzaXplICsgc2V0dGluZ3MoJ2JvcmRlclNpemUnKSxcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5QSSAqIDIsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgLy8gTm9kZTpcbiAgICB2YXIgbm9kZVJlbmRlcmVyID0gc2lnbWEuY2FudmFzLm5vZGVzW25vZGUudHlwZV0gfHwgc2lnbWEuY2FudmFzLm5vZGVzLmRlZjtcbiAgICBub2RlUmVuZGVyZXIobm9kZSwgY29udGV4dCwgc2V0dGluZ3MpO1xuXG4gICAgLy8gRGlzcGxheSB0aGUgbGFiZWw6XG4gICAgaWYgKG5vZGUubGFiZWwgJiYgdHlwZW9mIG5vZGUubGFiZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxIb3ZlckNvbG9yJyk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICAgIG5vZGUubGFiZWwsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMylcbiAgICAgICk7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IG5vZGUgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgZGlzYy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuYXJjKFxuICAgICAgbm9kZVtwcmVmaXggKyAneCddLFxuICAgICAgbm9kZVtwcmVmaXggKyAneSddLFxuICAgICAgbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgMCxcbiAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGVkZ2UgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGVkZ2UgYXMgYSBzaW1wbGUgbGluZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmRlZiA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J11cbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBhcnJvd3MgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmFycm93ID0gZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBhU2l6ZSA9IE1hdGgubWF4KHNpemUgKiAyLjUsIHNldHRpbmdzKCdtaW5BcnJvd1NpemUnKSksXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSksXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICBhWCxcbiAgICAgIGFZXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlkgKiAwLjYsIGFZIC0gdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmRlZiA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG4gICAgc2l6ZSAqPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJyk7XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J11cbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmN1cnZlID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgY3AgPSB7fSxcbiAgICAgICAgc1NpemUgPSBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcblxuICAgIGNwID0gKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSA/XG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCBzU2l6ZSkgOlxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZKTtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwLngxLCBjcC55MSwgY3AueDIsIGNwLnkyLCB0WCwgdFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgdFgsIHRZKTtcbiAgICB9XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuYXJyb3cgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcblxuICAgIHNpemUgPSAoZWRnZS5ob3ZlcikgP1xuICAgICAgc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogc2l6ZSA6IHNpemU7XG4gICAgdmFyIGFTaXplID0gc2l6ZSAqIDIuNSxcbiAgICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIHNYLCAyKSArIE1hdGgucG93KHRZIC0gc1ksIDIpKSxcbiAgICAgICAgYVggPSBzWCArICh0WCAtIHNYKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICBhWSA9IHNZICsgKHRZIC0gc1kpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIHZYID0gKHRYIC0gc1gpICogYVNpemUgLyBkLFxuICAgICAgICB2WSA9ICh0WSAtIHNZKSAqIGFTaXplIC8gZDtcblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgYVgsXG4gICAgICBhWVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZWRBcnJvdyA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcbiAgICAgICAgY3AgPSB7fSxcbiAgICAgICAgc2l6ZSA9IHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIChlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSksXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgIGQsXG4gICAgICAgIGFTaXplLFxuICAgICAgICBhWCxcbiAgICAgICAgYVksXG4gICAgICAgIHZYLFxuICAgICAgICB2WTtcblxuICAgIGNwID0gKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSA/XG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCB0U2l6ZSkgOlxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZKTtcblxuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIGNwLngxLCAyKSArIE1hdGgucG93KHRZIC0gY3AueTEsIDIpKTtcbiAgICAgIGFTaXplID0gc2l6ZSAqIDIuNTtcbiAgICAgIGFYID0gY3AueDEgKyAodFggLSBjcC54MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIGFZID0gY3AueTEgKyAodFkgLSBjcC55MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIHZYID0gKHRYIC0gY3AueDEpICogYVNpemUgLyBkO1xuICAgICAgdlkgPSAodFkgLSBjcC55MSkgKiBhU2l6ZSAvIGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZCA9IE1hdGguc3FydChNYXRoLnBvdyh0WCAtIGNwLngsIDIpICsgTWF0aC5wb3codFkgLSBjcC55LCAyKSk7XG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XG4gICAgICBhWCA9IGNwLnggKyAodFggLSBjcC54KSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xuICAgICAgYVkgPSBjcC55ICsgKHRZIC0gY3AueSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIHZYID0gKHRYIC0gY3AueCkgKiBhU2l6ZSAvIGQ7XG4gICAgICB2WSA9ICh0WSAtIGNwLnkpICogYVNpemUgLyBkO1xuICAgIH1cblxuICAgIGlmICghY29sb3IpXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xuICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xuICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwLngyLCBjcC55MiwgY3AueDEsIGNwLnkxLCBhWCwgYVkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgYVgsIGFZKTtcbiAgICB9XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IHJlbmRlcmVyIGZvciBob3ZlcmVkIGVkZ2UgZXh0cmVtaXRpZXMuIEl0IHJlbmRlcnMgdGhlIGVkZ2VcbiAgICogZXh0cmVtaXRpZXMgYXMgaG92ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzLmRlZiA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgLy8gU291cmNlIE5vZGU6XG4gICAgKFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVyc1tzb3VyY2UudHlwZV0gfHxcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnMuZGVmXG4gICAgKSAoXG4gICAgICBzb3VyY2UsIGNvbnRleHQsIHNldHRpbmdzXG4gICAgKTtcblxuICAgIC8vIFRhcmdldCBOb2RlOlxuICAgIChcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxuICAgICkgKFxuICAgICAgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5nc1xuICAgICk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcudXRpbHMnKTtcblxuICAvKipcbiAgICogU29tZSB1c2VmdWwgZnVuY3Rpb25zIHVzZWQgYnkgc2lnbWEncyBTVkcgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5zdmcudXRpbHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBzaG93LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBlbGVtZW50ICAgVGhlIERPTSBlbGVtZW50IHRvIHNob3cuXG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgaGlkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBoaWRlLlxuICAgICAqL1xuICAgIGhpZGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXG4gICAqL1xuICBzaWdtYS5zdmcubm9kZXMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2NpcmNsZScpO1xuXG4gICAgICAvLyBEZWZpbmluZyB0aGUgbm9kZSdzIGNpcmNsZVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW5vZGUtaWQnLCBub2RlLmlkKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctbm9kZScpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICBudWxsLCAnZmlsbCcsIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSk7XG5cbiAgICAgIC8vIFJldHVybmluZyB0aGUgRE9NIEVsZW1lbnRcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgY2lyY2xlICAgVGhlIG5vZGUgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihub2RlLCBjaXJjbGUsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICAvLyBBcHBseWluZyBjaGFuZ2VzXG4gICAgICAvLyBUT0RPOiBvcHRpbWl6ZSAtIGNoZWNrIGlmIG5lY2Vzc2FyeVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsIG5vZGVbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5Jywgbm9kZVtwcmVmaXggKyAneSddKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIG5vZGVbcHJlZml4ICsgJ3NpemUnXSk7XG5cbiAgICAgIC8vIFVwZGF0aW5nIG9ubHkgaWYgbm90IGZyZWVzdHlsZVxuICAgICAgaWYgKCFzZXR0aW5ncygnZnJlZVN0eWxlJykpXG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICBudWxsLCAnZmlsbCcsIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSk7XG5cbiAgICAgIC8vIFNob3dpbmdcbiAgICAgIGNpcmNsZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGxpbmUuXG4gICAqL1xuICBzaWdtYS5zdmcuZWRnZXMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnbGluZScpO1xuXG4gICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWVkZ2UnKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIGNvbG9yKTtcblxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBsaW5lICAgICAgIFRoZSBsaW5lIERPTSBFbGVtZW50LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlZGdlLCBsaW5lLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZS13aWR0aCcsIGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gxJywgc291cmNlW3ByZWZpeCArICd4J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTEnLCBzb3VyY2VbcHJlZml4ICsgJ3knXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MicsIHRhcmdldFtwcmVmaXggKyAneCddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kyJywgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBsaW5lLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJ2ZSBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgYmV6aWVyIGN1cnZlLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmVkZ2VzLmN1cnZlID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIHZhciBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAncGF0aCcpO1xuXG4gICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWVkZ2UnKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZScsIGNvbG9yKTtcblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICBsaW5lICAgICAgIFRoZSBsaW5lIERPTSBFbGVtZW50LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlZGdlLCBwYXRoLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XG5cbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ3N0cm9rZS13aWR0aCcsIGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKTtcblxuICAgICAgLy8gQ29udHJvbCBwb2ludFxuICAgICAgdmFyIGN4ID0gKHNvdXJjZVtwcmVmaXggKyAneCddICsgdGFyZ2V0W3ByZWZpeCArICd4J10pIC8gMiArXG4gICAgICAgICh0YXJnZXRbcHJlZml4ICsgJ3knXSAtIHNvdXJjZVtwcmVmaXggKyAneSddKSAvIDQsXG4gICAgICAgICAgY3kgPSAoc291cmNlW3ByZWZpeCArICd5J10gKyB0YXJnZXRbcHJlZml4ICsgJ3knXSkgLyAyICtcbiAgICAgICAgKHNvdXJjZVtwcmVmaXggKyAneCddIC0gdGFyZ2V0W3ByZWZpeCArICd4J10pIC8gNDtcblxuICAgICAgLy8gUGF0aFxuICAgICAgdmFyIHAgPSAnTScgKyBzb3VyY2VbcHJlZml4ICsgJ3gnXSArICcsJyArIHNvdXJjZVtwcmVmaXggKyAneSddICsgJyAnICtcbiAgICAgICAgICAgICAgJ1EnICsgY3ggKyAnLCcgKyBjeSArICcgJyArXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddICsgJywnICsgdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICAgIC8vIFVwZGF0aW5nIGF0dHJpYnV0ZXNcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2QnLCBwKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnbm9uZScpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBwYXRoLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBsYWJlbCByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbGFiZWwgYXMgYSBzaW1wbGUgdGV4dC5cbiAgICovXG4gIHNpZ21hLnN2Zy5sYWJlbHMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICd0ZXh0Jyk7XG5cbiAgICAgIHZhciBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgICAgdmFyIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcblxuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1sYWJlbC10YXJnZXQnLCBub2RlLmlkKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWxhYmVsJyk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LWZhbWlseScsIHNldHRpbmdzKCdmb250JykpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIGZvbnRDb2xvcik7XG5cbiAgICAgIHRleHQuaW5uZXJIVE1MID0gbm9kZS5sYWJlbDtcbiAgICAgIHRleHQudGV4dENvbnRlbnQgPSBub2RlLmxhYmVsO1xuXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgICAgICAgICB0ZXh0ICAgICBUaGUgbGFiZWwgRE9NIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihub2RlLCB0ZXh0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAgIC8vIENhc2Ugd2hlbiB3ZSBkb24ndCB3YW50IHRvIGRpc3BsYXkgdGhlIGxhYmVsXG4gICAgICBpZiAoIXNldHRpbmdzKCdmb3JjZUxhYmVscycpICYmIHNpemUgPCBzZXR0aW5ncygnbGFiZWxUaHJlc2hvbGQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIFVwZGF0aW5nXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMykpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XG5cbiAgICAgIC8vIFNob3dpbmdcbiAgICAgIHRleHQuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGhvdmVyIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmhvdmVycy5kZWYgPSB7XG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgIG5vZGUgICAgICAgICAgICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Q2FudmFzRWxlbWVudH0gICAgbWVhc3VyZW1lbnRDYW52YXMgIEEgZmFrZSBjYW52YXMgaGFuZGxlZCBieVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzdmcgdG8gcGVyZm9ybSBzb21lIG1lYXN1cmVtZW50cyBhbmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgIG5vZGVDaXJjbGUgICAgICAgICBUaGUgbm9kZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICBzZXR0aW5ncyAgICAgICAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgbm9kZUNpcmNsZSwgbWVhc3VyZW1lbnRDYW52YXMsIHNldHRpbmdzKSB7XG5cbiAgICAgIC8vIERlZmluaW5nIHZpc3VhbCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHcsXG4gICAgICAgICAgaCxcbiAgICAgICAgICBlLFxuICAgICAgICAgIGQsXG4gICAgICAgICAgZm9udFN0eWxlID0gc2V0dGluZ3MoJ2hvdmVyRm9udFN0eWxlJykgfHwgc2V0dGluZ3MoJ2ZvbnRTdHlsZScpLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICAgIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemUsXG4gICAgICAgICAgZm9udENvbG9yID0gKHNldHRpbmdzKCdsYWJlbEhvdmVyQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xuXG4gICAgICAvLyBDcmVhdGluZyBlbGVtZW50c1xuICAgICAgdmFyIGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnZycpLFxuICAgICAgICAgIHJlY3RhbmdsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3JlY3QnKSxcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKSxcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xuXG4gICAgICAvLyBEZWZpbmluZyBwcm9wZXJ0aWVzXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLW5vZGUtaWQnLCBub2RlLmlkKTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIC8vIFRleHRcbiAgICAgICAgdGV4dC5pbm5lckhUTUwgPSBub2RlLmxhYmVsO1xuICAgICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWxhYmVsJyk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsIGZvbnRDb2xvcik7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLFxuICAgICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsXG4gICAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpKTtcblxuICAgICAgICAvLyBNZWFzdXJlc1xuICAgICAgICAvLyBPUFRJTUlaRTogRmluZCBhIGJldHRlciB3YXkgdGhhbiBhIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgICAgICB4ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICAgIHcgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgIG1lYXN1cmVtZW50Q2FudmFzLm1lYXN1cmVUZXh0KG5vZGUubGFiZWwpLndpZHRoICtcbiAgICAgICAgICAgIGZvbnRTaXplIC8gMiArIHNpemUgKyA5XG4gICAgICAgICk7XG4gICAgICAgIGggPSBNYXRoLnJvdW5kKGZvbnRTaXplICsgNCk7XG4gICAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xuXG4gICAgICAgIC8vIENpcmNsZVxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5Jywgbm9kZVtwcmVmaXggKyAneSddKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgZSk7XG5cbiAgICAgICAgLy8gUmVjdGFuZ2xlXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLFxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWFyZWEnKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJyNmZmYnKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4Jywgbm9kZVtwcmVmaXggKyAneCddICsgZSAvIDQpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCBub2RlW3ByZWZpeCArICd5J10gLSBlKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIHcpO1xuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2hlaWdodCcsIGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBlbmRpbmcgY2hpbGRzXG4gICAgICBncm91cC5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQocmVjdGFuZ2xlKTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobm9kZUNpcmNsZSk7XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWlkZGxld2FyZSB3aWxsIHJlc2NhbGUgdGhlIGdyYXBoIHN1Y2ggdGhhdCBpdCB0YWtlcyBhbiBvcHRpbWFsIHNwYWNlXG4gICAqIG9uIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQXMgZWFjaCBtaWRkbGV3YXJlLCB0aGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBzY29wZSBvZiB0aGUgc2lnbWFcbiAgICogaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgVGhlIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5yZXNjYWxlID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZCxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIG1hcmdpbixcbiAgICAgICAgbiA9IHRoaXMuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgZSA9IHRoaXMuZ3JhcGguZWRnZXMoKSxcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgYm91bmRzID0gc2V0dGluZ3MoJ2JvdW5kcycpIHx8IHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMoXG4gICAgICAgICAgdGhpcy5ncmFwaCxcbiAgICAgICAgICByZWFkUHJlZml4LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKSxcbiAgICAgICAgbWluWCA9IGJvdW5kcy5taW5YLFxuICAgICAgICBtaW5ZID0gYm91bmRzLm1pblksXG4gICAgICAgIG1heFggPSBib3VuZHMubWF4WCxcbiAgICAgICAgbWF4WSA9IGJvdW5kcy5tYXhZLFxuICAgICAgICBzaXplTWF4ID0gYm91bmRzLnNpemVNYXgsXG4gICAgICAgIHdlaWdodE1heCA9IGJvdW5kcy53ZWlnaHRNYXgsXG4gICAgICAgIHcgPSBzZXR0aW5ncygnd2lkdGgnKSB8fCAxLFxuICAgICAgICBoID0gc2V0dGluZ3MoJ2hlaWdodCcpIHx8IDEsXG4gICAgICAgIHJlc2NhbGVTZXR0aW5ncyA9IHNldHRpbmdzKCdhdXRvUmVzY2FsZScpLFxuICAgICAgICB2YWxpZFNldHRpbmdzID0ge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbjogMSxcbiAgICAgICAgICBub2RlU2l6ZTogMSxcbiAgICAgICAgICBlZGdlU2l6ZTogMVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBlbGVtZW50cyBzaG91bGQgd2UgcmVzY2FsZT9cbiAgICAgKi9cbiAgICBpZiAoIShyZXNjYWxlU2V0dGluZ3MgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICByZXNjYWxlU2V0dGluZ3MgPSBbJ25vZGVQb3NpdGlvbicsICdub2RlU2l6ZScsICdlZGdlU2l6ZSddO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHJlc2NhbGVTZXR0aW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAoIXZhbGlkU2V0dGluZ3NbcmVzY2FsZVNldHRpbmdzW2ldXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgcmVzY2FsZSBzZXR0aW5nIFwiJyArIHJlc2NhbGVTZXR0aW5nc1tpXSArICdcIiBpcyBub3QgcmVjb2duaXplZC4nXG4gICAgICAgICk7XG5cbiAgICB2YXIgbnAgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVQb3NpdGlvbicpLFxuICAgICAgICBucyA9IH5yZXNjYWxlU2V0dGluZ3MuaW5kZXhPZignbm9kZVNpemUnKSxcbiAgICAgICAgZXMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ2VkZ2VTaXplJyk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCwgd2UgY29tcHV0ZSB0aGUgc2NhbGluZyByYXRpbywgd2l0aG91dCBjb25zaWRlcmluZyB0aGUgc2l6ZXNcbiAgICAgKiBvZiB0aGUgbm9kZXMgOiBFYWNoIG5vZGUgd2lsbCBoYXZlIGl0cyBjZW50ZXIgaW4gdGhlIGNhbnZhcywgYnV0IG1pZ2h0XG4gICAgICogYmUgcGFydGlhbGx5IG91dCBvZiBpdC5cbiAgICAgKi9cbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGVuLCB3ZSBjb3JyZWN0IHRoYXQgc2NhbGluZyByYXRpbyBjb25zaWRlcmluZyBhIG1hcmdpbiwgd2hpY2ggaXNcbiAgICAgKiBiYXNpY2FsbHkgdGhlIHNpemUgb2YgdGhlIGJpZ2dlc3Qgbm9kZS5cbiAgICAgKiBUaGlzIGhhcyB0byBiZSBkb25lIGFzIGEgY29ycmVjdGlvbiBzaW5jZSB0byBjb21wYXJlIHRoZSBzaXplIG9mIHRoZVxuICAgICAqIGJpZ2dlc3Qgbm9kZSB0byB0aGUgWCBhbmQgWSB2YWx1ZXMsIHdlIGhhdmUgdG8gZmlyc3QgZ2V0IGFuXG4gICAgICogYXBwcm94aW1hdGlvbiBvZiB0aGUgc2NhbGluZyByYXRpby5cbiAgICAgKiovXG4gICAgbWFyZ2luID1cbiAgICAgIChcbiAgICAgICAgc2V0dGluZ3MoJ3Jlc2NhbGVJZ25vcmVTaXplJykgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSB8fCBzaXplTWF4KSAvIHNjYWxlXG4gICAgICApICtcbiAgICAgIChzZXR0aW5ncygnc2lkZU1hcmdpbicpIHx8IDApO1xuICAgIG1heFggKz0gbWFyZ2luO1xuICAgIG1pblggLT0gbWFyZ2luO1xuICAgIG1heFkgKz0gbWFyZ2luO1xuICAgIG1pblkgLT0gbWFyZ2luO1xuXG4gICAgLy8gRml4IHRoZSBzY2FsaW5nIHdpdGggdGhlIG5ldyBleHRyZW1hOlxuICAgIHNjYWxlID0gc2V0dGluZ3MoJ3NjYWxpbmdNb2RlJykgPT09ICdvdXRzaWRlJyA/XG4gICAgICBNYXRoLm1heChcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKSA6XG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKTtcblxuICAgIC8vIFNpemUgaG9tb3RoZXRpYyBwYXJhbWV0ZXJzOlxuICAgIGlmICghc2V0dGluZ3MoJ21heE5vZGVTaXplJykgJiYgIXNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XG4gICAgICBhID0gMTtcbiAgICAgIGIgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgPT09IHNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XG4gICAgICBhID0gMDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21heE5vZGVTaXplJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgLSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkgLyBzaXplTWF4O1xuICAgICAgYiA9ICtzZXR0aW5ncygnbWluTm9kZVNpemUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXNldHRpbmdzKCdtYXhFZGdlU2l6ZScpICYmICFzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xuICAgICAgYyA9IDE7XG4gICAgICBkID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpID09PSBzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xuICAgICAgYyA9IDA7XG4gICAgICBkID0gK3NldHRpbmdzKCdtaW5FZGdlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjID0gKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIC8gd2VpZ2h0TWF4O1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9XG5cbiAgICAvLyBSZXNjYWxlIHRoZSBub2RlcyBhbmQgZWRnZXM6XG4gICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgZVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBlW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKGVzID8gYyA6IDEpICsgKGVzID8gZCA6IDApO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9XG4gICAgICAgIG5baV1bcmVhZFByZWZpeCArICdzaXplJ10gKiAobnMgPyBhIDogMSkgKyAobnMgPyBiIDogMCk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneCddIC0gKG1heFggKyBtaW5YKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneSddID1cbiAgICAgICAgKG5baV1bcmVhZFByZWZpeCArICd5J10gLSAobWF4WSArIG1pblkpIC8gMikgKiAobnAgPyBzY2FsZSA6IDEpO1xuICAgIH1cbiAgfTtcblxuICBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24oZ3JhcGgsIHByZWZpeCwgZG9FZGdlcykge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBlID0gZ3JhcGguZWRnZXMoKSxcbiAgICAgICAgbiA9IGdyYXBoLm5vZGVzKCksXG4gICAgICAgIHdlaWdodE1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgc2l6ZU1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWluWCA9IEluZmluaXR5LFxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBpZiAoZG9FZGdlcylcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgd2VpZ2h0TWF4ID0gTWF0aC5tYXgoZVtpXVtwcmVmaXggKyAnc2l6ZSddLCB3ZWlnaHRNYXgpO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzaXplTWF4ID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAnc2l6ZSddLCBzaXplTWF4KTtcbiAgICAgIG1heFggPSBNYXRoLm1heChuW2ldW3ByZWZpeCArICd4J10sIG1heFgpO1xuICAgICAgbWluWCA9IE1hdGgubWluKG5baV1bcHJlZml4ICsgJ3gnXSwgbWluWCk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneSddLCBtYXhZKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd5J10sIG1pblkpO1xuICAgIH1cblxuICAgIHdlaWdodE1heCA9IHdlaWdodE1heCB8fCAxO1xuICAgIHNpemVNYXggPSBzaXplTWF4IHx8IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0TWF4OiB3ZWlnaHRNYXgsXG4gICAgICBzaXplTWF4OiBzaXplTWF4LFxuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WVxuICAgIH07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCBqdXN0IGNvcHkgdGhlIGdyYXBoaWMgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHs/c3RyaW5nfSByZWFkUHJlZml4ICBUaGUgcmVhZCBwcmVmaXguXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gd3JpdGVQcmVmaXggVGhlIHdyaXRlIHByZWZpeC5cbiAgICovXG4gIHNpZ21hLm1pZGRsZXdhcmVzLmNvcHkgPSBmdW5jdGlvbihyZWFkUHJlZml4LCB3cml0ZVByZWZpeCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBhO1xuXG4gICAgaWYgKHdyaXRlUHJlZml4ICsgJycgPT09IHJlYWRQcmVmaXggKyAnJylcbiAgICAgIHJldHVybjtcblxuICAgIGEgPSB0aGlzLmdyYXBoLm5vZGVzKCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9IGFbaV1bcmVhZFByZWZpeCArICd4J107XG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9IGFbaV1bcmVhZFByZWZpeCArICd5J107XG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9IGFbaV1bcmVhZFByZWZpeCArICdzaXplJ107XG4gICAgfVxuXG4gICAgYSA9IHRoaXMuZ3JhcGguZWRnZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9IGFbaV1bcmVhZFByZWZpeCArICdzaXplJ107XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nJyk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRCBmb3IgdGhlIGFuaW1hdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBuZXcgSUQuXG4gICAqL1xuICB2YXIgX2dldElEID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcnICsgKCsraWQpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYW5pbWF0ZXMgYSBjYW1lcmEuIEl0IGhhcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgY2FtZXJhIHRvXG4gICAqIGFuaW1hdGUsIHRoZSB2YWx1ZXMgb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoIGFuZCBldmVudHVhbGx5IHNvbWVcbiAgICogb3B0aW9ucy4gSXQgcmV0dXJucyBhIG51bWJlciBpZCwgdGhhdCB5b3UgY2FuIHVzZSB0byBraWxsIHRoZSBhbmltYXRpb24sXG4gICAqIHdpdGggdGhlIG1ldGhvZCBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsKGlkKS5cbiAgICpcbiAgICogVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZTpcbiAgICpcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uTmV3RnJhbWUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgYSBuZXcgZnJhbWUuXG4gICAqICAgez9mdW5jdGlvbn0gICAgICAgICAgb25Db21wbGV0ZSBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgYW5pbWF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZWQgb3Iga2lsbGVkLlxuICAgKiAgIHs/KHN0cmluZ3xmdW5jdGlvbil9IGVhc2luZyAgICAgVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBmcm9tIHRoZSBwYWNrYWdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzLCBvciBhIGN1c3RvbSBlYXNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICBjYW1lcmEgIFRoZSBjYW1lcmEgdG8gYW5pbWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgdGFyZ2V0ICBUaGUgY29vcmRpbmF0ZXMgdG8gcmVhY2guXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3QgdG8gc3BlY2lmeSBzb21lIG9wdGlvbnMgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZnVuY3Rpb24uIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50ZWQgaW4gdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICBUaGUgYW5pbWF0aW9uIGlkLCB0byBtYWtlIGl0IGVhc3kgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm91Z2ggdGhlIG1ldGhvZCBcInNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxcIi5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgdmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKFxuICAgICAgIShjYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSkgfHxcbiAgICAgIHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8XG4gICAgICAhdmFsXG4gICAgKVxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5jYW1lcmE6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHZhbC54ICE9PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIHZhbC55ICE9PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIHZhbC5yYXRpbyAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwuYW5nbGUgIT09ICdudW1iZXInXG4gICAgKVxuICAgICAgdGhyb3cgJ1RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHZhbGlkIGNvb3JkaW5hdGUgaW4gdGhlIGdpdmVuIHZhbC4nO1xuXG4gICAgdmFyIGZuLFxuICAgICAgICBpZCxcbiAgICAgICAgYW5pbSxcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgaW5pdGlhbFZhbCxcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgIHN0YXJ0ID0gc2lnbWEudXRpbHMuZGF0ZU5vdygpO1xuXG4gICAgLy8gU3RvcmUgaW5pdGlhbCB2YWx1ZXM6XG4gICAgaW5pdGlhbFZhbCA9IHtcbiAgICAgIHg6IGNhbWVyYS54LFxuICAgICAgeTogY2FtZXJhLnksXG4gICAgICByYXRpbzogY2FtZXJhLnJhdGlvLFxuICAgICAgYW5nbGU6IGNhbWVyYS5hbmdsZVxuICAgIH07XG5cbiAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb247XG4gICAgZWFzaW5nID0gdHlwZW9mIG8uZWFzaW5nICE9PSAnZnVuY3Rpb24nID9cbiAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3Nbby5lYXNpbmcgfHwgJ3F1YWRyYXRpY0luT3V0J10gOlxuICAgICAgby5lYXNpbmc7XG5cbiAgICBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvZWYsXG4gICAgICAgICAgdCA9IG8uZHVyYXRpb24gPyAoc2lnbWEudXRpbHMuZGF0ZU5vdygpIC0gc3RhcnQpIC8gby5kdXJhdGlvbiA6IDE7XG5cbiAgICAgIC8vIElmIHRoZSBhbmltYXRpb24gaXMgb3ZlcjpcbiAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FtZXJhLmdvVG8oe1xuICAgICAgICAgIHg6IHZhbC54ICE9PSB1bmRlZmluZWQgPyB2YWwueCA6IGluaXRpYWxWYWwueCxcbiAgICAgICAgICB5OiB2YWwueSAhPT0gdW5kZWZpbmVkID8gdmFsLnkgOiBpbml0aWFsVmFsLnksXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID8gdmFsLnJhdGlvIDogaW5pdGlhbFZhbC5yYXRpbyxcbiAgICAgICAgICBhbmdsZTogdmFsLmFuZ2xlICE9PSB1bmRlZmluZWQgPyB2YWwuYW5nbGUgOiBpbml0aWFsVmFsLmFuZ2xlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vbkNvbXBsZXRlKCk7XG5cbiAgICAgIC8vIEVsc2UsIGxldCdzIGtlZXAgZ29pbmc6XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2VmID0gZWFzaW5nKHQpO1xuICAgICAgICBjYW1lcmEuaXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgIGNhbWVyYS5nb1RvKHtcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwueCArICh2YWwueCAtIGluaXRpYWxWYWwueCkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwueCxcbiAgICAgICAgICB5OiB2YWwueSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwueSArICh2YWwueSAtIGluaXRpYWxWYWwueSkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwueSxcbiAgICAgICAgICByYXRpbzogdmFsLnJhdGlvICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgaW5pdGlhbFZhbC5yYXRpbyArICh2YWwucmF0aW8gLSBpbml0aWFsVmFsLnJhdGlvKSAqIGNvZWYgOlxuICAgICAgICAgICAgaW5pdGlhbFZhbC5yYXRpbyxcbiAgICAgICAgICBhbmdsZTogdmFsLmFuZ2xlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgaW5pdGlhbFZhbC5hbmdsZSArICh2YWwuYW5nbGUgLSBpbml0aWFsVmFsLmFuZ2xlKSAqIGNvZWYgOlxuICAgICAgICAgICAgaW5pdGlhbFZhbC5hbmdsZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbk5ld0ZyYW1lID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25OZXdGcmFtZSgpO1xuXG4gICAgICAgIGFuaW0uZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlkID0gX2dldElEKCk7XG4gICAgYW5pbSA9IHtcbiAgICAgIGZyYW1lSWQ6IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbiksXG4gICAgICB0YXJnZXQ6IGNhbWVyYSxcbiAgICAgIHR5cGU6ICdjYW1lcmEnLFxuICAgICAgb3B0aW9uczogbyxcbiAgICAgIGZuOiBmblxuICAgIH07XG4gICAgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF0gPSBhbmltO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLaWxscyBhIHJ1bm5pbmcgYW5pbWF0aW9uLiBJdCB0cmlnZ2VycyB0aGUgZXZlbnR1YWwgb25Db21wbGV0ZSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZCAgVGhlIGlkIG9mIHRoZSBhbmltYXRpb24gdG8ga2lsbC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgUmV0dXJucyB0aGUgc2lnbWEubWlzYy5hbmltYXRpb24gcGFja2FnZS5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGwgPSBmdW5jdGlvbihpZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxIHx8IHR5cGVvZiBpZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnYW5pbWF0aW9uLmtpbGw6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgdmFyIG8gPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgIGlmIChvKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tvLmZyYW1lSWRdO1xuXG4gICAgICBpZiAoby50eXBlID09PSAnY2FtZXJhJylcbiAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICBpZiAodHlwZW9mIChvLm9wdGlvbnMgfHwge30pLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEtpbGxzIGV2ZXJ5IHJ1bm5pbmcgYW5pbWF0aW9ucywgb3Igb25seSB0aGUgb25lIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLFxuICAgKiBpZiBhIHN0cmluZyBwYXJhbWV0ZXIgaXMgZ2l2ZW4uXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfG9iamVjdCl9IGZpbHRlciBBIHN0cmluZyB0byBmaWx0ZXIgdGhlIGFuaW1hdGlvbnMgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBhbmltYXRpb25zIGtpbGxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCB3YXkuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIG8sXG4gICAgICAgIGlkLFxuICAgICAgICBjb3VudCA9IDAsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XG5cbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXG4gICAgICBpZiAoXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcbiAgICAgICkge1xuICAgICAgICBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKG8uZnJhbWVJZCk7XG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgICAgICBpZiAoby50eXBlID09PSAnY2FtZXJhJylcbiAgICAgICAgICBvLnRhcmdldC5pc0FuaW1hdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXI6XG4gICAgICAgIGNvdW50Kys7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIChvLm9wdGlvbnMgfHwge30pLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBcInRydWVcIiBpZiBhbnkgYW5pbWF0aW9uIHRoYXQgaXMgY3VycmVudGx5IHN0aWxsIHJ1bm5pbmcgbWF0Y2hlc1xuICAgKiB0aGUgZmlsdGVyIGdpdmVuIHRvIHRoZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfG9iamVjdH0gZmlsdGVyIEEgc3RyaW5nIHRvIGZpbHRlciB0aGUgYW5pbWF0aW9ucyB0byBraWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiB0aGVpciB0eXBlIChleGFtcGxlOiBcImNhbWVyYVwiKSwgb3IgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB0byBmaWx0ZXIgb24gdGhlaXIgdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgICAgUmV0dXJucyB0cnVlIGlmIGFueSBydW5uaW5nIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5cbiAgICovXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmhhcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBpZCxcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBmaWx0ZXIgPT09ICdzdHJpbmcnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgdGFyZ2V0ID0gdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICBydW5uaW5nID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZztcblxuICAgIGZvciAoaWQgaW4gcnVubmluZylcbiAgICAgIGlmIChcbiAgICAgICAgKCF0eXBlIHx8IHJ1bm5pbmdbaWRdLnR5cGUgPT09IHR5cGUpICYmXG4gICAgICAgICghdGFyZ2V0IHx8IHJ1bm5pbmdbaWRdLnRhcmdldCA9PT0gdGFyZ2V0KVxuICAgICAgKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBoZWxwZXIgd2lsbCBiaW5kIGFueSBuby1ET00gcmVuZGVyZXIgKGZvciBpbnN0YW5jZSBjYW52YXMgb3IgV2ViR0wpXG4gICAqIHRvIGl0cyBjYXB0b3JzLCB0byBwcm9wZXJseSBkaXNwYXRjaCB0aGUgZ29vZCBldmVudHMgdG8gdGhlIHNpZ21hIGluc3RhbmNlXG4gICAqIHRvIG1hbmFnZSBjbGlja2luZywgaG92ZXJpbmcgZXRjLi4uXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5iaW5kRXZlbnRzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIG1YLFxuICAgICAgICBtWSxcbiAgICAgICAgY2FwdG9yLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGdldE5vZGVzKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIG1YID0gJ3gnIGluIGUuZGF0YSA/IGUuZGF0YS54IDogbVg7XG4gICAgICAgIG1ZID0gJ3knIGluIGUuZGF0YSA/IGUuZGF0YS55IDogbVk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLFxuICAgICAgICAgIGosXG4gICAgICAgICAgbCxcbiAgICAgICAgICBuLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIGluc2VydGVkLFxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICBtWVxuICAgICAgICAgICksXG4gICAgICAgICAgbm9kZXMgPSBzZWxmLmNhbWVyYS5xdWFkdHJlZS5wb2ludChcbiAgICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgICBwb2ludC55XG4gICAgICAgICAgKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG4gPSBub2Rlc1tpXTtcbiAgICAgICAgICB4ID0gbltwcmVmaXggKyAneCddO1xuICAgICAgICAgIHkgPSBuW3ByZWZpeCArICd5J107XG4gICAgICAgICAgcyA9IG5bcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFuLmhpZGRlbiAmJlxuICAgICAgICAgICAgbW9kaWZpZWRYID4geCAtIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWCA8IHggKyBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFkgPiB5IC0gcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRZIDwgeSArIHMgJiZcbiAgICAgICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgICAgTWF0aC5wb3cobW9kaWZpZWRYIC0geCwgMikgK1xuICAgICAgICAgICAgICBNYXRoLnBvdyhtb2RpZmllZFkgLSB5LCAyKVxuICAgICAgICAgICAgKSA8IHNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZTpcbiAgICAgICAgICAgIGluc2VydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzZWxlY3RlZC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgaWYgKG4uc2l6ZSA+IHNlbGVjdGVkW2pdLnNpemUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaiwgMCwgbik7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2gobik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGdldEVkZ2VzKGUpIHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZW5hYmxlRWRnZUhvdmVyaW5nJykpIHtcbiAgICAgICAgLy8gTm8gZXZlbnQgaWYgdGhlIHNldHRpbmcgaXMgb2ZmOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0NhbnZhcyA9IChcbiAgICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcyAmJiBzZWxmIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLmNhbnZhcyk7XG5cbiAgICAgIGlmICghaXNDYW52YXMpIHtcbiAgICAgICAgLy8gQSBxdWljayBoYXJkY29kZWQgcnVsZSB0byBwcmV2ZW50IHBlb3BsZSBmcm9tIHVzaW5nIHRoaXMgZmVhdHVyZVxuICAgICAgICAvLyB3aXRoIHRoZSBXZWJHTCByZW5kZXJlciAod2hpY2ggaXMgbm90IGdvb2QgZW5vdWdoIGF0IHRoZSBtb21lbnQpOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1RoZSBlZGdlIGV2ZW50cyBmZWF0dXJlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFdlYkdMIHJlbmRlcmVyJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBlZGdlLFxuICAgICAgICAgIHMsXG4gICAgICAgICAgbWF4RXBzaWxvbiA9IHNlbGYuc2V0dGluZ3MoJ2VkZ2VIb3ZlclByZWNpc2lvbicpLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgY3AsXG4gICAgICAgICAgbm9kZUluZGV4ID0ge30sXG4gICAgICAgICAgaW5zZXJ0ZWQsXG4gICAgICAgICAgc2VsZWN0ZWQgPSBbXSxcbiAgICAgICAgICBtb2RpZmllZFggPSBtWCArIHNlbGYud2lkdGggLyAyLFxuICAgICAgICAgIG1vZGlmaWVkWSA9IG1ZICsgc2VsZi5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50ID0gc2VsZi5jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBtWCxcbiAgICAgICAgICAgIG1ZXG4gICAgICAgICAgKSxcbiAgICAgICAgICBlZGdlcyA9IFtdO1xuXG4gICAgICBpZiAoaXNDYW52YXMpIHtcbiAgICAgICAgdmFyIG5vZGVzT25TY3JlZW4gPSBzZWxmLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgICAgIHNlbGYuY2FtZXJhLmdldFJlY3RhbmdsZShzZWxmLndpZHRoLCBzZWxmLmhlaWdodClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChhID0gbm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBub2RlSW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWRnZXMgPSBzZWxmLmNhbWVyYS5lZGdlcXVhZHRyZWUucG9pbnQoXG4gICAgICAgICAgcG9pbnQueCxcbiAgICAgICAgICBwb2ludC55XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpIHtcbiAgICAgICAgaW5zZXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgaWYgKGVkZ2Uuc2l6ZSA+IHNlbGVjdGVkW2pdLnNpemUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShqLCAwLCBlZGdlKTtcbiAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgIHNlbGVjdGVkLnB1c2goZWRnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlcy5sZW5ndGgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgc291cmNlID0gc2VsZi5ncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2RlcyhlZGdlLnRhcmdldCk7XG4gICAgICAgICAgLy8gKEhBQ0spIHdlIGNhbid0IGdldCBlZGdlW3ByZWZpeCArICdzaXplJ10gb24gV2ViR0wgcmVuZGVyZXI6XG4gICAgICAgICAgcyA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fFxuICAgICAgICAgICAgICBlZGdlWydyZWFkXycgKyBwcmVmaXggKyAnc2l6ZSddO1xuXG4gICAgICAgICAgLy8gRmlyc3QsIGxldCdzIGlkZW50aWZ5IHdoaWNoIGVkZ2VzIGFyZSBkcmF3bi4gVG8gZG8gdGhpcywgd2Uga2VlcFxuICAgICAgICAgIC8vIGV2ZXJ5IGVkZ2VzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgZXh0cmVtaXR5IGRpc3BsYXllZCBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cbiAgICAgICAgICAvLyBlZGdlcy5cbiAgICAgICAgICAvLyBUaGVuLCBsZXQncyBjaGVjayBpZiB0aGUgbW91c2UgaXMgb24gdGhlIGVkZ2UgKHdlIHN1cHBvc2UgdGhhdCBpdFxuICAgICAgICAgIC8vIGlzIGEgbGluZSBzZWdtZW50KS5cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFlZGdlLmhpZGRlbiAmJlxuICAgICAgICAgICAgIXNvdXJjZS5oaWRkZW4gJiYgIXRhcmdldC5oaWRkZW4gJiZcbiAgICAgICAgICAgICghaXNDYW52YXMgfHxcbiAgICAgICAgICAgICAgKG5vZGVJbmRleFtlZGdlLnNvdXJjZV0gfHwgbm9kZUluZGV4W2VkZ2UudGFyZ2V0XSkpICYmXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXREaXN0YW5jZShcbiAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgIG1vZGlmaWVkWSkgPiBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSAmJlxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gdGFyZ2V0W3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChlZGdlLnR5cGUgPT0gJ2N1cnZlJyB8fCBlZGdlLnR5cGUgPT0gJ2N1cnZlZEFycm93Jykge1xuICAgICAgICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFksXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIGNwLngxLFxuICAgICAgICAgICAgICAgICAgY3AueTEsXG4gICAgICAgICAgICAgICAgICBjcC54MixcbiAgICAgICAgICAgICAgICAgIGNwLnkyLFxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uUXVhZHJhdGljQ3VydmUoXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFksXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIGNwLngsXG4gICAgICAgICAgICAgICAgICBjcC55LFxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudChcbiAgICAgICAgICAgICAgICBtb2RpZmllZFgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGJpbmRDYXB0b3IoY2FwdG9yKSB7XG4gICAgICB2YXIgbm9kZXMsXG4gICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgb3Zlck5vZGVzID0ge30sXG4gICAgICAgICAgb3ZlckVkZ2VzID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGljaycsIGUuZGF0YSk7XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGljaycsIGUuZGF0YSk7XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmlnaHRDbGljayhlKSB7XG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlOiBub2RlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrU3RhZ2UnLCB7Y2FwdG9yOiBlLmRhdGF9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25PdXQoZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGssXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGxlLFxuICAgICAgICAgICAgb3V0Tm9kZXMgPSBbXSxcbiAgICAgICAgICAgIG91dEVkZ2VzID0gW107XG5cbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcbiAgICAgICAgICBvdXROb2Rlcy5wdXNoKG92ZXJOb2Rlc1trXSk7XG5cbiAgICAgICAgb3Zlck5vZGVzID0ge307XG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBvdXROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlJywge1xuICAgICAgICAgICAgbm9kZTogb3V0Tm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0Tm9kZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZXMnLCB7XG4gICAgICAgICAgICBub2Rlczogb3V0Tm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIG92ZXJFZGdlcyA9IHt9O1xuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsZSA9IG91dEVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogb3V0RWRnZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0RWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlczogb3V0RWRnZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcbiAgICAgICAgZWRnZXMgPSBnZXRFZGdlcyhlKTtcblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgZWRnZSxcbiAgICAgICAgICAgIG5ld091dE5vZGVzID0gW10sXG4gICAgICAgICAgICBuZXdPdmVyTm9kZXMgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnRPdmVyTm9kZXMgPSB7fSxcbiAgICAgICAgICAgIGwgPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgICBuZXdPdXRFZGdlcyA9IFtdLFxuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzID0gW10sXG4gICAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzID0ge30sXG4gICAgICAgICAgICBsZSA9IGVkZ2VzLmxlbmd0aDtcblxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIG5vZGVzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIGN1cnJlbnRPdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgIGlmICghb3Zlck5vZGVzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICBuZXdPdmVyTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIG92ZXJOb2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm8gbW9yZSBvdmVycmVkIG5vZGVzOlxuICAgICAgICBmb3IgKGsgaW4gb3Zlck5vZGVzKVxuICAgICAgICAgIGlmICghY3VycmVudE92ZXJOb2Rlc1trXSkge1xuICAgICAgICAgICAgbmV3T3V0Tm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xuICAgICAgICAgICAgZGVsZXRlIG92ZXJOb2Rlc1trXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IG5ld092ZXJOb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5ld092ZXJOb2Rlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZXdPdXROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXROb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbmV3T3V0Tm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3T3Zlck5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGVzOiBuZXdPdmVyTm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3T3V0Tm9kZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlczogbmV3T3V0Tm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIG5ld2x5IG92ZXJyZWQgZWRnZXM6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZTsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIGN1cnJlbnRPdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgIGlmICghb3ZlckVkZ2VzW2VkZ2UuaWRdKSB7XG4gICAgICAgICAgICBuZXdPdmVyRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIG92ZXJFZGdlc1tlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm8gbW9yZSBvdmVycmVkIGVkZ2VzOlxuICAgICAgICBmb3IgKGsgaW4gb3ZlckVkZ2VzKVxuICAgICAgICAgIGlmICghY3VycmVudE92ZXJFZGdlc1trXSkge1xuICAgICAgICAgICAgbmV3T3V0RWRnZXMucHVzaChvdmVyRWRnZXNba10pO1xuICAgICAgICAgICAgZGVsZXRlIG92ZXJFZGdlc1trXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBuZXdPdmVyRWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJFZGdlJywge1xuICAgICAgICAgICAgZWRnZTogbmV3T3ZlckVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBuZXdPdXRFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG5ld091dEVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld092ZXJFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlczogbmV3T3ZlckVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld091dEVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG5ld091dEVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQmluZCBldmVudHM6XG4gICAgICBjYXB0b3IuYmluZCgnY2xpY2snLCBvbkNsaWNrKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZWRvd24nLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNldXAnLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlbW92ZScsIG9uTW92ZSk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2VvdXQnLCBvbk91dCk7XG4gICAgICBjYXB0b3IuYmluZCgnZG91YmxlY2xpY2snLCBvbkRvdWJsZUNsaWNrKTtcbiAgICAgIGNhcHRvci5iaW5kKCdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKTtcbiAgICAgIHNlbGYuYmluZCgncmVuZGVyJywgb25Nb3ZlKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jYXB0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGJpbmRDYXB0b3IodGhpcy5jYXB0b3JzW2ldKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBoZWxwZXIgd2lsbCBiaW5kIGFueSBET00gcmVuZGVyZXIgKGZvciBpbnN0YW5jZSBzdmcpXG4gICAqIHRvIGl0cyBjYXB0b3JzLCB0byBwcm9wZXJseSBkaXNwYXRjaCB0aGUgZ29vZCBldmVudHMgdG8gdGhlIHNpZ21hIGluc3RhbmNlXG4gICAqIHRvIG1hbmFnZSBjbGlja2luZywgaG92ZXJpbmcgZXRjLi4uXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5iaW5kRE9NRXZlbnRzID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGg7XG5cbiAgICAvLyBET01FbGVtZW50IGFic3RyYWN0aW9uXG4gICAgZnVuY3Rpb24gRWxlbWVudChkb21FbGVtZW50KSB7XG5cbiAgICAgIC8vIEhlbHBlcnNcbiAgICAgIHRoaXMuYXR0ciA9IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG4gICAgICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZU5TKG51bGwsIGF0dHJOYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFByb3BlcnRpZXNcbiAgICAgIHRoaXMudGFnID0gZG9tRWxlbWVudC50YWdOYW1lO1xuICAgICAgdGhpcy5jbGFzcyA9IHRoaXMuYXR0cignY2xhc3MnKTtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmF0dHIoJ2lkJyk7XG5cbiAgICAgIC8vIE1ldGhvZHNcbiAgICAgIHRoaXMuaXNOb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctbm9kZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5pc0VkZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmlzSG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3ZlcicpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDbGlja1xuICAgIGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIEdlbmVyaWMgZXZlbnRcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlKTtcblxuICAgICAgLy8gQXJlIHdlIG9uIGEgbm9kZT9cbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnQoZS50YXJnZXQpO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSlcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWxlbWVudC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScpO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIERvdWJsZSBjbGlja1xuICAgIGZ1bmN0aW9uIGRvdWJsZUNsaWNrKGUpIHtcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIEdlbmVyaWMgZXZlbnRcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlKTtcblxuICAgICAgLy8gQXJlIHdlIG9uIGEgbm9kZT9cbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnQoZS50YXJnZXQpO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSlcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWxlbWVudC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScpO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIE9uIG92ZXJcbiAgICBmdW5jdGlvbiBvbk92ZXIoZSkge1xuICAgICAgdmFyIHRhcmdldCA9IGUudG9FbGVtZW50IHx8IGUudGFyZ2V0O1xuXG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSB8fCAhdGFyZ2V0KVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KHRhcmdldCk7XG5cbiAgICAgIGlmIChlbC5pc05vZGUoKSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsLmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmlzRWRnZSgpKSB7XG4gICAgICAgIHZhciBlZGdlID0gZ3JhcGguZWRnZXMoZWwuYXR0cignZGF0YS1lZGdlLWlkJykpO1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ292ZXJFZGdlJywge1xuICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgc291cmNlOiBncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSksXG4gICAgICAgICAgdGFyZ2V0OiBncmFwaC5ub2RlcyhlZGdlLnRhcmdldClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT24gb3V0XG4gICAgZnVuY3Rpb24gb25PdXQoZSkge1xuICAgICAgdmFyIHRhcmdldCA9IGUuZnJvbUVsZW1lbnQgfHwgZS5vcmlnaW5hbFRhcmdldDtcblxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGVsID0gbmV3IEVsZW1lbnQodGFyZ2V0KTtcblxuICAgICAgaWYgKGVsLmlzTm9kZSgpKSB7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzKGVsLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlJywge1xuICAgICAgICAgIGVkZ2U6IGVkZ2UsXG4gICAgICAgICAgc291cmNlOiBncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSksXG4gICAgICAgICAgdGFyZ2V0OiBncmFwaC5ub2RlcyhlZGdlLnRhcmdldClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVnaXN0ZXJpbmcgRXZlbnRzOlxuXG4gICAgLy8gQ2xpY2tcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGljaywgZmFsc2UpO1xuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKGNvbnRhaW5lciwgJ2NsaWNrJywgZG91YmxlQ2xpY2spO1xuXG4gICAgLy8gVG91Y2ggY291bnRlcnBhcnRzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjbGljaywgZmFsc2UpO1xuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKGNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBkb3VibGVDbGljayk7XG5cbiAgICAvLyBNb3VzZW92ZXJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25PdmVyLCB0cnVlKTtcblxuICAgIC8vIE1vdXNlb3V0XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb25PdXQsIHRydWUpO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBsaXN0ZW5zIHRvIFwib3Zlck5vZGVcIiwgXCJvdXROb2RlXCIsIFwib3ZlckVkZ2VcIiBhbmQgXCJvdXRFZGdlXCJcbiAgICogZXZlbnRzIGZyb20gYSByZW5kZXJlciBhbmQgcmVuZGVycyB0aGUgbm9kZXMgZGlmZmVyZW50bHkgb24gdGhlIHRvcCBsYXllci5cbiAgICogVGhlIGdvYWwgaXMgdG8gbWFrZSBhbnkgbm9kZSBsYWJlbCByZWFkYWJsZSB3aXRoIHRoZSBtb3VzZSwgYW5kIHRvXG4gICAqIGhpZ2hsaWdodCBob3ZlcmVkIG5vZGVzIGFuZCBlZGdlcy5cbiAgICpcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXG4gICAqL1xuICBzaWdtYS5taXNjLmRyYXdIb3ZlcnMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGhvdmVyZWROb2RlcyA9IHt9LFxuICAgICAgICBob3ZlcmVkRWRnZXMgPSB7fTtcblxuICAgIHRoaXMuYmluZCgnb3Zlck5vZGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIG5vZGUgPSBldmVudC5kYXRhLm5vZGU7XG4gICAgICBpZiAoIW5vZGUuaGlkZGVuKSB7XG4gICAgICAgIGhvdmVyZWROb2Rlc1tub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIGRyYXcoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgnb3V0Tm9kZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBkZWxldGUgaG92ZXJlZE5vZGVzW2V2ZW50LmRhdGEubm9kZS5pZF07XG4gICAgICBkcmF3KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ292ZXJFZGdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBlZGdlID0gZXZlbnQuZGF0YS5lZGdlO1xuICAgICAgaWYgKCFlZGdlLmhpZGRlbikge1xuICAgICAgICBob3ZlcmVkRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICBkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ291dEVkZ2UnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZXRlIGhvdmVyZWRFZGdlc1tldmVudC5kYXRhLmVkZ2UuaWRdO1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdyZW5kZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZHJhdygpIHtcblxuICAgICAgdmFyIGssXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBob3ZlcmVkTm9kZSxcbiAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICBjID0gc2VsZi5jb250ZXh0cy5ob3Zlci5jYW52YXMsXG4gICAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gc2VsZi5zZXR0aW5ncygnZGVmYXVsdE5vZGVUeXBlJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VUeXBlID0gc2VsZi5zZXR0aW5ncygnZGVmYXVsdEVkZ2VUeXBlJyksXG4gICAgICAgICAgbm9kZVJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5ob3ZlcnMsXG4gICAgICAgICAgZWRnZVJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLFxuICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICAvLyBDbGVhciBzZWxmLmNvbnRleHRzLmhvdmVyOlxuICAgICAgc2VsZi5jb250ZXh0cy5ob3Zlci5jbGVhclJlY3QoMCwgMCwgYy53aWR0aCwgYy5oZWlnaHQpO1xuXG4gICAgICAvLyBOb2RlIHJlbmRlcjogc2luZ2xlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykgJiZcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKSAmJlxuICAgICAgICBPYmplY3Qua2V5cyhob3ZlcmVkTm9kZXMpLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGhvdmVyZWROb2RlID0gaG92ZXJlZE5vZGVzW09iamVjdC5rZXlzKGhvdmVyZWROb2RlcylbMF1dO1xuICAgICAgICAoXG4gICAgICAgICAgbm9kZVJlbmRlcmVyc1tob3ZlcmVkTm9kZS50eXBlXSB8fFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnNbZGVmYXVsdE5vZGVUeXBlXSB8fFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnMuZGVmXG4gICAgICAgICkoXG4gICAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vZGUgcmVuZGVyOiBtdWx0aXBsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpICYmXG4gICAgICAgICFlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpXG4gICAgICApXG4gICAgICAgIGZvciAoayBpbiBob3ZlcmVkTm9kZXMpXG4gICAgICAgICAgKFxuICAgICAgICAgICAgbm9kZVJlbmRlcmVyc1tob3ZlcmVkTm9kZXNba10udHlwZV0gfHxcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnNbZGVmYXVsdE5vZGVUeXBlXSB8fFxuICAgICAgICAgICAgbm9kZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICApKFxuICAgICAgICAgICAgaG92ZXJlZE5vZGVzW2tdLFxuICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAvLyBFZGdlIHJlbmRlcjogc2luZ2xlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpICYmXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoaG92ZXJlZEVkZ2VzKS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkRWRnZSA9IGhvdmVyZWRFZGdlc1tPYmplY3Qua2V5cyhob3ZlcmVkRWRnZXMpWzBdXTtcbiAgICAgICAgc291cmNlID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS5zb3VyY2UpO1xuICAgICAgICB0YXJnZXQgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnRhcmdldCk7XG5cbiAgICAgICAgaWYgKCEgaG92ZXJlZEVkZ2UuaGlkZGVuKSB7XG4gICAgICAgICAgKFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tkZWZhdWx0RWRnZVR5cGVdIHx8XG4gICAgICAgICAgICBlZGdlUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICkgKFxuICAgICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoZW1iZWRTZXR0aW5ncygnZWRnZUhvdmVyRXh0cmVtaXRpZXMnKSkge1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICkoXG4gICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBlZGdlcyByZW5kZXJlZCBvdmVyIG5vZGVzOlxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbc291cmNlLnR5cGVdIHx8XG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlc1t0YXJnZXQudHlwZV0gfHxcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRWRnZSByZW5kZXI6IG11bHRpcGxlIGhvdmVyXG4gICAgICBpZiAoXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpICYmXG4gICAgICAgICFlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpXG4gICAgICApIHtcbiAgICAgICAgZm9yIChrIGluIGhvdmVyZWRFZGdlcykge1xuICAgICAgICAgIGhvdmVyZWRFZGdlID0gaG92ZXJlZEVkZ2VzW2tdO1xuICAgICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2Uuc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnRhcmdldCk7XG5cbiAgICAgICAgICBpZiAoIWhvdmVyZWRFZGdlLmhpZGRlbikge1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2hvdmVyZWRFZGdlLnR5cGVdIHx8XG4gICAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzW2hvdmVyZWRFZGdlLnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICAgICkoXG4gICAgICAgICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGVkZ2VzIHJlbmRlcmVkIG92ZXIgbm9kZXM6XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbc291cmNlLnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZlxuICAgICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcbiIsIjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCcpO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZTpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5sYXlvdXQubm92ZXJsYXAnKTtcblxuICAvKipcbiAgICogTm92ZXJsYXAgTGF5b3V0XG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICpcbiAgICogQXV0aG9yOiBAYXBpdHRzIC8gQW5kcmV3IFBpdHRzXG4gICAqIEFsZ29yaXRobTogQGphY29teW1hIC8gTWF0aGlldSBKYWNvbXkgKG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgdG8gR2VwaGkgYW5kIHBvcnRlZCB0byBzaWdtYS5qcyB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgYnkgQGFuZHBpdHRzIHdpdGggcGVybWlzc2lvbilcbiAgICogQWNrbm93bGVkZ2VtZW50OiBAc2hleW1hbiAvIFPDqWJhc3RpZW4gSGV5bWFubiAoc29tZSBpbnNwaXJhdGlvbiBoYXMgYmVlbiB0YWtlbiBmcm9tIG90aGVyIE1JVCBsaWNlbnNlZCBsYXlvdXQgYWxnb3JpdGhtcyBhdXRob3JlZCBieSBAc2hleW1hbilcbiAgICogVmVyc2lvbjogMC4xXG4gICAqL1xuXG4gIHZhciBzZXR0aW5ncyA9IHtcbiAgICBzcGVlZDogMyxcbiAgICBzY2FsZU5vZGVzOiAxLjIsXG4gICAgbm9kZU1hcmdpbjogNS4wLFxuICAgIGdyaWRTaXplOiAyMCxcbiAgICBwZXJtaXR0ZWRFeHBhbnNpb246IDEuMSxcbiAgICByZW5kZXJlckluZGV4OiAwLFxuICAgIG1heEl0ZXJhdGlvbnM6IDUwMFxuICB9O1xuXG4gIHZhciBfaW5zdGFuY2UgPSB7fTtcblxuICAvKipcbiAgICogRXZlbnQgZW1pdHRlciBPYmplY3RcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICB2YXIgX2V2ZW50RW1pdHRlciA9IHt9O1xuXG4gICAvKipcbiAgICogTm92ZXJsYXAgT2JqZWN0XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgZnVuY3Rpb24gTm92ZXJsYXAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKHNpZ0luc3QsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnNpZ0luc3QgPSBzaWdJbnN0O1xuICAgICAgdGhpcy5jb25maWcgPSBzaWdtYS51dGlscy5leHRlbmQob3B0aW9ucywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5lYXNpbmcgPSBvcHRpb25zLmVhc2luZztcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICBpZiAob3B0aW9ucy5ub2Rlcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gb3B0aW9ucy5ub2RlcztcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMubm9kZXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2lnbWEucGx1Z2lucyB8fCB0eXBlb2Ygc2lnbWEucGx1Z2lucy5hbmltYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hLnBsdWdpbnMuYW5pbWF0ZSBpcyBub3QgZGVjbGFyZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhdGVcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW5nbGUgbGF5b3V0IGl0ZXJhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmF0b21pY0dvID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcgfHwgdGhpcy5pdGVyQ291bnQgPCAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMgfHwgdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCksXG4gICAgICAgICAgbm9kZXNDb3VudCA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbjEsXG4gICAgICAgICAgbjIsXG4gICAgICAgICAgeG1pbiA9IEluZmluaXR5LFxuICAgICAgICAgIHhtYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgeW1pbiA9IEluZmluaXR5LFxuICAgICAgICAgIHltYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgeHdpZHRoLFxuICAgICAgICAgIHloZWlnaHQsXG4gICAgICAgICAgeGNlbnRlcixcbiAgICAgICAgICB5Y2VudGVyLFxuICAgICAgICAgIGdyaWQsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGNvbCxcbiAgICAgICAgICBtaW5YQm94LFxuICAgICAgICAgIG1heFhCb3gsXG4gICAgICAgICAgbWluWUJveCxcbiAgICAgICAgICBtYXhZQm94LFxuICAgICAgICAgIGFkamFjZW50Tm9kZXMsXG4gICAgICAgICAgc3ViUm93LFxuICAgICAgICAgIHN1YkNvbCxcbiAgICAgICAgICBueG1pbixcbiAgICAgICAgICBueG1heCxcbiAgICAgICAgICBueW1pbixcbiAgICAgICAgICBueW1heDtcblxuICAgICAgdGhpcy5pdGVyQ291bnQtLTtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgIG4uZG4uZHggPSAwO1xuICAgICAgICBuLmRuLmR5ID0gMDtcblxuICAgICAgICAvL0ZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBib3RoIHggYW5kIHkgYWNyb3NzIGFsbCBub2Rlc1xuICAgICAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgbi5kbl94IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcbiAgICAgICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIG4uZG5feCArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XG4gICAgICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xuICAgICAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgbi5kbl95ICsgKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcblxuICAgICAgfVxuXG4gICAgICB4d2lkdGggPSB4bWF4IC0geG1pbjtcbiAgICAgIHloZWlnaHQgPSB5bWF4IC0geW1pbjtcbiAgICAgIHhjZW50ZXIgPSAoeG1pbiArIHhtYXgpIC8gMjtcbiAgICAgIHljZW50ZXIgPSAoeW1pbiArIHltYXgpIC8gMjtcbiAgICAgIHhtaW4gPSB4Y2VudGVyIC0gc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnh3aWR0aCAvIDI7XG4gICAgICB4bWF4ID0geGNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip4d2lkdGggLyAyO1xuICAgICAgeW1pbiA9IHljZW50ZXIgLSBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeWhlaWdodCAvIDI7XG4gICAgICB5bWF4ID0geWNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip5aGVpZ2h0IC8gMjtcblxuICAgICAgZ3JpZCA9IHt9OyAvL0FuIG9iamVjdCBvZiBvYmplY3RzIHdoZXJlIGdyaWRbcm93XVtjb2xdIGlzIGFuIGFycmF5IG9mIG5vZGUgaWRzIHJlcHJlc2VudGluZyBub2RlcyB0aGF0IGZhbGwgaW4gdGhhdCBncmlkLiBOb2RlcyBjYW4gZmFsbCBpbiBtb3JlIHRoYW4gb25lIGdyaWRcblxuICAgICAgZm9yKHJvdyA9IDA7IHJvdyA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyByb3crKykge1xuICAgICAgICBncmlkW3Jvd10gPSB7fTtcbiAgICAgICAgZm9yKGNvbCA9IDA7IGNvbCA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyBjb2wrKykge1xuICAgICAgICAgIGdyaWRbcm93XVtjb2xdID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9QbGFjZSBub2RlcyBpbiBncmlkXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgbnhtaW4gPSBuLmRuX3ggLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnhtYXggPSBuLmRuX3ggKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnltaW4gPSBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcbiAgICAgICAgbnltYXggPSBuLmRuX3kgKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcblxuICAgICAgICBtaW5YQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG54bWluIC0geG1pbikgLyAoeG1heCAtIHhtaW4pICk7XG4gICAgICAgIG1heFhCb3ggPSBNYXRoLmZsb29yKHNlbGYuY29uZmlnLmdyaWRTaXplKiAobnhtYXggLSB4bWluKSAvICh4bWF4IC0geG1pbikgKTtcbiAgICAgICAgbWluWUJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueW1pbiAtIHltaW4pIC8gKHltYXggLSB5bWluKSApO1xuICAgICAgICBtYXhZQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG55bWF4IC0geW1pbikgLyAoeW1heCAtIHltaW4pICk7XG4gICAgICAgIGZvcihjb2wgPSBtaW5YQm94OyBjb2wgPD0gbWF4WEJveDsgY29sKyspIHtcbiAgICAgICAgICBmb3Iocm93ID0gbWluWUJveDsgcm93IDw9IG1heFlCb3g7IHJvdysrKSB7XG4gICAgICAgICAgICBncmlkW3Jvd11bY29sXS5wdXNoKG4uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGFkamFjZW50Tm9kZXMgPSB7fTsgLy9BbiBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIG5vZGUgaWRzIG9mIGFkamFjZW50IG5vZGVzIChlaXRoZXIgaW4gc2FtZSBncmlkIGJveCBvciBhZGphY2VudCBncmlkIGJveCkgZm9yIGFsbCBub2Rlc1xuXG4gICAgICBmb3Iocm93ID0gMDsgcm93IDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IHJvdysrKSB7XG4gICAgICAgIGZvcihjb2wgPSAwOyBjb2wgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgY29sKyspIHtcbiAgICAgICAgICBncmlkW3Jvd11bY29sXS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYoIWFkamFjZW50Tm9kZXNbbm9kZUlkXSkge1xuICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihzdWJSb3cgPSBNYXRoLm1heCgwLCByb3cgLSAxKTsgc3ViUm93IDw9IE1hdGgubWluKHJvdyArIDEsIHNlbGYuY29uZmlnLmdyaWRTaXplIC0gMSk7IHN1YlJvdysrKSB7XG4gICAgICAgICAgICAgIGZvcihzdWJDb2wgPSBNYXRoLm1heCgwLCBjb2wgLSAxKTsgc3ViQ29sIDw9IE1hdGgubWluKGNvbCArIDEsICBzZWxmLmNvbmZpZy5ncmlkU2l6ZSAtIDEpOyBzdWJDb2wrKykge1xuICAgICAgICAgICAgICAgIGdyaWRbc3ViUm93XVtzdWJDb2xdLmZvckVhY2goZnVuY3Rpb24oc3ViTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICBpZihzdWJOb2RlSWQgIT09IG5vZGVJZCAmJiBhZGphY2VudE5vZGVzW25vZGVJZF0uaW5kZXhPZihzdWJOb2RlSWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhZGphY2VudE5vZGVzW25vZGVJZF0ucHVzaChzdWJOb2RlSWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9JZiB0d28gbm9kZXMgb3ZlcmxhcCB0aGVuIHJlcHVsc2UgdGhlbVxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcbiAgICAgICAgbjEgPSBub2Rlc1tpXTtcbiAgICAgICAgYWRqYWNlbnROb2Rlc1tuMS5pZF0uZm9yRWFjaChmdW5jdGlvbihub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbjIgPSBzZWxmLnNpZ0luc3QuZ3JhcGgubm9kZXMobm9kZUlkKTtcbiAgICAgICAgICB2YXIgeERpc3QgPSBuMi5kbl94IC0gbjEuZG5feDtcbiAgICAgICAgICB2YXIgeURpc3QgPSBuMi5kbl95IC0gbjEuZG5feTtcbiAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCh4RGlzdCp4RGlzdCArIHlEaXN0KnlEaXN0KTtcbiAgICAgICAgICB2YXIgY29sbGlzaW9uID0gKGRpc3QgPCAoKG4xLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICsgKG4yLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pKSk7XG4gICAgICAgICAgaWYoY29sbGlzaW9uKSB7XG4gICAgICAgICAgICBzZWxmLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYoZGlzdCA+IDApIHtcbiAgICAgICAgICAgICAgbjIuZG4uZHggKz0geERpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcbiAgICAgICAgICAgICAgbjIuZG4uZHkgKz0geURpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4yLmRuLmR4ICs9IHh3aWR0aCAqIDAuMDEgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XG4gICAgICAgICAgICAgIG4yLmRuLmR5ICs9IHloZWlnaHQgKiAwLjAxICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIG4gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYoIW4uZml4ZWQpIHtcbiAgICAgICAgICBuLmRuX3ggPSBuLmRuX3ggKyBuLmRuLmR4ICogMC4xICogc2VsZi5jb25maWcuc3BlZWQ7XG4gICAgICAgICAgbi5kbl95ID0gbi5kbl95ICsgbi5kbi5keSAqIDAuMSAqIHNlbGYuY29uZmlnLnNwZWVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMucnVubmluZyAmJiB0aGlzLml0ZXJDb3VudCA8IDEpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLml0ZXJDb3VudCA9IHRoaXMuY29uZmlnLm1heEl0ZXJhdGlvbnM7XG5cbiAgICAgIHdoaWxlICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5hdG9taWNHbygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHJldHVybjtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCk7XG5cbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLnNpZ0luc3QucmVuZGVyZXJzW3NlbGYuY29uZmlnLnJlbmRlcmVySW5kZXhdLm9wdGlvbnMucHJlZml4O1xuXG4gICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXG4gICAgICAvLyBJbml0IG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGVzW2ldLmRuX3ggPSBub2Rlc1tpXVtwcmVmaXggKyAneCddO1xuICAgICAgICBub2Rlc1tpXS5kbl95ID0gbm9kZXNbaV1bcHJlZml4ICsgJ3knXTtcbiAgICAgICAgbm9kZXNbaV0uZG5fc2l6ZSA9IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ107XG4gICAgICAgIG5vZGVzW2ldLmRuID0ge1xuICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgIGR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RhcnQnKTtcbiAgICAgIHRoaXMuZ28oKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnNpZ0luc3QuZ3JhcGgubm9kZXMoKTtcblxuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmVhc2luZykge1xuICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnaW50ZXJwb2xhdGUnKTtcbiAgICAgICAgc2lnbWEucGx1Z2lucy5hbmltYXRlKFxuICAgICAgICAgIHNlbGYuc2lnSW5zdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB4OiAnZG5feCcsXG4gICAgICAgICAgICB5OiAnZG5feSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVhc2luZzogc2VsZi5lYXNpbmcsXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5zaWdJbnN0LnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGVzW2ldLmRuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl94ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbl95ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RvcCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzZWxmLmR1cmF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5IGNoYW5nZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzW2ldLnggPSBub2Rlc1tpXS5kbl94O1xuICAgICAgICAgIG5vZGVzW2ldLnkgPSBub2Rlc1tpXS5kbl95O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaWdJbnN0LnJlZnJlc2goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXNbaV0uZG4gPSBudWxsO1xuICAgICAgICAgIG5vZGVzW2ldLmRuX3ggPSBudWxsO1xuICAgICAgICAgIG5vZGVzW2ldLmRuX3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF9ldmVudEVtaXR0ZXJbc2VsZi5zaWdJbnN0LmlkXS5kaXNwYXRjaEV2ZW50KCdzdG9wJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zaWdJbnN0ID0gbnVsbDtcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuZWFzaW5nID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBsYXlvdXQgYWxnb3JpdGhtLlxuXG4gICAqIFJlY29nbml6ZWQgb3B0aW9uczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyIGluIHRoZSBzZXR0aW5nc1xuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNjYWxlTm9kZXMgICAgICAgICAgVGhlIHJhdGlvIHRvIHNjYWxlIG5vZGVzIGJ5IC0gYSBsYXJnZXIgcmF0aW8gd2lsbCBsZWFkIHRvIG1vcmUgc3BhY2UgYXJvdW5kIGxhcmdlciBub2Rlc1xuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgZ3JpZFNpemUgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgdG8gdXNlIHdoZW4gcGFydGlvbmluZyBub2RlcyBpbnRvIGEgZ3JpZCBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgICAgICAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGUgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGEgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmNvbmZpZ05vdmVybGFwID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbmZpZykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50OiBcImNvbmZpZ1wiJyk7XG5cbiAgICAvLyBDcmVhdGUgaW5zdGFuY2UgaWYgdW5kZWZpbmVkXG4gICAgaWYgKCFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0pIHtcbiAgICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXSA9IG5ldyBOb3ZlcmxhcCgpO1xuXG4gICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0ge307XG4gICAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF0pO1xuXG4gICAgICAvLyBCaW5kaW5nIG9uIGtpbGwgdG8gY2xlYXIgdGhlIHJlZmVyZW5jZXNcbiAgICAgIHNpZ0luc3QuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0ua2lsbCgpO1xuICAgICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gPSBudWxsO1xuICAgICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5pbml0KHNpZ0luc3QsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4gX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgdGhlIGxheW91dCBhbGdvcml0aG0uIEl0IHdpbGwgdXNlIHRoZSBleGlzdGluZyBjb25maWd1cmF0aW9uIGlmIG5vXG4gICAqIG5ldyBjb25maWd1cmF0aW9uIGlzIHBhc3NlZC5cblxuICAgKiBSZWNvZ25pemVkIG9wdGlvbnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlciBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNjYWxlTm9kZXMgICAgICAgICAgVGhlIHJhdGlvIHRvIHNjYWxlIG5vZGVzIGJ5IC0gYSBsYXJnZXIgcmF0aW8gd2lsbCBsZWFkIHRvIG1vcmUgc3BhY2UgYXJvdW5kIGxhcmdlciBub2Rlc1xuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG5vZGVNYXJnaW4gICAgICAgICAgQSBmaXhlZCBtYXJnaW4gdG8gYXBwbHkgYXJvdW5kIG5vZGVzIHJlZ2FyZGxlc3Mgb2Ygc2l6ZVxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXG4gICAqICAgez9pbnRlZ2VyfSAgICAgICAgICAgZ3JpZFNpemUgICAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgdG8gdXNlIHdoZW4gcGFydGlvbmluZyBub2RlcyBpbnRvIGEgZ3JpZCBmb3IgZWZmaWNpZW50IGNvbXB1dGF0aW9uXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgcGVybWl0dGVkRXhwYW5zaW9uICBBIHBlcm1pdHRlZCBleHBhbnNpb24gZmFjdG9yIHRvIHRoZSBvdmVyYWxsIHNpemUgb2YgdGhlIG5ldHdvcmsgYXBwbGllZCBhdCBlYWNoIGl0ZXJhdGlvblxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgICAgICAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGUgc2lnbWEudXRpbHMuZWFzaW5ncyBwYWNrYWdlIG9yIGEgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxuICAgKi9cblxuICBzaWdtYS5wcm90b3R5cGUuc3RhcnROb3ZlcmxhcCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWdOb3ZlcmxhcChzaWdJbnN0LCBjb25maWcpO1xuICAgIH1cblxuICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5zdGFydCgpO1xuXG4gICAgcmV0dXJuIF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGhhcyBzdGFydGVkIGFuZCBpcyBub3QgY29tcGxldGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmlzTm92ZXJsYXBSdW5uaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XG5cbiAgICByZXR1cm4gISFfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gJiYgX2luc3RhbmNlW3NpZ0luc3QuaWRdLnJ1bm5pbmc7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7IiwiLyoqXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBhIG1ldGhvZCB0byBhbmltYXRlIGEgc2lnbWEgaW5zdGFuY2UgYnkgaW50ZXJwb2xhdGluZ1xuICogc29tZSBub2RlIHByb3BlcnRpZXMuIENoZWNrIHRoZSBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgZnVuY3Rpb24gZG9jIG9yIHRoZVxuICogZXhhbXBsZXMvYW5pbWF0ZS5odG1sIGNvZGUgc2FtcGxlIHRvIGtub3cgbW9yZS5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5wbHVnaW5zJyk7XG5cbiAgdmFyIF9pZCA9IDAsXG4gICAgICBfY2FjaGUgPSB7fTtcblxuICAvLyBUT09MSU5HIEZVTkNUSU9OUzpcbiAgLy8gKioqKioqKioqKioqKioqKioqXG4gIGZ1bmN0aW9uIHBhcnNlQ29sb3IodmFsKSB7XG4gICAgaWYgKF9jYWNoZVt2YWxdKVxuICAgICAgcmV0dXJuIF9jYWNoZVt2YWxdO1xuXG4gICAgdmFyIHJlc3VsdCA9IFswLCAwLCAwXTtcblxuICAgIGlmICh2YWwubWF0Y2goL14jLykpIHtcbiAgICAgIHZhbCA9ICh2YWwgfHwgJycpLnJlcGxhY2UoL14jLywgJycpO1xuICAgICAgcmVzdWx0ID0gKHZhbC5sZW5ndGggPT09IDMpID9cbiAgICAgICAgW1xuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDApLCAxNiksXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KSxcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgyKSwgMTYpXG4gICAgICAgIF0gOlxuICAgICAgICBbXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMSksIDE2KSxcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpLFxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoNCkgKyB2YWwuY2hhckF0KDUpLCAxNilcbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XG4gICAgICB2YWwgPSB2YWwubWF0Y2goXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXG4gICAgICApO1xuICAgICAgcmVzdWx0ID0gW1xuICAgICAgICArdmFsWzFdLFxuICAgICAgICArdmFsWzJdLFxuICAgICAgICArdmFsWzNdXG4gICAgICBdO1xuICAgIH1cblxuICAgIF9jYWNoZVt2YWxdID0ge1xuICAgICAgcjogcmVzdWx0WzBdLFxuICAgICAgZzogcmVzdWx0WzFdLFxuICAgICAgYjogcmVzdWx0WzJdXG4gICAgfTtcblxuICAgIHJldHVybiBfY2FjaGVbdmFsXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3JzKGMxLCBjMiwgcCkge1xuICAgIGMxID0gcGFyc2VDb2xvcihjMSk7XG4gICAgYzIgPSBwYXJzZUNvbG9yKGMyKTtcblxuICAgIHZhciBjID0ge1xuICAgICAgcjogYzEuciAqICgxIC0gcCkgKyBjMi5yICogcCxcbiAgICAgIGc6IGMxLmcgKiAoMSAtIHApICsgYzIuZyAqIHAsXG4gICAgICBiOiBjMS5iICogKDEgLSBwKSArIGMyLmIgKiBwXG4gICAgfTtcblxuICAgIHJldHVybiAncmdiKCcgKyBbYy5yIHwgMCwgYy5nIHwgMCwgYy5iIHwgMF0uam9pbignLCcpICsgJyknO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbmltYXRlIHNvbWUgc3BlY2lmaWVkIG5vZGUgcHJvcGVydGllcy4gSXQgd2lsbFxuICAgKiBiYXNpY2FsbHkgY2FsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGludGVycG9sYXRlIHRoZSB2YWx1ZXMgYW5kIGNhbGwgdGhlXG4gICAqIHJlZnJlc2ggbWV0aG9kIGR1cmluZyBhIHNwZWNpZmllZCBkdXJhdGlvbi5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBzZXR0aW5nc1xuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9hcnJheX0gICAgICAgICAgICAgbm9kZXMgICAgICBBbiBhcnJheSBvZiBub2RlIG9iamVjdHMgb3Igbm9kZSBpZHMuIElmXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3Qgc3BlY2lmaWVkLCBhbGwgbm9kZXMgb2YgdGhlIGdyYXBoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGFuaW1hdGVkLlxuICAgKiAgIHs/KGZ1bmN0aW9ufHN0cmluZyl9IGVhc2luZyAgICAgRWl0aGVyIHRoZSBuYW1lIG9mIGFuIGVhc2luZyBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNJbk91dCBlYXNpbmcgZnJvbSB0aGlzIHBhY2thZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCB0aGUgXCJhbmltYXRpb25zVGltZVwiIHNldHRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIG9mIHRoZSBzaWdtYSBpbnN0YW5jZSB3aWxsIGJlIHVzZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RlYWQuXG4gICAqICAgez9mdW5jdGlvbn0gICAgICAgICAgb25Db21wbGV0ZSBFdmVudHVhbGx5IGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uIGlzIGVuZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gICBzICAgICAgIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBhbmltYXRlIEFuIGhhc2ggd2l0aCB0aGUga2V5cyBiZWluZyB0aGUgbm9kZSBwcm9wZXJ0aWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gaW50ZXJwb2xhdGUsIGFuZCB0aGUgdmFsdWVzIGJlaW5nIHRoZSByZWxhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0IHZhbHVlcy5cbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gICAqL1xuICBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgPSBmdW5jdGlvbihzLCBhbmltYXRlLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBpZCA9ICsrX2lkLFxuICAgICAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb24gfHwgcy5zZXR0aW5ncygnYW5pbWF0aW9uc1RpbWUnKSxcbiAgICAgICAgZWFzaW5nID0gdHlwZW9mIG8uZWFzaW5nID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5nc1tvLmVhc2luZ10gOlxuICAgICAgICAgIHR5cGVvZiBvLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgby5lYXNpbmcgOlxuICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljSW5PdXQsXG4gICAgICAgIHN0YXJ0ID0gc2lnbWEudXRpbHMuZGF0ZU5vdygpLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgc3RhcnRQb3NpdGlvbnM7XG5cbiAgICBpZiAoby5ub2RlcyAmJiBvLm5vZGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBvLm5vZGVzWzBdID09PSAnb2JqZWN0JylcbiAgICAgICAgbm9kZXMgPSBvLm5vZGVzO1xuICAgICAgZWxzZVxuICAgICAgICBub2RlcyA9IHMuZ3JhcGgubm9kZXMoby5ub2Rlcyk7IC8vIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIElEc1xuICAgIH1cbiAgICBlbHNlXG4gICAgICBub2RlcyA9IHMuZ3JhcGgubm9kZXMoKTtcblxuICAgIC8vIFN0b3JlIGluaXRpYWwgcG9zaXRpb25zOlxuICAgIHN0YXJ0UG9zaXRpb25zID0gbm9kZXMucmVkdWNlKGZ1bmN0aW9uKHJlcywgbm9kZSkge1xuICAgICAgdmFyIGs7XG4gICAgICByZXNbbm9kZS5pZF0gPSB7fTtcbiAgICAgIGZvciAoayBpbiBhbmltYXRlKVxuICAgICAgICBpZiAoayBpbiBub2RlKVxuICAgICAgICAgIHJlc1tub2RlLmlkXVtrXSA9IG5vZGVba107XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHt9KTtcblxuICAgIHMuYW5pbWF0aW9ucyA9IHMuYW5pbWF0aW9ucyB8fCBPYmplY3QuY3JlYXRlKHt9KTtcbiAgICBzaWdtYS5wbHVnaW5zLmtpbGwocyk7XG5cbiAgICAvLyBEbyBub3QgcmVmcmVzaCBlZGdlcXVhZHRyZWUgZHVyaW5nIGRyYWc6XG4gICAgdmFyIGssXG4gICAgICAgIGM7XG4gICAgZm9yIChrIGluIHMuY2FtZXJhcykge1xuICAgICAgYyA9IHMuY2FtZXJhc1trXTtcbiAgICAgIGMuZWRnZXF1YWR0cmVlLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIHZhciBwID0gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICBpZiAocCA+PSAxKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGZvciAodmFyIGsgaW4gYW5pbWF0ZSlcbiAgICAgICAgICAgIGlmIChrIGluIGFuaW1hdGUpXG4gICAgICAgICAgICAgIG5vZGVba10gPSBub2RlW2FuaW1hdGVba11dO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBbGxvdyB0byByZWZyZXNoIGVkZ2VxdWFkdHJlZTpcbiAgICAgICAgdmFyIGssXG4gICAgICAgICAgICBjO1xuICAgICAgICBmb3IgKGsgaW4gcy5jYW1lcmFzKSB7XG4gICAgICAgICAgYyA9IHMuY2FtZXJhc1trXTtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzLnJlZnJlc2goKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgby5vbkNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwID0gZWFzaW5nKHApO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGFuaW1hdGUpXG4gICAgICAgICAgICBpZiAoayBpbiBhbmltYXRlKSB7XG4gICAgICAgICAgICAgIGlmIChrLm1hdGNoKC9jb2xvciQvKSlcbiAgICAgICAgICAgICAgICBub2RlW2tdID0gaW50ZXJwb2xhdGVDb2xvcnMoXG4gICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uc1tub2RlLmlkXVtrXSxcbiAgICAgICAgICAgICAgICAgIG5vZGVbYW5pbWF0ZVtrXV0sXG4gICAgICAgICAgICAgICAgICBwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVba10gPVxuICAgICAgICAgICAgICAgICAgbm9kZVthbmltYXRlW2tdXSAqIHAgK1xuICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbnNbbm9kZS5pZF1ba10gKiAoMSAtIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzLnJlZnJlc2goKTtcbiAgICAgICAgcy5hbmltYXRpb25zW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGVwKCk7XG4gIH07XG5cbiAgc2lnbWEucGx1Z2lucy5raWxsID0gZnVuY3Rpb24ocykge1xuICAgIGZvciAodmFyIGsgaW4gKHMuYW5pbWF0aW9ucyB8fCB7fSkpXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzLmFuaW1hdGlvbnNba10pO1xuXG4gICAgLy8gQWxsb3cgdG8gcmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgdmFyIGssXG4gICAgICAgIGM7XG4gICAgZm9yIChrIGluIHMuY2FtZXJhcykge1xuICAgICAgYyA9IHMuY2FtZXJhc1trXTtcbiAgICAgIGMuZWRnZXF1YWR0cmVlLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59KS5jYWxsKHdpbmRvdyk7XG4iLCIvKipcbiAqIFRoaXMgcGx1Z2luIHByb3ZpZGVzIGEgbWV0aG9kIHRvIGRyYWcgJiBkcm9wIG5vZGVzLiBDaGVjayB0aGVcbiAqIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzIGZ1bmN0aW9uIGRvYyBvciB0aGUgZXhhbXBsZXMvYmFzaWMuaHRtbCAmXG4gKiBleGFtcGxlcy9hcGktY2FuZHkuaHRtbCBjb2RlIHNhbXBsZXMgdG8ga25vdyBtb3JlLlxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnBsdWdpbnMnKTtcblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGBtb3VzZWRvd25gLCBgbW91c2V1cGAgJiBgbW91c2Vtb3ZlYCBldmVudHMgdG8gdGhlXG4gICAqIG5vZGVzIGluIHRoZSBgb3Zlck5vZGVgZXZlbnQgdG8gcGVyZm9ybSBkcmFnICYgZHJvcCBvcGVyYXRpb25zLiBJdCB1c2VzXG4gICAqIGBsaW5lYXIgaW50ZXJwb2xhdGlvbmAgW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25dXG4gICAqIGFuZCBgcm90YXRpb24gbWF0cml4YCBbaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3RhdGlvbl9tYXRyaXhdIHRvXG4gICAqIGNhbGN1bGF0ZSB0aGUgWCBhbmQgWSBjb29yZGluYXRlcyBmcm9tIHRoZSBgY2FtYCBvciBgcmVuZGVyZXJgIG5vZGVcbiAgICogYXR0cmlidXRlcy4gVGhlc2UgYXR0cmlidXRlcyByZXByZXNlbnQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBub2RlcyBpblxuICAgKiB0aGUgcmVhbCBjb250YWluZXIsIG5vdCBpbiBjYW52YXMuXG4gICAqXG4gICAqIEZpcmVkIGV2ZW50czpcbiAgICogKioqKioqKioqKioqKlxuICAgKiBzdGFydGRyYWcgIEZpcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXG4gICAqIGRyYWcgICAgICAgRmlyZWQgd2hpbGUgdGhlIG5vZGUgaXMgZHJhZ2dlZC5cbiAgICogZHJvcCAgICAgICBGaXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBkcmFnIGlmIHRoZSBub2RlIGhhcyBiZWVuIGRyYWdnZWQuXG4gICAqIGRyYWdlbmQgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgZHJhZy5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEBwYXJhbSAge3NpZ21hfSAgICBzICAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7cmVuZGVyZXJ9IHJlbmRlcmVyIFRoZSByZWxhdGVkIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gRHJhZ05vZGVzKHMsIHJlbmRlcmVyKSB7XG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIHBsdWdpbiB3aXRoIHRoZVxuICAgIC8vIFdlYkdMIHJlbmRlcmVyICh3aGljaCBpcyBpbXBvc3NpYmxlIGF0IHRoZSBtb21lbnQpOlxuICAgIC8vIGlmIChcbiAgICAvLyAgIHNpZ21hLnJlbmRlcmVycy53ZWJnbCAmJlxuICAgIC8vICAgcmVuZGVyZXIgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMud2ViZ2xcbiAgICAvLyApXG4gICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gICAgICdUaGUgc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXInXG4gICAgLy8gICApO1xuXG4gICAgLy8gSW5pdCB2YXJpYWJsZXM6XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgIF9zID0gcyxcbiAgICAgIF9ib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgIF9yZW5kZXJlciA9IHJlbmRlcmVyLFxuICAgICAgX21vdXNlID0gcmVuZGVyZXIuY29udGFpbmVyLmxhc3RDaGlsZCxcbiAgICAgIF9jYW1lcmEgPSByZW5kZXJlci5jYW1lcmEsXG4gICAgICBfbm9kZSA9IG51bGwsXG4gICAgICBfcHJlZml4ID0gJycsXG4gICAgICBfaG92ZXJTdGFjayA9IFtdLFxuICAgICAgX2hvdmVySW5kZXggPSB7fSxcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlLFxuICAgICAgX2lzTW91c2VPdmVyQ2FudmFzID0gZmFsc2UsXG4gICAgICBfZHJhZyA9IGZhbHNlO1xuXG4gICAgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLnN2Zykge1xuICAgICAgICBfbW91c2UgPSByZW5kZXJlci5jb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBJdCByZW1vdmVzIHRoZSBpbml0aWFsIHN1YnN0cmluZyAoJ3JlYWRfJykgaWYgaXQncyBhIFdlZ0dMIHJlbmRlcmVyLlxuICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy53ZWJnbCkge1xuICAgICAgX3ByZWZpeCA9IHJlbmRlcmVyLm9wdGlvbnMucHJlZml4LnN1YnN0cig1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3ByZWZpeCA9IHJlbmRlcmVyLm9wdGlvbnMucHJlZml4O1xuICAgIH1cblxuICAgIHJlbmRlcmVyLmJpbmQoJ292ZXJOb2RlJywgbm9kZU1vdXNlT3Zlcik7XG4gICAgcmVuZGVyZXIuYmluZCgnb3V0Tm9kZScsIHRyZWF0T3V0Tm9kZSk7XG4gICAgcmVuZGVyZXIuYmluZCgnY2xpY2snLCBjbGljayk7XG5cbiAgICBfcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICBfc2VsZi51bmJpbmRBbGwoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFVuYmluZCBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIHRoaXMudW5iaW5kQWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBub2RlTW91c2VNb3ZlKTtcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XG4gICAgICBfcmVuZGVyZXIudW5iaW5kKCdvdmVyTm9kZScsIG5vZGVNb3VzZU92ZXIpO1xuICAgICAgX3JlbmRlcmVyLnVuYmluZCgnb3V0Tm9kZScsIHRyZWF0T3V0Tm9kZSk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBtb3JlIGFjY3VyYXRlbHkgdGhhblxuICAgIC8vIGVsZW1lbnQub2Zmc2V0VG9wIGFuZCBlbGVtZW50Lm9mZnNldExlZnQuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgdmFyIGdldENzc1Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKS5yZXBsYWNlKCdweCcsICcnKSkgfHwgMDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBnZXRDc3NQcm9wZXJ0eSgncGFkZGluZy1sZWZ0JyksXG4gICAgICAgIHRvcDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBnZXRDc3NQcm9wZXJ0eSgncGFkZGluZy10b3AnKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcbiAgICAgIC8vIGV2ZW50IHRyaWdnZXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBjbGlja1xuICAgICAgX2lzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBub2RlTW91c2VNb3ZlKTtcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XG5cbiAgICAgIGlmICghX2hvdmVyU3RhY2subGVuZ3RoKSB7XG4gICAgICAgIF9ub2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlT3ZlcihldmVudCkge1xuICAgICAgLy8gRG9uJ3QgdHJlYXQgdGhlIG5vZGUgaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICBpZiAoX2hvdmVySW5kZXhbZXZlbnQuZGF0YS5ub2RlLmlkXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBub2RlIHRvIGFycmF5IG9mIGN1cnJlbnQgbm9kZXMgb3ZlclxuICAgICAgX2hvdmVyU3RhY2sucHVzaChldmVudC5kYXRhLm5vZGUpO1xuICAgICAgX2hvdmVySW5kZXhbZXZlbnQuZGF0YS5ub2RlLmlkXSA9IHRydWU7XG5cbiAgICAgIGlmKF9ob3ZlclN0YWNrLmxlbmd0aCAmJiAhIF9pc01vdXNlRG93bikge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgbm9kZSB0byBiZSB0aGUgbGFzdCBvbmUgaW4gdGhlIGFycmF5XG4gICAgICAgIF9ub2RlID0gX2hvdmVyU3RhY2tbX2hvdmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIF9tb3VzZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJlYXRPdXROb2RlKGV2ZW50KSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgYXJyYXlcbiAgICAgIHZhciBpbmRleENoZWNrID0gX2hvdmVyU3RhY2subWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGU7IH0pLmluZGV4T2YoZXZlbnQuZGF0YS5ub2RlKTtcbiAgICAgIF9ob3ZlclN0YWNrLnNwbGljZShpbmRleENoZWNrLCAxKTtcbiAgICAgIGRlbGV0ZSBfaG92ZXJJbmRleFtldmVudC5kYXRhLm5vZGUuaWRdO1xuXG4gICAgICBpZihfaG92ZXJTdGFjay5sZW5ndGggJiYgISBfaXNNb3VzZURvd24pIHtcbiAgICAgICAgLy8gT24gb3V0LCBzZXQgdGhlIGN1cnJlbnQgbm9kZSB0byBiZSB0aGUgbmV4dCBzdGF0ZWQgaW4gYXJyYXlcbiAgICAgICAgX25vZGUgPSBfaG92ZXJTdGFja1tfaG92ZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9tb3VzZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlRG93bihldmVudCkge1xuICAgICAgX2lzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIHZhciBzaXplID0gX3MuZ3JhcGgubm9kZXMoKS5sZW5ndGg7XG5cbiAgICAgIC8vIHdoZW4gdGhlcmUgaXMgb25seSBub2RlIGluIHRoZSBncmFwaCwgdGhlIHBsdWdpbiBjYW5ub3QgYXBwbHlcbiAgICAgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uLiBTbyB0cmVhdCBpdCBhcyBpZiBhIHVzZXIgaXMgZHJhZ2dpbmdcbiAgICAgIC8vIHRoZSBncmFwaFxuICAgICAgaWYgKF9ub2RlICYmIHNpemUgPiAxKSB7XG4gICAgICAgIF9tb3VzZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgICAgX2JvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICAgIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XG5cbiAgICAgICAgLy8gRG8gbm90IHJlZnJlc2ggZWRnZXF1YWR0cmVlIGR1cmluZyBkcmFnOlxuICAgICAgICB2YXIgayxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIGZvciAoayBpbiBfcy5jYW1lcmFzKSB7XG4gICAgICAgICAgYyA9IF9zLmNhbWVyYXNba107XG4gICAgICAgICAgaWYgKGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGMuZWRnZXF1YWR0cmVlLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVhY3RpdmF0ZSBkcmFnIGdyYXBoLlxuICAgICAgICBfcmVuZGVyZXIuc2V0dGluZ3Moe21vdXNlRW5hYmxlZDogZmFsc2UsIGVuYWJsZUhvdmVyaW5nOiBmYWxzZX0pO1xuICAgICAgICBfcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnc3RhcnRkcmFnJywge1xuICAgICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICAgIGNhcHRvcjogZXZlbnQsXG4gICAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlVXAoZXZlbnQpIHtcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgX21vdXNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuXG4gICAgICAvLyBBbGxvdyB0byByZWZyZXNoIGVkZ2VxdWFkdHJlZTpcbiAgICAgIHZhciBrLFxuICAgICAgICAgIGM7XG4gICAgICBmb3IgKGsgaW4gX3MuY2FtZXJhcykge1xuICAgICAgICBjID0gX3MuY2FtZXJhc1trXTtcbiAgICAgICAgaWYgKGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWN0aXZhdGUgZHJhZyBncmFwaC5cbiAgICAgIF9yZW5kZXJlci5zZXR0aW5ncyh7bW91c2VFbmFibGVkOiB0cnVlLCBlbmFibGVIb3ZlcmluZzogdHJ1ZX0pO1xuICAgICAgX3MucmVmcmVzaCgpO1xuXG4gICAgICBpZiAoX2RyYWcpIHtcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJvcCcsIHtcbiAgICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgICBjYXB0b3I6IGV2ZW50LFxuICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnZW5kJywge1xuICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgY2FwdG9yOiBldmVudCxcbiAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxuICAgICAgfSk7XG5cbiAgICAgIF9kcmFnID0gZmFsc2U7XG4gICAgICBfbm9kZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgPiAtMSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZU91dCk7XG4gICAgICAgIHZhciB0aW1lT3V0ID0gc2V0VGltZW91dChleGVjdXRlTm9kZU1vdXNlTW92ZSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGVjdXRlTm9kZU1vdXNlTW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleGVjdXRlTm9kZU1vdXNlTW92ZSgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGNhbGN1bGF0ZU9mZnNldChfcmVuZGVyZXIuY29udGFpbmVyKSxcbiAgICAgICAgICAgIHggPSBldmVudC5jbGllbnRYIC0gb2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WSAtIG9mZnNldC50b3AsXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhfY2FtZXJhLmFuZ2xlKSxcbiAgICAgICAgICAgIHNpbiA9IE1hdGguc2luKF9jYW1lcmEuYW5nbGUpLFxuICAgICAgICAgICAgbm9kZXMgPSBfcy5ncmFwaC5ub2RlcygpLFxuICAgICAgICAgICAgcmVmID0gW107XG5cbiAgICAgICAgLy8gR2V0dGluZyBhbmQgZGVyb3RhdGluZyB0aGUgcmVmZXJlbmNlIGNvb3JkaW5hdGVzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIGF1eCA9IHtcbiAgICAgICAgICAgIHg6IG4ueCAqIGNvcyArIG4ueSAqIHNpbixcbiAgICAgICAgICAgIHk6IG4ueSAqIGNvcyAtIG4ueCAqIHNpbixcbiAgICAgICAgICAgIHJlblg6IG5bX3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICByZW5ZOiBuW19wcmVmaXggKyAneSddLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVmLnB1c2goYXV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5aW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAvLyBpZiB0aGUgbm9kZXMgYXJlIG9uIHRvcCBvZiBlYWNoIG90aGVyLCB3ZSB1c2UgdGhlIGNhbWVyYSByYXRpbyB0byBpbnRlcnBvbGF0ZVxuICAgICAgICBpZiAocmVmWzBdLnggPT09IHJlZlsxXS54ICYmIHJlZlswXS55ID09PSByZWZbMV0ueSkge1xuICAgICAgICAgIHZhciB4UmF0aW8gPSAocmVmWzBdLnJlblggPT09IDApID8gMSA6IHJlZlswXS5yZW5YO1xuICAgICAgICAgIHZhciB5UmF0aW8gPSAocmVmWzBdLnJlblkgPT09IDApID8gMSA6IHJlZlswXS5yZW5ZO1xuICAgICAgICAgIHggPSAocmVmWzBdLnggLyB4UmF0aW8pICogKHggLSByZWZbMF0ucmVuWCkgKyByZWZbMF0ueDtcbiAgICAgICAgICB5ID0gKHJlZlswXS55IC8geVJhdGlvKSAqICh5IC0gcmVmWzBdLnJlblkpICsgcmVmWzBdLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHhSYXRpbyA9IChyZWZbMV0ucmVuWCAtIHJlZlswXS5yZW5YKSAvIChyZWZbMV0ueCAtIHJlZlswXS54KTtcbiAgICAgICAgICB2YXIgeVJhdGlvID0gKHJlZlsxXS5yZW5ZIC0gcmVmWzBdLnJlblkpIC8gKHJlZlsxXS55IC0gcmVmWzBdLnkpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgc2FtZSwgd2UgdXNlIHRoZSBvdGhlciByYXRpbyB0byBpbnRlcnBvbGF0ZVxuICAgICAgICAgIGlmIChyZWZbMV0ueCA9PT0gcmVmWzBdLngpIHtcbiAgICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVmWzFdLnkgPT09IHJlZlswXS55KSB7XG4gICAgICAgICAgICB5UmF0aW8gPSB4UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeCA9ICh4IC0gcmVmWzBdLnJlblgpIC8geFJhdGlvICsgcmVmWzBdLng7XG4gICAgICAgICAgeSA9ICh5IC0gcmVmWzBdLnJlblkpIC8geVJhdGlvICsgcmVmWzBdLnk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSb3RhdGluZyB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICAgIF9ub2RlLnggPSB4ICogY29zIC0geSAqIHNpbjtcbiAgICAgICAgX25vZGUueSA9IHkgKiBjb3MgKyB4ICogc2luO1xuXG4gICAgICAgIF9zLnJlZnJlc2goKTtcblxuICAgICAgICBfZHJhZyA9IHRydWU7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnLCB7XG4gICAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgICAgY2FwdG9yOiBldmVudCxcbiAgICAgICAgICByZW5kZXJlcjogX3JlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICpcbiAgICogPiB2YXIgZHJhZ05vZGVzTGlzdGVuZXIgPSBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyhzLCBzLnJlbmRlcmVyc1swXSk7XG4gICAqL1xuICB2YXIgX2luc3RhbmNlID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge3NpZ21hfSBzIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gIHtyZW5kZXJlcn0gcmVuZGVyZXIgVGhlIHJlbGF0ZWQgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyA9IGZ1bmN0aW9uKHMsIHJlbmRlcmVyKSB7XG4gICAgLy8gQ3JlYXRlIG9iamVjdCBpZiB1bmRlZmluZWRcbiAgICBpZiAoIV9pbnN0YW5jZVtzLmlkXSkge1xuICAgICAgX2luc3RhbmNlW3MuaWRdID0gbmV3IERyYWdOb2RlcyhzLCByZW5kZXJlcik7XG4gICAgfVxuXG4gICAgcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS5wbHVnaW5zLmtpbGxEcmFnTm9kZXMocyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2luc3RhbmNlW3MuaWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgYW5kIGtpbGxzIHRoZSBkcmFnTm9kZXMgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge3NpZ21hfSBzIFRoZSByZWxhdGVkIHNpZ21hIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucGx1Z2lucy5raWxsRHJhZ05vZGVzID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChfaW5zdGFuY2Vbcy5pZF0gaW5zdGFuY2VvZiBEcmFnTm9kZXMpIHtcbiAgICAgIF9pbnN0YW5jZVtzLmlkXS51bmJpbmRBbGwoKTtcbiAgICAgIGRlbGV0ZSBfaW5zdGFuY2Vbcy5pZF07XG4gICAgfVxuICB9O1xuXG59KS5jYWxsKHdpbmRvdyk7XG4iLCI7KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWlkZGxld2FyZSB3aWxsIHJlc2NhbGUgdGhlIGdyYXBoIHN1Y2ggdGhhdCBpdCB0YWtlcyBhbiBvcHRpbWFsIHNwYWNlXG4gICAqIG9uIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQXMgZWFjaCBtaWRkbGV3YXJlLCB0aGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBzY29wZSBvZiB0aGUgc2lnbWFcbiAgICogaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgVGhlIHBhcmFtZXRlcnMuXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5yZXNjYWxlID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZCxcbiAgICAgICAgc2NhbGUsXG4gICAgICAgIG1hcmdpbixcbiAgICAgICAgbiA9IHRoaXMuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgZSA9IHRoaXMuZ3JhcGguZWRnZXMoKSxcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgYm91bmRzID0gc2V0dGluZ3MoJ2JvdW5kcycpIHx8IHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMoXG4gICAgICAgICAgdGhpcy5ncmFwaCxcbiAgICAgICAgICByZWFkUHJlZml4LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKSxcbiAgICAgICAgbWluWCA9IGJvdW5kcy5taW5YLFxuICAgICAgICBtaW5ZID0gYm91bmRzLm1pblksXG4gICAgICAgIG1heFggPSBib3VuZHMubWF4WCxcbiAgICAgICAgbWF4WSA9IGJvdW5kcy5tYXhZLFxuICAgICAgICBzaXplTWF4ID0gYm91bmRzLnNpemVNYXgsXG4gICAgICAgIHdlaWdodE1heCA9IGJvdW5kcy53ZWlnaHRNYXgsXG4gICAgICAgIHcgPSBzZXR0aW5ncygnd2lkdGgnKSB8fCAxLFxuICAgICAgICBoID0gc2V0dGluZ3MoJ2hlaWdodCcpIHx8IDEsXG4gICAgICAgIHJlc2NhbGVTZXR0aW5ncyA9IHNldHRpbmdzKCdhdXRvUmVzY2FsZScpLFxuICAgICAgICB2YWxpZFNldHRpbmdzID0ge1xuICAgICAgICAgIG5vZGVQb3NpdGlvbjogMSxcbiAgICAgICAgICBub2RlU2l6ZTogMSxcbiAgICAgICAgICBlZGdlU2l6ZTogMVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBlbGVtZW50cyBzaG91bGQgd2UgcmVzY2FsZT9cbiAgICAgKi9cbiAgICBpZiAoIShyZXNjYWxlU2V0dGluZ3MgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICByZXNjYWxlU2V0dGluZ3MgPSBbJ25vZGVQb3NpdGlvbicsICdub2RlU2l6ZScsICdlZGdlU2l6ZSddO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHJlc2NhbGVTZXR0aW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAoIXZhbGlkU2V0dGluZ3NbcmVzY2FsZVNldHRpbmdzW2ldXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgcmVzY2FsZSBzZXR0aW5nIFwiJyArIHJlc2NhbGVTZXR0aW5nc1tpXSArICdcIiBpcyBub3QgcmVjb2duaXplZC4nXG4gICAgICAgICk7XG5cbiAgICB2YXIgbnAgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVQb3NpdGlvbicpLFxuICAgICAgICBucyA9IH5yZXNjYWxlU2V0dGluZ3MuaW5kZXhPZignbm9kZVNpemUnKSxcbiAgICAgICAgZXMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ2VkZ2VTaXplJyk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCwgd2UgY29tcHV0ZSB0aGUgc2NhbGluZyByYXRpbywgd2l0aG91dCBjb25zaWRlcmluZyB0aGUgc2l6ZXNcbiAgICAgKiBvZiB0aGUgbm9kZXMgOiBFYWNoIG5vZGUgd2lsbCBoYXZlIGl0cyBjZW50ZXIgaW4gdGhlIGNhbnZhcywgYnV0IG1pZ2h0XG4gICAgICogYmUgcGFydGlhbGx5IG91dCBvZiBpdC5cbiAgICAgKi9cbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvKipcbiAgICAgKiBUaGVuLCB3ZSBjb3JyZWN0IHRoYXQgc2NhbGluZyByYXRpbyBjb25zaWRlcmluZyBhIG1hcmdpbiwgd2hpY2ggaXNcbiAgICAgKiBiYXNpY2FsbHkgdGhlIHNpemUgb2YgdGhlIGJpZ2dlc3Qgbm9kZS5cbiAgICAgKiBUaGlzIGhhcyB0byBiZSBkb25lIGFzIGEgY29ycmVjdGlvbiBzaW5jZSB0byBjb21wYXJlIHRoZSBzaXplIG9mIHRoZVxuICAgICAqIGJpZ2dlc3Qgbm9kZSB0byB0aGUgWCBhbmQgWSB2YWx1ZXMsIHdlIGhhdmUgdG8gZmlyc3QgZ2V0IGFuXG4gICAgICogYXBwcm94aW1hdGlvbiBvZiB0aGUgc2NhbGluZyByYXRpby5cbiAgICAgKiovXG4gICAgbWFyZ2luID1cbiAgICAgIChcbiAgICAgICAgc2V0dGluZ3MoJ3Jlc2NhbGVJZ25vcmVTaXplJykgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSB8fCBzaXplTWF4KSAvIHNjYWxlXG4gICAgICApICtcbiAgICAgIChzZXR0aW5ncygnc2lkZU1hcmdpbicpIHx8IDApO1xuICAgIG1heFggKz0gbWFyZ2luO1xuICAgIG1pblggLT0gbWFyZ2luO1xuICAgIG1heFkgKz0gbWFyZ2luO1xuICAgIG1pblkgLT0gbWFyZ2luO1xuXG4gICAgLy8gRml4IHRoZSBzY2FsaW5nIHdpdGggdGhlIG5ldyBleHRyZW1hOlxuICAgIHNjYWxlID0gc2V0dGluZ3MoJ3NjYWxpbmdNb2RlJykgPT09ICdvdXRzaWRlJyA/XG4gICAgICBNYXRoLm1heChcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKSA6XG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcbiAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxuICAgICAgKTtcblxuICAgIC8vIFNpemUgaG9tb3RoZXRpYyBwYXJhbWV0ZXJzOlxuICAgIGlmICghc2V0dGluZ3MoJ21heE5vZGVTaXplJykgJiYgIXNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XG4gICAgICBhID0gMTtcbiAgICAgIGIgPSAwO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgPT09IHNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XG4gICAgICBhID0gMDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21heE5vZGVTaXplJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgLSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkgLyBzaXplTWF4O1xuICAgICAgYiA9ICtzZXR0aW5ncygnbWluTm9kZVNpemUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXNldHRpbmdzKCdtYXhFZGdlU2l6ZScpICYmICFzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xuICAgICAgYyA9IDE7XG4gICAgICBkID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpID09PSBzZXR0aW5ncygnbWluRWRnZVNpemUnKSkge1xuICAgICAgYyA9IDA7XG4gICAgICBkID0gK3NldHRpbmdzKCdtaW5FZGdlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjID0gKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIC8gd2VpZ2h0TWF4O1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9XG5cbiAgICAvLyBSZXNjYWxlIHRoZSBub2RlcyBhbmQgZWRnZXM6XG4gICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgZVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBlW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKGVzID8gYyA6IDEpICsgKGVzID8gZCA6IDApO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3NpemUnXSA9XG4gICAgICAgIG5baV1bcmVhZFByZWZpeCArICdzaXplJ10gKiAobnMgPyBhIDogMSkgKyAobnMgPyBiIDogMCk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneCddIC0gKG1heFggKyBtaW5YKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneSddID1cbiAgICAgICAgKG5baV1bcmVhZFByZWZpeCArICd5J10gLSAobWF4WSArIG1pblkpIC8gMikgKiAobnAgPyBzY2FsZSA6IDEpO1xuICAgIH1cbiAgfTtcblxuICBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24oZ3JhcGgsIHByZWZpeCwgZG9FZGdlcykge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBlID0gZ3JhcGguZWRnZXMoKSxcbiAgICAgICAgbiA9IGdyYXBoLm5vZGVzKCksXG4gICAgICAgIHdlaWdodE1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgc2l6ZU1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWluWCA9IEluZmluaXR5LFxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBpZiAoZG9FZGdlcylcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgd2VpZ2h0TWF4ID0gTWF0aC5tYXgoZVtpXVtwcmVmaXggKyAnc2l6ZSddLCB3ZWlnaHRNYXgpO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzaXplTWF4ID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAnc2l6ZSddLCBzaXplTWF4KTtcbiAgICAgIG1heFggPSBNYXRoLm1heChuW2ldW3ByZWZpeCArICd4J10sIG1heFgpO1xuICAgICAgbWluWCA9IE1hdGgubWluKG5baV1bcHJlZml4ICsgJ3gnXSwgbWluWCk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneSddLCBtYXhZKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd5J10sIG1pblkpO1xuICAgIH1cblxuICAgIHdlaWdodE1heCA9IHdlaWdodE1heCB8fCAxO1xuICAgIHNpemVNYXggPSBzaXplTWF4IHx8IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2VpZ2h0TWF4OiB3ZWlnaHRNYXgsXG4gICAgICBzaXplTWF4OiBzaXplTWF4LFxuICAgICAgbWluWDogbWluWCxcbiAgICAgIG1pblk6IG1pblksXG4gICAgICBtYXhYOiBtYXhYLFxuICAgICAgbWF4WTogbWF4WVxuICAgIH07XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYXJyYXlzID0gcmVxdWlyZShcIi4vYXJyYXlzXCIpO1xudmFyIExpbmtlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGFuIGVtcHR5IExpbmtlZCBMaXN0LlxuICAgICogQGNsYXNzIEEgbGlua2VkIGxpc3QgaXMgYSBkYXRhIHN0cnVjdHVyZSBjb25zaXN0aW5nIG9mIGEgZ3JvdXAgb2Ygbm9kZXNcbiAgICAqIHdoaWNoIHRvZ2V0aGVyIHJlcHJlc2VudCBhIHNlcXVlbmNlLlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuICAgICAgICAvKipcbiAgICAgICAgKiBGaXJzdCBub2RlIGluIHRoZSBsaXN0XG4gICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAqIExhc3Qgbm9kZSBpbiB0aGUgbGlzdFxuICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbGlzdFxuICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uRWxlbWVudHMgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGlzIGxpc3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBlbGVtZW50IHRvIGJlIGFkZGVkLlxuICAgICogQHBhcmFtIHtudW1iZXI9fSBpbmRleCBvcHRpb25hbCBpbmRleCB0byBhZGQgdGhlIGVsZW1lbnQuIElmIG5vIGluZGV4IGlzIHNwZWNpZmllZFxuICAgICogdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGlzIGxpc3QuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IHdhcyBhZGRlZCBvciBmYWxzZSBpZiB0aGUgaW5kZXggaXMgaW52YWxpZFxuICAgICogb3IgaWYgdGhlIGVsZW1lbnQgaXMgdW5kZWZpbmVkLlxuICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLm5FbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5uRWxlbWVudHMgfHwgdXRpbC5pc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5jcmVhdGVOb2RlKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5uRWxlbWVudHMgPT09IDAgfHwgdGhpcy5sYXN0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmlyc3Qgbm9kZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLm5FbGVtZW50cykge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGF0IHRoZSBlbmQuXG4gICAgICAgICAgICB0aGlzLmxhc3ROb2RlLm5leHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIC8vIENoYW5nZSBmaXJzdCBub2RlLlxuICAgICAgICAgICAgbmV3Tm9kZS5uZXh0ID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMubm9kZUF0SW5kZXgoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdOb2RlLm5leHQgPSBwcmV2Lm5leHQ7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubkVsZW1lbnRzKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgbGlzdC5cbiAgICAqIEByZXR1cm4geyp9IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0IG9yIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBpc1xuICAgICogZW1wdHkuXG4gICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3ROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdE5vZGUuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhpcyBsaXN0LlxuICAgICogQHJldHVybiB7Kn0gdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgbGlzdCBvciB1bmRlZmluZWQgaWYgdGhlIGxpc3QgaXNcbiAgICAqIGVtcHR5LlxuICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3ROb2RlLmVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpbiB0aGlzIGxpc3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGRlc2lyZWQgaW5kZXguXG4gICAgICogQHJldHVybiB7Kn0gdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5kZXggaXNcbiAgICAgKiBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmVsZW1lbnRBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlQXRJbmRleChpbmRleCk7XG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBpbiB0aGlzIGxpc3Qgb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlXG4gICAgICogc3BlY2lmaWVkIGVsZW1lbnQsIG9yIC0xIGlmIHRoZSBMaXN0IGRvZXMgbm90IGNvbnRhaW4gdGhpcyBlbGVtZW50LlxuICAgICAqIDxwPklmIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhpcyBsaXN0IGFyZVxuICAgICAqIG5vdCBjb21wYXJhYmxlIHdpdGggdGhlID09PSBvcGVyYXRvciBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICogcHJvdmlkZWQgdG8gcGVyZm9ybSBzZWFyY2hlcywgdGhlIGZ1bmN0aW9uIG11c3QgcmVjZWl2ZSB0d28gYXJndW1lbnRzIGFuZFxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgPSBmdW5jdGlvbihwZXQxLCBwZXQyKSB7XG4gICAgICogIHJldHVybiBwZXQxLm5hbWUgPT09IHBldDIubmFtZTtcbiAgICAgKiB9XG4gICAgICogPC9wcmU+XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIE9wdGlvbmFsXG4gICAgICogZnVuY3Rpb24gdXNlZCB0byBjaGVjayBpZiB0d28gZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IGluIHRoaXMgbGlzdCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZVxuICAgICAqIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCwgb3IgLTEgaWYgdGhpcyBsaXN0IGRvZXMgbm90IGNvbnRhaW4gdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBlcXVhbHNGID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbHNGKGN1cnJlbnROb2RlLmVsZW1lbnQsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAgICogPHA+SWYgdGhlIGVsZW1lbnRzIGluc2lkZSB0aGUgbGlzdCBhcmVcbiAgICAgICAqIG5vdCBjb21wYXJhYmxlIHdpdGggdGhlID09PSBvcGVyYXRvciBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICAgKiBwcm92aWRlZCB0byBwZXJmb3JtIHNlYXJjaGVzLCB0aGUgZnVuY3Rpb24gbXVzdCByZWNlaXZlIHR3byBhcmd1bWVudHMgYW5kXG4gICAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBFeGFtcGxlOjwvcD5cbiAgICAgICAqXG4gICAgICAgKiA8cHJlPlxuICAgICAgICogY29uc3QgcGV0c0FyZUVxdWFsQnlOYW1lID0gZnVuY3Rpb24ocGV0MSwgcGV0Mikge1xuICAgICAgICogIHJldHVybiBwZXQxLm5hbWUgPT09IHBldDIubmFtZTtcbiAgICAgICAqIH1cbiAgICAgICAqIDwvcHJlPlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gT3B0aW9uYWxcbiAgICAgICAqIGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgaWYgdHdvIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBsaXN0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudCwgZmFsc2VcbiAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleE9mKGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSA+PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoaXMgbGlzdC5cbiAgICAgKiA8cD5JZiB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZSBsaXN0IGFyZVxuICAgICAqIG5vdCBjb21wYXJhYmxlIHdpdGggdGhlID09PSBvcGVyYXRvciBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICogcHJvdmlkZWQgdG8gcGVyZm9ybSBzZWFyY2hlcywgdGhlIGZ1bmN0aW9uIG11c3QgcmVjZWl2ZSB0d28gYXJndW1lbnRzIGFuZFxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgPSBmdW5jdGlvbihwZXQxLCBwZXQyKSB7XG4gICAgICogIHJldHVybiBwZXQxLm5hbWUgPT09IHBldDIubmFtZTtcbiAgICAgKiB9XG4gICAgICogPC9wcmU+XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gZWxlbWVudCB0byBiZSByZW1vdmVkIGZyb20gdGhpcyBsaXN0LCBpZiBwcmVzZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGxpc3QgY29udGFpbmVkIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGVxdWFsc0YgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgICAgIGlmICh0aGlzLm5FbGVtZW50cyA8IDEgfHwgdXRpbC5pc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbHNGKGN1cnJlbnROb2RlLmVsZW1lbnQsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMubGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5FbGVtZW50cy0tO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBvZiB0aGUgZWxlbWVudHMgZnJvbSB0aGlzIGxpc3QuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubkVsZW1lbnRzID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpc3QgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxpc3QuXG4gICAgICogVHdvIGxpc3RzIGFyZSBlcXVhbCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICogQHBhcmFtIHtMaW5rZWRMaXN0fSBvdGhlciB0aGUgb3RoZXIgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbFxuICAgICAqIGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgaWYgdHdvIGVsZW1lbnRzIGFyZSBlcXVhbC4gSWYgdGhlIGVsZW1lbnRzIGluIHRoZSBsaXN0c1xuICAgICAqIGFyZSBjdXN0b20gb2JqZWN0cyB5b3Ugc2hvdWxkIHByb3ZpZGUgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlXG4gICAgICogdGhlID09PSBvcGVyYXRvciBpcyB1c2VkIHRvIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gZWxlbWVudHMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxpc3QgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxpc3QuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyLCBlcXVhbHNGdW5jdGlvbikge1xuICAgICAgICB2YXIgZXFGID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIExpbmtlZExpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpICE9PSBvdGhlci5zaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHNBdXgodGhpcy5maXJzdE5vZGUsIG90aGVyLmZpcnN0Tm9kZSwgZXFGKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmVxdWFsc0F1eCA9IGZ1bmN0aW9uIChuMSwgbjIsIGVxRikge1xuICAgICAgICB3aGlsZSAobjEgIT09IG51bGwgJiYgbjIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghZXFGKG4xLmVsZW1lbnQsIG4yLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbjEgPSBuMS5uZXh0O1xuICAgICAgICAgICAgbjIgPSBuMi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoaXMgbGlzdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggZ2l2ZW4gaW5kZXguXG4gICAgICogQHJldHVybiB7Kn0gcmVtb3ZlZCBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVFbGVtZW50QXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubkVsZW1lbnRzIHx8IHRoaXMuZmlyc3ROb2RlID09PSBudWxsIHx8IHRoaXMubGFzdE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLm5FbGVtZW50cyA9PT0gMSkge1xuICAgICAgICAgICAgLy9GaXJzdCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZmlyc3ROb2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMubm9kZUF0SW5kZXgoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmZpcnN0Tm9kZS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3ROb2RlID0gdGhpcy5maXJzdE5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZXZpb3VzLm5leHQgPT09IHRoaXMubGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5sYXN0Tm9kZS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAhPT0gbnVsbCAmJiBwcmV2aW91cy5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHByZXZpb3VzLm5leHQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gcHJldmlvdXMubmV4dC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubkVsZW1lbnRzLS07XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoaXMgbGlzdCBpbiBvcmRlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6Kn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgaXQgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiB0aGUgZWxlbWVudCB2YWx1ZSwgdG8gYnJlYWsgdGhlIGl0ZXJhdGlvbiB5b3UgY2FuXG4gICAgICogb3B0aW9uYWxseSByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmZpcnN0Tm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soY3VycmVudE5vZGUuZWxlbWVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBvcmRlciBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBsaW5rZWQgbGlzdCAobWFrZXMgdGhlIGxhc3RcbiAgICAgKiBlbGVtZW50IGZpcnN0LCBhbmQgdGhlIGZpcnN0IGVsZW1lbnQgbGFzdCkuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmZpcnN0Tm9kZTtcbiAgICAgICAgdmFyIHRlbXAgPSBudWxsO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IHRoaXMubGFzdE5vZGU7XG4gICAgICAgIHRoaXMubGFzdE5vZGUgPSB0ZW1wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBsaXN0IGluIHByb3BlclxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjwqPn0gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoaXMgbGlzdCxcbiAgICAgKiBpbiBwcm9wZXIgc2VxdWVuY2UuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2goY3VycmVudE5vZGUuZWxlbWVudCk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoaXMgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhpcyBsaXN0LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5FbGVtZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgbm8gZWxlbWVudHMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgbm8gZWxlbWVudHMuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubkVsZW1lbnRzIDw9IDA7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5cy50b1N0cmluZyh0aGlzLnRvQXJyYXkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLm5vZGVBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5uRWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gKHRoaXMubkVsZW1lbnRzIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3ROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXggJiYgbm9kZSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogaXRlbSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTsgLy8gRW5kIG9mIGxpbmtlZCBsaXN0XG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rZWRMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlua2VkTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaW5rZWRMaXN0XzEgPSByZXF1aXJlKFwiLi9MaW5rZWRMaXN0XCIpO1xudmFyIFF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgcXVldWUuXG4gICAgICogQGNsYXNzIEEgcXVldWUgaXMgYSBGaXJzdC1Jbi1GaXJzdC1PdXQgKEZJRk8pIGRhdGEgc3RydWN0dXJlLCB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGFkZGVkIHRvIHRoZSBxdWV1ZSB3aWxsIGJlIHRoZSBmaXJzdCBvbmUgdG8gYmUgcmVtb3ZlZC4gVGhpc1xuICAgICAqIGltcGxlbWVudGF0aW9uIHVzZXMgYSBsaW5rZWQgbGlzdCBhcyBhIGNvbnRhaW5lci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IExpbmtlZExpc3RfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGludG8gdGhlIGVuZCBvZiB0aGlzIHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIHRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IHdhcyBpbnNlcnRlZCwgb3IgZmFsc2UgaWYgaXQgaXMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5hZGQoZWxlbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpbnRvIHRoZSBlbmQgb2YgdGhpcyBxdWV1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCB3YXMgaW5zZXJ0ZWQsIG9yIGZhbHNlIGlmIGl0IGlzIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5hZGQoZWxlbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW5kIHJlbW92ZXMgdGhlIGhlYWQgb2YgdGhpcyBxdWV1ZS5cbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgaGVhZCBvZiB0aGlzIHF1ZXVlLCBvciB1bmRlZmluZWQgaWYgdGhpcyBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplKCkgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMubGlzdC5maXJzdCgpO1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZUVsZW1lbnRBdEluZGV4KDApO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMsIGJ1dCBkb2VzIG5vdCByZW1vdmUsIHRoZSBoZWFkIG9mIHRoaXMgcXVldWUuXG4gICAgICogQHJldHVybiB7Kn0gdGhlIGhlYWQgb2YgdGhpcyBxdWV1ZSwgb3IgdW5kZWZpbmVkIGlmIHRoaXMgcXVldWUgaXMgZW1wdHkuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3Quc2l6ZSgpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LmZpcnN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGlzIHF1ZXVlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGlzIHF1ZXVlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LnNpemUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHF1ZXVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKiA8cD5JZiB0aGUgZWxlbWVudHMgaW5zaWRlIHRoaXMgc3RhY2sgYXJlXG4gICAgICogbm90IGNvbXBhcmFibGUgd2l0aCB0aGUgPT09IG9wZXJhdG9yLCBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICogcHJvdmlkZWQgdG8gcGVyZm9ybSBzZWFyY2hlcywgdGhlIGZ1bmN0aW9uIG11c3QgcmVjZWl2ZSB0d28gYXJndW1lbnRzIGFuZFxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgKHBldDEsIHBldDIpIHtcbiAgICAgKiAgcmV0dXJuIHBldDEubmFtZSA9PT0gcGV0Mi5uYW1lO1xuICAgICAqIH1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWxcbiAgICAgKiBmdW5jdGlvbiB0byBjaGVjayBpZiB0d28gZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBxdWV1ZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChlbGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmNvbnRhaW5zKGVsZW0sIGVxdWFsc0Z1bmN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYW5kIG9ubHkgaWYgdGhpcyBxdWV1ZSBjb250YWlucyBubyBpdGVtczsgZmFsc2VcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2l6ZSgpIDw9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBvZiB0aGUgZWxlbWVudHMgZnJvbSB0aGlzIHF1ZXVlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0LmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnQgaW4gdGhpcyBxdWV1ZSBpblxuICAgICAqIEZJRk8gb3JkZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpOip9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIGl0IGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogdGhlIGVsZW1lbnQgdmFsdWUsIHRvIGJyZWFrIHRoZSBpdGVyYXRpb24geW91IGNhblxuICAgICAqIG9wdGlvbmFsbHkgcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBRdWV1ZTtcbn0oKSk7IC8vIEVuZCBvZiBxdWV1ZVxuZXhwb3J0cy5kZWZhdWx0ID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBpdGVtXG4gKiB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheS40XG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSBpbiB3aGljaCB0byBzZWFyY2ggdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSB0aGUgZWxlbWVudCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbCBmdW5jdGlvbiB1c2VkIHRvXG4gKiBjaGVjayBlcXVhbGl0eSBiZXR3ZWVuIDIgZWxlbWVudHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcbiAqIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGFycmF5LCBvciAtMSBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgdmFyIGVxdWFscyA9IGVxdWFsc0Z1bmN0aW9uIHx8IHV0aWwuZGVmYXVsdEVxdWFscztcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFscyhhcnJheVtpXSwgaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG4vKipcbiAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50XG4gKiB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gYXJyYXkgdGhlIGFycmF5IGluIHdoaWNoIHRvIHNlYXJjaCB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHRoZSBlbGVtZW50IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50XG4gKiB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheSBvciAtMSBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBlcXVhbHMgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGVxdWFscyhhcnJheVtpXSwgaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydHMubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBhcnJheSB0aGUgYXJyYXkgaW4gd2hpY2ggdG8gc2VhcmNoIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gdGhlIGVsZW1lbnQgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBhcnJheSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHJldHVybiBpbmRleE9mKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikgPj0gMDtcbn1cbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcbi8qKlxuICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoZSBzcGVjaWZpZWQgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSBpbiB3aGljaCB0byBzZWFyY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHRoZSBlbGVtZW50IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gKiBjaGVjayBlcXVhbGl0eSBiZXR3ZWVuIDIgZWxlbWVudHMuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcnJheSBjaGFuZ2VkIGFmdGVyIHRoaXMgY2FsbC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IGluZGV4T2YoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCBhcnJheSBlcXVhbFxuICogdG8gdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSB0aGUgYXJyYXkgaW4gd2hpY2ggdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY3kgb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSB0aGUgZWxlbWVudCB3aG9zZSBmcmVxdWVuY3kgaXMgdG8gYmUgZGV0ZXJtaW5lZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIGFycmF5XG4gKiBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZnJlcXVlbmN5KGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBlcXVhbHMgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgZnJlcSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzKGFycmF5W2ldLCBpdGVtKSkge1xuICAgICAgICAgICAgZnJlcSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmVxO1xufVxuZXhwb3J0cy5mcmVxdWVuY3kgPSBmcmVxdWVuY3k7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIHNwZWNpZmllZCBhcnJheXMgYXJlIGVxdWFsIHRvIG9uZSBhbm90aGVyLlxuICogVHdvIGFycmF5cyBhcmUgY29uc2lkZXJlZCBlcXVhbCBpZiBib3RoIGFycmF5cyBjb250YWluIHRoZSBzYW1lIG51bWJlclxuICogb2YgZWxlbWVudHMsIGFuZCBhbGwgY29ycmVzcG9uZGluZyBwYWlycyBvZiBlbGVtZW50cyBpbiB0aGUgdHdvXG4gKiBhcnJheXMgYXJlIGVxdWFsIGFuZCBhcmUgaW4gdGhlIHNhbWUgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheTEgb25lIGFycmF5IHRvIGJlIHRlc3RlZCBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheTIgdGhlIG90aGVyIGFycmF5IHRvIGJlIHRlc3RlZCBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbCBmdW5jdGlvbiB1c2VkIHRvXG4gKiBjaGVjayBlcXVhbGl0eSBiZXR3ZWVuIGVsZW1lbWVudHMgaW4gdGhlIGFycmF5cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhcnJheTEsIGFycmF5MiwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICB2YXIgZXF1YWxzID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgIGlmIChhcnJheTEubGVuZ3RoICE9PSBhcnJheTIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5MS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFscyhhcnJheTFbaV0sIGFycmF5MltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuLyoqXG4gKiBSZXR1cm5zIHNoYWxsb3cgYSBjb3B5IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSB0byBjb3B5LlxuICogQHJldHVybiB7QXJyYXl9IGEgY29weSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvcHkoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuY29uY2F0KCk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuLyoqXG4gKiBTd2FwcyB0aGUgZWxlbWVudHMgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbnMgaW4gdGhlIHNwZWNpZmllZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBpbiB3aGljaCB0byBzd2FwIGVsZW1lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGkgdGhlIGluZGV4IG9mIG9uZSBlbGVtZW50IHRvIGJlIHN3YXBwZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaiB0aGUgaW5kZXggb2YgdGhlIG90aGVyIGVsZW1lbnQgdG8gYmUgc3dhcHBlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFycmF5IGlzIGRlZmluZWQgYW5kIHRoZSBpbmRleGVzIGFyZSB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnJheSwgaSwgaikge1xuICAgIGlmIChpIDwgMCB8fCBpID49IGFycmF5Lmxlbmd0aCB8fCBqIDwgMCB8fCBqID49IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnN3YXAgPSBzd2FwO1xuZnVuY3Rpb24gdG9TdHJpbmcoYXJyYXkpIHtcbiAgICByZXR1cm4gJ1snICsgYXJyYXkudG9TdHJpbmcoKSArICddJztcbn1cbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoaXMgYXJyYXlcbiAqIHN0YXJ0aW5nIGZyb20gaW5kZXggMCB0byBsZW5ndGggLSAxLlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IGluIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6Kn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgaXQgaXNcbiAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6IHRoZSBlbGVtZW50IHZhbHVlLCB0byBicmVhayB0aGUgaXRlcmF0aW9uIHlvdSBjYW5cbiAqIG9wdGlvbmFsbHkgcmV0dXJuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyYXlfMSA9IGFycmF5OyBfaSA8IGFycmF5XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhcnJheV8xW19pXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGVsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5leHBvcnRzLmhhcyA9IGZ1bmN0aW9uIChvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn07XG4vKipcbiAqIERlZmF1bHQgZnVuY3Rpb24gdG8gY29tcGFyZSBlbGVtZW50IG9yZGVyLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0Q29tcGFyZSA9IGRlZmF1bHRDb21wYXJlO1xuLyoqXG4gKiBEZWZhdWx0IGZ1bmN0aW9uIHRvIHRlc3QgZXF1YWxpdHkuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5leHBvcnRzLmRlZmF1bHRFcXVhbHMgPSBkZWZhdWx0RXF1YWxzO1xuLyoqXG4gKiBEZWZhdWx0IGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb2JqZWN0IHRvIGEgc3RyaW5nLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUb1N0cmluZyhpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdDT0xMRUNUSU9OX05VTEwnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICByZXR1cm4gJ0NPTExFQ1RJT05fVU5ERUZJTkVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuICckcycgKyBpdGVtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICckbycgKyBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0VG9TdHJpbmcgPSBkZWZhdWx0VG9TdHJpbmc7XG4vKipcbiogSm9pbnMgYWxsIHRoZSBwcm9wZXJpZXMgb2YgdGhlIG9iamVjdCB1c2luZyB0aGUgcHJvdmlkZWQgam9pbiBzdHJpbmdcbiovXG5mdW5jdGlvbiBtYWtlU3RyaW5nKGl0ZW0sIGpvaW4pIHtcbiAgICBpZiAoam9pbiA9PT0gdm9pZCAwKSB7IGpvaW4gPSAnLCc7IH1cbiAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ0NPTExFQ1RJT05fTlVMTCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiAnQ09MTEVDVElPTl9VTkRFRklORUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyhpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRvcmV0ID0gJ3snO1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLmhhcyhpdGVtLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9yZXQgPSB0b3JldCArIGpvaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvcmV0ID0gdG9yZXQgKyBwcm9wICsgJzonICsgaXRlbVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9yZXQgKyAnfSc7XG4gICAgfVxufVxuZXhwb3J0cy5tYWtlU3RyaW5nID0gbWFrZVN0cmluZztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiAodHlwZW9mIGZ1bmMpID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyB1bmRlZmluZWQuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqKSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYSBzdHJpbmcuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbi8qKlxuICogUmV2ZXJzZXMgYSBjb21wYXJlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VDb21wYXJlRnVuY3Rpb24oY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGNvbXBhcmVGdW5jdGlvbikgfHwgIWlzRnVuY3Rpb24oY29tcGFyZUZ1bmN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUZ1bmN0aW9uKGQsIHYpICogLTE7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5yZXZlcnNlQ29tcGFyZUZ1bmN0aW9uID0gcmV2ZXJzZUNvbXBhcmVGdW5jdGlvbjtcbi8qKlxuICogUmV0dXJucyBhbiBlcXVhbCBmdW5jdGlvbiBnaXZlbiBhIGNvbXBhcmUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29tcGFyZVRvRXF1YWxzKGNvbXBhcmVGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZUZ1bmN0aW9uKGEsIGIpID09PSAwO1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBhcmVUb0VxdWFscyA9IGNvbXBhcmVUb0VxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiLyogLy8vIDxyZWZlcmVuY2UgcGF0aD1cInNjcmlwdGluZy50c1wiLz4gKi9cbmltcG9ydCB7XG4gICAgYWRkQWdlbnQsIHNldEFnZW50VmFyaWFibGUsIGFkZEl0ZW0sIGFkZExvY2F0aW9uLCBzZXRWYXJpYWJsZSwgZ2V0TmV4dExvY2F0aW9uLCBhY3Rpb24sXG4gICAgZ2V0UmFuZE51bWJlciwgZ2V0VmFyaWFibGUsIHNlcXVlbmNlLCBzZWxlY3RvciwgZXhlY3V0ZSwgUHJlY29uZGl0aW9uLCBnZXRBZ2VudFZhcmlhYmxlLCBuZWdfZ3VhcmQsIGd1YXJkLFxuICAgIGlzVmFyaWFibGVOb3RTZXQsIGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbiwgYWRkVXNlckFjdGlvbiwgYWRkVXNlckludGVyYWN0aW9uVHJlZSwgaW5pdGlhbGl6ZSxcbiAgICBnZXRVc2VySW50ZXJhY3Rpb25PYmplY3QsIGV4ZWN1dGVVc2VyQWN0aW9uLCB3b3JsZFRpY2ssIGF0dGFjaFRyZWVUb0FnZW50LCBzZXRJdGVtVmFyaWFibGUsIGdldEl0ZW1WYXJpYWJsZSxcbiAgICBkaXNwbGF5QWN0aW9uRWZmZWN0VGV4dCwgYXJlQWRqYWNlbnQsIGFkZFVzZXJBY3Rpb25UcmVlLCBsb2NhdGlvbkdyYXBoLCBUaWNrXG59IGZyb20gXCIuL3NjcmlwdGluZ1wiO1xuaW1wb3J0IHtpc1VuZGVmaW5lZH0gZnJvbSBcInR5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvdXRpbFwiO1xuXG5sZXQgZmlsZXMgPSBbXCIuLi9kYXRhL3VuaXZlcnNpdHkuY3N2XCIsXG4gICAgXCIuLi9kYXRhL0xhc3ROYW1lcy5jc3ZcIl1cblxubGV0IHNpZ21hID0gcmVxdWlyZSgnc2lnbWEnKTtcbig8YW55PndpbmRvdykuc2lnbWEgPSBzaWdtYTtcbnJlcXVpcmUoJ3NpZ21hL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMnKTtcbnJlcXVpcmUoJ3NpZ21hL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5hbmltYXRlL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZScpO1xucmVxdWlyZSgnc2lnbWEvcGx1Z2lucy9zaWdtYS5sYXlvdXQubm92ZXJsYXAvc2lnbWEubGF5b3V0Lm5vdmVybGFwJyk7XG5yZXF1aXJlKCdzaWdtYS9zcmMvbWlkZGxld2FyZXMvc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZScpO1xuXG4vL2Z1bmN0aW9uIGZvciByYW5kb20gY29sb3Jcbi8vVGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNDg0NTA2L3JhbmRvbS1jb2xvci1nZW5lcmF0b3JcbmZ1bmN0aW9uIGdldFJhbmRvbUNvbG9yKCkge1xuICAgIHZhciBsZXR0ZXJzID0gJzAxMjM0NTY3ODlBQkNERUYnO1xuICAgIHZhciBjb2xvciA9ICcjJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBjb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGVzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBsZXQgZGF0YTogc3RyaW5nW11bXSA9IFtdO1xuICAgIGxldCByb3dzOiBzdHJpbmdbXTtcbiAgICBsZXQgQnVpbGRpbmdMaXN0OiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge307XG4gICAgbGV0IFByZWZpeExpc3Q6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHJldHVybkxpc3Q6IHN0cmluZ1tdID0gW107XG4gICAgZm9yICh2YXIgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMucmVzcG9uc2VUZXh0LnNwbGl0KC9cXG58XFxyXFxuLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKHJlcS5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxLm9wZW4oXCJHRVRcIiwgZmlsZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmVxLnJlc3BvbnNlVHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgICAgIHJlcS5zZW5kKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93cyA9IGRhdGFbMF1baV0uc3BsaXQoJywnKTtcbiAgICAgICAgY29uc29sZS5sb2cocm93cyk7XG4gICAgICAgIEJ1aWxkaW5nTGlzdFtyb3dzWzBdXSA9IGdldFJhbmROdW1iZXIoTnVtYmVyKHJvd3NbMV0pLCBOdW1iZXIocm93c1syXSkpO1xuICAgIH1cbiAgICBQcmVmaXhMaXN0ID0gZGF0YVsxXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gQnVpbGRpbmdMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgQnVpbGRpbmdMaXN0W2tleV07IGorKykge1xuICAgICAgICAgICAgaWYoa2V5ICE9IFwiRXhpdFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0UmFuZE51bWJlcigwLCBQcmVmaXhMaXN0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybkxpc3QucHVzaChQcmVmaXhMaXN0W2luZGV4XSArIFwiIFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICBQcmVmaXhMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICByZXR1cm5MaXN0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJldHVybkxpc3QpO1xufVxuXG5yZWFkRmlsZXMoKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBHcmFwaCA9IGNvbm5lY3ROb2Rlcyh2YWx1ZSk7XG4gICAgSW5pdGlhbGl6ZVZpbGlsbGFuZShHcmFwaCk7XG59KVxuXG5cbmZ1bmN0aW9uIGNvbm5lY3ROb2Rlcyhsb2NhdGlvbjogc3RyaW5nW10pOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIH0ge1xuICAgIGxldCBub2RlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9ID0ge307XG4gICAgbGV0IHZpc2l0ZWQ6IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2aXNpdGVkW2xvY2F0aW9uW2ldXSA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgc3RhY2s6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHJlc3Q6IHN0cmluZ1tdID0gW107XG5cbiAgICAvL3JhbmRvbWx5IGdlbmVyYXRlIGEgZ3JhcGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG5vZGVzW2xvY2F0aW9uW2ldXSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBub2Rlc1tsb2NhdGlvbltpXV0gPSBbXVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxvY2F0aW9uLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBub2Rlc1tsb2NhdGlvbltqXV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG5vZGVzW2xvY2F0aW9uW2pdXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbbG9jYXRpb25baV1dLnB1c2gobG9jYXRpb25bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vbWFraW5nIHN1cmUgaXQgaXMgY29ubmVjdGVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodmlzaXRlZFtsb2NhdGlvbltpXV0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxldCBpdGVtOiBzdHJpbmcgPSBsb2NhdGlvbltpXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobG9jYXRpb25baV0pO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkW2N1cl0gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRbY3VyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBjdXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2Ygbm9kZXNbY3VyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIG5vZGVzW3Jlc3RbaV1dLnB1c2gocmVzdFtpICsgMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIHZpc3VhbGl6ZShHcmFwaDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9KSB7XG4vL2ZvciBjdXN0b20gc2hhcGVzXG4gICAgc2lnbWEuY2FudmFzLm5vZGVzLmJvcmRlciA9IGZ1bmN0aW9uIChub2RlOiBhbnksIGNvbnRleHQ6IGFueSwgc2V0dGluZ3M6IGFueSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgICAvLyBBZGRpbmcgYSBib3JkZXJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBub2RlLmJvcmRlcldpZHRoIHx8IDI7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBub2RlLmJvcmRlckNvbG9yIHx8ICcjZmZmJztcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9O1xuLy9Jbml0aWFsaXplIHNpZ21hXG4gICAgdmFyIHNpZ21hSW5zdGFuY2UgPSBuZXcgc2lnbWEoe1xuICAgICAgICBncmFwaDoge1xuICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgZWRnZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnY2FudmFzJyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogJ2dyYXBoLWNvbnRhaW5lcidcbiAgICAgICAgfSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgIGRlZmF1bHROb2RlQ29sb3I6ICcjMDAwJyxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlVHlwZTogJ2JvcmRlcicsXG4gICAgICAgICAgICBkZWZhdWx0TGFiZWxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgbGFiZWxUaHJlc2hvbGQ6IDEwMCxcbiAgICAgICAgICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIGVkZ2VDb2xvcjogJ2RlZmF1bHQnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBlZGdlSUQ6IG51bWJlciA9IDA7XG5cbiAgICBmb3IgKHZhciBsb2NhdGlvbnMgaW4gR3JhcGgpIHtcbiAgICAgICAgc2lnbWFJbnN0YW5jZS5ncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgIC8vIE1haW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgIGlkOiBsb2NhdGlvbnMsXG4gICAgICAgICAgICBsYWJlbDogbG9jYXRpb25zLFxuICAgICAgICAgICAgeDogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICBzaXplOiAxNyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBnZXRSYW5kb21Db2xvcigpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBsb2NhdGlvbnMgaW4gR3JhcGgpIHtcbiAgICAgICAgbGV0IGFkamFjZW50ID0gR3JhcGhbbG9jYXRpb25zXTtcbiAgICAgICAgZm9yICh2YXIgYWRqIG9mIGFkamFjZW50KSB7XG4gICAgICAgICAgICBzaWdtYUluc3RhbmNlLmdyYXBoLmFkZEVkZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAnZScgKyAoZWRnZUlEKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc291cmNlOiBsb2NhdGlvbnMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhZGosXG4gICAgICAgICAgICAgICAgc2l6ZTogMTBcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZHJhZ0xpc3RlbmVyID0gc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMoXG4gICAgICAgIHNpZ21hSW5zdGFuY2UsIHNpZ21hSW5zdGFuY2UucmVuZGVyZXJzWzBdKTtcblxuICAgIGRyYWdMaXN0ZW5lci5iaW5kKCdzdGFydGRyYWcnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG4gICAgZHJhZ0xpc3RlbmVyLmJpbmQoJ2RyYWcnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG4gICAgZHJhZ0xpc3RlbmVyLmJpbmQoJ2Ryb3AnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG4gICAgZHJhZ0xpc3RlbmVyLmJpbmQoJ2RyYWdlbmQnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG5cbiAgICBzaWdtYUluc3RhbmNlLnJlZnJlc2goKTtcblxuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIG5vZGVNYXJnaW46IDIwLFxuICAgICAgICBncmlkU2l6ZTogNSxcbiAgICB9O1xuXG4vL0NvbmZpZ3VyZSB0aGUgYWxnb3JpdGhtXG4gICAgdmFyIGxpc3RlbmVyID0gc2lnbWFJbnN0YW5jZS5jb25maWdOb3ZlcmxhcChjb25maWcpO1xuXG4vL0JpbmQgYWxsIGV2ZW50czpcbiAgICBsaXN0ZW5lci5iaW5kKCdzdGFydCBzdG9wIGludGVycG9sYXRlJywgZnVuY3Rpb24gKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQudHlwZSk7XG4gICAgfSk7XG5cbi8vU3RhcnQgdGhlIGFsZ29yaXRobTpcbiAgICBzaWdtYUluc3RhbmNlLnN0YXJ0Tm92ZXJsYXAoKTtcbn1cblxuZnVuY3Rpb24gSW5pdGlhbGl6ZVZpbGlsbGFuZShHcmFwaDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmdbXSB9KSB7XG4gICAgZm9yIChsZXQga2V5IGluIEdyYXBoKSB7XG4gICAgICAgIGFkZExvY2F0aW9uKGtleSwgR3JhcGhba2V5XSk7XG4gICAgfVxuICAgIHZhciBsb2NhdGlvbnMgPSBPYmplY3Qua2V5cyhHcmFwaCk7XG5cbi8vIGFnZW50c1xuICAgIHZhciBhbGllbiA9IGFkZEFnZW50KFwiQWxpZW5cIik7XG5cbi8vIGl0ZW1zXG4gICAgdmFyIHJhbmRvbUxvY2F0aW9uOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGdldFJhbmROdW1iZXIoMCwgbG9jYXRpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgICByYW5kb21Mb2NhdGlvbi5wdXNoKGxvY2F0aW9uc1tpbmRleF0pO1xuICAgICAgICBsb2NhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJsb2MxOlwiICsgcmFuZG9tTG9jYXRpb25bMF0pO1xuICAgIGNvbnNvbGUubG9nKFwibG9jMjpcIiArIHJhbmRvbUxvY2F0aW9uWzFdKTtcblxuICAgIHZhciBjcmV3Q2FyZDEgPSBhZGRJdGVtKFwiQ3JldyBjYXJkMVwiKTtcbiAgICB2YXIgY3Jld0NhcmQyID0gYWRkSXRlbShcIkNyZXcgY2FyZDJcIik7XG4gICAgc2V0SXRlbVZhcmlhYmxlKGNyZXdDYXJkMSwgXCJjdXJyZW50TG9jYXRpb25cIiwgcmFuZG9tTG9jYXRpb25bMF0pO1xuICAgIHNldEl0ZW1WYXJpYWJsZShjcmV3Q2FyZDIsIFwiY3VycmVudExvY2F0aW9uXCIsIHJhbmRvbUxvY2F0aW9uWzFdKTtcblxuLy8gdmFyaWFibGVzXG5cbi8vYWxpZW5cblxuICAgIHNldEFnZW50VmFyaWFibGUoYWxpZW4sIFwiY3VycmVudExvY2F0aW9uXCIsIHJhbmRvbUxvY2F0aW9uWzJdKTtcblxuLy9wbGF5ZXJcbiAgICB2YXIgcGxheWVyTG9jYXRpb24gPSBzZXRWYXJpYWJsZShcInBsYXllckxvY2F0aW9uXCIsIHJhbmRvbUxvY2F0aW9uWzNdKTtcbiAgICB2YXIgY3Jld0NhcmRzQ29sbGVjdGVkID0gc2V0VmFyaWFibGUoXCJjcmV3Q2FyZHNDb2xsZWN0ZWRcIiwgMCk7XG5cbi8vIDIuIERlZmluZSBCVHNcbi8vIGNyZWF0ZSBncm91bmQgYWN0aW9uc1xuXG4gICAgLy9SZWNvdmVyIGxvY2F0aW9uIGFycmF5XG4gICAgbG9jYXRpb25zID0gT2JqZWN0LmtleXMoR3JhcGgpO1xuICAgIGxldCBzZXRSYW5kTnVtYmVyID0gYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzZXRWYXJpYWJsZShcInJhbmROdW1iZXJcIiwgZ2V0UmFuZE51bWJlcigxLCBsb2NhdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICApO1xuXG4gICAgdmFyIEJUbGlzdDogVGlja1tdID0gW107XG4gICAgbGV0IGlkOiBudW1iZXIgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2cobG9jYXRpb25zW2ldKTtcbiAgICAgICAgbGV0IGFjdGlvbnM6IFRpY2sgPSBhY3Rpb24oKCkgPT4gZ2V0VmFyaWFibGUoXCJyYW5kTnVtYmVyXCIpID09IGkgKyAxLCAoKSA9PiBzZXRWYXJpYWJsZShcImRlc3RpbmF0aW9uXCIsIGxvY2F0aW9uc1tpXSksIDApO1xuICAgICAgICBCVGxpc3QucHVzaChhY3Rpb25zKTtcbiAgICB9XG4gICAgbGV0IGF0RGVzdGluYXRpb246IFByZWNvbmRpdGlvbiA9ICgpID0+IGdldFZhcmlhYmxlKFwiZGVzdGluYXRpb25cIikgPT0gZ2V0QWdlbnRWYXJpYWJsZShhbGllbiwgXCJjdXJyZW50TG9jYXRpb25cIik7XG4gICAgbGV0IHNldERlc3RpbmF0aW9uUHJlY29uZDogUHJlY29uZGl0aW9uID0gKCkgPT4gaXNWYXJpYWJsZU5vdFNldChcImRlc3RpbmF0aW9uXCIpIHx8IGF0RGVzdGluYXRpb24oKTtcblxuLy8gY3JlYXRlIGJlaGF2aW9yIHRyZWVzXG4gICAgbGV0IHNldE5leHREZXN0aW5hdGlvbiA9IHNlcXVlbmNlKFtcbiAgICAgICAgc2V0UmFuZE51bWJlcixcbiAgICAgICAgc2VsZWN0b3IoQlRsaXN0KSxcbiAgICBdKTtcblxuICAgIGxldCBnb3RvTmV4dExvY2F0aW9uID0gYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzZXRBZ2VudFZhcmlhYmxlKGFsaWVuLCBcImN1cnJlbnRMb2NhdGlvblwiLCBnZXROZXh0TG9jYXRpb24oZ2V0QWdlbnRWYXJpYWJsZShhbGllbiwgXCJjdXJyZW50TG9jYXRpb25cIiksIGdldFZhcmlhYmxlKFwiZGVzdGluYXRpb25cIikpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQWxpZW4gaXMgYXQ6IFwiICsgZ2V0QWdlbnRWYXJpYWJsZShhbGllbiwgXCJjdXJyZW50TG9jYXRpb25cIikpXG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICApO1xuXG4gICAgbGV0IGVhdFBsYXllciA9IGFjdGlvbigoKSA9PiBnZXRBZ2VudFZhcmlhYmxlKGFsaWVuLCBcImN1cnJlbnRMb2NhdGlvblwiKSA9PSBnZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHNldFZhcmlhYmxlKFwiZW5kR2FtZVwiLCBcImxvc2VcIik7XG4gICAgICAgICAgICBzZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiwgXCJOQVwiKTtcbiAgICAgICAgfSwgMFxuICAgICk7XG5cbiAgICBsZXQgc2VhcmNoID0gc2VxdWVuY2UoW1xuICAgICAgICBzZWxlY3RvcihbXG4gICAgICAgICAgICBndWFyZChzZXREZXN0aW5hdGlvblByZWNvbmQsIHNldE5leHREZXN0aW5hdGlvbiksXG4gICAgICAgICAgICBhY3Rpb24oKCkgPT4gdHJ1ZSwgKCkgPT4ge1xuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgXSksXG4gICAgICAgIGdvdG9OZXh0TG9jYXRpb24sXG4gICAgXSk7XG5cbiAgICBsZXQgYWxpZW5CVCA9IHNlbGVjdG9yKFtcbiAgICAgICAgZWF0UGxheWVyLFxuICAgICAgICBzZXF1ZW5jZShbXG4gICAgICAgICAgICBzZWFyY2gsIGVhdFBsYXllclxuICAgICAgICBdKVxuICAgIF0pO1xuXG4vL2F0dGFjaCBiZWhhdmlvdXIgdHJlZXMgdG8gYWdlbnRzXG4gICAgYXR0YWNoVHJlZVRvQWdlbnQoYWxpZW4sIGFsaWVuQlQpO1xuICAgIC8vIDMuIENvbnN0cnVjdCBzdG9yeVxuICAgIC8vIGNyZWF0ZSB1c2VyIGFjdGlvbnNcbiAgICBmb3IgKGxldCBrZXkgaW4gbG9jYXRpb25HcmFwaCkge1xuICAgICAgICBsZXQgc2VxOiBhbnlbXSA9IFtdO1xuICAgICAgICBzZXEucHVzaChkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJZb3UgZW50ZXIgdGhlIFwiICsga2V5ICsgXCIuXCIpKTtcbiAgICAgICAgc2VxLnB1c2goYWRkVXNlckFjdGlvbihcIlN0YXkgd2hlcmUgeW91IGFyZS5cIiwgKCkgPT4ge30pKTtcbiAgICAgICAgZm9yIChsZXQgYWRqIG9mIGxvY2F0aW9uR3JhcGhba2V5XSkge1xuICAgICAgICAgICAgc2VxLnB1c2goYWRkVXNlckFjdGlvbihcIkVudGVyIHRoZSBcIiArIGFkaiArIFwiLlwiLCAoKSA9PiBzZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiwgYWRqKSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBTdGF0ZUJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGtleSxcbiAgICAgICAgICAgIHNlcXVlbmNlKHNlcSkpO1xuICAgICAgICBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKFN0YXRlQlQpO1xuICAgIH1cblxuXG4gICAgdmFyIGNyZXdDYXJkMUJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGdldEl0ZW1WYXJpYWJsZShjcmV3Q2FyZDEsIFwiY3VycmVudExvY2F0aW9uXCIpLFxuICAgICAgICBzZXF1ZW5jZShbXG4gICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiWW91IG5vdGljZSBhIGNyZXcgY2FyZCBseWluZyBhcm91bmQuXCIpLFxuICAgICAgICAgICAgICAgIGFkZFVzZXJBY3Rpb25UcmVlKFwiUGljayB1cCB0aGUgY3JldyBjYXJkXCIsXG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbigoKSA9PiB0cnVlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUFjdGlvbkVmZmVjdFRleHQoXCJZb3UgcGljayB1cCB0aGUgY3JldyBjYXJkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJdGVtVmFyaWFibGUoY3Jld0NhcmQxLCBcImN1cnJlbnRMb2NhdGlvblwiLCBcInBsYXllclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShjcmV3Q2FyZHNDb2xsZWN0ZWQsIGdldFZhcmlhYmxlKGNyZXdDYXJkc0NvbGxlY3RlZCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCgpID0+IHRydWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5QWN0aW9uRWZmZWN0VGV4dChcIldvdyB5b3Uga25vdyBob3cgdG8gcGljayB1cCB0aGluZ3MuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSk7XG4gICAgdmFyIGNyZXdDYXJkMkJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGdldEl0ZW1WYXJpYWJsZShjcmV3Q2FyZDIsIFwiY3VycmVudExvY2F0aW9uXCIpLFxuICAgICAgICBzZXF1ZW5jZShbXG4gICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiWW91IG5vdGljZSBhIGNyZXcgY2FyZCBseWluZyBhcm91bmQuXCIpLFxuICAgICAgICAgICAgICAgIGFkZFVzZXJBY3Rpb24oXCJQaWNrIHVwIHRoZSBjcmV3IGNhcmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5QWN0aW9uRWZmZWN0VGV4dChcIllvdSBwaWNrIHVwIHRoZSBjcmV3IGNhcmQuXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtVmFyaWFibGUoY3Jld0NhcmQyLCBcImN1cnJlbnRMb2NhdGlvblwiLCBcInBsYXllclwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoY3Jld0NhcmRzQ29sbGVjdGVkLCBnZXRWYXJpYWJsZShjcmV3Q2FyZHNDb2xsZWN0ZWQpICsgMSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSk7XG4gICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShjcmV3Q2FyZDFCVCk7XG4gICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShjcmV3Q2FyZDJCVCk7XG5cbiAgICB2YXIgYWxpZW5OZWFyYnkgPSBndWFyZCgoKSA9PiBhcmVBZGphY2VudChnZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiksIGdldEFnZW50VmFyaWFibGUoYWxpZW4sIFwiY3VycmVudExvY2F0aW9uXCIpKSxcbiAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiWW91IGhlYXIgYSB0aHVtcGluZyBzb3VuZC4gVGhlIGFsaWVuIGlzIG5lYXJieS5cIikpO1xuICAgIGFkZFVzZXJJbnRlcmFjdGlvblRyZWUoYWxpZW5OZWFyYnkpO1xuXG4gICAgdmFyIGdhbWVPdmVyID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IFwiTkFcIixcbiAgICAgICAgc2VsZWN0b3IoW1xuICAgICAgICAgICAgICAgIGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKFwiZW5kR2FtZVwiKSA9PSBcIndpblwiLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJZb3UgaGF2ZSBtYW5hZ2VkIHRvIGVzY2FwZSFcIikpLFxuICAgICAgICAgICAgICAgIGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKFwiZW5kR2FtZVwiKSA9PSBcImxvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKFwiVGhlIGNyZWF0dXJlIGdyYWJzIHlvdSBiZWZvcmUgeW91IGNhbiByZWFjdCEgWW91IHN0cnVnZ2xlIGZvciBhIGJpdCBiZWZvcmUgcmVhbGlzaW5nIGl0J3MgYWxsIG92ZXIuLlwiKSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSk7XG4gICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShnYW1lT3Zlcik7XG5cbi8vSW5pdGlhbGl6ZSBzaWdtYVxuXG4vL2ZvciBjdXN0b20gc2hhcGVzXG4gICAgc2lnbWEuY2FudmFzLm5vZGVzLmJvcmRlciA9IGZ1bmN0aW9uIChub2RlOiBhbnksIGNvbnRleHQ6IGFueSwgc2V0dGluZ3M6IGFueSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLlBJICogMixcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcblxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgICAvLyBBZGRpbmcgYSBib3JkZXJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBub2RlLmJvcmRlcldpZHRoIHx8IDI7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBub2RlLmJvcmRlckNvbG9yIHx8ICcjZmZmJztcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9O1xuXG4vL0luaXRpYWxpemUgc2lnbWFcbiAgICB2YXIgc2lnbWFJbnN0YW5jZSA9IG5ldyBzaWdtYSh7XG4gICAgICAgIGdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBlZGdlczogW11cbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjYW52YXMnLFxuICAgICAgICAgICAgY29udGFpbmVyOiAnZ3JhcGgtY29udGFpbmVyJ1xuICAgICAgICB9LFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgZGVmYXVsdE5vZGVDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgZGVmYXVsdE5vZGVUeXBlOiAnYm9yZGVyJyxcbiAgICAgICAgICAgIGRlZmF1bHRMYWJlbENvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBsYWJlbFRocmVzaG9sZDogMTAwLFxuICAgICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgZWRnZUNvbG9yOiAnZGVmYXVsdCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGVkZ2VJRDogbnVtYmVyID0gMDtcblxuICAgIGZvciAodmFyIGxvY3MgaW4gR3JhcGgpIHtcbiAgICAgICAgc2lnbWFJbnN0YW5jZS5ncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgIC8vIE1haW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgIGlkOiBsb2NzLFxuICAgICAgICAgICAgbGFiZWw6IGxvY3MsXG4gICAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgIHNpemU6IDE3LFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGdldFJhbmRvbUNvbG9yKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIGxvY3MgaW4gR3JhcGgpIHtcbiAgICAgICAgbGV0IGFkamFjZW50ID0gR3JhcGhbbG9jc107XG4gICAgICAgIGZvciAodmFyIGFkaiBvZiBhZGphY2VudCkge1xuICAgICAgICAgICAgc2lnbWFJbnN0YW5jZS5ncmFwaC5hZGRFZGdlKHtcbiAgICAgICAgICAgICAgICBpZDogJ2UnICsgKGVkZ2VJRCsrKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogbG9jcyxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGFkaixcbiAgICAgICAgICAgICAgICBzaXplOiAxMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkcmFnTGlzdGVuZXIgPSBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyhcbiAgICAgICAgc2lnbWFJbnN0YW5jZSwgc2lnbWFJbnN0YW5jZS5yZW5kZXJlcnNbMF0pO1xuXG4gICAgZHJhZ0xpc3RlbmVyLmJpbmQoJ3N0YXJ0ZHJhZycsIGZ1bmN0aW9uIChldmVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkcmFnTGlzdGVuZXIuYmluZCgnZHJhZycsIGZ1bmN0aW9uIChldmVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkcmFnTGlzdGVuZXIuYmluZCgnZHJvcCcsIGZ1bmN0aW9uIChldmVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkcmFnTGlzdGVuZXIuYmluZCgnZHJhZ2VuZCcsIGZ1bmN0aW9uIChldmVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcblxuXG4vLzQuIFJ1biB0aGUgd29ybGRcbiAgICBpbml0aWFsaXplKCk7XG4gICAgdmFyIHVzZXJJbnRlcmFjdGlvbk9iamVjdCA9IGdldFVzZXJJbnRlcmFjdGlvbk9iamVjdCgpO1xuXG4vL1JFTkRFUklORy0tLS0tXG4vL3ZhciBkaXNwbGF5UGFuZWwgPSB7eDogNTAwLCB5OiAwfTtcbiAgICB2YXIgdGV4dFBhbmVsID0ge3g6IDQwMCwgeTogNDI1fTtcbiAgICB2YXIgYWN0aW9uc1BhbmVsID0ge3g6IDQyMCwgeTogNDc1fTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGFsaWVuTG9jYXRpb24gPSBnZXRBZ2VudFZhcmlhYmxlKGFsaWVuLCBcImN1cnJlbnRMb2NhdGlvblwiKTtcbiAgICAgICAgbGV0IHBsYXllckwgPSBnZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbik7XG4gICAgICAgIGZvciAodmFyIG5vZGUgb2Ygc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcygpKSB7XG4gICAgICAgICAgICBub2RlLmNvbG9yID0gJyMwMDAnO1xuICAgICAgICB9XG4gICAgICAgIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoYWxpZW5Mb2NhdGlvbikuY29sb3IgPSAnIzBlZmE3Nic7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcyhwbGF5ZXJMKSkpIHtcbiAgICAgICAgICAgIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMocGxheWVyTCkuY29sb3IgPSAnI2YwZic7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbWFJbnN0YW5jZS5yZWZyZXNoKCk7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBub2RlTWFyZ2luOiAyMCxcbiAgICAgICAgICAgIGdyaWRTaXplOiA1LFxuICAgICAgICB9O1xuXG4vL0NvbmZpZ3VyZSB0aGUgYWxnb3JpdGhtXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHNpZ21hSW5zdGFuY2UuY29uZmlnTm92ZXJsYXAoY29uZmlnKTtcblxuLy9CaW5kIGFsbCBldmVudHM6XG4gICAgICAgIGxpc3RlbmVyLmJpbmQoJ3N0YXJ0IHN0b3AgaW50ZXJwb2xhdGUnLCBmdW5jdGlvbiAoZXZlbnQ6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudHlwZSk7XG4gICAgICAgIH0pO1xuXG4vL1N0YXJ0IHRoZSBhbGdvcml0aG06XG4gICAgICAgIHNpZ21hSW5zdGFuY2Uuc3RhcnROb3ZlcmxhcCgpO1xuICAgICAgICAvL3NpZ21hSW5zdGFuY2Uuc3RhcnRGb3JjZUF0bGFzMigpO1xuXG4gICAgICAgIGRpc3BsYXlUZXh0QW5kQWN0aW9ucygpO1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSA8SFRNTENhbnZhc0VsZW1lbnQ+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXNwbGF5Jyk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHZhciBjdXJyZW50U2VsZWN0aW9uO1xuICAgIHZhciB5T2Zmc2V0ID0gYWN0aW9uc1BhbmVsLnkgKyAyNTtcbiAgICB2YXIgeU9mZnNldEluY3JlbWVudCA9IDUwO1xuXG4gICAgZnVuY3Rpb24gZGlzcGxheVRleHRBbmRBY3Rpb25zKCkge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCh0ZXh0UGFuZWwueCwgdGV4dFBhbmVsLnksIDEwMDAsIDEwMDApO1xuICAgICAgICB5T2Zmc2V0ID0gYWN0aW9uc1BhbmVsLnkgKyAyNTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSBcIjE1cHQgQ2FsaWJyaVwiO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWN0aW9ucyBlZmZlY3QgdGV4dDogXCIgKyB1c2VySW50ZXJhY3Rpb25PYmplY3QuYWN0aW9uRWZmZWN0c1RleHQpO1xuICAgICAgICB2YXIgdGV4dFRvRGlzcGxheSA9IHVzZXJJbnRlcmFjdGlvbk9iamVjdC5hY3Rpb25FZmZlY3RzVGV4dC5sZW5ndGggIT0gMCA/IHVzZXJJbnRlcmFjdGlvbk9iamVjdC5hY3Rpb25FZmZlY3RzVGV4dCA6IHVzZXJJbnRlcmFjdGlvbk9iamVjdC50ZXh0O1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHRUb0Rpc3BsYXksIHRleHRQYW5lbC54LCB0ZXh0UGFuZWwueSArIDIwKTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSBcIjE1cHQgQ2FsaWJyaVwiO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHVzZXJBY3Rpb25UZXh0ID0gdXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dFtpXTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQodXNlckFjdGlvblRleHQsIGFjdGlvbnNQYW5lbC54ICsgMjAsIHlPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeU9mZnNldCArPSB5T2Zmc2V0SW5jcmVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGxheUFycm93KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ3JldyBjYXJkczogXCIgKyBnZXRWYXJpYWJsZShjcmV3Q2FyZHNDb2xsZWN0ZWQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5QXJyb3coKSB7XG4gICAgICAgIGlmICh1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdChhY3Rpb25zUGFuZWwueCwgYWN0aW9uc1BhbmVsLnksIDIwLCAxMDAwKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoXCI+IFwiLCA0MjAsIGFjdGlvbnNQYW5lbC55ICsgMjUgKyAoY3VycmVudFNlbGVjdGlvbiAqIHlPZmZzZXRJbmNyZW1lbnQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuLy9Vc2VyIGlucHV0XG4gICAgZnVuY3Rpb24ga2V5UHJlc3MoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRBY3Rpb24gPSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0W2N1cnJlbnRTZWxlY3Rpb25dO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzZWxlY3RlZEFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlVXNlckFjdGlvbihzZWxlY3RlZEFjdGlvbik7XG4gICAgICAgICAgICAgICAgd29ybGRUaWNrKCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSA0MCkgey8vZG93blxuICAgICAgICAgICAgaWYgKHVzZXJJbnRlcmFjdGlvbk9iamVjdC51c2VyQWN0aW9uc1RleHQubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uKys7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb24gJSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5QXJyb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMzgpIHsvL3VwXG4gICAgICAgICAgICBpZiAodXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dC5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24tLTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbiA8IDApXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgZGlzcGxheUFycm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlwcmVzc1wiLCBrZXlQcmVzcywgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleURvd24sIGZhbHNlKTtcbn0iLCJpbXBvcnQgUXVldWUgZnJvbSBcInR5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvUXVldWVcIjtcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCJ0eXBlc2NyaXB0LWNvbGxlY3Rpb25zL2Rpc3QvbGliL3V0aWxcIjtcbmxldCBzaWdtYSA9IHJlcXVpcmUoJ3NpZ21hJyk7XG4oPGFueT53aW5kb3cpLnNpZ21hID0gc2lnbWE7XG5yZXF1aXJlKCdzaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzJyk7XG5yZXF1aXJlKCdzaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS9zaWdtYS5wbHVnaW5zLmFuaW1hdGUnKTtcbnJlcXVpcmUoJ3NpZ21hL3BsdWdpbnMvc2lnbWEubGF5b3V0Lm5vdmVybGFwL3NpZ21hLmxheW91dC5ub3ZlcmxhcCcpO1xuXG5leHBvcnQgZW51bSBTdGF0dXMge1xuICAgIFJVTk5JTkcsXG4gICAgU1VDQ0VTUyxcbiAgICBGQUlMVVJFXG59XG5cbmZ1bmN0aW9uIHRlcm1pbmF0ZUFuZFJldHVybihpZDogbnVtYmVyLCBibGFja2JvYXJkOiBhbnksIHN0YXR1czogU3RhdHVzKSB7XG4gICAgZGVsZXRlIGJsYWNrYm9hcmRbaWRdO1xuICAgIHJldHVybiBzdGF0dXM7XG59XG5cbmV4cG9ydCB0eXBlIEVmZmVjdCA9ICgpID0+IHZvaWRcbmV4cG9ydCB0eXBlIFByZWNvbmRpdGlvbiA9ICgpID0+IGJvb2xlYW5cbmV4cG9ydCB0eXBlIFRpY2sgPSAoKSA9PiBTdGF0dXNcbmV4cG9ydCB0eXBlIEFjdGlvblRpY2sgPSAocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGVmZmVjdDogRWZmZWN0LCB0aWNrc1JlcXVpcmVkPzogbnVtYmVyKSA9PiBUaWNrXG4vKipcbiAqIFRoZSBndWFyZCB0aWNrIGlzIHRvIGFkZCBhIHByZWNvbmRpdGlvbiB0byB0aGUgY29tcG9zaXRlIHRpY2tzXG4gKi9cbmV4cG9ydCB0eXBlIEd1YXJkVGljayA9IChwcmVjb25kaXRpb246IFByZWNvbmRpdGlvbiwgYXN0VGljazogVGljaywgbmVnYXRlPzogYm9vbGVhbikgPT4gVGlja1xuLyoqXG4gKiBTZXF1ZW5jZS9TZWxlY3RvclxuICovXG5leHBvcnQgdHlwZSBDb21wb3NpdGVUaWNrID0gKGFzdFRpY2tzOiBUaWNrW10pID0+IFRpY2tcblxudmFyIGJsYWNrYm9hcmQgPSB7fTtcblxuZnVuY3Rpb24gZ2V0QWN0aW9uVGljayhpZDogbnVtYmVyKTogQWN0aW9uVGljayB7XG4gICAgcmV0dXJuIChwcmVjb25kaXRpb24sIGVmZmVjdCwgdGlja3NSZXF1aXJlZCA9IDEpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmVjb25kaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGlmICghYmxhY2tib2FyZFtpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0udGlja3NEb25lID0gdGlja3NSZXF1aXJlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmxhY2tib2FyZFtpZF0udGlja3NEb25lID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXS50aWNrc0RvbmUtLTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1cy5SVU5OSU5HO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYXRlQW5kUmV0dXJuKGlkLCBibGFja2JvYXJkLCBTdGF0dXMuU1VDQ0VTUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzLkZBSUxVUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEd1YXJkVGljaygpOiBHdWFyZFRpY2sge1xuICAgIHJldHVybiAocHJlY29uZGl0aW9uLCBhc3RUaWNrLCBuZWdhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByb2NlZWQgPSBuZWdhdGUgPyAhcHJlY29uZGl0aW9uKCkgOiBwcmVjb25kaXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZWVkID8gZXhlY3V0ZShhc3RUaWNrKSA6IFN0YXR1cy5GQUlMVVJFO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZVRpY2soaWQ6IG51bWJlcik6IENvbXBvc2l0ZVRpY2sge1xuICAgIHJldHVybiAoYXN0VGlja3MpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxhY2tib2FyZFtpZF0pIHtcbiAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXSA9IHt9O1xuICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXggPCBhc3RUaWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTdGF0dXMgPSBleGVjdXRlKGFzdFRpY2tzW2JsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkU3RhdHVzID09IFN0YXR1cy5SVU5OSU5HKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRTdGF0dXMgPT0gU3RhdHVzLkZBSUxVUkUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hdGVBbmRSZXR1cm4oaWQsIGJsYWNrYm9hcmQsIFN0YXR1cy5GQUlMVVJFKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFN0YXR1cyA9PSBTdGF0dXMuU1VDQ0VTUylcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVybWluYXRlQW5kUmV0dXJuKGlkLCBibGFja2JvYXJkLCBTdGF0dXMuU1VDQ0VTUyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yVGljayhpZDogbnVtYmVyKTogQ29tcG9zaXRlVGljayB7XG4gICAgcmV0dXJuIChhc3RUaWNrcykgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFibGFja2JvYXJkW2lkXSkge1xuICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdID0ge307XG4gICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGJsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleCA8IGFzdFRpY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFN0YXR1cyA9IGV4ZWN1dGUoYXN0VGlja3NbYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRTdGF0dXMgPT0gU3RhdHVzLlJVTk5JTkcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXMuUlVOTklORztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFN0YXR1cyA9PSBTdGF0dXMuU1VDQ0VTUylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmF0ZUFuZFJldHVybihpZCwgYmxhY2tib2FyZCwgU3RhdHVzLlNVQ0NFU1MpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkU3RhdHVzID09IFN0YXR1cy5GQUlMVVJFKVxuICAgICAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hdGVBbmRSZXR1cm4oaWQsIGJsYWNrYm9hcmQsIFN0YXR1cy5GQUlMVVJFKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoYXN0VGljazogVGljayk6IFN0YXR1cyB7XG4gICAgcmV0dXJuIGFzdFRpY2soKTtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb24ocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGVmZmVjdDogRWZmZWN0LCB0aWNrc1JlcXVpcmVkPzogbnVtYmVyKTogVGljayB7XG4gICAgcmV0dXJuIGdldEFjdGlvblRpY2soZ2xvYmFsSWRDb3VudGVyKyspKHByZWNvbmRpdGlvbiwgZWZmZWN0LCB0aWNrc1JlcXVpcmVkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3VhcmQocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGFzdFRpY2s6IFRpY2spOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0R3VhcmRUaWNrKCkocHJlY29uZGl0aW9uLCBhc3RUaWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ19ndWFyZChwcmVjb25kaXRpb246IFByZWNvbmRpdGlvbiwgYXN0VGljazogVGljayk6IFRpY2sge1xuICAgIHJldHVybiBnZXRHdWFyZFRpY2soKShwcmVjb25kaXRpb24sIGFzdFRpY2ssIHRydWUpO1xufVxuXG4vKipcbiAqIEN5Y2xlcyBvdmVyIGl0cyBjaGlsZHJlbjogaXRlcmF0ZXMgdG8gdGhlIG5leHQgY2hpbGQgb24gc3VjY2VzcyBvZiBhIGNoaWxkXG4gKiBTdWNjZWVkcyBpZiBhbGwgc3VjY2VlZCwgZWxzZSBmYWlsc1xuICogQHBhcmFtIHtUaWNrW119IGFzdFRpY2tzXG4gKiBAcmV0dXJucyB7VGlja31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbmNlKGFzdFRpY2tzOiBUaWNrW10pOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0U2VxdWVuY2VUaWNrKGdsb2JhbElkQ291bnRlcisrKShhc3RUaWNrcyk7XG59XG5cbi8qKlxuICogQ3ljbGVzIG92ZXIgaXRzIGNoaWxkcmVuOiBpdGVyYXRlcyB0byB0aGUgbmV4dCBjaGlsZCBvbiBmYWlsdXJlIG9mIGEgY2hpbGQodGhpbmsgb2YgaXQgYXMgaWYtZWxzZSBibG9ja3MpXG4gKiBTdWNjZWVkcyBpZiBldmVuIG9uZSBzdWNjZWVkcywgZWxzZSBmYWlsc1xuICogQHBhcmFtIHtUaWNrW119IGFzdFRpY2tzXG4gKiBAcmV0dXJucyB7VGlja31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdG9yKGFzdFRpY2tzOiBUaWNrW10pOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0b3JUaWNrKGdsb2JhbElkQ291bnRlcisrKShhc3RUaWNrcyk7XG59XG5cblxuLyotLS0tLS0tLS0tLS0tLS0gQVBJcyAtLS0tLS0tLS0tLS0tLS0gKi9cblxuXG4vLzAuIHV0aWxpdGllc1xuLy8gbWluIGFuZCBtYXggYXJlIGluY2x1c2l2ZVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmROdW1iZXIobWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn1cblxuLy8xLiBzdG9yeSBpbnN0YW5jZVxuXG4vLzEuMSBsb2NhdGlvbnNcbmV4cG9ydCB2YXIgbG9jYXRpb25HcmFwaCA9IHt9O1xuXG4vL2FkZCB0byBib3RoIHNpZGVzXG5leHBvcnQgZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25OYW1lOiBzdHJpbmcsIGFkamFjZW50TG9jYXRpb25zOiBzdHJpbmdbXSkge1xuICAgIGlmIChsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2F0aW9uR3JhcGhbbG9jYXRpb25OYW1lXSA9IFtdO1xuICAgIH1cbiAgICBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0gPSBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0uY29uY2F0KGFkamFjZW50TG9jYXRpb25zKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRqYWNlbnRMb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uR3JhcGhbYWRqYWNlbnRMb2NhdGlvbnNbaV1dID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbG9jYXRpb25HcmFwaFthZGphY2VudExvY2F0aW9uc1tpXV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhdGlvbkdyYXBoW2FkamFjZW50TG9jYXRpb25zW2ldXS5wdXNoKGxvY2F0aW9uTmFtZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJlQWRqYWNlbnQobG9jYXRpb24xOiBzdHJpbmcsIGxvY2F0aW9uMjogc3RyaW5nKTpib29sZWFuIHtcbiAgICBjb25zb2xlLmxvZyhcIkFyZSBhZGphY2VudDogXCIgKyBsb2NhdGlvbjEgKyBcIiwgXCIrbG9jYXRpb24yKTtcbiAgICBpZiAobG9jYXRpb25HcmFwaFtsb2NhdGlvbjFdID09IHVuZGVmaW5lZCB8fCBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uMl0gPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFaXRoZXIgb25lL2JvdGggbG9jYXRpb25zIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYXRpb25HcmFwaFtsb2NhdGlvbjFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbkdyYXBoW2xvY2F0aW9uMV1baV0gPT0gbG9jYXRpb24yKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9wYXRoZmluZGluZyBwcmltaXRpdmVzXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHN0YXJ0OiBzdHJpbmcsIGRlc3RpbmF0aW9uOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHZhciB2aXNpdGVkID0ge307XG4gICAgdmFyIHByZXZpb3VzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGxvY2F0aW9uR3JhcGgpIHtcbiAgICAgICAgdmlzaXRlZFtrZXldID0gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0ZWRbc3RhcnRdID0gdHJ1ZTtcblxuICAgIHZhciBteVF1ZXVlID0gbmV3IFF1ZXVlPHN0cmluZz4oKTtcbiAgICBteVF1ZXVlLmVucXVldWUoc3RhcnQpO1xuXG4gICAgd2hpbGUgKCFteVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgY3VycmVudDogc3RyaW5nID0gbXlRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IGxvY2F0aW9uR3JhcGhbY3VycmVudF07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtuZWlnaGJvcnNbaV1dKSB7XG4gICAgICAgICAgICAgICAgbXlRdWV1ZS5lbnF1ZXVlKG5laWdoYm9yc1tpXSk7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtuZWlnaGJvcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1tuZWlnaGJvcnNbaV1dID0gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjdXJyZW50OiBzdHJpbmcgPSBkZXN0aW5hdGlvbjtcbiAgICBpZiAoY3VycmVudCA9PSBzdGFydClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgd2hpbGUgKHByZXZpb3VzW2N1cnJlbnRdICE9IHN0YXJ0KSB7XG4gICAgICAgIGN1cnJlbnQgPSBwcmV2aW91c1tjdXJyZW50XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudDtcbn1cblxuLy8xLjIgYWdlbnRzXG52YXIgYWdlbnRzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRBZ2VudChhZ2VudE5hbWU6IHN0cmluZykge1xuICAgIGFnZW50cy5wdXNoKGFnZW50TmFtZSk7XG4gICAgcmV0dXJuIGFnZW50TmFtZTtcbn1cblxuLy8xLjMgaXRlbXNcbnZhciBpdGVtcyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSXRlbShpdGVtTmFtZTogc3RyaW5nKSB7XG4gICAgaXRlbXMucHVzaChpdGVtTmFtZSk7XG4gICAgcmV0dXJuIGl0ZW1OYW1lO1xufVxuXG4vLzEuNCB2YXJpYWJsZXNcbnZhciB2YXJpYWJsZXMgPSB7fTtcbnZhciBhZ2VudFZhcmlhYmxlcyA9IHt9O1xudmFyIGl0ZW1WYXJpYWJsZXMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFZhcmlhYmxlKHZhck5hbWU6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIHZhcmlhYmxlc1t2YXJOYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YXJOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWdlbnRWYXJpYWJsZShhZ2VudDogc3RyaW5nLCB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdKSlcbiAgICAgICAgYWdlbnRWYXJpYWJsZXNbYWdlbnRdID0ge307XG5cbiAgICBhZ2VudFZhcmlhYmxlc1thZ2VudF1bdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZSh2YXJOYW1lOiBzdHJpbmcpOiBhbnkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh2YXJpYWJsZXNbdmFyTmFtZV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCIgbm90IHNldCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlc1t2YXJOYW1lXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZW50VmFyaWFibGUoYWdlbnQ6IHN0cmluZywgdmFyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGFnZW50VmFyaWFibGVzW2FnZW50XSkgfHwgaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdW3Zhck5hbWVdKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIFwiICsgdmFyTmFtZSArIFwiIGZvciBhZ2VudCBcIiArIGFnZW50ICsgXCIgbm90IHNldCFcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYWdlbnRWYXJpYWJsZXNbYWdlbnRdW3Zhck5hbWVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYXJpYWJsZU5vdFNldCh2YXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFyaWFibGVzW3Zhck5hbWVdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWdlbnRWYXJpYWJsZU5vdFNldChhZ2VudDogc3RyaW5nLCB2YXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdKSB8fCBpc1VuZGVmaW5lZChhZ2VudFZhcmlhYmxlc1thZ2VudF1bdmFyTmFtZV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SXRlbVZhcmlhYmxlKGl0ZW06IHN0cmluZywgdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV0pKVxuICAgICAgICBpdGVtVmFyaWFibGVzW2l0ZW1dID0ge307XG5cbiAgICBpdGVtVmFyaWFibGVzW2l0ZW1dW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbVZhcmlhYmxlKGl0ZW06IHN0cmluZywgdmFyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV0pIHx8IGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV1bdmFyTmFtZV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCIgZm9yIGl0ZW0gXCIgKyBpdGVtICsgXCIgbm90IHNldCFcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbVZhcmlhYmxlc1tpdGVtXVt2YXJOYW1lXTtcbn1cblxuXG4vLzJcbi8vYWdlbnQtYmVoYXZpb3IgdHJlZSBtYXBwaW5nXG52YXIgYWdlbnRUcmVlcyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoVHJlZVRvQWdlbnQoYWdlbnQ6IHN0cmluZywgdHJlZTogVGljaykge1xuICAgIGFnZW50VHJlZXNbYWdlbnRdID0gdHJlZTtcbn1cblxuLy8zLjFcbi8vdXNlciBhY3Rpb25zXG4vL1RPRE8gYWRkIHZhcmlhYmxlcyB0byB1c2VyIGFjdGlvbiB0ZXh0c1xudmFyIHVzZXJJbnRlcmFjdGlvbk9iamVjdCA9IHtcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHVzZXJBY3Rpb25zVGV4dDogW10sXG4gICAgYWN0aW9uRWZmZWN0c1RleHQ6IFwiXCJcbn1cbnZhciB1c2VySW50ZXJhY3Rpb25UcmVlcyA9IFtdO1xudmFyIHVzZXJBY3Rpb25zID0ge307XG5cbmZ1bmN0aW9uIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCkge1xuICAgIHVzZXJJbnRlcmFjdGlvbk9iamVjdC50ZXh0ID0gXCJcIjtcbiAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0ID0gW107XG4gICAgdXNlckFjdGlvbnMgPSB7fTsvL3tcIkdvIHRvIGxvY2F0aW9uIFhcIiA6IGVmZmVjdFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlckludGVyYWN0aW9uVHJlZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhlY3V0ZSh1c2VySW50ZXJhY3Rpb25UcmVlc1tpXSk7XG4gICAgfVxufVxuXG5leHBvcnQgbGV0IGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbiA9ICh0ZXh0OiBzdHJpbmcpID0+XG4gICAgYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB1c2VySW50ZXJhY3Rpb25PYmplY3QudGV4dCArPSBcIlxcblwiICsgdGV4dCwgMFxuICAgICk7XG5leHBvcnQgbGV0IGRpc3BsYXlBY3Rpb25FZmZlY3RUZXh0ID0gKHRleHQ6IHN0cmluZykgPT4gdXNlckludGVyYWN0aW9uT2JqZWN0LmFjdGlvbkVmZmVjdHNUZXh0ICs9IFwiXFxuXCIgKyB0ZXh0O1xuXG5leHBvcnQgbGV0IGFkZFVzZXJBY3Rpb25UcmVlID0gKHRleHQ6IHN0cmluZywgZWZmZWN0VHJlZTogVGljaykgPT4gYWN0aW9uKFxuICAgICgpID0+IHRydWUsXG4gICAgKCkgPT4gbWFwVXNlckFjdGlvblRvVHJlZSh0ZXh0LCBlZmZlY3RUcmVlKSwgMFxuKTtcblxuZXhwb3J0IGxldCBhZGRVc2VyQWN0aW9uID0gKHRleHQ6IHN0cmluZywgZWZmZWN0OiAoKSA9PiBhbnkpID0+XG4gICAgYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiBtYXBVc2VyQWN0aW9uVG9UcmVlKHRleHQsIGFjdGlvbigoKT0+dHJ1ZSwgZWZmZWN0LCAwKSksIDBcbiAgICApO1xuXG5mdW5jdGlvbiBtYXBVc2VyQWN0aW9uVG9UcmVlKHRleHQ6IHN0cmluZywgdHJlZTogVGljaykge1xuICAgIHVzZXJBY3Rpb25zW3RleHRdID0gdHJlZTtcbiAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0LnB1c2godGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKHRpY2s6IFRpY2spIHtcbiAgICB1c2VySW50ZXJhY3Rpb25UcmVlcy5wdXNoKHRpY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVVzZXJBY3Rpb24odGV4dDogc3RyaW5nKSB7XG4gICAgLy9leGVjdXRlIHRoZSB1c2VyIGFjdGlvblxuICAgIHVzZXJJbnRlcmFjdGlvbk9iamVjdC5hY3Rpb25FZmZlY3RzVGV4dCA9IFwiXCI7XG4gICAgdmFyIHVzZXJBY3Rpb25FZmZlY3RUcmVlID0gdXNlckFjdGlvbnNbdGV4dF07XG4gICAgZXhlY3V0ZSh1c2VyQWN0aW9uRWZmZWN0VHJlZSk7XG59XG5cbi8vNC5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VySW50ZXJhY3Rpb25PYmplY3QoKSB7XG4gICAgcmV0dXJuIHVzZXJJbnRlcmFjdGlvbk9iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVGljaygpIHtcbiAgICAvL2FsbCBhZ2VudCB0aWNrc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWdlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0cmVlID0gYWdlbnRUcmVlc1thZ2VudHNbaV1dO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRyZWUpKSB7XG4gICAgICAgICAgICBzZXRWYXJpYWJsZShcImV4ZWN1dGluZ0FnZW50XCIsIGFnZW50c1tpXSk7XG4gICAgICAgICAgICBleGVjdXRlKHRyZWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCk7XG59Il19
