(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  // Deal with resize.  skip this for node.js apps
  if (typeof window != 'undefined')
    window.addEventListener('resize', function() {
      for (var key in __instances) {
        if (__instances.hasOwnProperty(key)) {
          var instance = __instances[key];
          instance.refresh();
        }
      }
    });

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapÄ¥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'hovers',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.dispatchEvent('coordinatesUpdated');
      self.renderCamera(camera);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'hovers',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph, {
          prefix: c.readPrefix,
          maxLevel: c.settings('nodeQuadtreeMaxLevel'),
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          (c.settings('enableEdgeHovering') ||
            c.settings('edgesClippingWithNodes'))
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            maxLevel: c.settings('edgeQuadtreeMaxLevel'),
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var l,
        i,
        prefix = 0;

    // Call each renderer:
    for (i in this.renderers)
      if (this.settings('skipErrors'))
        try {
          this.renderers[i].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + this.renderers[i] +
              '" crashed on ".render()"'
            );
        }
      else
        this.renderers[i].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "'+ a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "'+a[i].id +'" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.5.2';


  /**
   * Disable ES6 features if true:
   */
  sigma.forceES5 = false;


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exists or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every jobs that are stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */


  /**
   * SigmaMap wraps an ES6 Object. Methods set, get, has, forEach, delete, and clear
   * have the same signature than the corresponding Map methods.
   */
  function SigmaMap() {
    var self = this;
    var _store;

    if (!sigma.forceES5 &&
      typeof Map !== 'undefined' &&
      Map.prototype.keys !== undefined &&
      Map.prototype.forEach !== undefined
      && Array.from !== undefined) {

      _store = new Map();

      Object.defineProperty(this, 'size', {
        get: function() { return _store.size; },
        set: undefined,
        enumerable: true
      });

      this.set = function(key, value) { _store.set('' + key, value); };
      this.get = function(key) { return _store.get('' + key); };
      this.has = function(key) { return _store.has('' + key); };
      this.forEach = function(func) { return _store.forEach(func); };
      this.delete = function(key) { return _store.delete('' + key); };
      this.clear = function() { _store.clear(); };

      this.keyList = function () {
        return Array.from(_store.keys());
      };

      this.valueList = function () {
        var values = [];
        _store.forEach(function(val) {
          values.push(val);
        });
        return values;
      };
    }
    else {
      _store = Object.create(null);
      this.size = 0;

      this.keyList = function () {
        return Object.keys(_store).filter(function(key) {
          return _store[key] !== undefined;
        });
      };

      this.valueList = function () {
        var keys = Object.keys(_store);
        var values = [];

        for (var i = 0; i < keys.length; i++) {
          var val = _store[keys[i]];
          if (val !== undefined) {
            values.push(val);
          }
        }
        return values;
      };

      this.set = function (key, value) {
        if (_store[key] === undefined) self.size++;

        _store[key] = value;
      };

      this.get = function (key) {
        return _store[key];
      };

      this.has = function (key) {
        return _store[key] !== undefined;
      };

      this.forEach = function (func) {
        var keys = Object.keys(_store);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i],
              obj = _store[key];

          if (typeof obj !== 'undefined') {
            func(obj, key);
          }
        }
      };

      this.delete = function (key) {
        var value = _store[key];
        _store[key] = undefined;

        if (value !== undefined) self.size--;

        return value;
      };

      this.clear = function () {
        for (var k in _store)
          if (!('hasOwnProperty' in _store) || _store.hasOwnProperty(k))
            delete _store[k];

        _store = Object.create(null);
        self.size = 0;
      };
    }
  }

  sigma.utils.map = SigmaMap;


  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number}  x1  The X coordinate of the start point.
   * @param  {number}  y1  The Y coordinate of the start point.
   * @param  {number}  x2  The X coordinate of the end point.
   * @param  {number}  y2  The Y coordinate of the end point.
   * @param  {?number} cc  The curvature coefficients.
   * @return {x,y}         The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2, cc) {
    cc = this.extend(cc, { x: 2, y: 4 });
    return {
      x: (x1 + x2) / cc.x + (y2 - y1) / cc.y,
      y: (y1 + y2) / cc.x + (x1 - x2) / cc.y
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * xi + t * t * x2,
      y: (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * yi + t * t * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = (1 - t) * (1 - t) * (1 - t),
        B1_t = 3 * t * (1 - t) * (1 - t),
        B2_t = 3 * t * t * (1 - t),
        B3_t = t * t * t;

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    return sigma.utils.distancePointToSegment(x, y, x1, y1, x2, y2) < epsilon;
  };

  /**
    * Compute the distance of a point to a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @return {number}         Distance to the segment
  */
  sigma.utils.distancePointToSegment = function(x, y, x1, y1, x2, y2) {
    // http://stackoverflow.com/a/6853926/1075195
    var A = x - x1,
        B = y - y1,
        C = x2 - x1,
        D = y2 - y1,
        dot = A * C + B * D,
        len_sq = C * C + D * D,
        param = -1,
        xx, yy;

    if (len_sq !== 0) //in case of 0 length line
        param = dot / len_sq;

    if (param < 0) {
      xx = x1;
      yy = y1;
    }
    else if (param > 1) {
      xx = x2;
      yy = y2;
    }
    else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }

    var dx = x - xx;
    var dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy);
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio),
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */

  /**
   * Return true if the browser support webgl
   *
   * @return {boolean}
   */
  sigma.utils.isWebGLSupported = function() {
    var canvas,
        webgl = !!window.WebGLRenderingContext;
    if (webgl) {
      canvas = document.createElement('canvas');
      try {
        return !!(
          canvas.getContext('webgl') ||
          canvas.getContext('experimental-webgl')
        );
      } catch (e) {}
    }
    return false;
  };

  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };

  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };


  /**
   * ************
   * CANVAS UTILS:
   * ************
   */
  /**
   * Calculate the width of the text either approximated via the font size or
   * via the more expensive but accurate context.measureText.
   *
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {boolean}     approximate   Approximate or not.
   * @param  {integer}     fontSize      Font size of the text.
   * @param  {string}      text          The text to use.
   *
   * @return {float}       Returns the width.
   */
   sigma.utils.canvas = {};
   sigma.utils.canvas.getTextWidth =
        function(context, approximate, fontSize, text) {

    if (!text) return 0;

    return approximate ? 0.6 * text.length * fontSize :
      context.measureText(text).width;
  };

  /**
   * Set the shadow values of the specified context according to the level
   * to create visual depth.
   *
   * @param  {number}     level     The level (from 1 to 5).
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   */
  sigma.utils.canvas.setLevel = function(level, context) {
    if (level) {
      context.shadowOffsetX = 0;
      // inspired by Material Design shadows, level from 1 to 5:
      switch(level) {
        case 1:
          context.shadowOffsetY = 1.5;
          context.shadowBlur = 4;
          context.shadowColor = 'rgba(0,0,0,0.36)';
          break;
        case 2:
          context.shadowOffsetY = 3;
          context.shadowBlur = 12;
          context.shadowColor = 'rgba(0,0,0,0.39)';
          break;
        case 3:
          context.shadowOffsetY = 6;
          context.shadowBlur = 12;
          context.shadowColor = 'rgba(0,0,0,0.42)';
          break;
        case 4:
          context.shadowOffsetY = 10;
          context.shadowBlur = 20;
          context.shadowColor = 'rgba(0,0,0,0.47)';
          break;
        case 5:
          context.shadowOffsetY = 15;
          context.shadowBlur = 24;
          context.shadowColor = 'rgba(0,0,0,0.52)';
          break;
      }
    }
  };

  /**
   * Reset the shadow values.
   *
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   */
  sigma.utils.canvas.resetLevel = function(context) {
    context.shadowOffsetY = 0;
    context.shadowBlur = 0;
    context.shadowColor = '#000000';
  };

  // incrementally scaled, not automatically resized for now
  // (ie. possible memory leak if there are many graph load / unload)
  var imgCache = {};

  /**
   * Draw an image inside the specified node on the canvas.
   *
   * @param  {object}                   node     The node object.
   * @param  {number}                   x        The node x coordinate.
   * @param  {number}                   y        The node y coordinate.
   * @param  {number}                   size     The node size.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {string}                   imgCrossOrigin Cross-origin URL or '*'.
   * @param  {number}                  threshold Display if node size is larger
   * @param  {function}                 clipFn    The clipping shape function.
   */
  sigma.utils.canvas.drawImage =
    function(node, x, y, size, context, imgCrossOrigin, threshold, clipFn) {

    if(!node.image || !node.image.url || size < threshold) return;

    var url = node.image.url;
    var ih = node.image.h || 1; // 1 is arbitrary, anyway only the ratio counts
    var iw = node.image.w || 1;
    var scale = node.image.scale || 1;
    var clip = node.image.clip || 1;

    // create new IMG or get from imgCache
    var image = imgCache[url];
    if(!image) {
      image = document.createElement('IMG');
      image.setAttribute('crossOrigin', imgCrossOrigin);
      image.src = url;
      image.onload = function() {
        window.dispatchEvent(new Event('resize'));
      };
      imgCache[url] = image;
    }

    // calculate position and draw
    var xratio = (iw < ih) ? (iw / ih) : 1;
    var yratio = (ih < iw) ? (ih / iw) : 1;
    var r = size * scale;

    context.save(); // enter clipping mode
      context.beginPath();
    if (typeof clipFn === 'function') {
      clipFn(node, x, y, size, context, clip);
    }
    else {
      // Draw the clipping disc:
      context.arc(x, y, size * clip, 0, Math. PI * 2, true);
    }
    context.closePath();
    context.clip();

    // Draw the actual image
    context.drawImage(
      image,
      x + Math.sin(-3.142 / 4) * r * xratio,
      y - Math.cos(-3.142 / 4) * r * yratio,
      r * xratio * 2 * Math.sin(-3.142 / 4) * (-1),
      r * yratio * 2 * Math.cos(-3.142 / 4)
    );
    context.restore(); // exit clipping mode
  };

  /**
   * Draw an icon inside the specified node on the canvas.
   *
   * @param  {object}                   node     The node object.
   * @param  {number}                   x        The node x coordinate.
   * @param  {number}                   y        The node y coordinate.
   * @param  {number}                   size     The node size.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {number}                  threshold Display if node size is larger
   */
  sigma.utils.canvas.drawIcon = function(node, x, y, size, context, threshold){
    if(!node.icon || size < threshold) return;

    var font = node.icon.font || 'Arial',
        fgColor = node.icon.color || '#F00',
        text = node.icon.content || '?',
        px = node.icon.x || 0.5,
        py = node.icon.y || 0.5,
        height = size,
        width = size;

    var fontSizeRatio = 0.70;
    if (typeof node.icon.scale === "number") {
      fontSizeRatio = Math.abs(Math.max(0.01, node.icon.scale));
    }

    var fontSize = Math.round(fontSizeRatio * height);

    context.save();
    context.fillStyle = fgColor;

    context.font = '' + fontSize + 'px ' + font;
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, x, y);
    context.restore();
  };

}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik MÃ¶ller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: false,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Label position relative to its node. Available values:
    //          "right", "left", "top", "bottom", "center", "inside"
    labelAlignment: 'right',
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} Maximum length of a node's label (in characters). Displays the label on several lines. 0 disables it
    // (the whole label is displayed on one line)
    maxNodeLabelLineLength: 0,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of nodes.
    nodeBorderSize: 0,
    // {number} The default node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,
    // {boolean} Approximate labels width instead of using canvas.measureText
    approximateLabelWidth: true,
    // {boolean} Hide edges from nodes too far away
    edgesClippingWithNodes: true,
    // {number} if sigma.canvas.edges.autoCurve is called, set relative
    // distance between curved parallel edges (i.e. edges with same
    // extremities). Smaller value increases distances.
    autoCurveRatio: 1,
    // {boolean} if sigma.canvas.edges.autoCurve is called, sort edges by
    // direction.
    autoCurveSortByDirection: true,


    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean} If true, the user will need to click on the visualization element
    // in order to focus it
    clickToFocus: false,
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {boolean} Defines whether the zoom focuses on the mouse location.
    zoomOnLocation: true,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,



    /**
     * SPATIAL INDEXING SETTINGS:
     * ****************
     */
    // {number} Max height of the node quad tree.
    nodeQuadtreeMaxLevel: 4,
    // {number} Max height of the edge quad tree.
    edgeQuadtreeMaxLevel: 4,



    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: new sigma.utils.map(),
      edgesIndex: new sigma.utils.map(),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: new sigma.utils.map(),
      outNeighborsIndex: new sigma.utils.map(),
      allNeighborsIndex: new sigma.utils.map()
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex.get(node.id))
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Try to fix the node coordinates and size
    if (validNode.x !== undefined && typeof validNode.x !== 'number') {
      validNode.x = parseFloat(validNode.x);
    }
    if (validNode.y !== undefined && typeof validNode.y !== 'number') {
      validNode.y = parseFloat(validNode.y);
    }
    if (validNode.size !== undefined && typeof validNode.size !== 'number') {
      validNode.size = parseFloat(validNode.size);
    }

    // Check node size
    if (!validNode.size || validNode.size <= 0) {
      validNode.size = 1;
    }

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex.set(id, new sigma.utils.map());
    this.outNeighborsIndex.set(id, new sigma.utils.map());
    this.allNeighborsIndex.set(id, new sigma.utils.map());

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex.set(validNode.id, validNode);

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex.get(edge.source))
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex.get(edge.target))
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex.get(edge.id))
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Try to fix the edge size
    if (validEdge.size !== undefined && typeof validEdge.size !== 'number') {
      validEdge.size = parseFloat(validEdge.size);
    }

    // Check edge size
    if (!validEdge.size || validEdge.size <= 0) {
      validEdge.size = 1;
    }

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex.set(validEdge.id, validEdge);

    if (!this.inNeighborsIndex.get(validEdge.target).get(validEdge.source))
      this.inNeighborsIndex.get(validEdge.target).set(validEdge.source,
        new sigma.utils.map());
    this.inNeighborsIndex.get(validEdge.target).get(validEdge.source).set(validEdge.id,
      validEdge);

    if (!this.outNeighborsIndex.get(validEdge.source).get(validEdge.target))
      this.outNeighborsIndex.get(validEdge.source).set(validEdge.target,
        new sigma.utils.map());
    this.outNeighborsIndex.get(validEdge.source).get(validEdge.target).set(validEdge.id,
      validEdge);

    if (!this.allNeighborsIndex.get(validEdge.source).get(validEdge.target))
      this.allNeighborsIndex.get(validEdge.source).set(validEdge.target,
        new sigma.utils.map());
    this.allNeighborsIndex.get(validEdge.source).get(validEdge.target).set(validEdge.id,
      validEdge);

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex.get(validEdge.target).get(validEdge.source))
        this.allNeighborsIndex.get(validEdge.target).set(validEdge.source,
          new sigma.utils.map());
      this.allNeighborsIndex.get(validEdge.target).get(validEdge.source).set(validEdge.id,
        validEdge);
    }

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex.get(id))
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    this.nodesIndex.delete(id);
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    this.inNeighborsIndex.delete(id);
    this.outNeighborsIndex.delete(id);
    this.allNeighborsIndex.delete(id);

    var self = this;
    this.nodesIndex.forEach(function(n, k) {
      self.inNeighborsIndex.get(k).delete(id);
      self.outNeighborsIndex.get(k).delete(id);
      self.allNeighborsIndex.get(k).delete(id);
    });

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex.get(id))
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex.get(id);
    this.edgesIndex.delete(id);
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    this.inNeighborsIndex.get(edge.target).get(edge.source).delete(edge.id);
    if (this.inNeighborsIndex.get(edge.target).get(edge.source).size == 0)
      this.inNeighborsIndex.get(edge.target).delete(edge.source);

    this.outNeighborsIndex.get(edge.source).get(edge.target).delete(edge.id);
    if (this.outNeighborsIndex.get(edge.source).get(edge.target).size == 0)
      this.outNeighborsIndex.get(edge.source).delete(edge.target);

    this.allNeighborsIndex.get(edge.source).get(edge.target).delete(edge.id);
    if (this.allNeighborsIndex.get(edge.source).get(edge.target).size == 0)
      this.allNeighborsIndex.get(edge.source).delete(edge.target);

    if (edge.target !== edge.source) {
      this.allNeighborsIndex.get(edge.target).get(edge.source).delete(edge.id);
      if (this.allNeighborsIndex.get(edge.target).get(edge.source).size == 0)
        this.allNeighborsIndex.get(edge.target).delete(edge.source);
    }

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    this.nodesIndex.clear();
    this.edgesIndex.clear();
    this.nodesIndex.clear();
    this.inNeighborsIndex.clear();
    this.outNeighborsIndex.clear();
    this.allNeighborsIndex.clear();

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex.get(v);

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex.get(v[i]));
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsIndex,
      'out': this.outNeighborsIndex
    }[which || ''] || this.allNeighborsIndex;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which.get(v).size;

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which.get(v[i]).size);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex.get(v);

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex.get(v[i]));
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ('ratio' in coordinates && !this.settings('zoomOnLocation'))
          ? ['ratio', 'angle'] : ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal), SÃ©bastien Heymann, Damien MariÃ©
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },


    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          (r.x2 - r.x1) * (r.x2 - r.x1) +
          (r.y2 - r.y1) * (r.y2 - r.y1)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (a.x * a.x + a.y * a.y)
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * @param  {boolean?} indexEdges Tell to index edges or nodes
   *
   * property {object} _tree       Property holding the quadtree object
   * property {object} _geom       Exposition of the _geom namespace for testing
   * property {object} _cache      Cache for the area method
   */
  var quad = function(indexEdges) {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
    this._indexEdges = indexEdges || false;
  };

  /**
   * Index a graph by inserting its elements into the quadtree.
   *
   * @param  {array}  graph      The graph to index
   * @param  {object} params     An object of parameters with at least the quad
   *                             bounds.
   * @return {object}            The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(graph, params) {
    if (!this._enabled) {
      return this._tree;
    }

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        cc = params.curvatureCoefficients,
        source,
        target,
        i,
        l,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    if (!this._indexEdges) {
      var nodes = graph.nodes();
      // Inserting graph nodes into the tree
      for (i = 0, l = nodes.length; i < l; i++) {

        // Inserting node
        _quadInsert(
          nodes[i],
          _geom.pointToSquare({
            x: nodes[i][prefix + 'x'],
            y: nodes[i][prefix + 'y'],
            size: nodes[i][prefix + 'size']
          }),
          this._tree
        );
      }
    } else {
      var edges = graph.edges();
      // Inserting graph edges into the tree
      for (i = 0, l = edges.length; i < l; i++) {
        source = graph.nodes(edges[i].source);
        target = graph.nodes(edges[i].target);
        e = {
          x1: source[prefix + 'x'],
          y1: source[prefix + 'y'],
          x2: target[prefix + 'x'],
          y2: target[prefix + 'y'],
          size: edges[i][prefix + 'size'] || 0
        };

        // Inserting edge
        if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
          if (source.id === target.id) {
            n = {
              x: source[prefix + 'x'],
              y: source[prefix + 'y'],
              size: source[prefix + 'size'] || 0
            };
            _quadInsert(
              edges[i],
              _geom.selfLoopToSquare(n),
              this._tree);
          }
          else {
            cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2, edges[i].cc || cc);
            _quadInsert(
              edges[i],
              _geom.quadraticCurveToSquare(e, cp),
              this._tree);
          }
        }
        else {
          _quadInsert(
            edges[i],
            _geom.lineToSquare(e),
            this._tree);
        }
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var elements = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var elementsArr = [];
    for (var i in elements)
      elementsArr.push(elements[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = elementsArr;

    return elementsArr;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
    this.sigma.classes.edgequad = quad.bind(this, true);
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;

}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    this.eltFocused = false;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    _target.addEventListener('mouseenter', _enterHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    function _enterHandler(e) {
      if (!_settings('clickToFocus')) {
        target.focus();
      }
    }

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      _self.eltFocused = false;
      target.blur();

      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      _self.eltFocused = true;
      target.focus();

      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && (!_settings('clickToFocus') || _self.eltFocused)) {
        ratio = sigma.utils.getDelta(e) > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };

  /**
   * Static method to render edges or nodes with the given renderers
   *
   * @param  {object}       params     The parameters passed in an object
   * {
   *   renderers: {object}              Renderers indexed by types
   *   type:      {string}              "edges" or "nodes"
   *   ctx:       {Context2D}           Canvas Context to draw on
   *   settings:  {object}              Settings object to use
   *   elements:  {array}               Elements to render
   *   graph?:    {sigma.classes.graph} Graph object
   *                                    (only necessary for edge rendering)
   *   start?:    {integer}             Starting index of the elements to render
   *   end?:      {integer}             Last index of the elements to render
   * }
   */
  sigma.renderers.canvas.applyRenderers = function(params) {
    var i,
        renderer,
        specializedRenderer,
        def,
        render,
        els = params.elements,
        ctx_infos = {font: params.ctx.font},
        elementType = (params.elements || params.type == 'edges' ?
              'defaultEdgeType' : 'defaultNodeType');

    params.start = params.start || 0;
    params.end = params.end || params.elements.length;
    params.end = Math.min(params.elements.length, params.end);

    params.ctx.save();

    for (i = params.start; i < params.end; i++) {
      if (!els[i].hidden) {
        specializedRenderer = params.renderers[
          els[i].type || params.settings(elementType)
        ];
        def = (specializedRenderer || params.renderers.def);
        if (params.type == 'edges') {
          def(
            els[i],
            params.graph.nodes(els[i].source),
            params.graph.nodes(els[i].target),
            params.ctx,
            params.settings,
            {ctx: ctx_infos}
          );
        }else {
          def(
            els[i],
            params.ctx,
            params.settings,
            {ctx: ctx_infos}
          );
        }
      }
    }

    params.ctx.restore();
  };


  /**
   * Render a batch of edges
   *
   * @param    {integer}      start    Starting index of the elements to render
   * @param    {integer}      end      Last index of the elements to render
   * @param    {object}       settings Settings to use
   */
  sigma.renderers.canvas.prototype.renderEdges =
          function(start, end, settings) {
    var renderParams = {
      renderers: sigma.canvas.edges,
      type: 'edges',
      elements: this.edgesOnScreen,
      ctx: this.contexts.edges,
      start: start,
      end: end,
      graph: this.graph,
      settings: settings
    };
    sigma.renderers.canvas.applyRenderers(renderParams);
    if (settings('drawEdgeLabels')) {
      renderParams.renderers = sigma.canvas.edges.labels;
      renderParams.ctx = this.contexts.labels;
      sigma.renderers.canvas.applyRenderers(renderParams);
    }
  };

  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    this.dispatchEvent('beforeRender');

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      this.edgesOnScreen = [];
      if (embedSettings('edgesClippingWithNodes')) {
        // Identify which edges to draw by keeping every edges that have at
        // least one extremity displayed according to the quadtree and the
        // "hidden" attribute. We also do not keep hidden edges.
        for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
          o = a[i];
          if (
            (index[o.source] || index[o.target]) &&
            (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
          )
            this.edgesOnScreen.push(o);
        }
      } else {
        this.edgesOnScreen = this.camera.edgequadtree.area(
          this.camera.getRectangle(this.width, this.height)
        );
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (embedSettings('batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          this.renderEdges(start, end, embedSettings);

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        this.renderEdges(0, this.edgesOnScreen.length, embedSettings);
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      sigma.renderers.canvas.applyRenderers({
        renderers: sigma.canvas.nodes,
        type: 'nodes',
        ctx: this.contexts.nodes,
        elements: this.nodesOnScreen,
        settings: embedSettings
      });
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      sigma.renderers.canvas.applyRenderers({
        renderers: sigma.canvas.labels,
        type: 'nodes',
        ctx: this.contexts.labels,
        elements: this.nodesOnScreen,
        settings: embedSettings
      });
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      edgelabels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    this.dispatchEvent('beforeRender');

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);
    this.hideDOMElements(this.domElements.edgelabels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          if (drawLabels) {
            e = (subrenderers[a[i].type] || subrenderers.def).create(
              a[i],
              embedSettings
            );

            this.domElements.labels[a[i].id] = e;
            this.domElements.groups.labels.appendChild(e);
          }
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        if (drawLabels) {
          (subrenderers[a[i].type] || subrenderers.def).update(
            a[i],
            this.domElements.labels[a[i].id],
            embedSettings
          );
        }
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;
    subrenderers = sigma.svg.edges.labels;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] ||
            renderers[defaultEdgeType] ||
            renderers.def
          ).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);

          // Label
          if (drawEdgeLabels) {

            e = (subrenderers[a[i].type] ||
              subrenderers[defaultEdgeType]  ||
              subrenderers.def
            ).create(
              a[i],
              embedSettings
            );
            this.domElements.edgelabels[a[i].id] = e;
            this.domElements.groups.edgelabels.appendChild(e);
          }
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] ||
          renderers[defaultEdgeType] ||
          renderers.def
        ).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );

        // Label
        if (drawEdgeLabels) {
          (subrenderers[a[i].type] ||
            subrenderers[defaultEdgeType] ||
            subrenderers.def
          ).update(
            a[i],
            source,
            target,
            this.domElements.edgelabels[a[i].id],
            embedSettings
          );
        }
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'edgelabels', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function updateHovers(e) {
      var node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      if (e.data.enter.nodes.length > 0) { // over
        node = e.data.enter.nodes[0];
        var hover = (renderers[node.type] || renderers.def).create(
          node,
          self.domElements.nodes[node.id],
          self.measurementCanvas,
          embedSettings
        );

        self.domElements.hovers[node.id] = hover;

        // Inserting the hover in the dom
        self.domElements.groups.hovers.appendChild(hover);
        hoveredNode = node;
      } else if (e.data.leave.nodes.length > 0) { // out
        node = e.data.leave.nodes[0];

        // Deleting element
        self.domElements.groups.hovers.removeChild(
          self.domElements.hovers[node.id]
        );
        hoveredNode = null;
        delete self.domElements.hovers[node.id];

        // Reinstate
        self.domElements.groups.nodes.appendChild(
          self.domElements.nodes[node.id]
        );
      }
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('hovers', updateHovers);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = this.width + 'px';
      this.domElements.graph.style.height = this.height + 'px';
    }

    return this;
  };

  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
  sigma.utils.pkg('sigma.svg.edgelabels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Copy the good renderer:
  sigma.renderers.def = sigma.utils.isWebGLSupported() ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will display the label of the node
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   * @param  {object?}                  infos    The batch infos.
   */
  sigma.canvas.labels.def = function(node, context, settings, infos) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'] || 1,
        fontStyle = settings('fontStyle'),
        borderSize = settings('nodeBorderSize'),
        labelWidth,
        labelOffsetX,
        labelOffsetY,
        alignment = settings('labelAlignment'),
        maxLineLength = settings('maxNodeLabelLineLength') || 0;

    if (size <= settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    var new_font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' +
      (node.active ?
        settings('activeFont') || settings('font') :
        settings('font'));

    if (infos && infos.ctx.font != new_font) { //use font value caching
      context.font = new_font;
      infos.ctx.font = new_font;
    } else {
      context.font = new_font;
    }

    context.fillStyle =
        (settings('labelColor') === 'node') ?
        node.color || settings('defaultNodeColor') :
        settings('defaultLabelColor');

    labelOffsetX = 0;
    labelOffsetY = fontSize / 3;
    context.textAlign = 'center';

    switch (alignment) {
      case 'bottom':
        labelOffsetY = + size + 4 * fontSize / 3;
        break;
      case 'center':
        break;
      case 'left':
        context.textAlign = 'right';
        labelOffsetX = - size - borderSize - 3;
        break;
      case 'top':
        labelOffsetY = - size - 2 * fontSize / 3;
        break;
      case 'inside':
        labelWidth = sigma.utils.canvas.getTextWidth(context, settings('approximateLabelWidth'), fontSize, node.label);
        if (labelWidth <= (size + fontSize / 3) * 2) {
          break;
        }
      /* falls through*/
      case 'right':
      /* falls through*/
      default:
        labelOffsetX = size + borderSize + 3;
        context.textAlign = 'left';
        break;
    }

    var lines = getLines(node.label, maxLineLength),
        baseX = node[prefix + 'x'] + labelOffsetX,
        baseY = Math.round(node[prefix + 'y'] + labelOffsetY);

    for (var i = 0; i < lines.length; ++i) {
      context.fillText(lines[i], baseX, baseY + i * (fontSize + 1));
    }
  };

  /**
   * Split a text into several lines. Each line won't be longer than the specified maximum length.
   * @param {string}  text            Text to split
   * @param {number}  maxLineLength   Maximum length of a line. A value <= 1 will be treated as "infinity".
   * @returns {Array<string>}         List of lines
   */
  function getLines(text, maxLineLength) {
    if (maxLineLength <= 1) {
      return [text];
    }

    var words = text.split(' '),
        lines = [],
        lineLength = 0,
        lineIndex = -1,
        lineList = [],
        lineFull = true;

    for (var i = 0; i < words.length; ++i) {
      if (lineFull) {
        if (words[i].length > maxLineLength) {
          var parts = splitWord(words[i], maxLineLength);
          for (var j = 0; j < parts.length; ++j) {
            lines.push([parts[j]]);
            ++lineIndex;
          }
          lineLength = parts[parts.length - 1].length;
        } else {
          lines.push([words[i]
          ]);
          ++lineIndex;
          lineLength = words[i].length + 1;
        }
        lineFull = false;
      } else if (lineLength + words[i].length <= maxLineLength) {
        lines[lineIndex].push(words[i]);
        lineLength += words[i].length + 1;
      } else {
        lineFull = true;
        --i;
      }
    }

    for (i = 0; i < lines.length; ++i) {
      lineList.push(lines[i].join(' '))
    }

    return lineList;
  }

  /**
   * Split a word into several lines (with a '-' at the end of each line but the last).
   * @param {string} word       Word to split
   * @param {number} maxLength  Maximum length of a line
   * @returns {Array<string>}   List of lines
   */
  function splitWord(word, maxLength) {
    var parts = [];

    for (var i = 0; i < word.length; i += maxLength - 1) {
      parts.push(word.substr(i, maxLength - 1) + '-');
    }

    var lastPartLen = parts[parts.length - 1].length;
    parts[parts.length - 1] = parts[parts.length - 1].substr(0, lastPartLen - 1) + ' ';

    return parts;
  }
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        labelX,
        labelY,
        lines,
        baseX,
        baseY,
        borderSize = settings('nodeBorderSize'),
        alignment = settings('labelAlignment'),
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        maxLineLength = settings('maxNodeLabelLineLength') || 0,
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;


    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    lines = getLines(node.label, maxLineLength);
    drawHoverBorder(alignment, context, fontSize, node, lines, maxLineLength);

    // Node border:
    if (borderSize > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + borderSize,
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');
      var labelWidth = sigma.utils.canvas.getTextWidth(context,
            settings('approximateLabelWidth'), fontSize, node.label),
          labelOffsetX = - labelWidth / 2,
          labelOffsetY = fontSize / 3;

      switch (alignment) {
        case 'bottom':
          labelOffsetY = + size + 4 * fontSize / 3;
          break;
        case 'center':
          break;
        case 'left':
          labelOffsetX = - size - borderSize - 3 - labelWidth;
          break;
        case 'top':
          labelOffsetY = - size - 2 * fontSize / 3;
          break;
        case 'inside':
          if (labelWidth <= (size + fontSize / 3) * 2) {
            break;
          }
        /* falls through*/
        case 'right':
        /* falls through*/
        default:
          labelOffsetX = size + borderSize + 3;
          break;
      }

      baseX = node[prefix + 'x'] + labelOffsetX;
      baseY = Math.round(node[prefix + 'y'] + labelOffsetY);

      for (var i = 0; i < lines.length; ++i) {
        context.fillText(lines[i], baseX, baseY + i * (fontSize + 1));
      }
    }

    function drawHoverBorder(alignment, context, fontSize, node, lines, maxLineLength) {
      var labelWidth =
        (maxLineLength > 1 && lines.length > 1) ?
        0.6 * maxLineLength * fontSize :
        sigma.utils.canvas.getTextWidth(
          context,
          settings('approximateLabelWidth'),
          fontSize,
          lines[0]
        );

      var x = Math.round(node[prefix + 'x']),
          y = Math.round(node[prefix + 'y']),
          h = ((fontSize + 1) * lines.length) + 4,
          e = Math.round(size + fontSize / 4),
          w = Math.round(labelWidth + size + 1.5 + fontSize / 3);

      if (node.label && typeof node.label === 'string') {
        // draw a rectangle for the label
        switch (alignment) {
          case 'center':
            break;
          case 'left':
            x = Math.round(node[prefix + 'x'] + fontSize / 2 + 2);
            y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);

            context.moveTo(x, y + e);
            context.arcTo(x, y, x - e, y, e);
            context.lineTo(x - w - borderSize - e, y);
            context.lineTo(x - w - borderSize - e, y + h);
            context.lineTo(x - e, y + h);
            context.arcTo(x, y + h, x, y + h - e, e);
            context.lineTo(x, y + e);
            break;
          case 'top':
            context.rect(x - w / 2, y - e - h, w, h);
            break;
          case 'bottom':
            context.rect(x - w / 2, y + e, w, h);
            break;
          case 'inside':
            if (labelWidth <= e * 2) {
              // don't draw anything
              break;
            }
            // use default setting, falling through
          /* falls through*/
          case 'right':
          /* falls through*/
          default:
            x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
            y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);

            context.moveTo(x, y + e);
            context.arcTo(x, y, x + e, y, e);
            context.lineTo(x + w + borderSize + e, y);
            context.lineTo(x + w + borderSize + e, y + h);
            context.lineTo(x + e, y + h);
            context.arcTo(x, y + h, x, y + h - e, e);
            context.lineTo(x, y + e);
            break;
        }
      }

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    /**
     * Split a text into several lines. Each line won't be longer than the specified maximum length.
     * @param {string}  text            Text to split
     * @param {number}  maxLineLength   Maximum length of a line. A value <= 1 will be treated as "infinity".
     * @returns {Array<string>}         List of lines
     */
    function getLines(text, maxLineLength) {
      if (maxLineLength <= 1) {
        return [text];
      }

      var words = text.split(' '),
        lines = [],
        lineLength = 0,
        lineIndex = -1,
        lineList = [],
        lineFull = true;

      for (var i = 0; i < words.length; ++i) {
        if (lineFull) {
          if (words[i].length > maxLineLength) {
            var parts = splitWord(words[i], maxLineLength);
            for (var j = 0; j < parts.length; ++j) {
              lines.push([parts[j]]);
              ++lineIndex;
            }
            lineLength = parts[parts.length - 1].length;
          } else {
            lines.push([words[i]
            ]);
            ++lineIndex;
            lineLength = words[i].length + 1;
          }
          lineFull = false;
        } else if (lineLength + words[i].length <= maxLineLength) {
          lines[lineIndex].push(words[i]);
          lineLength += words[i].length + 1;
        } else {
          lineFull = true;
          --i;
        }
      }

      for (i = 0; i < lines.length; ++i) {
        lineList.push(lines[i].join(' '))
      }

      return lineList;
    }

    /**
     * Split a word into several lines (with a '-' at the end of each line but the last).
     * @param {string} word       Word to split
     * @param {number} maxLength  Maximum length of a line
     * @returns {Array<string>}   List of lines
     */
    function splitWord(word, maxLength) {
      var parts = [];

      for (var i = 0; i < word.length; i += maxLength - 1) {
        parts.push(word.substr(i, maxLength - 1) + '-');
      }

      var lastPartLen = parts[parts.length - 1].length;
      parts[parts.length - 1] = parts[parts.length - 1].substr(0, lastPartLen - 1) + ' ';

      return parts;
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as curves.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.curve = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt((tX - sX) * (tX - sX) + (tY - sY) * (tY - sY)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as curves with arrow heading.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (source.id === target.id) {
      d = Math.sqrt((tX - cp.x1) * (tX - cp.x1) + (tY - cp.y1) * (tY - cp.y1));
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt((tX - cp.x) * (tX - cp.x) + (tY - cp.y) * (tY - cp.y));
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt((tX - sX) * (tX - sX) + (tY - sY) * (tY - sY)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);

    if (source.id === target.id) {
      d = Math.sqrt((tX - cp.x1) * (tX - cp.x1) + (tY - cp.y1) * (tY - cp.y1));
      aSize = Math.max(size * 2.5, settings('minArrowSize'));
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt((tX - cp.x) * (tX - cp.x) + (tY - cp.y) * (tY - cp.y));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the edge as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               path       The path DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '',
          sSize = source[prefix + 'size'],
          sX = source[prefix + 'x'],
          sY = source[prefix + 'y'],
          tX = target[prefix + 'x'],
          tY = target[prefix + 'y'],
          cp,
          p;

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      if (source.id === target.id) {
        cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'C' + cp.x1 + ',' + cp.y1 + ' ' +
            cp.x2 + ',' + cp.y2 + ' ' +
            tX + ',' + tY;
      }
      else {
        cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'Q' + cp.x + ',' + cp.y + ' ' +
            tX + ',' + tY;
      }

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * TODO add arrow
   */
  sigma.svg.edges.curvedArrow = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               path       The path DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '',
          sSize = source[prefix + 'size'],
          sX = source[prefix + 'x'],
          sY = source[prefix + 'y'],
          tX = target[prefix + 'x'],
          tY = target[prefix + 'y'],
          cp,
          p;

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      if (source.id === target.id) {
        cp = sigma.utils.getSelfLoopControlPoints(sX, sY, sSize);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'C' + cp.x1 + ',' + cp.y1 + ' ' +
            cp.x2 + ',' + cp.y2 + ' ' +
            tX + ',' + tY;
      }
      else {
        cp = sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY, edge.cc);
        // Path
        p = 'M' + sX + ',' + sY + ' ' +
            'Q' + cp.x + ',' + cp.y + ' ' +
            tX + ',' + tY;
      }

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    if (np) {
      /**
       * First, we compute the scaling ratio, without considering the sizes
       * of the nodes : Each node will have its center in the canvas, but might
       * be partially out of it.
       */
      scale = settings('scalingMode') === 'outside' ?
        Math.max(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        ) :
        Math.min(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        );

      /**
       * Then, we correct that scaling ratio considering a margin, which is
       * basically the size of the biggest node.
       * This has to be done as a correction since to compare the size of the
       * biggest node to the X and Y values, we have to first get an
       * approximation of the scaling ratio.
       **/
      margin =
        (
          settings('rescaleIgnoreSize') ?
            0 :
            (settings('maxNodeSize') || sizeMax) / scale
        ) +
        (settings('sideMargin') || 0);
      maxX += margin;
      minX -= margin;
      maxY += margin;
      minY -= margin;

      // Fix the scaling with the new extrema:
      scale = settings('scalingMode') === 'outside' ?
        Math.max(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        ) :
        Math.min(
          w / Math.max(maxX - minX, 1),
          h / Math.max(maxY - minY, 1)
        );
    }

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);

      if (np) {
        n[i][writePrefix + 'x'] =
          (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * scale;
        n[i][writePrefix + 'y'] =
          (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * scale;
      }
      else {
        n[i][writePrefix + 'x'] = n[i][readPrefix + 'x'];
        n[i][writePrefix + 'y'] = n[i][readPrefix + 'y'];
      }
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              (modifiedX - x) * (modifiedX - x) +
              (modifiedY - y) * (modifiedY - y)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  edge.cc);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            event = {
              current: { nodes: [], edges: [], },
              enter: { nodes: [], edges: [], },
              leave: { nodes: [], edges: [], },
              captor: e.data
            },
            leave = event.leave;

        for (k in overNodes)
          leave.nodes.push(overNodes[k]);

        for (k in overEdges)
          leave.edges.push(overEdges[k]);

        overNodes = {};
        overEdges = {};

        if (leave.nodes.length || leave.edges.length) {
          self.dispatchEvent('hovers', event);
        }
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {};

        // Check newly overred nodes:
        for (i = 0; i < nodes.length; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Check newly overred edges:
        for (i = 0; i < edges.length; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        if (newOutEdges.length || newOverEdges.length ||
             newOutNodes.length || newOverNodes.length) {
          self.dispatchEvent('hovers', {
            current: {
              nodes: nodes,
              edges: edges,
            },
            enter: {
              nodes: newOverNodes,
              edges: newOverEdges,
            },
            leave: {
              nodes: newOutNodes,
              edges: newOutEdges,
            },
            captor: e.data
          });
        }
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph,
        hovered = {nodes: [], edges: []};

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', sigma.utils.mouseCoords(e));

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', sigma.utils.mouseCoords(e));

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el_svg = new Element(target),
        event = {
          leave: {nodes: [], edges: []},
          enter: {nodes: [], edges: []},
          captor: sigma.utils.mouseCoords(e),
        },
        el;

      if (el_svg.isNode()) {
        el = graph.nodes(el_svg.attr('data-node-id'));
        event.enter.nodes = [el];
        hovered.nodes.push(el);
      } else if (el_svg.isEdge()) {
        el = graph.edges(el_svg.attr('data-edge-id'));
        event.enter.edges = [el];
        hovered.edges.push(el);
      }

      event.current = hovered;
      self.dispatchEvent('hovers', event);
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el_svg = new Element(target),
        event = {
          leave: {nodes: [], edges: []},
          enter: {nodes: [], edges: []},
          captor: sigma.utils.mouseCoords(e),
        },
        el;

      if (el_svg.isNode()) {
        el = graph.nodes(el_svg.attr('data-node-id'));
        event.leave.nodes = [el];
        hovered.nodes.push(el);
      } else if (el_svg.isEdge()) {
        el = graph.edges(el_svg.attr('data-edge-id'));
        event.leave.edges = [el];
        hovered.edges.push(el);
      } else {
        return;
      }

      event.current = hovered;
      self.dispatchEvent('hovers', event);
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "hovers" events from a renderer and renders
   * the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        current = {nodes: [], edges: []};

    this.bind('hovers', function(event) {
      current = event.data.current;
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {
      var c = self.contexts.hover.canvas,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          }),
          end = embedSettings('singleHover') ? 1 : undefined,
          renderParams = {
            elements: current.nodes,
            renderers: sigma.canvas.hovers,
            type: 'nodes',
            ctx: self.contexts.hover,
            end: end,
            graph: self.graph,
            settings: embedSettings,
          };

      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render
      if (current.nodes.length > 0 && embedSettings('enableHovering')) {
        sigma.renderers.canvas.applyRenderers(renderParams);
      }

      // Edge render
      if (current.edges.length > 0 && embedSettings('enableEdgeHovering')) {
        renderParams.renderers = sigma.canvas.edgehovers;
        renderParams.elements = current.edges;
        renderParams.type = 'edges';
        sigma.renderers.canvas.applyRenderers(renderParams);

        if (embedSettings('edgeHoverExtremities')) {
          renderParams.renderers = sigma.canvas.extremities;
          sigma.renderers.canvas.applyRenderers(renderParams);
        } else { //draw nodes over edges
          renderParams.ctx = self.contexts.nodes;
          renderParams.type = 'nodes';
          renderParams.renderers = sigma.canvas.nodes;
          renderParams.elements = current.nodes;
          sigma.renderers.canvas.applyRenderers(renderParams);
        }
      }
    }
  };
}).call(this);

},{}],2:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.layouts.noverlap');

  /**
   * Noverlap Layout
   * ===============================
   *
   * Author: @apitts / Andrew Pitts
   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)
   * Acknowledgement: @sheyman / SÃ©bastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)
   * Version: 0.1
   */

  var settings = {
    speed: 3,
    scaleNodes: 1.2,
    nodeMargin: 5.0,
    gridSize: 20,
    permittedExpansion: 1.1,
    rendererIndex: 0,
    maxIterations: 500
  };

  var _instance = {};

  /**
   * Event emitter Object
   * ------------------
   */
  var _eventEmitter = {};

   /**
   * Noverlap Object
   * ------------------
   */
  function Noverlap() {
    var self = this;

    this.init = function (sigInst, options) {
      options = options || {};

      // Properties
      this.sigInst = sigInst;
      this.config = sigma.utils.extend(options, settings);
      this.easing = options.easing;
      this.duration = options.duration;

      if (options.nodes) {
        this.nodes = options.nodes;
        delete options.nodes;
      }

      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {
        throw new Error('sigma.plugins.animate is not declared');
      }

      // State
      this.running = false;
    };

    /**
     * Single layout iteration.
     */
    this.atomicGo = function () {
      if (!this.running || this.iterCount < 1) return false;

      var nodes = this.nodes || this.sigInst.graph.nodes(),
          nodesCount = nodes.length,
          i,
          n,
          n1,
          n2,
          xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity,
          xwidth,
          yheight,
          xcenter,
          ycenter,
          grid,
          row,
          col,
          minXBox,
          maxXBox,
          minYBox,
          maxYBox,
          adjacentNodes,
          subRow,
          subCol,
          nxmin,
          nxmax,
          nymin,
          nymax;

      this.iterCount--;
      this.running = false;

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        n.dn.dx = 0;
        n.dn.dy = 0;

        //Find the min and max for both x and y across all nodes
        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );

      }

      xwidth = xmax - xmin;
      yheight = ymax - ymin;
      xcenter = (xmin + xmax) / 2;
      ycenter = (ymin + ymax) / 2;
      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;
      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;
      ymin = ycenter - self.config.permittedExpansion*yheight / 2;
      ymax = ycenter + self.config.permittedExpansion*yheight / 2;

      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid

      for(row = 0; row < self.config.gridSize; row++) {
        grid[row] = {};
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col] = [];
        }
      }

      //Place nodes in grid
      for (i=0; i < nodesCount; i++) {
        n = nodes[i];

        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);

        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );
        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );
        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );
        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );
        for(col = minXBox; col <= maxXBox; col++) {
          for(row = minYBox; row <= maxYBox; row++) {
            grid[row][col].push(n.id);
          }
        }
      }


      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes

      for(row = 0; row < self.config.gridSize; row++) {
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col].forEach(function(nodeId) {
            if(!adjacentNodes[nodeId]) {
              adjacentNodes[nodeId] = [];
            }
            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {
              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {
                grid[subRow][subCol].forEach(function(subNodeId) {
                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {
                    adjacentNodes[nodeId].push(subNodeId);
                  }
                });
              }
            }
          });
        }
      }

      //If two nodes overlap then repulse them
      for (i=0; i < nodesCount; i++) {
        n1 = nodes[i];
        adjacentNodes[n1.id].forEach(function(nodeId) {
          var n2 = self.sigInst.graph.nodes(nodeId);
          var xDist = n2.dn_x - n1.dn_x;
          var yDist = n2.dn_y - n1.dn_y;
          var dist = Math.sqrt(xDist*xDist + yDist*yDist);
          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));
          if(collision) {
            self.running = true;
            if(dist > 0) {
              n2.dn.dx += xDist / dist * (1 + n1.dn_size);
              n2.dn.dy += yDist / dist * (1 + n1.dn_size);
            } else {
              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());
              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());
            }
          }
        });
      }

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        if(!n.fixed) {
          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;
          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;
        }
      }

      if(this.running && this.iterCount < 1) {
        this.running = false;
      }

      return this.running;
    };

    this.go = function () {
      this.iterCount = this.config.maxIterations;

      while (this.running) {
        this.atomicGo();
      };

      this.stop();
    };

    this.start = function() {
      if (this.running) return;

      var nodes = this.sigInst.graph.nodes();

      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;

      this.running = true;

      // Init nodes
      for (var i = 0; i < nodes.length; i++) {
        nodes[i].dn_x = nodes[i][prefix + 'x'];
        nodes[i].dn_y = nodes[i][prefix + 'y'];
        nodes[i].dn_size = nodes[i][prefix + 'size'];
        nodes[i].dn = {
          dx: 0,
          dy: 0
        };
      }
      _eventEmitter[self.sigInst.id].dispatchEvent('start');
      this.go();
    };

    this.stop = function() {
      var nodes = this.sigInst.graph.nodes();

      this.running = false;

      if (this.easing) {
        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');
        sigma.plugins.animate(
          self.sigInst,
          {
            x: 'dn_x',
            y: 'dn_y'
          },
          {
            easing: self.easing,
            onComplete: function() {
              self.sigInst.refresh();
              for (var i = 0; i < nodes.length; i++) {
                nodes[i].dn = null;
                nodes[i].dn_x = null;
                nodes[i].dn_y = null;
              }
              _eventEmitter[self.sigInst.id].dispatchEvent('stop');
            },
            duration: self.duration
          }
        );
      }
      else {
        // Apply changes
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].x = nodes[i].dn_x;
          nodes[i].y = nodes[i].dn_y;
        }

        this.sigInst.refresh();

        for (var i = 0; i < nodes.length; i++) {
          nodes[i].dn = null;
          nodes[i].dn_x = null;
          nodes[i].dn_y = null;
        }
        _eventEmitter[self.sigInst.id].dispatchEvent('stop');
      }
    };

    this.kill = function() {
      this.sigInst = null;
      this.config = null;
      this.easing = null;
    };
  };

  /**
   * Interface
   * ----------
   */

  /**
   * Configure the layout algorithm.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object:
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */
  sigma.prototype.configNoverlap = function(config) {

    var sigInst = this;

    if (!config) throw new Error('Missing argument: "config"');

    // Create instance if undefined
    if (!_instance[sigInst.id]) {
      _instance[sigInst.id] = new Noverlap();

      _eventEmitter[sigInst.id] = {};
      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);

      // Binding on kill to clear the references
      sigInst.bind('kill', function() {
        _instance[sigInst.id].kill();
        _instance[sigInst.id] = null;
        _eventEmitter[sigInst.id] = null;
      });
    }

    _instance[sigInst.id].init(sigInst, config);

    return _eventEmitter[sigInst.id];
  };

  /**
   * Start the layout algorithm. It will use the existing configuration if no
   * new configuration is passed.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */

  sigma.prototype.startNoverlap = function(config) {

    var sigInst = this;

    if (config) {
      this.configNoverlap(sigInst, config);
    }

    _instance[sigInst.id].start();

    return _eventEmitter[sigInst.id];
  };

  /**
   * Returns true if the layout has started and is not completed.
   *
   * @return {boolean}
   */
  sigma.prototype.isNoverlapRunning = function() {

    var sigInst = this;

    return !!_instance[sigInst.id] && _instance[sigInst.id].running;
  };

}).call(this);
},{}],3:[function(require,module,exports){
/**
 * This plugin provides a method to animate a sigma instance by interpolating
 * some node properties. Check the sigma.plugins.animate function doc or the
 * examples/animate.html code sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');

  var _id = 0,
      _cache = {};

  // TOOLING FUNCTIONS:
  // ******************
  function parseColor(val) {
    if (_cache[val])
      return _cache[val];

    var result = [0, 0, 0];

    if (val.match(/^#/)) {
      val = (val || '').replace(/^#/, '');
      result = (val.length === 3) ?
        [
          parseInt(val.charAt(0) + val.charAt(0), 16),
          parseInt(val.charAt(1) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(2), 16)
        ] :
        [
          parseInt(val.charAt(0) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(3), 16),
          parseInt(val.charAt(4) + val.charAt(5), 16)
        ];
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      result = [
        +val[1],
        +val[2],
        +val[3]
      ];
    }

    _cache[val] = {
      r: result[0],
      g: result[1],
      b: result[2]
    };

    return _cache[val];
  }

  function interpolateColors(c1, c2, p) {
    c1 = parseColor(c1);
    c2 = parseColor(c2);

    var c = {
      r: c1.r * (1 - p) + c2.r * p,
      g: c1.g * (1 - p) + c2.g * p,
      b: c1.b * (1 - p) + c2.b * p
    };

    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';
  }

  /**
   * This function will animate some specified node properties. It will
   * basically call requestAnimationFrame, interpolate the values and call the
   * refresh method during a specified duration.
   *
   * Events fired though sigma instance:
   * *************
   * animate.start  Fired at the beginning of the animation.
   * animate.end    Fired at the end of the animation.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {?array}             nodes      An array of node objects or node ids. If
   *                                   not specified, all nodes of the graph
   *                                   will be animated.
   *   {?(function|string)} easing     Either the name of an easing in the
   *                                   sigma.utils.easings package or a
   *                                   function. If not specified, the
   *                                   quadraticInOut easing from this package
   *                                   will be used instead.
   *   {?number}            duration   The duration of the animation. If not
   *                                   specified, the "animationsTime" setting
   *                                   value of the sigma instance will be used
   *                                   instead.
   *   {?function}          onComplete Eventually a function to call when the
   *                                   animation is ended.
   *
   * @param  {sigma}   s       The related sigma instance.
   * @param  {object}  animate An hash with the keys being the node properties
   *                           to interpolate, and the values being the related
   *                           target values.
   * @param  {?object} options Eventually an object with options.
   */
  sigma.plugins.animate = function(s, animate, options) {
    var o = options || {},
        id = ++_id,
        duration = o.duration || s.settings('animationsTime'),
        easing = typeof o.easing === 'string' ?
          sigma.utils.easings[o.easing] :
          typeof o.easing === 'function' ?
          o.easing :
          sigma.utils.easings.quadraticInOut,
        start = sigma.utils.dateNow(),
        nodes,
        startPositions;

    if (o.nodes && o.nodes.length) {
      if (typeof o.nodes[0] === 'object')
        nodes = o.nodes;
      else
        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs
    }
    else
      nodes = s.graph.nodes();

    // Store initial positions:
    startPositions = nodes.reduce(function(res, node) {
      var k;
      res[node.id] = {};
      for (k in animate)
        if (k in node)
          res[node.id][k] = node[k];
      return res;
    }, {});

    s.animations = s.animations || Object.create({});
    sigma.plugins.killAnimate(s);

    s.dispatchEvent('animate.start'); // send a sigma event

    function step() {
      var p = (sigma.utils.dateNow() - start) / duration;

      if (p >= 1) {
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate && animate[k] in node)
              node[k] = node[animate[k]];
        });

        s.refresh({skipIndexation: true});
        if (typeof o.onComplete === 'function') {
          o.onComplete();
        }
        s.dispatchEvent('animate.end'); // send a sigma event
      }
      else {
        p = easing(p);
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate && animate[k] in node) {
              if (k.match(/color$/))
                node[k] = interpolateColors(
                  startPositions[node.id][k],
                  node[animate[k]],
                  p
                );
              else
                node[k] =
                  node[animate[k]] * p +
                  startPositions[node.id][k] * (1 - p);
            }
        });

        s.refresh({skipIndexation: true});
        s.animations[id] = requestAnimationFrame(step);
      }
    }

    step();
  };

  sigma.plugins.killAnimate = function(s) {
    for (var k in (s.animations || {}))
      cancelAnimationFrame(s.animations[k]);
  };
}).call(window);

},{}],4:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.plugins');

  /**
   * Sigma design
   * =============================
   *
   * @author SÃ©bastien Heymann <seb@linkurio.us> (Linkurious)
   * @version 0.4
   */


  /**
   * Convert Javascript string in dot notation into an object reference.
   *
   * @param  {object} obj The object.
   * @param  {string} str The string to convert, e.g. 'a.b.etc'.
   * @return {?}          The object reference.
   */
  function strToObjectRef(obj, str) {
    // http://stackoverflow.com/a/6393943
    return str.split('.').reduce(function(obj, i) { return obj[i] }, obj);
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }

  /**
   * Fast deep copy function.
   *
   * @param  {object} o The object.
   * @return {object}   The object copy.
   */
  function deepCopy(o) {
    var copy = Object.create(null);
    for (var i in o) {
      if (typeof o[i] === "object" && o[i] !== null) {
        copy[i] = deepCopy(o[i]);
      }
      else if (typeof o[i] === "function" && o[i] !== null) {
        // clone function:
        eval(" copy[i] = " +  o[i].toString());
        //copy[i] = o[i].bind(_g);
      }

      else
        copy[i] = o[i];
    }
    return copy;
  }

  /**
   * This method will put the values in different bins using a linear scale,
   * for a specified number of bins (i.e. histogram). It will return a
   * dictionary of bins indexed by the specified values.
   *
   * @param  {array}  values The values.
   * @param  {number} nbins  The number of bins.
   * @return {object}        The basic histogram.
   */
  function baseHistogram(values, nbins) {
    var numlist,
        min,
        max,
        bin,
        res = {};

    if (!values.length)
      return res;

    // sort values by inverse order:
    numlist = values.map(function (val) {
      return parseFloat(val);
    })
    .sort(function(a, b) {
      return a - b;
    });

    min = numlist[0];
    max = numlist[numlist.length - 1];


    if (max - min !== 0) {
      numlist.forEach(function (num) {
        bin = Math.floor(nbins * Math.abs(num - min) / Math.abs(max - min));
        bin -= (bin == nbins) ? 1 : 0;
        res[num] = bin;
      });
    } else {
      // if the max is the same as the minimum, we put all the numbers in the same bin.
      numlist.forEach(function(num){
        res[num] = 0;
      });
    }

    return res;
  }

  /**
   * This function will generate a consolidated histogram of values grouped by
   * bins. The result is an array of objects ordered by bins. Each object
   * contains the list of `values` in the `bin`, the `min` and `max` values,
   * and the `ratio` of values in the bin compared to the largest bin.
   *
   * @param  {object} h         The nodes or edges histograms.
   * @param  {string} p         The property accessor.
   * @return {array}            The consolidated histogram.
   */
  function histogram(h, p) {
    var d = [],
        bins,
        maxOcc = 0;

    if (h && h[p]) {
      Object.keys(h[p]).forEach(function(value) {
        var bin = h[p][value];
        d[bin] = d[bin] || [];
        d[bin].push(+value);
      });

      bins = (d.length !== 1 ) ? d.length : 7;

      for (var bin = 0; bin < bins; bin++) {
        if (d[bin]) {
          maxOcc = (maxOcc > d[bin].length) ? maxOcc : d[bin].length;
        }
      }

      for (var bin = 0; bin < bins; bin++) {
        if (d[bin] === undefined) {
          d[bin] = [];
        }
        d[bin] = {
          bin: bin,
          values: d[bin],
          ratio: d[bin].length / maxOcc
        };
        // d[bin][visualVar] = design.palette.sequential[bins][bin];

        if (d[bin].values.length) {
          d[bin].min = Math.min.apply(null, d[bin].values);
          d[bin].max = Math.max.apply(null, d[bin].values);
        }
      }
    }
    return d;
  }

  /**
   * Add reference to nodes or edges in histogram bins.
   *
   * @param  {object} h         The nodes or edges histograms.
   * @param  {Vision} vision    The vision object.
   * @param  {string} p         The property accessor.
   * @return {array}            The consolidated histogram.
   */
  function resolveHistogram(h, vision, p) {
    var items = vision.get(p),
      item,
      value,
      nBins = h.length,
      maxOcc = 0;

    for (var bin = 0; bin < nBins; bin++) {
      h[bin].items = [];
    }

    Object.keys(items).forEach(function(value) {
      for (var i = 0; i < items[value].items.length; i++) {
        item = items[value].items[i];
        value = strToObjectRef(item, p);

        for (var bin = 0; bin < h.length; bin++) {
          if ((!'min' in h[bin]) || (!'max' in h[bin]))
            continue;

          if (h[bin].min <= value && value <= h[bin].max) {
            h[bin].items.push(item);
          }
        }
      }
    });

    for (var bin = 0; bin < nBins; bin++) {
      if (h[bin].items) {
        maxOcc = (maxOcc > h[bin].items.length) ? maxOcc : h[bin].items.length;
      }
    }

    for (var bin = 0; bin < nBins; bin++) {
      h[bin].itemsRatio = h[bin].items.length / maxOcc;
    }

    return h;
  }

  // Utilities
  function download(fileEntry, extension, filename) {
    var blob = null,
        objectUrl = null,
        dataUrl = null;

    if(window.Blob){
      // use Blob if available
      blob = new Blob([fileEntry], {type: 'text/json'});
      objectUrl = window.URL.createObjectURL(blob);
    }
    else {
      // else use dataURI
      dataUrl = 'data:text/json;charset=UTF-8,' + encodeURIComponent(fileEntry);
    }

    if (navigator.msSaveBlob) { // IE11+ : (has Blob, but not a[download])
      navigator.msSaveBlob(blob, filename);
    } else if (navigator.msSaveOrOpenBlob) { // IE10+ : (has Blob, but not a[download])
      navigator.msSaveOrOpenBlob(blob, filename);
    } else {
      // A-download
      var anchor = document.createElement('a');
      anchor.setAttribute('href', (window.Blob) ? objectUrl : dataUrl);
      anchor.setAttribute('download', filename || 'graph.' + extension);

      // Firefox requires the link to be added to the DOM before it can be clicked.
      document.body.appendChild(anchor);
      anchor.click();
      document.body.removeChild(anchor);
    }

    if (objectUrl) {
      setTimeout(function() { // Firefox needs a timeout
        window.URL.revokeObjectURL(objectUrl);
      }, 0);
    }
  }


  /**
   * This constructor instanciates a new vision on a specified dataset (nodes
   * or edges).
   *
   * @param  {sigma} s              The sigma instance.
   * @param  {function} datasetName The dataset. Available options: 'nodes',
   *                                'edges'.
   * @param  {object} mappings      The style mappings object.
   * @param  {object} palette       The palette object.
   * @return {Vision}               The vision instance.
   */
  function Vision(s, datasetName, mappings, palette) {
    var that = this;

    // defined below:
    this.visualVars = null;

    // mappings may be overriden:
    this.mappings = null;

    // palette may be overriden:
    this.palette = palette;

    // index of data properties:
    this.idx = Object.create(null);

    // histograms of data properties for visual variables:
    this.histograms = Object.create(null);

    // index of deprecated visions on data properties:
    this.deprecated = Object.create(null);

    // some original sigma settings:
    this.sigmaSettings = Object.create(null);

    // properties are sequential or qualitative data
    this.dataTypes = Object.create(null);

    // original values of visual variables
    this.originalVisualVariable = Object.create(null);

    // nodes or edges:
    if (datasetName === 'nodes') {
      this.visualVars = ['color', 'size', 'label', 'type', 'icon', 'image'];
      this.mappings = mappings.nodes;
      this.dataset = function() { return s.graph.nodes(); }
    }
    else if (datasetName === 'edges') {
      this.visualVars = ['color', 'size', 'label', 'type'];
      this.mappings = mappings.edges;
      this.dataset = function() { return s.graph.edges(); }
    }
    else
      throw new Error('Invalid argument: "datasetName" is not "nodes" or "edges", was ' + datasetName);


    /**
     * This method will index the collection with the specified property, and
     * will compute all styles related to the specified property for each item.
     *
     * @param  {string}  key The property accessor.
     */
    this.update = function(key) {
      // console.log('Vision.update', key);
      var self = this;

      if (key === undefined)
        throw new Error('Missing argument: "key".');

      if (typeof key !== 'string')
        throw new Error('Invalid argument: "key" is not a string, was ' + key);

      var val,
          byFn,
          schemeFn,
          isSequential = undefined,
          isArray = true;

      byFn = function(item, key) { return strToObjectRef(item, key); };
      schemeFn = function(palette, key) { return strToObjectRef(palette, key); };

      function insertItem(val, item) {
        if (self.idx[key][val] === undefined) {
          self.idx[key][val] = {
            key: val,
            items: [],
            styles: Object.create(null)
          };
        }
        self.idx[key][val].items.push(item);

        if (isSequential || isSequential === undefined) {
          isSequential = (typeof val === 'number');
          // TODO: throw error if is number AND (is NaN or is Infinity)
        }
      }

      // Index the collection:
      this.idx[key] = {};
      this.dataset().forEach(function (item) {
        val = byFn(item, key);
        if (val !== undefined) {
          if (isArray) {
            isArray = Array.isArray(val) ? isArray : false;
          }
          if (isArray) {
            if (val.length === 1) {
              insertItem(val[0], item);
            }
            else {
              val.forEach(function (v) {
                insertItem(v, item);
              });
            }
          }
          else {
            insertItem(val, item);
          }
        }
      });

      this.dataTypes[key] = { sequential: isSequential, array: isArray };
      this.deprecated[key] = false;

      // Find the max number of occurrence of values:
      var maxOcc = 0;
      for (val in this.idx[key]) {
        maxOcc =
          (maxOcc < this.idx[key][val].items.length) ?
          this.idx[key][val].items.length :
          maxOcc;
      }

      // number of occurrence / max number of occurrences of the value:
      Object.keys(this.idx[key]).forEach(function (val) {
        self.idx[key][val].ratio =
          parseFloat(self.idx[key][val].items.length / maxOcc);
      });

      var format,
          colorHist,
          sizeHist,
          colorScheme,
          typeScheme,
          iconScheme,
          imageScheme,
          bins,
          visualVars,
          nset = 0;

      // Visual variables mapped to the specified property:
      visualVars = Object.keys(that.mappings).filter(function (visualVar) {
        return (
          (that.mappings[visualVar]) &&
          (that.mappings[visualVar].by !== undefined) &&
          (that.mappings[visualVar].by.toString() == key)
        );
      });

      // Validate the mappings and compute histograms if needed:
      visualVars.forEach(function (visualVar) {
        switch (visualVar) {
          case 'color':
            colorScheme = that.mappings.color.scheme;

            if (typeof colorScheme !== 'string')
              throw new Error('color.scheme "' + colorScheme + '" is not a string.');

            if (isSequential) {
              bins = that.mappings.color.bins || 7;
              self.histograms.color = self.histograms.color || {};
              self.histograms.color[key] = baseHistogram(Object.keys(self.idx[key]), bins);
            }

            break;

          case 'label':
            format = that.mappings.label.format || function(item) {
              return (typeof item === 'string') ? item : item.label;
            };

            if (typeof format !== 'function')
              throw new Error('label.format "' + format + '" is not a function.');
            break;

          case 'size':
            if (isSequential === undefined) break;

            if (!isSequential)
              throw new Error('One value of the property "' + key + '" is not a number.');

            self.histograms.size = self.histograms.size || {};
            self.histograms.size[key] = baseHistogram(
              Object.keys(self.idx[key]),
              (that.mappings.size.bins || 7)
            );
            break;

          case 'type':
            typeScheme = that.mappings.type.scheme;

            if (typeof typeScheme !== 'string')
              throw new Error('type.scheme "' + typeScheme + '" is not a string.');

            break;

          case 'icon':
            iconScheme = that.mappings.icon.scheme;

            if (typeof iconScheme !== 'string')
              throw new Error('icon.scheme "' + iconScheme + '" is not a string.');

            break;

          case 'image':
            imageScheme = that.mappings.image.scheme;

            if (typeof imageScheme !== 'string')
              throw new Error('type.scheme "' + imageScheme + '" is not a string.');

            break;
        }
      });

      // Compute all styles related to the property for each item:
      Object.keys(this.idx[key]).forEach(function (val) {
        visualVars.forEach(function (visualVar) {
          switch (visualVar) {

            case 'color':
              if (isSequential) {
                self.idx[key][val].styles.color = function() {
                  var bin = self.histograms.color[key][val];
                  return schemeFn(that.palette, colorScheme)[bins][bin];
                };
              }
              else {
                self.idx[key][val].styles.color = function() {
                  if (schemeFn(that.palette, colorScheme) === undefined)
                    throw new Error('Wrong or undefined color scheme.');

                  if (that.mappings.color.set > 0) {
                    var setItem = schemeFn(that.palette, colorScheme)[that.mappings.color.set][nset];
                    nset = (nset + 1) % that.mappings.color.set;
                    return setItem;
                  }

                  return schemeFn(that.palette, colorScheme)[val];
                };
              }
              break;

            case 'label':
              self.idx[key][val].styles.label = function(item) {
                return format(byFn(item, key));
              };
              break;

            case 'size':
              self.idx[key][val].styles.size = function() {
                return 1 + self.histograms.size[key][val];
              };
              break;

            case 'type':
              self.idx[key][val].styles.type = function() {
                if (schemeFn(that.palette, typeScheme) === undefined)
                  throw new Error('Wrong or undefined type scheme.');

                return schemeFn(that.palette, typeScheme)[val];
              };
              break;

            case 'icon':
              self.idx[key][val].styles.icon = function() {
                if (schemeFn(that.palette, iconScheme) === undefined)
                  throw new Error('Wrong or undefined icon scheme.');

                return schemeFn(that.palette, iconScheme)[val];
              };
              break;

            case 'image':
              self.idx[key][val].styles.image = function() {
                if (schemeFn(that.palette, imageScheme) === undefined)
                  throw new Error('Wrong or undefined image scheme.');

                return schemeFn(that.palette, imageScheme)[val];
              };
              break;
          }
        });
      });
    };

    /**
     * This method will return the vision on a specified property. It will update
     * the vision on the property if it is deprecated or missing.
     *
     * @param  {string} key  The property accessor.
     * @return {object}      The vision on the property.
     */
    this.get = function (key) {
      if (key === undefined)
        throw new TypeError('Missing argument: "key".');

      if (typeof key !== 'string')
        throw new TypeError('Invalid argument: "key" is not a string, was ' + key);

      // lazy updating:
      if (this.deprecated[key]) this.update(key);

      // lazy indexing:
      if (this.idx[key] === undefined) this.update(key);

      return this.idx[key];
    };

    /**
     * This method will apply a mapping between a visual variable and a property.
     * It will update the vision on the property if it is deprecated or missing.
     * It will stores the original value of the visual variable for each item.
     * If the new value is `undefined`, it will keep the original value.
     * Available visual variables are stored in `visualVars`.
     *
     * @param {string} visualVar The name of the visual variable.
     * @param {string} key       The property accessor.
     */
    this.applyStyle = function(visualVar, key) {
      if (key === undefined)
        throw new TypeError('Missing argument: "key"');

      if (typeof key !== 'string')
        throw new TypeError('Invalid argument: "key" is not a string, was ' + key);

      if (this.visualVars.indexOf(visualVar) == -1)
        throw new Error('Unknown style "' + visualVar + '"');

      var self = this,
          idxp = this.get(key);

      if (visualVar === 'color' && self.dataTypes[key].array) {
        this.dataset().forEach(function (item) {
          delete item.colors;
        });

        Object.keys(idxp).forEach(function (val) {
          var o = idxp[val];
          o.items.forEach(function (item) {
            item.colors = [];
          });
        });
      }

      Object.keys(idxp).forEach(function (val) {
        var o = idxp[val];
        o.items.forEach(function (item) {
          if (item !== undefined &&
              o.styles !== undefined &&
              typeof o.styles[visualVar] === 'function') {

            if (!self.originalVisualVariable[item.id]) {
              self.originalVisualVariable[item.id] = {};
            }
            if (!(visualVar in self.originalVisualVariable[item.id])) {
              // non-writable property
              Object.defineProperty(self.originalVisualVariable[item.id], visualVar, {
               enumerable: true,
               value: item[visualVar]
              });
            }

            var newVal = o.styles[visualVar](item);

            if (visualVar === 'color' && self.dataTypes[key].array) {
              if (newVal !== undefined) {
                item.color = newVal;  // backward-compatibility
                item.colors.push(newVal);
              }
            }
            else if (newVal !== undefined) {
              item[visualVar] = newVal;
            }
          }
          else {
            if (typeof o.styles[visualVar] === 'function')
              throw new TypeError(o.styles + '.' + visualVar + 'is not a function, was ' + o.styles[visualVar]);
          }
        });
      });

      if (visualVar === 'size') {
        if (datasetName === 'nodes') {
          if (this.mappings.size.min > this.mappings.size.max) {
            throw new RangeError('nodes.size.min must be ' +
            'lower or equal than nodes.size.max');
          }

          if (this.mappings.size.min) {
            if (!this.sigmaSettings.minNodeSize) {
              this.sigmaSettings.minNodeSize = s.settings('minNodeSize');
            }
            s.settings('minNodeSize', this.mappings.size.min);
          }

          if (this.mappings.size.max) {
            if (!this.sigmaSettings.maxNodeSize) {
              this.sigmaSettings.maxNodeSize = s.settings('maxNodeSize');
            }
            s.settings('maxNodeSize', this.mappings.size.max);
          }
        }
        else if (datasetName === 'edges') {
          if (this.mappings.size.min > this.mappings.size.max) {
            throw new RangeError('edges.size.min must be '+
            'lower or equal than edges.size.max');
          }

          if (this.mappings.size.min) {
            if (!this.sigmaSettings.minEdgeSize) {
              this.sigmaSettings.minEdgeSize = s.settings('minEdgeSize');
            }
            s.settings('minEdgeSize', this.mappings.size.min);
          }

          if (this.mappings.size.max) {
            if (!this.sigmaSettings.maxEdgeSize) {
              this.sigmaSettings.maxEdgeSize = s.settings('maxEdgeSize');
            }
            s.settings('maxEdgeSize', this.mappings.size.max);
          }
        }
      }
    };

    /**
     * This method will reset a mapping between a visual variable and a property.
     * It restores the original value of the visual variable for each item. It
     * will do nothing if the vision on the property is missing.
     * Available visual variables are stored in `visualVars`.
     *
     * @param {string} visualVar The name of the visual variable.
     * @param {string} key       The property accessor.
     */
    this.resetStyle = function(visualVar, key) {
      if (key === undefined)
        throw new TypeError('Missing argument: "key"');

      if (typeof key !== 'string')
        throw new TypeError('Invalid argument: "key" is not a string, was ' + key);

      if (this.visualVars.indexOf(visualVar) == -1)
        throw new Error('Unknown style "' + visualVar + '".');

      if (this.idx[key] === undefined) return;

      var self = this,
          idxp = this.get(key);

      if (visualVar === 'color' && self.dataTypes[key].array) {
        Object.keys(idxp).forEach(function (val) {
          var o = idxp[val];
          o.items.forEach(function (item) {
            delete item.colors;
          });
        });
      }

      Object.keys(idxp).forEach(function (val) {
        var o = idxp[val];
        o.items.forEach(function (item) {
          if (item !== undefined && item[visualVar] !== undefined) {

            if (self.originalVisualVariable[item.id] === undefined ||
              self.originalVisualVariable[item.id][visualVar] === undefined) {

              // Avoid Sigma bug on edge with no size
              if (self.key === 'edges' && visualVar === 'size')
                item.size = 1;
              else
                delete item[visualVar];
          }
            else
              item[visualVar] = self.originalVisualVariable[item.id][visualVar];
          }
        });
      });

      if (visualVar === 'size') {
        if (datasetName === 'nodes') {
          if (this.sigmaSettings.minNodeSize) {
            s.settings('minNodeSize', this.sigmaSettings.minNodeSize);
          }
          if (this.sigmaSettings.maxNodeSize) {
            s.settings('maxNodeSize', this.sigmaSettings.maxNodeSize);
          }
        }
        else if (datasetName === 'edges') {
          if (this.sigmaSettings.minEdgeSize) {
            s.settings('minEdgeSize', this.sigmaSettings.minEdgeSize);
          }
          if (this.sigmaSettings.maxEdgeSize) {
            s.settings('maxEdgeSize', this.sigmaSettings.maxEdgeSize);
          }
        }
      }
    };

    /**
     * This method empties the arrays and indexes.
     */
    this.clear = function() {
      this.visualVars.length = 0;
      emptyObject(this.idx);
      emptyObject(this.histograms);
      emptyObject(this.deprecated);
      emptyObject(this.sigmaSettings);
      emptyObject(this.dataTypes);
      emptyObject(this.originalVisualVariable);
    };

    return this;
  };


  /**
   * design Object
   * ------------------
   * @param  {sigma}   s       The related sigma instance.
   * @param  {?object} options The object contains `palette` and `styles`.
   *                           Styles are mappings between visual variables and
   *                           data properties on nodes and edges.
   */
  function design(s, options) {
    this.palette = (options || {}).palette || {};
    this.styles = sigma.utils.extend((options || {}).styles || {}, {
      nodes: {},
      edges: {}
    });

    var self = this,
        _visionOnNodes = new Vision(s, 'nodes', this.styles, this.palette),
        _visionOnEdges = new Vision(s, 'edges', this.styles, this.palette);

    s.bind('kill', function() {
      sigma.plugins.killDesign(s);
    });


    /**
     * This method will set new styles. Styles are mappings between visual
     * variables and data properties on nodes and edges. It will deprecate
     * existing styles.
     *
     * @param  {object}  styles The styles object.
     * @return {design}       The instance.
     */
    this.setStyles = function(styles) {
      this.styles = sigma.utils.extend(styles || {}, {
        nodes: {},
        edges: {}
      });

      _visionOnNodes.mappings = this.styles.nodes;
      _visionOnEdges.mappings = this.styles.edges;

      this.deprecate();
      return this;
    };

    /**
     * This method will set a specified node style. Styles are mappings between
     * visual variables and data properties on nodes and edges. It will
     * deprecate existing node styles bound to the specified data property.
     *
     * @param  {string}  visualVar The visual variable.
     * @param  {object}  params    The style parameter.
     * @return {design}          The instance.
     */
    this.nodesBy = function(visualVar, params) {
      this.styles = sigma.utils.extend(this.styles || {}, {
        nodes: {},
        edges: {}
      });

      this.styles.nodes[visualVar] = params;
      _visionOnNodes.mappings = this.styles.nodes;

      if (params.by) {
        this.deprecate('nodes', params.by);
      }

      return this;
    };

    /**
     * This method will set a specified edge style. Styles are mappings between
     * visual variables and data properties on nodes and edges. It will
     * deprecate existing edge styles bound to the specified data property.
     *
     * @param  {string}  visualVar The visual variable.
     * @param  {object}  params    The style parameter.
     * @return {design}          The instance.
     */
    this.edgesBy = function(visualVar, params) {
      this.styles = sigma.utils.extend(this.styles || {}, {
        nodes: {},
        edges: {}
      });

      this.styles.edges[visualVar] = params;
      _visionOnEdges.mappings = this.styles.edges;

      if (params.by) {
        this.deprecate('edges', params.by);
      }

      return this;
    };


    /**
     * This method will set a new palette. It will deprecate existing styles.
     *
     * @param  {object}  palette The palette object.
     * @return {design}        The instance.
     */
    this.setPalette = function(palette) {
      this.palette = palette;

      _visionOnNodes.palette = this.palette;
      _visionOnEdges.palette = this.palette;

      this.deprecate();
      return this;
    };

    /**
     * This method is used to get the styles bound to each node of the graph for
     * a specified property.
     *
     * @param  {string} key The property accessor. Use a dot notation like
     *                      'data.myProperty'.
     * @return {object}     The styles.
     */
    this.nodes = function(key) {
      return _visionOnNodes.get(key);
    };

    /**
     * This method is used to get the styles bound to each edge of the graph for
     * a specified property.
     *
     * @param  {string} key The property accessor. Use a dot notation like
     *                      'data.myProperty'.
     * @return {object}     The styles.
     */
    this.edges = function(key) {
      return _visionOnEdges.get(key);
    };

    /**
     * This method will export a deep copy of the internal `Vision` objects,
     * which store the indexes, bound styles and histograms.
     *
     * @return {object}  The object of keys `nodes` and `edges`.
     */
    this.inspect = function() {
      return {
        nodes: deepCopy(_visionOnNodes),
        edges: deepCopy(_visionOnEdges)
      };
    };

    function __apply(mappings, vision, visualVar) {
      if (!visualVar) {
        // apply all styles if no visual variable is specified:
        Object.keys(mappings).forEach(function (visuVar) {
          mappings[visuVar].active = false;
          if (mappings[visuVar] && mappings[visuVar].by) {
            vision.applyStyle(visuVar, mappings[visuVar].by);
            mappings[visuVar].active = true;
          }
        });
      }
      else if (mappings[visualVar] && mappings[visualVar].by) {
        // apply the style of the specified visual variable:
        vision.applyStyle(visualVar, mappings[visualVar].by);
        mappings[visualVar].active = true;
      }

      if (s) s.refresh({skipIndexation: true});
    };

    /**
     * This method is used to apply all target styles or a specified target
     * style, depending on how it is called. Apply all styles if it is called
     * without argument. It will refresh the display.
     *
     * @param  {?string} target     The data target. Available values:
     *                              "nodes", "edges".
     * @param  {?string} visualVar  The visual variable. Available values:
     *                              "color", "size", "label".
     * @return {design}            The instance.
     */
    this.apply = function(target, visualVar) {
      if (!this.styles) return;

      if (!target) {
        __apply(this.styles.nodes, _visionOnNodes, visualVar);
        __apply(this.styles.edges, _visionOnEdges, visualVar);
        return this;
      }

      switch (target) {
        case 'nodes':
          __apply(this.styles.nodes, _visionOnNodes, visualVar);
          break;
        case 'edges':
          __apply(this.styles.edges, _visionOnEdges, visualVar);
          break;
        default:
          throw new Error('Invalid argument: "target" is not "nodes" or "edges", was ' + target);
      }

      return this;
    };

    function __reset(mappings, vision, visualVar) {
      if (!visualVar) {
        // reset all styles if no visual variable is specified:
        Object.keys(mappings).forEach(function (visuVar) {
          if (mappings[visuVar].active) {
            vision.resetStyle(visuVar, mappings[visuVar].by);
            mappings[visuVar].active = false;
          }
        });
      }
      else if (mappings[visualVar] && mappings[visualVar].active) {
        // reset the style of the specified visual variable:
        vision.resetStyle(visualVar, mappings[visualVar].by);
        mappings[visualVar].active = false;
      }

      if (s) s.refresh({skipIndexation: true});
    };

    /**
     * This method is used to reset all target styles or a specified target style,
     * depending on how it is called. reset all styles if it is called
     * without argument. It will do nothing if the visual variable
     * is not in the existing styles. It will finally refresh the display.
     *
     * @param  {?string} target     The data target. Available values:
     *                               "nodes", "edges".
     * @param  {?string} visualVar  The visual variable. Available values:
     *                             "color", "size", "label".
     * @return {design}  The instance.
     */
    this.reset = function(target, visualVar) {
      if (!this.styles) return;

      if (!target) {
        __reset(this.styles.nodes, _visionOnNodes, visualVar);
        __reset(this.styles.edges, _visionOnEdges, visualVar);
        return this;
      }

      switch (target) {
        case 'nodes':
          __reset(this.styles.nodes, _visionOnNodes, visualVar);
          break;
        case 'edges':
          __reset(this.styles.edges, _visionOnEdges, visualVar);
          break;
        default:
          throw new Error('Invalid argument: "target" is not "nodes" or "edges", was ' + target);
      }

      return this;
    };

    /**
     * This method is used when the styles are deprecated, for instance when the
     * graph has changed. The specified property style will be remade the next
     * time it is called using `.apply()`, `.nodes()`, or `.edges()`
     * or all property styles if called without argument.
     *
     * @param  {?string} target  The data target. Available values:
     *                           "nodes", "edges".
     * @param  {?string} key     The property accessor. Use a dot notation like
     *                           'data.myProperty'.
     *
     * @return {design}          The instance.
     */
    this.deprecate = function(target, key) {
      if (target) {
        if (target !== 'nodes' && target !== 'edges')
          throw new Error('Invalid argument: "target" is not "nodes" or "edges", was ' + target);

        if (key) {
          if (target === 'nodes') {
            _visionOnNodes.deprecated[key] = true;
          }
          else if (target === 'edges') {
            _visionOnEdges.deprecated[key] = true;
          }
        }
        else {
          if (target === 'nodes') {
            Object.keys(_visionOnNodes.deprecated).forEach(function(prop) {
              _visionOnNodes.deprecated[prop] = true;
            });
          }
          else if (target === 'edges') {
            Object.keys(_visionOnEdges.deprecated).forEach(function(prop) {
              _visionOnEdges.deprecated[prop] = true;
            });
          }
        }
      }
      else {
        Object.keys(_visionOnNodes.deprecated).forEach(function(prop) {
          _visionOnNodes.deprecated[prop] = true;
        });

        Object.keys(_visionOnEdges.deprecated).forEach(function(prop) {
          _visionOnEdges.deprecated[prop] = true;
        });
      }

      return this;
    };

    /**
     * Delete styles from a node or an edge according to its specified id,
     * target type and property reference.
     *
     * @param {string}  target The data target. Available values: "nodes", "edges".
     * @param {number}  id     The id of the node or edge to update
     * @param {string}  key    The property key to delete styles from.
     *
     * @return {design}        The instance.
     */
    this.deletePropertyStylesFrom = function(target, id, key){

      if (id == null){
        throw new TypeError('Missing argument: "id".');
      }
      if (target !== 'nodes' && target !== 'edges') {
        throw new Error('Invalid argument: "target" is not "nodes" or "edges", was ' + target);
      }
      if (key == null){
        throw new TypeError('Missing argument: "key".');
      }

      var
        computedStyles,
        computedStyle,
        appliedStyles,
        item;

      if (target === 'nodes'){
        computedStyles = _visionOnNodes.get(key);
      } else {
        computedStyles = _visionOnEdges.get(key);
      }

      var values = Object.keys(computedStyles);

      for (var k = 0 ; k < values.length ; k++){

        computedStyle = computedStyles[values[k]];
        appliedStyles = Object.keys(computedStyle.styles);

        for (var i = 0 ; i < computedStyle.items.length ; i++){

          item = computedStyle.items[i];
          if (item.id === id) {

            // For a given property, we want to delete all the styles references that are computed
            // from it for a given node
            for (var j = 0; j < appliedStyles.length; j++) {

              if (appliedStyles[j] !== 'label' && appliedStyles[j] !== 'size') {
                delete item[appliedStyles[j]];
              } else if (appliedStyles[j] === 'size'){
                item.size = 1;
              }
            }
            // There is only one node that should correspond to this. Once we have found it, we
            // can return.
            this.deprecate(target, key);
            return this;
          }
        }
      }

      return this;
    };

    /**
     * This method is used to clear all styles. It will refresh the display. Use
     * `.reset()` instead to reset styles without losing the configuration.
     *
     * @return {design}  The instance.
     */
    this.clear = function() {
      this.reset();
      this.styles = {
        nodes: {},
        edges: {}
      };
      this.palette = {};

      _visionOnNodes.clear();
      _visionOnEdges.clear();

      _visionOnNodes = new Vision(s, 'nodes', this.styles, this.palette);
      _visionOnEdges = new Vision(s, 'edges', this.styles, this.palette);

      if (s) s.refresh({skipIndexation: true});

      return this;
    };

    /**
     * This method destroys the current instance.
     */
    this.kill = function() {
      delete this.styles;
      delete this.palette;
      _visionOnNodes.clear();
      _visionOnEdges.clear();
    };

    /**
     * Transform the styles and palette into a JSON representation.
     *
     * @param  {object} params The options.
     * @return {string}        The JSON string.
     */
    this.toJSON = function(params) {
      params = params || {};

      var o = {
        styles: this.styles,
        palette: this.palette
      }

      if (params.pretty) {
        var jsonString = JSON.stringify(o, null, ' ');
      }
      else {
        var jsonString = JSON.stringify(o);
      }

      if (params.download) {
        download(jsonString, 'json', params.filename);
      }

      return jsonString;
    };

    this.utils = {};

    /**
     * This method is used to get the data type of a specified property on nodes
     * or edges. It is true if data is sequential, false otherwise (qualitative),
     * or undefined if the property doesn't exist.
     *
     * @param  {string} target     The data target. Available values:
     *                             "nodes", "edges".
     * @param  {string} property   The property accessor.
     * @return {boolean}           The data type.
     */
    this.utils.isSequential = function(target, property) {
      if (!target)
        throw new TypeError('Missing argument: "target"');

      var v;
      switch (target) {
        case 'nodes':
          v = _visionOnNodes;
          break;
        case 'edges':
          v = _visionOnEdges;
          break;
        default:
          throw new Error('Invalid argument: "target" is not "nodes" or "edges", was ' + target);
      }

      if (property === undefined)
        throw new TypeError('Missing argument: "property"');

      if (typeof property !== 'string')
        throw new TypeError('Invalid argument: "property" is not a string, was ' + property);

      if (!(property in v.dataTypes) || v.dataTypes[property].sequential === undefined) {
        var val,
            found = false,
            isSequential = true;

        v.dataset().forEach(function (item) {
          val = strToObjectRef(item, property);
          if (val !== undefined) {
            found = true;
            isSequential = (typeof val === 'number') ? isSequential : false;
            // TODO: throw error if is number AND (is NaN or is Infinity)
          }
        });

        if (found) {
          v.dataTypes[property] = { sequential: isSequential };
        }
        else if(v.dataTypes[property]) {
          v.dataTypes[property].sequential = undefined;
        }
      }

      return (v.dataTypes[property] || {}).sequential;
    };

    /**
     * This method is used to get the histogram of values, grouped by bins, on
     * a specified property of nodes or edges computed for a visual variable.
     * The property must have been used on a style before calling this method.
     *
     * The result is an array of objects ordered by bins. Each object contains
     * the list of `values` in the `bin`, the `min` and `max` values, and the
     * `ratio` of values in the bin compared to the largest bin.
     * If the visual variable is the `color`, it also contains the `color` of the
     * bin.
     *
     * @param  {string} target     The data target. Available values:
     *                             "nodes", "edges".
     * @param  {string} visualVar  The visual variable. Available values:
     *                             "color", "size", "label".
     * @param  {string} property   The property accessor.
     * @return {array}             The histogram.
     */
    this.utils.histogram = function(target, visualVar, property) {
      if (!target)
        throw new TypeError('Missing argument: "target"');

      var v;
      switch (target) {
        case 'nodes':
          v = _visionOnNodes;
          break;
        case 'edges':
          v = _visionOnEdges;
          break;
        default:
          throw new Error('Invalid argument: "target" is not "nodes" or "edges", was ' + target);
      }

      if (v.visualVars.indexOf(visualVar) == -1)
        throw new Error('Unknown visual variable "' + visualVar + '".');

      if (property === undefined)
        throw new TypeError('Missing argument: "property".');

      if (typeof property !== 'string')
        throw new TypeError('Invalid argument: "property" is not a string, was' + property);

      var isSequential = self.utils.isSequential(target, property);

      if (!isSequential)
        throw new Error('The property "'+ property +'" is not sequential.');

      var h = histogram(v.histograms[visualVar], property);
      h = resolveHistogram(h, v, property);

      if (visualVar === 'color') {
        if (!self.styles[target].color) {
          throw new Error('Missing key "color" in '+ target +' palette.');
        }
        var bins = h.length,
          o = strToObjectRef(self.palette, self.styles[target].color.scheme);

        if (!o)
          throw new Error('Color scheme "' + self.styles[target].color.scheme + '" not in '+ target +' palette.');

        if (isSequential) {
          for (var bin = 0; bin < bins; bin++) {
            if (!o[bins])
              throw new Error('Missing key "'+ bins +'" in '+ target +' palette " of color scheme ' + self.styles[target].color.scheme + '".');

            h[bin][visualVar] = o[bins][bin];
          }
        }
      }

      return h;
    };
  };


  /**
   * Interface
   * ------------------
   *
   * > var design = sigma.plugins.design(s, options);
   */
  var _instance = {};

  /**
   * @param  {sigma}   s       The related sigma instance.
   * @param  {?object} options The object contains `palette` and `styles`.
   *                           Styles are mappings between visual variables and
   *                           data properties on nodes and edges.
   * @return {design}        The instance.
   */
  sigma.plugins.design = function(s, options) {
    // Create instance if undefined
    if (!_instance[s.id]) {
      _instance[s.id] = new design(s, options);
    }
    return _instance[s.id];
  };

  /**
   *  This function kills the design instance.
   */
  sigma.plugins.killDesign = function(s) {
    if (_instance[s.id] instanceof design) {
      _instance[s.id].kill();
    }
    delete _instance[s.id];
  };

}).call(this);

},{}],5:[function(require,module,exports){
/**
 * This plugin provides a method to drag & drop nodes. Check the
 * sigma.plugins.dragNodes function doc or the examples/drag-nodes.html code
 * sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');


  /**
   * This function will add `mousedown`, `mouseup` & `mousemove` events to the
   * nodes in the `overNode`event to perform drag & drop operations. It uses
   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]
   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to
   * calculate the X and Y coordinates from the `cam` or `renderer` node
   * attributes. These attributes represent the coordinates of the nodes in
   * the real container, not in canvas.
   *
   * Fired events:
   * *************
   * startdrag  Fired at the beginning of the drag.
   * drag       Fired while the node is dragged.
   * drop       Fired at the end of the drag if the node has been dragged.
   * dragend    Fired at the end of the drag.
   *
   * Recognized parameters:
   * **********************
   * @param  {sigma}                      s        The related sigma instance.
   * @param  {renderer}                   renderer The related renderer instance.
   * @param  {?sigma.plugins.activeState} a        The activeState plugin instance.
   */
  function DragNodes(s, renderer, a) {
    sigma.classes.dispatcher.extend(this);

    // A quick hardcoded rule to prevent people from using this plugin with the
    // WebGL renderer (which is impossible at the moment):
    if (
      sigma.renderers.webgl &&
      renderer instanceof sigma.renderers.webgl
    )
      throw new Error(
        'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'
      );

    // Init variables:
    var _self = this,
      _s = s,
      _a = a,
      _body = document.body,
      _renderer = renderer,
      _mouse = renderer.container.getElementsByClassName('sigma-mouse')[0],
      _prefix = renderer.options.prefix,
      _node = null,
      _draggingNode = null,
      _hoveredNode = null,
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false,
      _sticky = true,
      _enabled = true;

    if (renderer instanceof sigma.renderers.svg) {
        _mouse = renderer.container.firstChild;
    }

    renderer.bind('hovers', nodeMouseOver);
    renderer.bind('hovers', treatOutNode);
    renderer.bind('click', click);

    /**
     * Enable dragging and events.
     */
    this.enable = function() {
      _enabled = true;
    }

    /**
     * Disable dragging and events.
     */
    this.disable = function() {
      _enabled = false;
      _node = null,
      _draggingNode = null,
      _hoveredNode = null;
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false,
      _sticky = true;
    }

    /**
     * Unbind all event listeners.
     */
    this.unbindAll = function() {
      _mouse.removeEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);
      _renderer.unbind('hovers', nodeMouseOver);
      _renderer.unbind('hovers', treatOutNode);
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function calculateOffset(element) {
      var style = window.getComputedStyle(element);
      var getCssProperty = function(prop) {
        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
      };
      return {
        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
        top: element.getBoundingClientRect().top + getCssProperty('padding-top')
      };
    };

    function click(event) {
      // event triggered at the end of the click
      _isMouseDown = false;
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      if (!_hoveredNode) {
        _node = null;
      }
      else {
        // Drag node right after click instead of needing mouse out + mouse over:
        setTimeout(function() {
          // Set the current node to be the last hovered node
          _node = _hoveredNode;
          _mouse.addEventListener('mousedown', nodeMouseDown);
        }, 0);
      }
    };

    function nodeMouseOver(event) {
      if (event.data.enter.nodes.length == 0) {
        return;
      }
      var n = event.data.enter.nodes[0];

      // Don't treat the node if it is already registered
      if (_hoveredNode && _hoveredNode.id === n.id) {
        return;
      }

      // Set reference to the hovered node
      _hoveredNode = n;

      if(!_isMouseDown) {
        // Set the current node to be the last hovered node
        _node = _hoveredNode;
        _mouse.addEventListener('mousedown', nodeMouseDown);
      }
    };

    function treatOutNode(event) {
      if (event.data.leave.nodes.length == 0) {
        return;
      }
      var n = event.data.leave.nodes[0];

      if (_hoveredNode && _hoveredNode.id === n.id) {
        _hoveredNode = null;
        _node = null;
      }
      else if (!_hoveredNode) {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
      }
    };

    function nodeMouseDown(event) {
      if(!_enabled || event.which == 3) return; // Right mouse button pressed

      _isMouseDown = true;
      if (_node && _s.graph.nodes().length > 0) {
        _sticky = true;
        _mouse.removeEventListener('mousedown', nodeMouseDown);
        _body.addEventListener('mousemove', nodeMouseMove);
        _body.addEventListener('mouseup', nodeMouseUp);

        // Deactivate drag graph.
        _renderer.settings({mouseEnabled: false, enableHovering: false});

        _self.dispatchEvent('startdrag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };

    function nodeMouseUp(event) {
      _isMouseDown = false;
      _mouse.addEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      // Activate drag graph.
      _renderer.settings({mouseEnabled: true, enableHovering: true});

      if (_drag) {
        _self.dispatchEvent('drop', {
          node: _draggingNode,
          captor: event,
          renderer: _renderer
        });

        if(_a) {
          var activeNodes = _a.nodes();
          for(var i = 0; i < activeNodes.length; i++) {
            activeNodes[i].alphaX = undefined;
            activeNodes[i].alphaY = undefined;
          }
        }

        _s.refresh();
      }
      _self.dispatchEvent('dragend', {
        node: _node,
        captor: event,
        renderer: _renderer
      });

      _drag = false;
      _draggingNode = null;
    };

    function nodeMouseMove(event) {
      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        clearTimeout(timeOut);
        var timeOut = setTimeout(executeNodeMouseMove, 0);
      } else {
        executeNodeMouseMove();
      }

      function executeNodeMouseMove() {
        var offset = calculateOffset(_renderer.container),
            x = event.clientX - offset.left,
            y = event.clientY - offset.top,
            cos = Math.cos(_renderer.camera.angle),
            sin = Math.sin(_renderer.camera.angle),
            nodes = _s.graph.nodes(),
            ref = [],
            x2,
            y2,
            activeNodes,
            n,
            aux,
            isHoveredNodeActive,
            dist;

        if (_a && _a.nbNodes() === nodes.length) return;

        if (!_enabled || nodes.length < 2) return;

        dist = sigma.utils.getDistance(x, y, _node[_prefix + 'x'],_node[_prefix + 'y']);

        if (_sticky && dist < _node[_prefix + 'size']) return;
        _sticky = false;

        // Find two reference points and derotate them
        // We take the first node as a first reference point and then try to find
        // another node not aligned with it
        for (var i = 0;;i++) {
          if(!_enabled) break;

          n = nodes[i];
          if (n) {
            aux = {
              x: n.x * cos + n.y * sin,
              y: n.y * cos - n.x * sin,
              renX: n[_prefix + 'x'], //renderer X
              renY: n[_prefix + 'y'], //renderer Y
            };
            ref.push(aux);
          }
          if(i == nodes.length - 1) { //we tried all nodes
            break
          }
          if (i > 0) {
            if (ref[0].x == ref[1].x || ref[0].y == ref[1].y) {
              ref.pop() // drop last nodes and try to find another one
            } else { // we managed to find two nodes not aligned
              break
            }
          }
        }

        var a = ref[0], b = ref[1];

        // Applying linear interpolation.
        var divx = (b.renX - a.renX);
        if (divx === 0) divx = 1; //fix edge case where axis are aligned

        var divy = (b.renY - a.renY);
        if (divy === 0) divy = 1; //fix edge case where axis are aligned

        x = ((x - a.renX) / divx) * (b.x - a.x) + a.x;
        y = ((y - a.renY) / divy) * (b.y - a.y) + a.y;

        x2 = x * cos - y * sin;
        y2 = y * cos + x * sin;

        // Drag multiple nodes, Keep distance
        if(_a) {
          activeNodes = _a.nodes();

          // If hovered node is active, drag active nodes
          isHoveredNodeActive = (-1 < activeNodes.map(function(node) {
            return node.id;
          }).indexOf(_node.id));

          if (isHoveredNodeActive) {
            for(var i = 0; i < activeNodes.length; i++) {
              // Delete old reference
              if(_draggingNode != _node) {
                activeNodes[i].alphaX = undefined;
                activeNodes[i].alphaY = undefined;
              }

              // Calcul first position of activeNodes
              if(!activeNodes[i].alphaX || !activeNodes[i].alphaY) {
                activeNodes[i].alphaX = activeNodes[i].x - x;
                activeNodes[i].alphaY = activeNodes[i].y - y;
              }

              // Move activeNodes to keep same distance between dragged nodes
              // and active nodes
              activeNodes[i].x = _node.x + activeNodes[i].alphaX;
              activeNodes[i].y = _node.y + activeNodes[i].alphaY;
            }
          }
        }

        // Rotating the coordinates.
        _node.x = x2;
        _node.y = y2;

        _s.refresh({skipIndexation: true});

        _drag = true;
        _draggingNode = _node;

        _self.dispatchEvent('drag', {
          node: _draggingNode,
          captor: event,
          renderer: _renderer
        });
      }
    };
  };

  /**
   * Interface
   * ------------------
   *
   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0], a);
   */
  var _instance = {};

  /**
   * @param  {sigma}                      s        The related sigma instance.
   * @param  {renderer}                   renderer The related renderer instance.
   * @param  {?sigma.plugins.activeState} a        The activeState plugin instance.
   */
  sigma.plugins.dragNodes = function(s, renderer, a) {
    // Create object if undefined
    if (!_instance[s.id]) {
      // Handle drag events:
      _instance[s.id] = new DragNodes(s, renderer, a);
    }

    s.bind('kill', function() {
      sigma.plugins.killDragNodes(s);
    });

    // disable on plugins.animate start.
    s.bind('animate.start', function() {
      _instance[s.id].disable();
    });

    // enable on plugins.animate end.
    s.bind('animate.end', function() {
      _instance[s.id].enable();
    });

    return _instance[s.id];
  };

  /**
   * This method removes the event listeners and kills the dragNodes instance.
   *
   * @param  {sigma} s The related sigma instance.
   */
  sigma.plugins.killDragNodes = function(s) {
    if (_instance[s.id] instanceof DragNodes) {
      _instance[s.id].unbindAll();
      delete _instance[s.id];
    }
  };

}).call(window);

},{}],6:[function(require,module,exports){
/**
 * This plugin provides a method to display a tooltip at a specific event, e.g.
 * to display some node properties on node hover. Check the
 * sigma.plugins.tooltip function doc or the examples/tooltip.html code sample
 * to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.plugins');

  /**
   * Sigma tooltip
   * =============================
   *
   * @author SÃ©bastien Heymann <seb@linkurio.us> (Linkurious)
   * @version 0.3
   */

  var settings = {
    stage: {
      show: 'rightClickStage',
      hide: 'clickStage',
      cssClass: 'sigma-tooltip',
      position: 'top',    // top | bottom | left | right
      autoadjust: false,
      delay: 0,
      hideDelay: 0,
      template: '',       // HTML string
      renderer: null      // function
    },
    node: {
      show: 'clickNode',
      hide: 'clickStage',
      cssClass: 'sigma-tooltip',
      position: 'top',    // top | bottom | left | right
      autoadjust: false,
      delay: 0,
      hideDelay: 0,
      template: '',       // HTML string
      renderer: null      // function
    },
    edge: {
      show: 'clickEdge',
      hide: 'clickStage',
      cssClass: 'sigma-tooltip',
      position: 'top',    // top | bottom | left | right
      autoadjust: false,
      delay: 0,
      hideDelay: 0,
      template: '',       // HTML string
      renderer: null      // function
    },
    doubleClickDelay: 800
  };


  /**
   * This function will display a tooltip when a sigma event is fired. It will
   * basically create a DOM element, fill it with the template or the result of
   * the renderer function, set its position and CSS class, and insert the
   * element as a child of the sigma container. Only one tooltip may exist.
   *
   * Recognized parameters of options:
   * *********************************
   * Enable node tooltips by adding the "node" key to the options object.
   * Enable edge tooltips by adding the "edge" key to the options object.
   * Each value could be an array of objects for multiple tooltips,
   * or an object for one tooltip.
   * Here is the exhaustive list of every accepted parameter in these objects:
   *
   *   {?string}   show       The event that triggers the tooltip. Default
   *                          values: "clickNode", "clickEdge". Other suggested
   *                          values: "overNode", "doubleClickNode",
   *                          "rightClickNode", "hovers", "doubleClickEdge",
   *                          "rightClickEdge", "doubleClickNode",
   *                          "rightClickNode".
   *   {?string}   hide       The event that hides the tooltip. Default value:
   *                          "clickStage". Other suggested values: "hovers"
   *   {?string}   template   The HTML template. It is directly inserted inside
   *                          a div element unless a renderer is specified.
   *   {?function} renderer   This function may process the template or be used
   *                          independently. It should return an HTML string or
   *                          a DOM element. It is executed at runtime. Its
   *                          context is sigma.graph.
   *   {?string}   cssClass   The CSS class attached to the top div element.
   *                          Default value: "sigma-tooltip".
   *   {?string}   position   The position of the tooltip regarding the mouse.
   *                          If it is not specified, the tooltip top-left
   *                          corner is positionned at the mouse position.
   *                          Available values: "top", "bottom", "left",
   *                          "right".
   *   {?number}   delay      The delay in miliseconds before displaying the
   *                          tooltip after the show event is triggered.
   *   {?boolean}  autoadjust [EXPERIMENTAL] If true, tries to adjust the
   *                          tooltip position to be fully included in the body
   *                          area. Doesn't work on Firefox 30. Better work on
   *                          elements with fixed width and height.
   *
   * > sigma.plugins.tooltip(s, {
   * >   node: {
   * >     template: 'Hello node!'
   * >   },
   * >   edge: {
   * >     template: 'Hello edge!'
   * >   },
   * >   stage: {
   * >     template: 'Hello stage!'
   * >   }
   * > });
   *
   * @param {sigma}    s        The related sigma instance.
   * @param {renderer} renderer The related sigma renderer.
   * @param {object}   options  An object with options.
   */
  function Tooltips(s, renderer, options) {
    var self = this,
        _tooltip,
        _timeoutHandle,
        _timeoutHideHandle,
        _stageTooltips = [],
        _nodeTooltips = [],
        _edgeTooltips = [],
        _mouseOverTooltip = false,
        _doubleClick = false;

    if (Array.isArray(options.stage)) {
      for (var i = 0; i < options.stage.length; i++) {
        _stageTooltips.push(sigma.utils.extend(options.stage[i], settings.stage));
      }
    } else {
      _stageTooltips.push(sigma.utils.extend(options.stage, settings.stage));
    }

    if (Array.isArray(options.node)) {
      for (var i = 0; i < options.node.length; i++) {
        _nodeTooltips.push(sigma.utils.extend(options.node[i], settings.node));
      }
    } else {
      _nodeTooltips.push(sigma.utils.extend(options.node, settings.node));
    }

    if (Array.isArray(options.edge)) {
      for (var i = 0; i < options.edge.length; i++) {
        _edgeTooltips.push(sigma.utils.extend(options.edge[i], settings.edge));
      }
    } else {
      _edgeTooltips.push(sigma.utils.extend(options.edge, settings.edge));
    }

    sigma.classes.dispatcher.extend(this);

    s.bind('kill', function() {
      sigma.plugins.killTooltips(s);
    });

    function contextmenuListener(event) {
      event.preventDefault();
    };

    /**
     * This function removes the existing tooltip and creates a new tooltip for a
     * specified node or edge.
     *
     * @param {object}    o          The node or the edge.
     * @param {object}    options    The options related to the object.
     * @param {number}    x          The X coordinate of the mouse.
     * @param {number}    y          The Y coordinate of the mouse.
     * @param {function?} onComplete Optional function called when open finish
     */
    this.open = function(o, options, x, y, onComplete) {
      remove();

      // Create the DOM element:
      _tooltip = document.createElement('div');
      if (options.renderer) {
        // Copy the object:
        var clone = Object.create(null),
            tooltipRenderer,
            type,
            k;
        for (k in o)
          clone[k] = o[k];

        tooltipRenderer = options.renderer.call(s.graph, clone, options.template);

        type = typeof tooltipRenderer;

        if (type === 'undefined') return;

        if (type === 'string') {
           _tooltip.innerHTML = tooltipRenderer;
        }
        else {
          // tooltipRenderer is a dom element:
          _tooltip.appendChild(tooltipRenderer);
        }
      }
      else {
        _tooltip.innerHTML = options.template;
      }

      var containerPosition = window.getComputedStyle(renderer.container).position;

      if(containerPosition !== 'static') {
        _tooltip.style.position = 'absolute';
        var containerRect = renderer.container.getBoundingClientRect();
        x = ~~(x - containerRect.left);
        y = ~~(y - containerRect.top);
      }


      // Style it:
      _tooltip.className = options.cssClass;

      if (options.position !== 'css') {
        if(containerPosition === 'static') {
          _tooltip.style.position = 'absolute';
        }

        // Default position is mouse position:
        _tooltip.style.left = x + 'px';
        _tooltip.style.top = y + 'px';
      }

      _tooltip.addEventListener('mouseenter', function() {
        _mouseOverTooltip = true;
      }, false);

      _tooltip.addEventListener('mouseleave', function() {
        _mouseOverTooltip = false;
      }, false);

      // Execute after rendering:
      setTimeout(function() {
        if (!_tooltip)
          return;

        // Insert the element in the DOM:
        renderer.container.appendChild(_tooltip);

        // Find offset:
        var bodyRect = document.body.getBoundingClientRect(),
            tooltipRect = _tooltip.getBoundingClientRect(),
            offsetTop =  tooltipRect.top - bodyRect.top,
            offsetBottom = bodyRect.bottom - tooltipRect.bottom,
            offsetLeft =  tooltipRect.left - bodyRect.left,
            offsetRight = bodyRect.right - tooltipRect.right;

        if (options.position === 'top') {
          // New position vertically aligned and on top of the mouse:
          _tooltip.className = options.cssClass + ' top';
          _tooltip.style.left = x - (tooltipRect.width / 2) + 'px';
          _tooltip.style.top = y - tooltipRect.height + 'px';
        }
        else if (options.position === 'bottom') {
          // New position vertically aligned and on bottom of the mouse:
          _tooltip.className = options.cssClass + ' bottom';
          _tooltip.style.left = x - (tooltipRect.width / 2) + 'px';
          _tooltip.style.top = y + 'px';
        }
        else if (options.position === 'left') {
          // New position vertically aligned and on bottom of the mouse:
          _tooltip.className = options.cssClass+ ' left';
          _tooltip.style.left = x - tooltipRect.width + 'px';
          _tooltip.style.top = y - (tooltipRect.height / 2) + 'px';
        }
        else if (options.position === 'right') {
          // New position vertically aligned and on bottom of the mouse:
          _tooltip.className = options.cssClass + ' right';
          _tooltip.style.left = x + 'px';
          _tooltip.style.top = y - (tooltipRect.height / 2) + 'px';
        }

        // Adjust position to keep the tooltip inside body:
        // FIXME: doesn't work on Firefox
        if (options.autoadjust) {

          // Update offset
          tooltipRect = _tooltip.getBoundingClientRect();
          offsetTop = tooltipRect.top - bodyRect.top;
          offsetBottom = bodyRect.bottom - tooltipRect.bottom;
          offsetLeft = tooltipRect.left - bodyRect.left;
          offsetRight = bodyRect.right - tooltipRect.right;

          if (offsetBottom < 0) {
            _tooltip.className = options.cssClass;
            if (options.position === 'top' || options.position === 'bottom') {
              _tooltip.className = options.cssClass + ' top';
            }
            _tooltip.style.top = y - tooltipRect.height + 'px';
          }
          else if (offsetTop < 0) {
            _tooltip.className = options.cssClass;
            if (options.position === 'top' || options.position === 'bottom') {
              _tooltip.className = options.cssClass + ' bottom';
            }
            _tooltip.style.top = y + 'px';
          }
          if (offsetRight < 0) {
            //! incorrect tooltipRect.width on non fixed width element.
            _tooltip.className = options.cssClass;
            if (options.position === 'left' || options.position === 'right') {
              _tooltip.className = options.cssClass + ' left';
            }
            _tooltip.style.left = x - tooltipRect.width + 'px';
          }
          else if (offsetLeft < 0) {
            _tooltip.className = options.cssClass;
            if (options.position === 'left' || options.position === 'right') {
              _tooltip.className = options.cssClass + ' right';
            }
            _tooltip.style.left = x + 'px';
          }
        }
        if (onComplete) onComplete();
      }, 0);
    };

    /**
     * This function removes the tooltip element from the DOM.
     */
    function remove() {
      if (_tooltip && _tooltip.parentNode) {
        // Remove from the DOM:
        _tooltip.parentNode.removeChild(_tooltip);
        _tooltip = null;
      }
    };

    /**
     * This function clears all timeouts related to the tooltip
     * and removes the tooltip.
     */
    function cancel() {
      clearTimeout(_timeoutHandle);
      clearTimeout(_timeoutHideHandle);
      _timeoutHandle = false;
      _timeoutHideHandle = false;
      remove();
    };

    /**
     * Similar to cancel() but can be delayed.
     *
     * @param {number} delay. The delay in miliseconds.
     */
    function delayedCancel(delay) {
      clearTimeout(_timeoutHandle);
      clearTimeout(_timeoutHideHandle);
      _timeoutHandle = false;
      _timeoutHideHandle = setTimeout(function() {
        if (!_mouseOverTooltip) remove();
      }, delay);
    };

    // INTERFACE:
    this.close = function() {
      cancel();
      this.dispatchEvent('hidden');
      return this;
    };

    this.kill = function() {
      this.unbindEvents();
      clearTimeout(_timeoutHandle);
      clearTimeout(_timeoutHideHandle);
      _tooltip = null;
      _timeoutHandle = null;
      _timeoutHideHandle = null;
      _doubleClick = false;
      _stageTooltips = [];
      _nodeTooltips = [];
      _edgeTooltips = [];
    };

    this.unbindEvents = function() {
      var tooltips = _stageTooltips.concat(_nodeTooltips).concat(_edgeTooltips);

      for (var i = 0; i < tooltips.length; i++) {
        s.unbind(tooltips[i].show);
        s.unbind(tooltips[i].hide);

        if (tooltips[i].show === 'rightClickNode' || tooltips[i].show === 'rightClickEdge') {
          renderer.container.removeEventListener(
            'contextmenu',
            contextmenuListener
          );
        }
      }
      // Remove the default event handlers
      s.unbind('doubleClickStage');
      s.unbind('doubleClickNode');
      s.unbind('doubleClickEdge');
    };

    this.bindStageEvents = function(tooltip) {
      s.bind(tooltip.show, function(event) {
        if (tooltip.show !== 'doubleClickStage' && _doubleClick) {
          return;
        }

        var clientX = event.data.captor.clientX,
            clientY = event.data.captor.clientY;

        clearTimeout(_timeoutHandle);
        _timeoutHandle = setTimeout(function() {
          self.open(
            null,
            tooltip,
            clientX,
            clientY,
            self.dispatchEvent.bind(self,'shown', event.data));
        }, tooltip.delay);
      });

      s.bind(tooltip.hide, function(event) {
        var p = _tooltip;
        delayedCancel(settings.stage.hideDelay);
        if (p)
          self.dispatchEvent('hidden', event.data);
      });
    };

    this.bindNodeEvents = function(tooltip) {
      s.bind(tooltip.show, function(event) {
        if (tooltip.show !== 'doubleClickNode' && _doubleClick) {
          return;
        }

        var n = event.data.node;
        if (!n && event.data.enter) {
          n = event.data.enter.nodes[0];
        }
        if (n == undefined) return;

        var clientX = event.data.captor.clientX,
            clientY = event.data.captor.clientY;

        clearTimeout(_timeoutHandle);
        _timeoutHandle = setTimeout(function() {
          self.open(
            n,
            tooltip,
            clientX,
            clientY,
            self.dispatchEvent.bind(self,'shown', event.data));
        }, tooltip.delay);
      });

      s.bind(tooltip.hide, function(event) {
        if (event.data.leave && event.data.leave.nodes.length == 0)
          return
        var p = _tooltip;
        delayedCancel(settings.node.hideDelay);
        if (p)
          self.dispatchEvent('hidden', event.data);
      });
    };

    this.bindEdgeEvents = function(tooltip) {
      s.bind(tooltip.show, function(event) {
        if (tooltip.show !== 'doubleClickEdge' && _doubleClick) {
          return;
        }

        var e = event.data.edge;
        if (!e && event.data.enter) {
          e = event.data.enter.edges[0];
        }
        if (e == undefined) return;

        var clientX = event.data.captor.clientX,
            clientY = event.data.captor.clientY;

        clearTimeout(_timeoutHandle);
        _timeoutHandle = setTimeout(function() {
          self.open(
            e,
            tooltip,
            clientX,
            clientY,
            self.dispatchEvent.bind(self,'shown', event.data));
        }, tooltip.delay);
      });

      s.bind(tooltip.hide, function(event) {
        if (event.data.leave && event.data.leave.edges.length == 0)
          return
        var p = _tooltip;
        delayedCancel(settings.edge.hideDelay);
        if (p)
          self.dispatchEvent('hidden', event.data);
      });
    };

    // STAGE tooltip:
    if (options.stage) {
      var hasDoubleClickStage = false;

      for (var i = 0; i < _stageTooltips.length; i++) {
        if (_stageTooltips[i].renderer !== null &&
            typeof _stageTooltips[i].renderer !== 'function')
          throw new TypeError('"options.stage.renderer" is not a function, was ' + _stageTooltips[i].renderer);

        if (_stageTooltips[i].position !== undefined) {
          if (_stageTooltips[i].position !== 'top' &&
              _stageTooltips[i].position !== 'bottom' &&
              _stageTooltips[i].position !== 'left' &&
              _stageTooltips[i].position !== 'right' &&
              _stageTooltips[i].position !== 'css') {
            throw new Error('"options.position" is not "top", "bottom", "left", "right", or "css", was ' + _stageTooltips[i].position);
          }
        }

        if (_stageTooltips[i].show === 'doubleClickStage') {
          hasDoubleClickStage = true;
        }
      }

      for (var i = 0; i < _stageTooltips.length; i++) {
        this.bindStageEvents(_stageTooltips[i]);
      }

      if (!hasDoubleClickStage) {
        s.bind('doubleClickStage', function(event) {
          cancel();
          _doubleClick = true;
          self.dispatchEvent('hidden', event.data);
          setTimeout(function() {
            _doubleClick = false;
          }, settings.doubleClickDelay);
        });
      }
    }

    // NODE tooltip:
    if (options.node) {
      var hasRightClickNode = false;
      var hasDoubleClickNode = false;

      for (var i = 0; i < _nodeTooltips.length; i++) {
        if (_nodeTooltips[i].renderer !== null &&
            typeof _nodeTooltips[i].renderer !== 'function')
          throw new TypeError('"options.node.renderer" is not a function, was ' + _nodeTooltips[i].renderer);

        if (_nodeTooltips[i].position !== undefined) {
          if (_nodeTooltips[i].position !== 'top' &&
              _nodeTooltips[i].position !== 'bottom' &&
              _nodeTooltips[i].position !== 'left' &&
              _nodeTooltips[i].position !== 'right' &&
              _nodeTooltips[i].position !== 'css') {
            throw new Error('"options.position" is not "top", "bottom", "left", "right", or "css", was ' + _nodeTooltips[i].position);
          }
        }

        if (_nodeTooltips[i].show === 'doubleClickNode') {
          hasDoubleClickNode = true;
        } else if (_nodeTooltips[i].show === 'rightClickNode') {
          hasRightClickNode = true;
        }
      }

      for (var i = 0; i < _nodeTooltips.length; i++) {
        this.bindNodeEvents(_nodeTooltips[i]);
      }

      if (!hasDoubleClickNode) {
        s.bind('doubleClickNode', function(event) {
          cancel();
          _doubleClick = true;
          self.dispatchEvent('hidden', event.data);
          setTimeout(function() {
            _doubleClick = false;
          }, settings.doubleClickDelay);
        });
      }
    }

    // EDGE tooltip:
    if (options.edge) {
      var hasRightClickEdge = false;
      var hasDoubleClickEdge = false;

      for (var i = 0; i < _edgeTooltips.length; i++) {
        if (_edgeTooltips[i].renderer !== null &&
            typeof _edgeTooltips[i].renderer !== 'function')
          throw new TypeError('"options.edge.renderer" is not a function, was ' + _edgeTooltips[i].renderer);

        if (_edgeTooltips[i].position !== undefined) {
          if (_edgeTooltips[i].position !== 'top' &&
              _edgeTooltips[i].position !== 'bottom' &&
              _edgeTooltips[i].position !== 'left' &&
              _edgeTooltips[i].position !== 'right' &&
              _edgeTooltips[i].position !== 'css') {
            throw new Error('"options.position" is not "top", "bottom", "left", "right", or "css", was ' + _edgeTooltips[i].position);
          }
        }

        if (_edgeTooltips[i].show === 'doubleClickEdge') {
          hasDoubleClickEdge = true;
        } else if (_edgeTooltips[i].show === 'rightClickEdge') {
          hasRightClickEdge = true;
        }
      }

      for (var i = 0; i < _edgeTooltips.length; i++) {
        this.bindEdgeEvents(_edgeTooltips[i]);
      }

      if (!hasDoubleClickEdge) {
        s.bind('doubleClickEdge', function(event) {
          cancel();
          _doubleClick = true;
          self.dispatchEvent('hidden', event.data);
          setTimeout(function() {
            _doubleClick = false;
          }, settings.doubleClickDelay);
        })
      }
    }

    // Prevent the browser context menu to appear
    // if the right click event is already handled:
    if (hasRightClickNode || hasRightClickEdge) {
      renderer.container.addEventListener(
        'contextmenu',
        contextmenuListener
      );
    }
  };

  /**
   * Interface
   * ------------------
   */
  var _instance = {};

  /**
   * @param {sigma}    s        The related sigma instance.
   * @param {renderer} renderer The related sigma renderer.
   * @param {object}   options  An object with options.
   */
  sigma.plugins.tooltips = function(s, renderer, options) {
    // Create object if undefined
    if (!_instance[s.id]) {
      _instance[s.id] = new Tooltips(s, renderer, options);
    }
    return _instance[s.id];
  };

  /**
   *  This function kills the tooltips instance.
   */
  sigma.plugins.killTooltips = function(s) {
    if (_instance[s.id] instanceof Tooltips) {
      _instance[s.id].kill();
    }
    delete _instance[s.id];
  };

}).call(window);

},{}],7:[function(require,module,exports){
;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  var drawBorder = function(context, x, y, radius, color, line_width) {
    context.beginPath();
    context.strokeStyle = color;
	  context.lineWidth = line_width;
    context.arc(x, y, radius, 0, Math.PI * 2, true);
    context.closePath();
    context.stroke();
  };


  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   * @param  {?object}                  options  Force optional parameters (e.g. color).
   */
  sigma.canvas.nodes.def = function(node, context, settings, options) {
    var o = options || {},
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'] || 1,
        x = node[prefix + 'x'],
        y = node[prefix + 'y'],
        defaultNodeColor = settings('defaultNodeColor'),
        imgCrossOrigin = settings('imgCrossOrigin') || 'anonymous',
        borderSize = node.border_size || settings('nodeBorderSize'),
        outerBorderSize = settings('nodeOuterBorderSize'),
        activeBorderSize = node.border_size || settings('nodeActiveBorderSize'),
        activeOuterBorderSize = settings('nodeActiveOuterBorderSize'),
        color = o.color || node.color || defaultNodeColor,
	      borderColor = settings('nodeBorderColor') === 'default'
          ? settings('defaultNodeBorderColor')
          : (o.borderColor || node.border_color || node.color || defaultNodeColor),
        level = node.active ? settings('nodeActiveLevel') : node.level;

    // Level:
    sigma.utils.canvas.setLevel(level, context);

    if (node.active) {
      // Color:
      if (settings('nodeActiveColor') === 'node') {
        color = node.active_color || color;
      }
      else {
        color = settings('defaultNodeActiveColor') || color;
      }

      // Outer Border:
      if (activeOuterBorderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeActiveOuterBorderColor') === 'node' ?
          (color || defaultNodeColor) :
          settings('defaultNodeActiveOuterBorderColor');
        context.arc(x, y, size + activeBorderSize + activeOuterBorderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }
      // Border:
      if (activeBorderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeActiveBorderColor') === 'node'
          ? borderColor
          : settings('defaultNodeActiveBorderColor');
        context.arc(x, y, size + activeBorderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }
    }
    else {
      // Outer Border:
      if (outerBorderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeOuterBorderColor') === 'node' ?
          (color || defaultNodeColor) :
          settings('defaultNodeOuterBorderColor');
        context.arc(x, y, size + borderSize + outerBorderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }

      // Border:
      if (borderSize > 0) {
        context.beginPath();
        context.fillStyle = settings('nodeBorderColor') === 'node'
          ? borderColor
          : settings('defaultNodeBorderColor');
        context.arc(x, y, size + borderSize, 0, Math.PI * 2, true);
        context.closePath();
        context.fill();
      }
    }

    if ((!node.active ||
      (node.active && settings('nodeActiveColor') === 'node')) &&
      node.colors &&
      node.colors.length) {

      // see http://jsfiddle.net/hvYkM/1/
      var i,
          l = node.colors.length,
          j = 1 / l,
          lastend = 0;

      for (i = 0; i < l; i++) {
        context.fillStyle = node.colors[i];
        context.beginPath();
        context.moveTo(x, y);
        context.arc(x, y, size, lastend, lastend + (Math.PI * 2 * j), false);
        context.lineTo(x, y);
        context.closePath();
        context.fill();
        lastend += Math.PI * 2 * j;
      }
      sigma.utils.canvas.resetLevel(context);
    }
    else {
      context.fillStyle = color;
      context.beginPath();
      context.arc(x, y, size, 0, Math.PI * 2, true);
      context.closePath();
      context.fill();

      sigma.utils.canvas.resetLevel(context);

      if (!node.active && borderSize > 0 && (size > 2 * borderSize)) {
		    drawBorder(context, x, y, size, borderColor, borderSize);
      }
    }

    // Image:
    if (node.image) {
      sigma.utils.canvas.drawImage(
        node, x, y, size, context, imgCrossOrigin, settings('imageThreshold')
      );
    }

    // Icon:
    if (node.icon) {
      sigma.utils.canvas.drawIcon(node, x, y, size, context, settings('iconThreshold'));
    }

  };
})();

},{}],8:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  var __instances = {};

  /**
   * This is the sigma instances constructor. One instance of sigma represent
   * one graph. It is possible to represent this grapÄ¥ with several renderers
   * at the same time. By default, the default renderer (WebGL + Canvas
   * polyfill) will be used as the only renderer, with the container specified
   * in the configuration.
   *
   * @param  {?*}    conf The configuration of the instance. There are a lot of
   *                      different recognized forms to instantiate sigma, check
   *                      example files, documentation in this file and unit
   *                      tests to know more.
   * @return {sigma}      The fresh new sigma instance.
   *
   * Instanciating sigma:
   * ********************
   * If no parameter is given to the constructor, the instance will be created
   * without any renderer or camera. It will just instantiate the graph, and
   * other modules will have to be instantiated through the public methods,
   * like "addRenderer" etc:
   *
   *  > s0 = new sigma();
   *  > s0.addRenderer({
   *  >   type: 'canvas',
   *  >   container: 'my-container-id'
   *  > });
   *
   * In most of the cases, sigma will simply be used with the default renderer.
   * Then, since the only required parameter is the DOM container, there are
   * some simpler way to call the constructor. The four following calls do the
   * exact same things:
   *
   *  > s1 = new sigma('my-container-id');
   *  > s2 = new sigma(document.getElementById('my-container-id'));
   *  > s3 = new sigma({
   *  >   container: document.getElementById('my-container-id')
   *  > });
   *  > s4 = new sigma({
   *  >   renderers: [{
   *  >     container: document.getElementById('my-container-id')
   *  >   }]
   *  > });
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters, when calling the
   * constructor with to top level configuration object (fourth case in the
   * previous examples):
   *
   *   {?string} id        The id of the instance. It will be generated
   *                       automatically if not specified.
   *   {?array}  renderers An array containing objects describing renderers.
   *   {?object} graph     An object containing an array of nodes and an array
   *                       of edges, to avoid having to add them by hand later.
   *   {?object} settings  An object containing instance specific settings that
   *                       will override the default ones defined in the object
   *                       sigma.settings.
   */
  var sigma = function(conf) {
    // Local variables:
    // ****************
    var i,
        l,
        a,
        c,
        o,
        id;

    sigma.classes.dispatcher.extend(this);

    // Private attributes:
    // *******************
    var _self = this,
        _conf = conf || {};

    // Little shortcut:
    // ****************
    // The configuration is supposed to have a list of the configuration
    // objects for each renderer.
    //  - If there are no configuration at all, then nothing is done.
    //  - If there are no renderer list, the given configuration object will be
    //    considered as describing the first and only renderer.
    //  - If there are no renderer list nor "container" object, it will be
    //    considered as the container itself (a DOM element).
    //  - If the argument passed to sigma() is a string, it will be considered
    //    as the ID of the DOM container.
    if (
      typeof _conf === 'string' ||
      _conf instanceof HTMLElement
    )
      _conf = {
        renderers: [_conf]
      };
    else if (Object.prototype.toString.call(_conf) === '[object Array]')
      _conf = {
        renderers: _conf
      };

    // Also check "renderer" and "container" keys:
    o = _conf.renderers || _conf.renderer || _conf.container;
    if (!_conf.renderers || _conf.renderers.length === 0)
      if (
        typeof o === 'string' ||
        o instanceof HTMLElement ||
        (typeof o === 'object' && 'container' in o)
      )
        _conf.renderers = [o];

    // Recense the instance:
    if (_conf.id) {
      if (__instances[_conf.id])
        throw 'sigma: Instance "' + _conf.id + '" already exists.';
      Object.defineProperty(this, 'id', {
        value: _conf.id
      });
    } else {
      id = 0;
      while (__instances[id])
        id++;
      Object.defineProperty(this, 'id', {
        value: '' + id
      });
    }
    __instances[this.id] = this;

    // Initialize settings function:
    this.settings = new sigma.classes.configurable(
      sigma.settings,
      _conf.settings || {}
    );

    // Initialize locked attributes:
    Object.defineProperty(this, 'graph', {
      value: new sigma.classes.graph(this.settings),
      configurable: true
    });
    Object.defineProperty(this, 'middlewares', {
      value: [],
      configurable: true
    });
    Object.defineProperty(this, 'cameras', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderers', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'renderersPerCamera', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'cameraFrames', {
      value: {},
      configurable: true
    });
    Object.defineProperty(this, 'camera', {
      get: function() {
        return this.cameras[0];
      }
    });
    Object.defineProperty(this, 'events', {
      value: [
        'click',
        'rightClick',
        'clickStage',
        'doubleClickStage',
        'rightClickStage',
        'clickNode',
        'clickNodes',
        'doubleClickNode',
        'doubleClickNodes',
        'rightClickNode',
        'rightClickNodes',
        'overNode',
        'overNodes',
        'outNode',
        'outNodes',
        'downNode',
        'downNodes',
        'upNode',
        'upNodes'
      ],
      configurable: true
    });

    // Add a custom handler, to redispatch events from renderers:
    this._handler = (function(e) {
      var k,
          data = {};

      for (k in e.data)
        data[k] = e.data[k];

      data.renderer = e.target;
      this.dispatchEvent(e.type, data);
    }).bind(this);

    // Initialize renderers:
    a = _conf.renderers || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addRenderer(a[i]);

    // Initialize middlewares:
    a = _conf.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      this.middlewares.push(
        typeof a[i] === 'string' ?
          sigma.middlewares[a[i]] :
          a[i]
      );

    // Check if there is already a graph to fill in:
    if (typeof _conf.graph === 'object' && _conf.graph) {
      this.graph.read(_conf.graph);

      // If a graph is given to the to the instance, the "refresh" method is
      // directly called:
      this.refresh();
    }

    // Deal with resize:
    window.addEventListener('resize', function() {
      if (_self.settings)
        _self.refresh();
    });
  };




  /**
   * This methods will instantiate and reference a new camera. If no id is
   * specified, then an automatic id will be generated.
   *
   * @param  {?string}              id Eventually the camera id.
   * @return {sigma.classes.camera}    The fresh new camera instance.
   */
  sigma.prototype.addCamera = function(id) {
    var self = this,
        camera;

    if (!arguments.length) {
      id = 0;
      while (this.cameras['' + id])
        id++;
      id = '' + id;
    }

    if (this.cameras[id])
      throw 'sigma.addCamera: The camera "' + id + '" already exists.';

    camera = new sigma.classes.camera(id, this.graph, this.settings);
    this.cameras[id] = camera;

    // Add a quadtree to the camera:
    camera.quadtree = new sigma.classes.quad();

    // Add an edgequadtree to the camera:
    if (sigma.classes.edgequad !== undefined) {
      camera.edgequadtree = new sigma.classes.edgequad();
    }

    camera.bind('coordinatesUpdated', function(e) {
      self.renderCamera(camera, camera.isAnimated);
    });

    this.renderersPerCamera[id] = [];

    return camera;
  };

  /**
   * This method kills a camera, and every renderer attached to it.
   *
   * @param  {string|camera} v The camera to kill or its ID.
   * @return {sigma}           Returns the instance.
   */
  sigma.prototype.killCamera = function(v) {
    v = typeof v === 'string' ? this.cameras[v] : v;

    if (!v)
      throw 'sigma.killCamera: The camera is undefined.';

    var i,
        l,
        a = this.renderersPerCamera[v.id];

    for (l = a.length, i = l - 1; i >= 0; i--)
      this.killRenderer(a[i]);

    delete this.renderersPerCamera[v.id];
    delete this.cameraFrames[v.id];
    delete this.cameras[v.id];

    if (v.kill)
      v.kill();

    return this;
  };

  /**
   * This methods will instantiate and reference a new renderer. The "type"
   * argument can be the constructor or its name in the "sigma.renderers"
   * package. If no type is specified, then "sigma.renderers.def" will be used.
   * If no id is specified, then an automatic id will be generated.
   *
   * @param  {?object}  options Eventually some options to give to the renderer
   *                            constructor.
   * @return {renderer}         The fresh new renderer instance.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?string}            id     Eventually the renderer id.
   *   {?(function|string)} type   Eventually the renderer constructor or its
   *                               name in the "sigma.renderers" package.
   *   {?(camera|string)}   camera Eventually the renderer camera or its
   *                               id.
   */
  sigma.prototype.addRenderer = function(options) {
    var id,
        fn,
        camera,
        renderer,
        o = options || {};

    // Polymorphism:
    if (typeof o === 'string')
      o = {
        container: document.getElementById(o)
      };
    else if (o instanceof HTMLElement)
      o = {
        container: o
      };

    // If the container still is a string, we get it by id
    if (typeof o.container === 'string')
      o.container = document.getElementById(o.container);

    // Reference the new renderer:
    if (!('id' in o)) {
      id = 0;
      while (this.renderers['' + id])
        id++;
      id = '' + id;
    } else
      id = o.id;

    if (this.renderers[id])
      throw 'sigma.addRenderer: The renderer "' + id + '" already exists.';

    // Find the good constructor:
    fn = typeof o.type === 'function' ? o.type : sigma.renderers[o.type];
    fn = fn || sigma.renderers.def;

    // Find the good camera:
    camera = 'camera' in o ?
      (
        o.camera instanceof sigma.classes.camera ?
          o.camera :
          this.cameras[o.camera] || this.addCamera(o.camera)
      ) :
      this.addCamera();

    if (this.cameras[camera.id] !== camera)
      throw 'sigma.addRenderer: The camera is not properly referenced.';

    // Instantiate:
    renderer = new fn(this.graph, camera, this.settings, o);
    this.renderers[id] = renderer;
    Object.defineProperty(renderer, 'id', {
      value: id
    });

    // Bind events:
    if (renderer.bind)
      renderer.bind(
        [
          'click',
          'rightClick',
          'clickStage',
          'doubleClickStage',
          'rightClickStage',
          'clickNode',
          'clickNodes',
          'clickEdge',
          'clickEdges',
          'doubleClickNode',
          'doubleClickNodes',
          'doubleClickEdge',
          'doubleClickEdges',
          'rightClickNode',
          'rightClickNodes',
          'rightClickEdge',
          'rightClickEdges',
          'overNode',
          'overNodes',
          'overEdge',
          'overEdges',
          'outNode',
          'outNodes',
          'outEdge',
          'outEdges',
          'downNode',
          'downNodes',
          'downEdge',
          'downEdges',
          'upNode',
          'upNodes',
          'upEdge',
          'upEdges'
        ],
        this._handler
      );

    // Reference the renderer by its camera:
    this.renderersPerCamera[camera.id].push(renderer);

    return renderer;
  };

  /**
   * This method kills a renderer.
   *
   * @param  {string|renderer} v The renderer to kill or its ID.
   * @return {sigma}             Returns the instance.
   */
  sigma.prototype.killRenderer = function(v) {
    v = typeof v === 'string' ? this.renderers[v] : v;

    if (!v)
      throw 'sigma.killRenderer: The renderer is undefined.';

    var a = this.renderersPerCamera[v.camera.id],
        i = a.indexOf(v);

    if (i >= 0)
      a.splice(i, 1);

    if (v.kill)
      v.kill();

    delete this.renderers[v.id];

    return this;
  };




  /**
   * This method calls the "render" method of each renderer, with the same
   * arguments than the "render" method, but will also check if the renderer
   * has a "process" method, and call it if it exists.
   *
   * It is useful for quadtrees or WebGL processing, for instance.
   *
   * @param  {?object}  options Eventually some options to give to the refresh
   *                            method.
   * @return {sigma}            Returns the instance itself.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the "options"
   * object:
   *
   *   {?boolean} skipIndexation A flag specifying wether or not the refresh
   *                             function should reindex the graph in the
   *                             quadtrees or not (default: false).
   */
  sigma.prototype.refresh = function(options) {
    var i,
        l,
        k,
        a,
        c,
        bounds,
        prefix = 0;

    options = options || {};

    // Call each middleware:
    a = this.middlewares || [];
    for (i = 0, l = a.length; i < l; i++)
      a[i].call(
        this,
        (i === 0) ? '' : 'tmp' + prefix + ':',
        (i === l - 1) ? 'ready:' : ('tmp' + (++prefix) + ':')
      );

    // Then, for each camera, call the "rescale" middleware, unless the
    // settings specify not to:
    for (k in this.cameras) {
      c = this.cameras[k];
      if (
        c.settings('autoRescale') &&
        this.renderersPerCamera[c.id] &&
        this.renderersPerCamera[c.id].length
      )
        sigma.middlewares.rescale.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix,
          {
            width: this.renderersPerCamera[c.id][0].width,
            height: this.renderersPerCamera[c.id][0].height
          }
        );
      else
        sigma.middlewares.copy.call(
          this,
          a.length ? 'ready:' : '',
          c.readPrefix
        );

      if (!options.skipIndexation) {
        // Find graph boundaries:
        bounds = sigma.utils.getBoundaries(
          this.graph,
          c.readPrefix
        );

        // Refresh quadtree:
        c.quadtree.index(this.graph.nodes(), {
          prefix: c.readPrefix,
          bounds: {
            x: bounds.minX,
            y: bounds.minY,
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
          }
        });

        // Refresh edgequadtree:
        if (
          c.edgequadtree !== undefined &&
          c.settings('drawEdges') &&
          c.settings('enableEdgeHovering')
        ) {
          c.edgequadtree.index(this.graph, {
            prefix: c.readPrefix,
            bounds: {
              x: bounds.minX,
              y: bounds.minY,
              width: bounds.maxX - bounds.minX,
              height: bounds.maxY - bounds.minY
            }
          });
        }
      }
    }

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.renderers[a[i]].process) {
        if (this.settings('skipErrors'))
          try {
            this.renderers[a[i]].process();
          } catch (e) {
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".process()"'
            );
          }
        else
          this.renderers[a[i]].process();
      }

    this.render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer.
   *
   * @return {sigma} Returns the instance itself.
   */
  sigma.prototype.render = function() {
    var i,
        l,
        a,
        prefix = 0;

    // Call each renderer:
    a = Object.keys(this.renderers);
    for (i = 0, l = a.length; i < l; i++)
      if (this.settings('skipErrors'))
        try {
          this.renderers[a[i]].render();
        } catch (e) {
          if (this.settings('verbose'))
            console.log(
              'Warning: The renderer "' + a[i] + '" crashed on ".render()"'
            );
        }
      else
        this.renderers[a[i]].render();

    return this;
  };

  /**
   * This method calls the "render" method of each renderer that is bound to
   * the specified camera. To improve the performances, if this method is
   * called too often, the number of effective renderings is limitated to one
   * per frame, unless you are using the "force" flag.
   *
   * @param  {sigma.classes.camera} camera The camera to render.
   * @param  {?boolean}             force  If true, will render the camera
   *                                       directly.
   * @return {sigma}                       Returns the instance itself.
   */
  sigma.prototype.renderCamera = function(camera, force) {
    var i,
        l,
        a,
        self = this;

    if (force) {
      a = this.renderersPerCamera[camera.id];
      for (i = 0, l = a.length; i < l; i++)
        if (this.settings('skipErrors'))
          try {
            a[i].render();
          } catch (e) {
            if (this.settings('verbose'))
              console.log(
                'Warning: The renderer "' + a[i].id + '" crashed on ".render()"'
              );
          }
        else
          a[i].render();
    } else {
      if (!this.cameraFrames[camera.id]) {
        a = this.renderersPerCamera[camera.id];
        for (i = 0, l = a.length; i < l; i++)
          if (this.settings('skipErrors'))
            try {
              a[i].render();
            } catch (e) {
              if (this.settings('verbose'))
                console.log(
                  'Warning: The renderer "' +
                    a[i].id +
                    '" crashed on ".render()"'
                );
            }
          else
            a[i].render();

        this.cameraFrames[camera.id] = requestAnimationFrame(function() {
          delete self.cameraFrames[camera.id];
        });
      }
    }

    return this;
  };

  /**
   * This method calls the "kill" method of each module and destroys any
   * reference from the instance.
   */
  sigma.prototype.kill = function() {
    var k;

    // Dispatching event
    this.dispatchEvent('kill');

    // Kill graph:
    this.graph.kill();

    // Kill middlewares:
    delete this.middlewares;

    // Kill each renderer:
    for (k in this.renderers)
      this.killRenderer(this.renderers[k]);

    // Kill each camera:
    for (k in this.cameras)
      this.killCamera(this.cameras[k]);

    delete this.renderers;
    delete this.cameras;

    // Kill everything else:
    for (k in this)
      if (this.hasOwnProperty(k))
        delete this[k];

    delete __instances[this.id];
  };




  /**
   * Returns a clone of the instances object or a specific running instance.
   *
   * @param  {?string} id Eventually an instance ID.
   * @return {object}     The related instance or a clone of the instances
   *                      object.
   */
  sigma.instances = function(id) {
    return arguments.length ?
      __instances[id] :
      sigma.utils.extend({}, __instances);
  };



  /**
   * The current version of sigma:
   */
  sigma.version = '1.2.1';




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined')
    throw 'An object called sigma is already in the global scope.';

  this.sigma = sigma;

}).call(this);

/**
 * conrad.js is a tiny JavaScript jobs scheduler,
 *
 * Version: 0.1.0
 * Sources: http://github.com/jacomyal/conrad.js
 * Doc:     http://github.com/jacomyal/conrad.js#readme
 *
 * License:
 * --------
 * Copyright Â© 2013 Alexis Jacomy, Sciences-Po mÃ©dialab
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * The Software is provided "as is", without warranty of any kind, express or
 * implied, including but not limited to the warranties of merchantability,
 * fitness for a particular purpose and noninfringement. In no event shall the
 * authors or copyright holders be liable for any claim, damages or other
 * liability, whether in an action of contract, tort or otherwise, arising
 * from, out of or in connection with the software or the use or other dealings
 * in the Software.
 */
(function(global) {
  'use strict';

  // Check that conrad.js has not been loaded yet:
  if (global.conrad)
    throw new Error('conrad already exists');


  /**
   * PRIVATE VARIABLES:
   * ******************
   */

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Number}
   */
  var _lastFrameTime;

  /**
   * A flag indicating whether conrad is running or not.
   *
   * @type {Boolean}
   */
  var _isRunning = false;

  /**
   * The hash of registered jobs. Each job must at least have a unique ID
   * under the key "id" and a function under the key "job". This hash
   * contains each running job and each waiting job.
   *
   * @type {Object}
   */
  var _jobs = {};

  /**
   * The hash of currently running jobs.
   *
   * @type {Object}
   */
  var _runningJobs = {};

  /**
   * The array of currently running jobs, sorted by priority.
   *
   * @type {Array}
   */
  var _sortedByPriorityJobs = [];

  /**
   * The array of currently waiting jobs.
   *
   * @type {Object}
   */
  var _waitingJobs = {};

  /**
   * The array of finished jobs. They are stored in an array, since two jobs
   * with the same "id" can happen at two different times.
   *
   * @type {Array}
   */
  var _doneJobs = [];

  /**
   * A dirty flag to keep conrad from starting: Indeed, when addJob() is called
   * with several jobs, conrad must be started only at the end. This flag keeps
   * me from duplicating the code that effectively adds a job.
   *
   * @type {Boolean}
   */
  var _noStart = false;

  /**
   * An hash containing some global settings about how conrad.js should
   * behave.
   *
   * @type {Object}
   */
  var _parameters = {
    frameDuration: 20,
    history: true
  };

  /**
   * This object contains every handlers bound to conrad events. It does not
   * requirea any DOM implementation, since the events are all JavaScript.
   *
   * @type {Object}
   */
  var _handlers = Object.create(null);


  /**
   * PRIVATE FUNCTIONS:
   * ******************
   */

  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string|array|object} events  The name of the event (or the events
   *                                       separated by spaces).
   * @param  {function(Object)}    handler The handler to bind.
   * @return {Object}                      Returns conrad.
   */
  function _bind(events, handler) {
    var i,
        i_end,
        event,
        eArray;

    if (!arguments.length)
      return;
    else if (
      arguments.length === 1 &&
      Object(arguments[0]) === arguments[0]
    )
      for (events in arguments[0])
        _bind(events, arguments[0][events]);
    else if (arguments.length > 1) {
      eArray =
        Array.isArray(events) ?
          events :
          events.split(/ /);

      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];

        if (!_handlers[event])
          _handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        _handlers[event].push({
          handler: handler
        });
      }
    }
  }

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(Object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {Object}            Returns conrad.
   */
  function _unbind(events, handler) {
    var i,
        i_end,
        j,
        j_end,
        a,
        event,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    if (!arguments.length)
      _handlers = Object.create(null);
    else if (handler) {
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
        event = eArray[i];
        if (_handlers[event]) {
          a = [];
          for (j = 0, j_end = _handlers[event].length; j !== j_end; j += 1)
            if (_handlers[event][j].handler !== handler)
              a.push(_handlers[event][j]);

          _handlers[event] = a;
        }

        if (_handlers[event] && _handlers[event].length === 0)
          delete _handlers[event];
      }
    } else
      for (i = 0, i_end = eArray.length; i !== i_end; i += 1)
        delete _handlers[eArray[i]];
  }

  /**
   * Executes each handler bound to the event.
   *
   * @param  {string}  events The name of the event (or the events separated
   *                          by spaces).
   * @param  {?Object} data   The content of the event (optional).
   * @return {Object}         Returns conrad.
   */
  function _dispatch(events, data) {
    var i,
        j,
        i_end,
        j_end,
        event,
        eventName,
        eArray = Array.isArray(events) ?
                   events :
                   events.split(/ /);

    data = data === undefined ? {} : data;

    for (i = 0, i_end = eArray.length; i !== i_end; i += 1) {
      eventName = eArray[i];

      if (_handlers[eventName]) {
        event = {
          type: eventName,
          data: data || {}
        };

        for (j = 0, j_end = _handlers[eventName].length; j !== j_end; j += 1)
          try {
            _handlers[eventName][j].handler(event);
          } catch (e) {}
      }
    }
  }

  /**
   * Executes the most prioritary job once, and deals with filling the stats
   * (done, time, averageTime, currentTime, etc...).
   *
   * @return {?Object} Returns the job object if it has to be killed, null else.
   */
  function _executeFirstJob() {
    var i,
        l,
        test,
        kill,
        pushed = false,
        time = __dateNow(),
        job = _sortedByPriorityJobs.shift();

    // Execute the job and look at the result:
    test = job.job();

    // Deal with stats:
    time = __dateNow() - time;
    job.done++;
    job.time += time;
    job.currentTime += time;
    job.weightTime = job.currentTime / (job.weight || 1);
    job.averageTime = job.time / job.done;

    // Check if the job has to be killed:
    kill = job.count ? (job.count <= job.done) : !test;

    // Reset priorities:
    if (!kill) {
      for (i = 0, l = _sortedByPriorityJobs.length; i < l; i++)
        if (_sortedByPriorityJobs[i].weightTime > job.weightTime) {
          _sortedByPriorityJobs.splice(i, 0, job);
          pushed = true;
          break;
        }

      if (!pushed)
        _sortedByPriorityJobs.push(job);
    }

    return kill ? job : null;
  }

  /**
   * Activates a job, by adding it to the _runningJobs object and the
   * _sortedByPriorityJobs array. It also initializes its currentTime value.
   *
   * @param  {Object} job The job to activate.
   */
  function _activateJob(job) {
    var l = _sortedByPriorityJobs.length;

    // Add the job to the running jobs:
    _runningJobs[job.id] = job;
    job.status = 'running';

    // Add the job to the priorities:
    if (l) {
      job.weightTime = _sortedByPriorityJobs[l - 1].weightTime;
      job.currentTime = job.weightTime * (job.weight || 1);
    }

    // Initialize the job and dispatch:
    job.startTime = __dateNow();
    _dispatch('jobStarted', __clone(job));

    _sortedByPriorityJobs.push(job);
  }

  /**
   * The main loop of conrad.js:
   *  . It executes job such that they all occupate the same processing time.
   *  . It stops jobs that do not need to be executed anymore.
   *  . It triggers callbacks when it is relevant.
   *  . It starts waiting jobs when they need to be started.
   *  . It injects frames to keep a constant frapes per second ratio.
   *  . It stops itself when there are no more jobs to execute.
   */
  function _loop() {
    var k,
        o,
        l,
        job,
        time,
        deadJob;

    // Deal with the newly added jobs (the _jobs object):
    for (k in _jobs) {
      job = _jobs[k];

      if (job.after)
        _waitingJobs[k] = job;
      else
        _activateJob(job);

      delete _jobs[k];
    }

    // Set the _isRunning flag to false if there are no running job:
    _isRunning = !!_sortedByPriorityJobs.length;

    // Deal with the running jobs (the _runningJobs object):
    while (
      _sortedByPriorityJobs.length &&
      __dateNow() - _lastFrameTime < _parameters.frameDuration
    ) {
      deadJob = _executeFirstJob();

      // Deal with the case where the job has ended:
      if (deadJob) {
        _killJob(deadJob.id);

        // Check for waiting jobs:
        for (k in _waitingJobs)
          if (_waitingJobs[k].after === deadJob.id) {
            _activateJob(_waitingJobs[k]);
            delete _waitingJobs[k];
          }
      }
    }

    // Check if conrad still has jobs to deal with, and kill it if not:
    if (_isRunning) {
      // Update the _lastFrameTime:
      _lastFrameTime = __dateNow();

      _dispatch('enterFrame');
      setTimeout(_loop, 0);
    } else
      _dispatch('stop');
  }

  /**
   * Adds one or more jobs, and starts the loop if no job was running before. A
   * job is at least a unique string "id" and a function, and there are some
   * parameters that you can specify for each job to modify the way conrad will
   * execute it. If a job is added with the "id" of another job that is waiting
   * or still running, an error will be thrown.
   *
   * When a job is added, it is referenced in the _jobs object, by its id.
   * Then, if it has to be executed right now, it will be also referenced in
   * the _runningJobs object. If it has to wait, then it will be added into the
   * _waitingJobs object, until it can start.
   *
   * Keep reading this documentation to see how to call this method.
   *
   * @return {Object} Returns conrad.
   *
   * Adding one job:
   * ***************
   * Basically, a job is defined by its string id and a function (the job). It
   * is also possible to add some parameters:
   *
   *  > conrad.addJob('myJobId', myJobFunction);
   *  > conrad.addJob('myJobId', {
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *  > conrad.addJob({
   *  >   id: 'myJobId',
   *  >   job: myJobFunction,
   *  >   someParameter: someValue
   *  > });
   *
   * Adding several jobs:
   * ********************
   * When adding several jobs at the same time, it is possible to specify
   * parameters for each one individually or for all:
   *
   *  > conrad.addJob([
   *  >   {
   *  >     id: 'myJobId1',
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   {
   *  >     id: 'myJobId2',
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > ], {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: {,
   *  >     job: myJobFunction1,
   *  >     someParameter1: someValue1
   *  >   },
   *  >   myJobId2: {,
   *  >     job: myJobFunction2,
   *  >     someParameter2: someValue2
   *  >   }
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *  > conrad.addJob({
   *  >   myJobId1: myJobFunction1,
   *  >   myJobId2: myJobFunction2
   *  > }, {
   *  >   someCommonParameter: someCommonValue
   *  > });
   *
   *  Recognized parameters:
   *  **********************
   *  Here is the exhaustive list of every accepted parameters:
   *
   *    {?Function} end      A callback to execute when the job is ended. It is
   *                         not executed if the job is killed instead of ended
   *                         "naturally".
   *    {?Integer}  count    The number of time the job has to be executed.
   *    {?Number}   weight   If specified, the job will be executed as it was
   *                         added "weight" times.
   *    {?String}   after    The id of another job (eventually not added yet).
   *                         If specified, this job will start only when the
   *                         specified "after" job is ended.
   */
  function _addJob(v1, v2) {
    var i,
        l,
        o;

    // Array of jobs:
    if (Array.isArray(v1)) {
      // Keep conrad to start until the last job is added:
      _noStart = true;

      for (i = 0, l = v1.length; i < l; i++)
        _addJob(v1[i].id, __extend(v1[i], v2));

      _noStart = false;
      if (!_isRunning) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }
    } else if (typeof v1 === 'object') {
      // One job (object):
      if (typeof v1.id === 'string')
        _addJob(v1.id, v1);

      // Hash of jobs:
      else {
        // Keep conrad to start until the last job is added:
        _noStart = true;

        for (i in v1)
          if (typeof v1[i] === 'function')
            _addJob(i, __extend({
              job: v1[i]
            }, v2));
          else
            _addJob(i, __extend(v1[i], v2));

        _noStart = false;
        if (!_isRunning) {
          // Update the _lastFrameTime:
          _lastFrameTime = __dateNow();

          _dispatch('start');
          _loop();
        }
      }

    // One job (string, *):
    } else if (typeof v1 === 'string') {
      if (_hasJob(v1))
        throw new Error(
          '[conrad.addJob] Job with id "' + v1 + '" already exists.'
        );

      // One job (string, function):
      if (typeof v2 === 'function') {
        o = {
          id: v1,
          done: 0,
          time: 0,
          status: 'waiting',
          currentTime: 0,
          averageTime: 0,
          weightTime: 0,
          job: v2
        };

      // One job (string, object):
      } else if (typeof v2 === 'object') {
        o = __extend(
          {
            id: v1,
            done: 0,
            time: 0,
            status: 'waiting',
            currentTime: 0,
            averageTime: 0,
            weightTime: 0
          },
          v2
        );

      // If none of those cases, throw an error:
      } else
        throw new Error('[conrad.addJob] Wrong arguments.');

      // Effectively add the job:
      _jobs[v1] = o;
      _dispatch('jobAdded', __clone(o));

      // Check if the loop has to be started:
      if (!_isRunning && !_noStart) {
        // Update the _lastFrameTime:
        _lastFrameTime = __dateNow();

        _dispatch('start');
        _loop();
      }

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.addJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills one or more jobs, indicated by their ids. It is only possible to
   * kill running jobs or waiting jobs. If you try to kill a job that does not
   * exist or that is already killed, a warning will be thrown.
   *
   * @param  {Array|String} v1 A string job id or an array of job ids.
   * @return {Object}       Returns conrad.
   */
  function _killJob(v1) {
    var i,
        l,
        k,
        a,
        job,
        found = false;

    // Array of job ids:
    if (Array.isArray(v1))
      for (i = 0, l = v1.length; i < l; i++)
        _killJob(v1[i]);

    // One job's id:
    else if (typeof v1 === 'string') {
      a = [_runningJobs, _waitingJobs, _jobs];

      // Remove the job from the hashes:
      for (i = 0, l = a.length; i < l; i++)
        if (v1 in a[i]) {
          job = a[i][v1];

          if (_parameters.history) {
            job.status = 'done';
            _doneJobs.push(job);
          }

          _dispatch('jobEnded', __clone(job));
          delete a[i][v1];

          if (typeof job.end === 'function')
            job.end();

          found = true;
        }

      // Remove the priorities array:
      a = _sortedByPriorityJobs;
      for (i = 0, l = a.length; i < l; i++)
        if (a[i].id === v1) {
          a.splice(i, 1);
          break;
        }

      if (!found)
        throw new Error('[conrad.killJob] Job "' + v1 + '" not found.');

    // If none of those cases, throw an error:
    } else
      throw new Error('[conrad.killJob] Wrong arguments.');

    return this;
  }

  /**
   * Kills every running, waiting, and just added jobs.
   *
   * @return {Object} Returns conrad.
   */
  function _killAll() {
    var k,
        jobs = __extend(_jobs, _runningJobs, _waitingJobs);

    // Take every jobs and push them into the _doneJobs object:
    if (_parameters.history)
      for (k in jobs) {
        jobs[k].status = 'done';
        _doneJobs.push(jobs[k]);

        if (typeof jobs[k].end === 'function')
          jobs[k].end();
      }

    // Reinitialize the different jobs lists:
    _jobs = {};
    _waitingJobs = {};
    _runningJobs = {};
    _sortedByPriorityJobs = [];

    // In case some jobs are added right after the kill:
    _isRunning = false;

    return this;
  }

  /**
   * Returns true if a job with the specified id is currently running or
   * waiting, and false else.
   *
   * @param  {String}  id The id of the job.
   * @return {?Object} Returns the job object if it exists.
   */
  function _hasJob(id) {
    var job = _jobs[id] || _runningJobs[id] || _waitingJobs[id];
    return job ? __extend(job) : null;
  }

  /**
   * This method will set the setting specified by "v1" to the value specified
   * by "v2" if both are given, and else return the current value of the
   * settings "v1".
   *
   * @param  {String}   v1 The name of the property.
   * @param  {?*}       v2 Eventually, a value to set to the specified
   *                       property.
   * @return {Object|*} Returns the specified settings value if "v2" is not
   *                    given, and conrad else.
   */
  function _settings(v1, v2) {
    var o;

    if (typeof a1 === 'string' && arguments.length === 1)
      return _parameters[a1];
    else {
      o = (typeof a1 === 'object' && arguments.length === 1) ?
        a1 || {} :
        {};
      if (typeof a1 === 'string')
        o[a1] = a2;

      for (var k in o)
        if (o[k] !== undefined)
          _parameters[k] = o[k];
        else
          delete _parameters[k];

      return this;
    }
  }

  /**
   * Returns true if conrad is currently running, and false else.
   *
   * @return {Boolean} Returns _isRunning.
   */
  function _getIsRunning() {
    return _isRunning;
  }

  /**
   * Unreference every job that is stored in the _doneJobs object. It will
   * not be possible anymore to get stats about these jobs, but it will release
   * the memory.
   *
   * @return {Object} Returns conrad.
   */
  function _clearHistory() {
    _doneJobs = [];
    return this;
  }

  /**
   * Returns a snapshot of every data about jobs that wait to be started, are
   * currently running or are done.
   *
   * It is possible to get only running, waiting or done jobs by giving
   * "running", "waiting" or "done" as fist argument.
   *
   * It is also possible to get every job with a specified id by giving it as
   * first argument. Also, using a RegExp instead of an id will return every
   * jobs whose ids match the RegExp. And these two last use cases work as well
   * by giving before "running", "waiting" or "done".
   *
   * @return {Array} The array of the matching jobs.
   *
   * Some call examples:
   * *******************
   *  > conrad.getStats('running')
   *  > conrad.getStats('waiting')
   *  > conrad.getStats('done')
   *  > conrad.getStats('myJob')
   *  > conrad.getStats(/test/)
   *  > conrad.getStats('running', 'myRunningJob')
   *  > conrad.getStats('running', /test/)
   */
  function _getStats(v1, v2) {
    var a,
        k,
        i,
        l,
        stats,
        pattern,
        isPatternString;

    if (!arguments.length) {
      stats = [];

      for (k in _jobs)
        stats.push(_jobs[k]);

      for (k in _waitingJobs)
        stats.push(_waitingJobs[k]);

      for (k in _runningJobs)
        stats.push(_runningJobs[k]);

      stats = stats.concat(_doneJobs);
    }

    if (typeof v1 === 'string')
      switch (v1) {
        case 'waiting':
          stats = __objectValues(_waitingJobs);
          break;
        case 'running':
          stats = __objectValues(_runningJobs);
          break;
        case 'done':
          stats = _doneJobs;
          break;
        default:
          pattern = v1;
      }

    if (v1 instanceof RegExp)
      pattern = v1;

    if (!pattern && (typeof v2 === 'string' || v2 instanceof RegExp))
      pattern = v2;

    // Filter jobs if a pattern is given:
    if (pattern) {
      isPatternString = typeof pattern === 'string';

      if (stats instanceof Array) {
        a = stats;
      } else if (typeof stats === 'object') {
        a = [];

        for (k in stats)
          a = a.concat(stats[k]);
      } else {
        a = [];

        for (k in _jobs)
          a.push(_jobs[k]);

        for (k in _waitingJobs)
          a.push(_waitingJobs[k]);

        for (k in _runningJobs)
          a.push(_runningJobs[k]);

        a = a.concat(_doneJobs);
      }

      stats = [];
      for (i = 0, l = a.length; i < l; i++)
        if (isPatternString ? a[i].id === pattern : a[i].id.match(pattern))
          stats.push(a[i]);
    }

    return __clone(stats);
  }


  /**
   * TOOLS FUNCTIONS:
   * ****************
   */

  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when two objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > __extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {Object+} Any number of objects.
   * @return {Object}  The merged object.
   */
  function __extend() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  }

  /**
   * This function simply clones an object. This object must contain only
   * objects, arrays and immutable values. Since it is not public, it does not
   * deal with cyclic references, DOM elements and instantiated objects - so
   * use it carefully.
   *
   * @param  {Object} The object to clone.
   * @return {Object} The clone.
   */
  function __clone(item) {
    var result, i, k, l;

    if (!item)
      return item;

    if (Array.isArray(item)) {
      result = [];
      for (i = 0, l = item.length; i < l; i++)
        result.push(__clone(item[i]));
    } else if (typeof item === 'object') {
      result = {};
      for (i in item)
        result[i] = __clone(item[i]);
    } else
      result = item;

    return result;
  }

  /**
   * Returns an array containing the values of an object.
   *
   * @param  {Object} The object.
   * @return {Array}  The array of values.
   */
  function __objectValues(o) {
    var k,
        a = [];

    for (k in o)
      a.push(o[k]);

    return a;
  }

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  function __dateNow() {
    return Date.now ? Date.now() : new Date().getTime();
  }

  /**
   * Polyfill for the Array.isArray function:
   */
  if (!Array.isArray)
    Array.isArray = function(v) {
      return Object.prototype.toString.call(v) === '[object Array]';
    };


  /**
   * EXPORT PUBLIC API:
   * ******************
   */
  var conrad = {
    hasJob: _hasJob,
    addJob: _addJob,
    killJob: _killJob,
    killAll: _killAll,
    settings: _settings,
    getStats: _getStats,
    isRunning: _getIsRunning,
    clearHistory: _clearHistory,

    // Events management:
    bind: _bind,
    unbind: _unbind,

    // Version:
    version: '0.1.0'
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = conrad;
    exports.conrad = conrad;
  }
  global.conrad = conrad;
})(this);

// Hardcoded export for the node.js version:
var sigma = this.sigma,
    conrad = this.conrad;

sigma.conrad = conrad;

// Dirty polyfills to permit sigma usage in node
if (typeof HTMLElement === 'undefined')
  HTMLElement = function() {};

if (typeof window === 'undefined')
  window = {
    addEventListener: function() {}
  };

if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports)
    exports = module.exports = sigma;
  exports.sigma = sigma;
}

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  var _root = this;

  // Initialize packages:
  sigma.utils = sigma.utils || {};

  /**
   * MISC UTILS:
   */
  /**
   * This function takes any number of objects as arguments, copies from each
   * of these objects each pair key/value into a new object, and finally
   * returns this object.
   *
   * The arguments are parsed from the last one to the first one, such that
   * when several objects have keys in common, the "earliest" object wins.
   *
   * Example:
   * ********
   *  > var o1 = {
   *  >       a: 1,
   *  >       b: 2,
   *  >       c: '3'
   *  >     },
   *  >     o2 = {
   *  >       c: '4',
   *  >       d: [ 5 ]
   *  >     };
   *  > sigma.utils.extend(o1, o2);
   *  > // Returns: {
   *  > //   a: 1,
   *  > //   b: 2,
   *  > //   c: '3',
   *  > //   d: [ 5 ]
   *  > // };
   *
   * @param  {object+} Any number of objects.
   * @return {object}  The merged object.
   */
  sigma.utils.extend = function() {
    var i,
        k,
        res = {},
        l = arguments.length;

    for (i = l - 1; i >= 0; i--)
      for (k in arguments[i])
        res[k] = arguments[i][k];

    return res;
  };

  /**
   * A short "Date.now()" polyfill.
   *
   * @return {Number} The current time (in ms).
   */
  sigma.utils.dateNow = function() {
    return Date.now ? Date.now() : new Date().getTime();
  };

  /**
   * Takes a package name as parameter and checks at each lebel if it exists,
   * and if it does not, creates it.
   *
   * Example:
   * ********
   *  > sigma.utils.pkg('a.b.c');
   *  > a.b.c;
   *  > // Object {};
   *  >
   *  > sigma.utils.pkg('a.b.d');
   *  > a.b;
   *  > // Object { c: {}, d: {} };
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.pkg = function(pkgName) {
    return (pkgName || '').split('.').reduce(function(context, objName) {
      return (objName in context) ?
        context[objName] :
        (context[objName] = {});
    }, _root);
  };

  /**
   * Returns a unique incremental number ID.
   *
   * Example:
   * ********
   *  > sigma.utils.id();
   *  > // 1;
   *  >
   *  > sigma.utils.id();
   *  > // 2;
   *  >
   *  > sigma.utils.id();
   *  > // 3;
   *
   * @param  {string} pkgName The name of the package to create/find.
   * @return {object}         The related package.
   */
  sigma.utils.id = (function() {
    var i = 0;
    return function() {
      return ++i;
    };
  })();

  /**
   * This function takes an hexa color (for instance "#ffcc00" or "#fc0") or a
   * rgb / rgba color (like "rgb(255,255,12)" or "rgba(255,255,12,1)") and
   * returns an integer equal to "r * 255 * 255 + g * 255 + b", to gain some
   * memory in the data given to WebGL shaders.
   *
   * Note that the function actually caches its results for better performance.
   *
   * @param  {string} val The hexa or rgba color.
   * @return {number}     The number value.
   */
  var floatColorCache = {};

  sigma.utils.floatColor = function(val) {

    // Is the color already computed?
    if (floatColorCache[val])
      return floatColorCache[val];

    var original = val,
        r = 0,
        g = 0,
        b = 0;

    if (val[0] === '#') {
      val = val.slice(1);

      if (val.length === 3) {
        r = parseInt(val.charAt(0) + val.charAt(0), 16);
        g = parseInt(val.charAt(1) + val.charAt(1), 16);
        b = parseInt(val.charAt(2) + val.charAt(2), 16);
      }
      else {
        r = parseInt(val.charAt(0) + val.charAt(1), 16);
        g = parseInt(val.charAt(2) + val.charAt(3), 16);
        b = parseInt(val.charAt(4) + val.charAt(5), 16);
      }
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      r = +val[1];
      g = +val[2];
      b = +val[3];
    }

    var color = (
      r * 256 * 256 +
      g * 256 +
      b
    );

    // Caching the color
    floatColorCache[original] = color;

    return color;
  };

    /**
   * Perform a zoom into a camera, with or without animation, to the
   * coordinates indicated using a specified ratio.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the animation
   * object:
   *
   *   {?number} duration     An amount of time that means the duration of the
   *                          animation. If this parameter doesn't exist the
   *                          zoom will be performed without animation.
   *   {?function} onComplete A function to perform it after the animation. It
   *                          will be performed even if there is no duration.
   *
   * @param {camera}     The camera where perform the zoom.
   * @param {x}          The X coordiantion where the zoom goes.
   * @param {y}          The Y coordiantion where the zoom goes.
   * @param {ratio}      The ratio to apply it to the current camera ratio.
   * @param {?animation} A dictionary with options for a possible animation.
   */
  sigma.utils.zoomTo = function(camera, x, y, ratio, animation) {
    var settings = camera.settings,
        count,
        newRatio,
        animationSettings,
        coordinates;

    // Create the newRatio dealing with min / max:
    newRatio = Math.max(
      settings('zoomMin'),
      Math.min(
        settings('zoomMax'),
        camera.ratio * ratio
      )
    );

    // Check that the new ratio is different from the initial one:
    if (newRatio !== camera.ratio) {
      // Create the coordinates variable:
      ratio = newRatio / camera.ratio;
      coordinates = {
        x: x * (1 - ratio) + camera.x,
        y: y * (1 - ratio) + camera.y,
        ratio: newRatio
      };

      if (animation && animation.duration) {
        // Complete the animation setings:
        count = sigma.misc.animation.killAll(camera);
        animation = sigma.utils.extend(
          animation,
          {
            easing: count ? 'quadraticOut' : 'quadraticInOut'
          }
        );

        sigma.misc.animation.camera(camera, coordinates, animation);
      } else {
        camera.goTo(coordinates);
        if (animation && animation.onComplete)
          animation.onComplete();
      }
    }
  };

  /**
   * Return the control point coordinates for a quadratic bezier curve.
   *
   * @param  {number} x1  The X coordinate of the start point.
   * @param  {number} y1  The Y coordinate of the start point.
   * @param  {number} x2  The X coordinate of the end point.
   * @param  {number} y2  The Y coordinate of the end point.
   * @return {x,y}        The control point coordinates.
   */
  sigma.utils.getQuadraticControlPoint = function(x1, y1, x2, y2) {
    return {
      x: (x1 + x2) / 2 + (y2 - y1) / 4,
      y: (y1 + y2) / 2 + (x1 - x2) / 4
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the quadratic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the ending point.
    * @param  {number} y2 The Y coordinate of the ending point.
    * @param  {number} xi The X coordinate of the control point.
    * @param  {number} yi The Y coordinate of the control point.
    * @return {object}    {x,y}.
  */
  sigma.utils.getPointOnQuadraticCurve = function(t, x1, y1, x2, y2, xi, yi) {
    // http://stackoverflow.com/a/5634528
    return {
      x: Math.pow(1 - t, 2) * x1 + 2 * (1 - t) * t * xi + Math.pow(t, 2) * x2,
      y: Math.pow(1 - t, 2) * y1 + 2 * (1 - t) * t * yi + Math.pow(t, 2) * y2
    };
  };

  /**
    * Compute the coordinates of the point positioned
    * at length t in the cubic bezier curve.
    *
    * @param  {number} t  In [0,1] the step percentage to reach
    *                     the point in the curve from the context point.
    * @param  {number} x1 The X coordinate of the context point.
    * @param  {number} y1 The Y coordinate of the context point.
    * @param  {number} x2 The X coordinate of the end point.
    * @param  {number} y2 The Y coordinate of the end point.
    * @param  {number} cx The X coordinate of the first control point.
    * @param  {number} cy The Y coordinate of the first control point.
    * @param  {number} dx The X coordinate of the second control point.
    * @param  {number} dy The Y coordinate of the second control point.
    * @return {object}    {x,y} The point at t.
  */
  sigma.utils.getPointOnBezierCurve =
    function(t, x1, y1, x2, y2, cx, cy, dx, dy) {
    // http://stackoverflow.com/a/15397596
    // Blending functions:
    var B0_t = Math.pow(1 - t, 3),
        B1_t = 3 * t * Math.pow(1 - t, 2),
        B2_t = 3 * Math.pow(t, 2) * (1 - t),
        B3_t = Math.pow(t, 3);

    return {
      x: (B0_t * x1) + (B1_t * cx) + (B2_t * dx) + (B3_t * x2),
      y: (B0_t * y1) + (B1_t * cy) + (B2_t * dy) + (B3_t * y2)
    };
  };

  /**
   * Return the coordinates of the two control points for a self loop (i.e.
   * where the start point is also the end point) computed as a cubic bezier
   * curve.
   *
   * @param  {number} x    The X coordinate of the node.
   * @param  {number} y    The Y coordinate of the node.
   * @param  {number} size The node size.
   * @return {x1,y1,x2,y2} The coordinates of the two control points.
   */
  sigma.utils.getSelfLoopControlPoints = function(x , y, size) {
    return {
      x1: x - size * 7,
      y1: y,
      x2: x,
      y2: y + size * 7
    };
  };

  /**
   * Return the euclidian distance between two points of a plane
   * with an orthonormal basis.
   *
   * @param  {number} x1  The X coordinate of the first point.
   * @param  {number} y1  The Y coordinate of the first point.
   * @param  {number} x2  The X coordinate of the second point.
   * @param  {number} y2  The Y coordinate of the second point.
   * @return {number}     The euclidian distance.
   */
  sigma.utils.getDistance = function(x0, y0, x1, y1) {
    return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
  };

  /**
   * Return the coordinates of the intersection points of two circles.
   *
   * @param  {number} x0  The X coordinate of center location of the first
   *                      circle.
   * @param  {number} y0  The Y coordinate of center location of the first
   *                      circle.
   * @param  {number} r0  The radius of the first circle.
   * @param  {number} x1  The X coordinate of center location of the second
   *                      circle.
   * @param  {number} y1  The Y coordinate of center location of the second
   *                      circle.
   * @param  {number} r1  The radius of the second circle.
   * @return {xi,yi}      The coordinates of the intersection points.
   */
  sigma.utils.getCircleIntersection = function(x0, y0, r0, x1, y1, r1) {
    // http://stackoverflow.com/a/12219802
    var a, dx, dy, d, h, rx, ry, x2, y2;

    // dx and dy are the vertical and horizontal distances between the circle
    // centers:
    dx = x1 - x0;
    dy = y1 - y0;

    // Determine the straight-line distance between the centers:
    d = Math.sqrt((dy * dy) + (dx * dx));

    // Check for solvability:
    if (d > (r0 + r1)) {
        // No solution. circles do not intersect.
        return false;
    }
    if (d < Math.abs(r0 - r1)) {
        // No solution. one circle is contained in the other.
        return false;
    }

    //'point 2' is the point where the line through the circle intersection
    // points crosses the line between the circle centers.

    // Determine the distance from point 0 to point 2:
    a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

    // Determine the coordinates of point 2:
    x2 = x0 + (dx * a / d);
    y2 = y0 + (dy * a / d);

    // Determine the distance from point 2 to either of the intersection
    // points:
    h = Math.sqrt((r0 * r0) - (a * a));

    // Determine the offsets of the intersection points from point 2:
    rx = -dy * (h / d);
    ry = dx * (h / d);

    // Determine the absolute intersection points:
    var xi = x2 + rx;
    var xi_prime = x2 - rx;
    var yi = y2 + ry;
    var yi_prime = y2 - ry;

    return {xi: xi, xi_prime: xi_prime, yi: yi, yi_prime: yi_prime};
  };

  /**
    * Check if a point is on a line segment.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the line start point.
    * @param  {number} y1      The Y coordinate of the line start point.
    * @param  {number} x2      The X coordinate of the line end point.
    * @param  {number} y2      The Y coordinate of the line end point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if point is "close to" the line
    *                          segment, false otherwise.
  */
  sigma.utils.isPointOnSegment = function(x, y, x1, y1, x2, y2, epsilon) {
    // http://stackoverflow.com/a/328122
    var crossProduct = Math.abs((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)),
        d = sigma.utils.getDistance(x1, y1, x2, y2),
        nCrossProduct = crossProduct / d; // normalized cross product

    return (nCrossProduct < epsilon &&
     Math.min(x1, x2) <= x && x <= Math.max(x1, x2) &&
     Math.min(y1, y2) <= y && y <= Math.max(y1, y2));
  };

  /**
    * Check if a point is on a quadratic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx     The X coordinate of the curve control point.
    * @param  {number} cpy     The Y coordinate of the curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnQuadraticCurve =
    function(x, y, x1, y1, x2, y2, cpx, cpy, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1P2 = sigma.utils.getDistance(x1, y1, x2, y2);
    if (Math.abs(x - x1) > dP1P2 || Math.abs(y - y1) > dP1P2) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnQuadraticCurve(t, x1, y1, x2, y2, cpx, cpy);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
    * Check if a point is on a cubic bezier curve segment with a thickness.
    *
    * @param  {number} x       The X coordinate of the point to check.
    * @param  {number} y       The Y coordinate of the point to check.
    * @param  {number} x1      The X coordinate of the curve start point.
    * @param  {number} y1      The Y coordinate of the curve start point.
    * @param  {number} x2      The X coordinate of the curve end point.
    * @param  {number} y2      The Y coordinate of the curve end point.
    * @param  {number} cpx1    The X coordinate of the 1st curve control point.
    * @param  {number} cpy1    The Y coordinate of the 1st curve control point.
    * @param  {number} cpx2    The X coordinate of the 2nd curve control point.
    * @param  {number} cpy2    The Y coordinate of the 2nd curve control point.
    * @param  {number} epsilon The precision (consider the line thickness).
    * @return {boolean}        True if (x,y) is on the curve segment,
    *                          false otherwise.
  */
  sigma.utils.isPointOnBezierCurve =
    function(x, y, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2, epsilon) {
    // Fails if the point is too far from the extremities of the segment,
    // preventing for more costly computation:
    var dP1CP1 = sigma.utils.getDistance(x1, y1, cpx1, cpy1);
    if (Math.abs(x - x1) > dP1CP1 || Math.abs(y - y1) > dP1CP1) {
      return false;
    }

    var dP1 = sigma.utils.getDistance(x, y, x1, y1),
        dP2 = sigma.utils.getDistance(x, y, x2, y2),
        t = 0.5,
        r = (dP1 < dP2) ? -0.01 : 0.01,
        rThreshold = 0.001,
        i = 100,
        pt = sigma.utils.getPointOnBezierCurve(
          t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2),
        dt = sigma.utils.getDistance(x, y, pt.x, pt.y),
        old_dt;

    // This algorithm minimizes the distance from the point to the curve. It
    // find the optimal t value where t=0 is the start point and t=1 is the end
    // point of the curve, starting from t=0.5.
    // It terminates because it runs a maximum of i interations.
    while (i-- > 0 &&
      t >= 0 && t <= 1 &&
      (dt > epsilon) &&
      (r > rThreshold || r < -rThreshold)) {
      old_dt = dt;
      pt = sigma.utils.getPointOnBezierCurve(
        t, x1, y1, x2, y2, cpx1, cpy1, cpx2, cpy2);
      dt = sigma.utils.getDistance(x, y, pt.x, pt.y);

      if (dt > old_dt) {
        // not the right direction:
        // halfstep in the opposite direction
        r = -r / 2;
        t += r;
      }
      else if (t + r < 0 || t + r > 1) {
        // oops, we've gone too far:
        // revert with a halfstep
        r = r / 2;
        dt = old_dt;
      }
      else {
        // progress:
        t += r;
      }
    }

    return dt < epsilon;
  };


  /**
   * ************
   * EVENTS UTILS:
   * ************
   */
  /**
   * Here are some useful functions to unify extraction of the information we
   * need with mouse events and touch events, from different browsers:
   */

  /**
   * Extract the local X position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local X value of the mouse.
   */
  sigma.utils.getX = function(e) {
    return (
      (e.offsetX !== undefined && e.offsetX) ||
      (e.layerX !== undefined && e.layerX) ||
      (e.clientX !== undefined && e.clientX)
    );
  };

  /**
   * Extract the local Y position from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The local Y value of the mouse.
   */
  sigma.utils.getY = function(e) {
    return (
      (e.offsetY !== undefined && e.offsetY) ||
      (e.layerY !== undefined && e.layerY) ||
      (e.clientY !== undefined && e.clientY)
    );
  };

  /**
   * The pixel ratio of the screen. Taking zoom into account
   *
   * @return {number}        Pixel ratio of the screen
   */
  sigma.utils.getPixelRatio = function() {
    var ratio = 1;
    if (window.screen.deviceXDPI !== undefined &&
         window.screen.logicalXDPI !== undefined &&
         window.screen.deviceXDPI > window.screen.logicalXDPI) {
        ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    else if (window.devicePixelRatio !== undefined) {
        ratio = window.devicePixelRatio;
    }
    return ratio;
  };

  /**
   * Extract the width from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The width of the event's target.
   */
  sigma.utils.getWidth = function(e) {
    var w = (!e.target.ownerSVGElement) ?
              e.target.width :
              e.target.ownerSVGElement.width;

    return (
      (typeof w === 'number' && w) ||
      (w !== undefined && w.baseVal !== undefined && w.baseVal.value)
    );
  };

  /**
   * Extract the center from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {object}   The center of the event's target.
   */
  sigma.utils.getCenter = function(e) {
    var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 :
        sigma.utils.getPixelRatio();
    return {
      x: sigma.utils.getWidth(e) / (2 * ratio),
      y: sigma.utils.getHeight(e) / (2 * ratio)
    };
  };

  /**
   * Convert mouse coords to sigma coords
   *
   * @param  {event}   e A mouse or touch event.
   * @param  {number?} x The x coord to convert
   * @param  {number?} x The y coord to convert
   *
   * @return {object}    The standardized event
   */
  sigma.utils.mouseCoords = function(e, x, y) {
    x = x || sigma.utils.getX(e);
    y = y || sigma.utils.getY(e);
    return {
        x: x - sigma.utils.getCenter(e).x,
        y: y - sigma.utils.getCenter(e).y,
        clientX: e.clientX,
        clientY: e.clientY,
        ctrlKey: e.ctrlKey,
        metaKey: e.metaKey,
        altKey: e.altKey,
        shiftKey: e.shiftKey
    };
  };

  /**
   * Extract the height from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The height of the event's target.
   */
  sigma.utils.getHeight = function(e) {
    var h = (!e.target.ownerSVGElement) ?
              e.target.height :
              e.target.ownerSVGElement.height;

    return (
      (typeof h === 'number' && h) ||
      (h !== undefined && h.baseVal !== undefined && h.baseVal.value)
    );
  };

  /**
   * Extract the wheel delta from a mouse or touch event.
   *
   * @param  {event}  e A mouse or touch event.
   * @return {number}   The wheel delta of the mouse.
   */
  sigma.utils.getDelta = function(e) {
    return (
      (e.wheelDelta !== undefined && e.wheelDelta) ||
      (e.detail !== undefined && -e.detail)
    );
  };

  /**
   * Returns the offset of a DOM element.
   *
   * @param  {DOMElement} dom The element to retrieve the position.
   * @return {object}         The offset of the DOM element (top, left).
   */
  sigma.utils.getOffset = function(dom) {
    var left = 0,
        top = 0;

    while (dom) {
      top = top + parseInt(dom.offsetTop);
      left = left + parseInt(dom.offsetLeft);
      dom = dom.offsetParent;
    }

    return {
      top: top,
      left: left
    };
  };

  /**
   * Simulates a "double click" event.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   * @param  {function}    callback The callback to execute.
   */
  sigma.utils.doubleClick = function(target, type, callback) {
    var clicks = 0,
        self = this,
        handlers;

    target._doubleClickHandler = target._doubleClickHandler || {};
    target._doubleClickHandler[type] = target._doubleClickHandler[type] || [];
    handlers = target._doubleClickHandler[type];

    handlers.push(function(e) {
      clicks++;

      if (clicks === 2) {
        clicks = 0;
        return callback(e);
      } else if (clicks === 1) {
        setTimeout(function() {
          clicks = 0;
        }, sigma.settings.doubleClickTimeout);
      }
    });

    target.addEventListener(type, handlers[handlers.length - 1], false);
  };

  /**
   * Unbind simulated "double click" events.
   *
   * @param  {HTMLElement} target   The event target.
   * @param  {string}      type     The event type.
   */
  sigma.utils.unbindDoubleClick = function(target, type) {
    var handler,
        handlers = (target._doubleClickHandler || {})[type] || [];

    while ((handler = handlers.pop())) {
      target.removeEventListener(type, handler);
    }

    delete (target._doubleClickHandler || {})[type];
  };




  /**
   * Here are just some of the most basic easing functions, used for the
   * animated camera "goTo" calls.
   *
   * If you need some more easings functions, don't hesitate to add them to
   * sigma.utils.easings. But I will not add some more here or merge PRs
   * containing, because I do not want sigma sources full of overkill and never
   * used stuff...
   */
  sigma.utils.easings = sigma.utils.easings || {};
  sigma.utils.easings.linearNone = function(k) {
    return k;
  };
  sigma.utils.easings.quadraticIn = function(k) {
    return k * k;
  };
  sigma.utils.easings.quadraticOut = function(k) {
    return k * (2 - k);
  };
  sigma.utils.easings.quadraticInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k;
    return - 0.5 * (--k * (k - 2) - 1);
  };
  sigma.utils.easings.cubicIn = function(k) {
    return k * k * k;
  };
  sigma.utils.easings.cubicOut = function(k) {
    return --k * k * k + 1;
  };
  sigma.utils.easings.cubicInOut = function(k) {
    if ((k *= 2) < 1)
      return 0.5 * k * k * k;
    return 0.5 * ((k -= 2) * k * k + 2);
  };




  /**
   * ************
   * WEBGL UTILS:
   * ************
   */
  /**
   * Loads a WebGL shader and returns it.
   *
   * @param  {WebGLContext}           gl           The WebGLContext to use.
   * @param  {string}                 shaderSource The shader source.
   * @param  {number}                 shaderType   The type of shader.
   * @param  {function(string): void} error        Callback for errors.
   * @return {WebGLShader}                         The created shader.
   */
  sigma.utils.loadShader = function(gl, shaderSource, shaderType, error) {
    var compiled,
        shader = gl.createShader(shaderType);

    // Load the shader source
    gl.shaderSource(shader, shaderSource);

    // Compile the shader
    gl.compileShader(shader);

    // Check the compile status
    compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    // If something went wrong:
    if (!compiled) {
      if (error) {
        error(
          'Error compiling shader "' + shader + '":' +
          gl.getShaderInfoLog(shader)
        );
      }

      gl.deleteShader(shader);
      return null;
    }

    return shader;
  };

  /**
   * Creates a program, attaches shaders, binds attrib locations, links the
   * program and calls useProgram.
   *
   * @param  {Array.<WebGLShader>}    shaders   The shaders to attach.
   * @param  {Array.<string>}         attribs   The attribs names.
   * @param  {Array.<number>}         locations The locations for the attribs.
   * @param  {function(string): void} error     Callback for errors.
   * @return {WebGLProgram}                     The created program.
   */
  sigma.utils.loadProgram = function(gl, shaders, attribs, loc, error) {
    var i,
        linked,
        program = gl.createProgram();

    for (i = 0; i < shaders.length; ++i)
      gl.attachShader(program, shaders[i]);

    if (attribs)
      for (i = 0; i < attribs.length; ++i)
        gl.bindAttribLocation(
          program,
          locations ? locations[i] : i,
          opt_attribs[i]
        );

    gl.linkProgram(program);

    // Check the link status
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      if (error)
        error('Error in program linking: ' + gl.getProgramInfoLog(program));

      gl.deleteProgram(program);
      return null;
    }

    return program;
  };




  /**
   * *********
   * MATRICES:
   * *********
   * The following utils are just here to help generating the transformation
   * matrices for the WebGL renderers.
   */
  sigma.utils.pkg('sigma.utils.matrices');

  /**
   * The returns a 3x3 translation matrix.
   *
   * @param  {number} dx The X translation.
   * @param  {number} dy The Y translation.
   * @return {array}     Returns the matrix.
   */
  sigma.utils.matrices.translation = function(dx, dy) {
    return [
      1, 0, 0,
      0, 1, 0,
      dx, dy, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 rotation matrix.
   *
   * @param  {number}  angle The rotation angle.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.rotation = function(angle, m2) {
    var cos = Math.cos(angle),
        sin = Math.sin(angle);

    return m2 ? [
      cos, -sin,
      sin, cos
    ] : [
      cos, -sin, 0,
      sin, cos, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {number}  ratio The scaling ratio.
   * @param  {boolean} m2    If true, the function will return a 2x2 matrix.
   * @return {array}         Returns the matrix.
   */
  sigma.utils.matrices.scale = function(ratio, m2) {
    return m2 ? [
      ratio, 0,
      0, ratio
    ] : [
      ratio, 0, 0,
      0, ratio, 0,
      0, 0, 1
    ];
  };

  /**
   * The returns a 3x3 or 2x2 homothetic transformation matrix.
   *
   * @param  {array}   a  The first matrix.
   * @param  {array}   b  The second matrix.
   * @param  {boolean} m2 If true, the function will assume both matrices are
   *                      2x2.
   * @return {array}      Returns the matrix.
   */
  sigma.utils.matrices.multiply = function(a, b, m2) {
    var l = m2 ? 2 : 3,
        a00 = a[0 * l + 0],
        a01 = a[0 * l + 1],
        a02 = a[0 * l + 2],
        a10 = a[1 * l + 0],
        a11 = a[1 * l + 1],
        a12 = a[1 * l + 2],
        a20 = a[2 * l + 0],
        a21 = a[2 * l + 1],
        a22 = a[2 * l + 2],
        b00 = b[0 * l + 0],
        b01 = b[0 * l + 1],
        b02 = b[0 * l + 2],
        b10 = b[1 * l + 0],
        b11 = b[1 * l + 1],
        b12 = b[1 * l + 2],
        b20 = b[2 * l + 0],
        b21 = b[2 * l + 1],
        b22 = b[2 * l + 2];

    return m2 ? [
      a00 * b00 + a01 * b10,
      a00 * b01 + a01 * b11,
      a10 * b00 + a11 * b10,
      a10 * b01 + a11 * b11
    ] : [
      a00 * b00 + a01 * b10 + a02 * b20,
      a00 * b01 + a01 * b11 + a02 * b21,
      a00 * b02 + a01 * b12 + a02 * b22,
      a10 * b00 + a11 * b10 + a12 * b20,
      a10 * b01 + a11 * b11 + a12 * b21,
      a10 * b02 + a11 * b12 + a12 * b22,
      a20 * b00 + a21 * b10 + a22 * b20,
      a20 * b01 + a21 * b11 + a22 * b21,
      a20 * b02 + a21 * b12 + a22 * b22
    ];
  };
}).call(this);

;(function(global) {
  'use strict';

  /**
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * requestAnimationFrame polyfill by Erik MÃ¶ller.
   * fixes from Paul Irish and Tino Zijdel
   * MIT license
   */
  var x,
      lastTime = 0,
      vendors = ['ms', 'moz', 'webkit', 'o'];

  for (x = 0; x < vendors.length && !global.requestAnimationFrame; x++) {
    global.requestAnimationFrame =
      global[vendors[x] + 'RequestAnimationFrame'];
    global.cancelAnimationFrame =
      global[vendors[x] + 'CancelAnimationFrame'] ||
      global[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!global.requestAnimationFrame)
    global.requestAnimationFrame = function(callback, element) {
      var currTime = new Date().getTime(),
          timeToCall = Math.max(0, 16 - (currTime - lastTime)),
          id = global.setTimeout(
            function() {
              callback(currTime + timeToCall);
            },
            timeToCall
          );

      lastTime = currTime + timeToCall;
      return id;
    };

  if (!global.cancelAnimationFrame)
    global.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };

  /**
   * Function.prototype.bind polyfill found on MDN.
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
   * Public domain
   */
  if (!Function.prototype.bind)
    Function.prototype.bind = function(oThis) {
      if (typeof this !== 'function')
        // Closest thing possible to the ECMAScript 5 internal IsCallable
        // function:
        throw new TypeError(
          'Function.prototype.bind - what is trying to be bound is not callable'
        );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP,
          fBound;

      fNOP = function() {};
      fBound = function() {
        return fToBind.apply(
          this instanceof fNOP && oThis ?
            this :
            oThis,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
})(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Packages initialization:
  sigma.utils.pkg('sigma.settings');

  var settings = {
    /**
     * GRAPH SETTINGS:
     * ***************
     */
    // {boolean} Indicates if the data have to be cloned in methods to add
    //           nodes or edges.
    clone: true,
    // {boolean} Indicates if nodes "id" values and edges "id", "source" and
    //           "target" values must be set as immutable.
    immutable: true,
    // {boolean} Indicates if sigma can log its errors and warnings.
    verbose: false,


    /**
     * RENDERERS SETTINGS:
     * *******************
     */
    // {string}
    classPrefix: 'sigma',
    // {string}
    defaultNodeType: 'def',
    // {string}
    defaultEdgeType: 'def',
    // {string}
    defaultLabelColor: '#000',
    // {string}
    defaultEdgeColor: '#000',
    // {string}
    defaultNodeColor: '#000',
    // {string}
    defaultLabelSize: 14,
    // {string} Indicates how to choose the edges color. Available values:
    //          "source", "target", "default"
    edgeColor: 'source',
    // {number} Defines the minimal edge's arrow display size.
    minArrowSize: 0,
    // {string}
    font: 'arial',
    // {string} Example: 'bold'
    fontStyle: '',
    // {string} Indicates how to choose the labels color. Available values:
    //          "node", "default"
    labelColor: 'default',
    // {string} Indicates how to choose the labels size. Available values:
    //          "fixed", "proportional"
    labelSize: 'fixed',
    // {string} The ratio between the font size of the label and the node size.
    labelSizeRatio: 1,
    // {number} The minimum size a node must have to see its label displayed.
    labelThreshold: 8,
    // {number} The oversampling factor used in WebGL renderer.
    webglOversamplingRatio: 2,
    // {number} The size of the border of hovered nodes.
    borderSize: 0,
    // {number} The default hovered node border's color.
    defaultNodeBorderColor: '#000',
    // {number} The hovered node's label font. If not specified, will heritate
    //          the "font" value.
    hoverFont: '',
    // {boolean} If true, then only one node can be hovered at a time.
    singleHover: true,
    // {string} Example: 'bold'
    hoverFontStyle: '',
    // {string} Indicates how to choose the hovered nodes shadow color.
    //          Available values: "node", "default"
    labelHoverShadow: 'default',
    // {string}
    labelHoverShadowColor: '#000',
    // {string} Indicates how to choose the hovered nodes color.
    //          Available values: "node", "default"
    nodeHoverColor: 'node',
    // {string}
    defaultNodeHoverColor: '#000',
    // {string} Indicates how to choose the hovered nodes background color.
    //          Available values: "node", "default"
    labelHoverBGColor: 'default',
    // {string}
    defaultHoverLabelBGColor: '#fff',
    // {string} Indicates how to choose the hovered labels color.
    //          Available values: "node", "default"
    labelHoverColor: 'default',
    // {string}
    defaultLabelHoverColor: '#000',
    // {string} Indicates how to choose the edges hover color. Available values:
    //          "edge", "default"
    edgeHoverColor: 'edge',
    // {number} The size multiplicator of hovered edges.
    edgeHoverSizeRatio: 1,
    // {string}
    defaultEdgeHoverColor: '#000',
    // {boolean} Indicates if the edge extremities must be hovered when the
    //           edge is hovered.
    edgeHoverExtremities: false,
    // {booleans} The different drawing modes:
    //           false: Layered not displayed.
    //           true: Layered displayed.
    drawEdges: true,
    drawNodes: true,
    drawLabels: true,
    drawEdgeLabels: false,
    // {boolean} Indicates if the edges must be drawn in several frames or in
    //           one frame, as the nodes and labels are drawn.
    batchEdgesDrawing: false,
    // {boolean} Indicates if the edges must be hidden during dragging and
    //           animations.
    hideEdgesOnMove: false,
    // {numbers} The different batch sizes, when elements are displayed in
    //           several frames.
    canvasEdgesBatchSize: 500,
    webglEdgesBatchSize: 1000,




    /**
     * RESCALE SETTINGS:
     * *****************
     */
    // {string} Indicates of to scale the graph relatively to its container.
    //          Available values: "inside", "outside"
    scalingMode: 'inside',
    // {number} The margin to keep around the graph.
    sideMargin: 0,
    // {number} Determine the size of the smallest and the biggest node / edges
    //          on the screen. This mapping makes easier to display the graph,
    //          avoiding too big nodes that take half of the screen, or too
    //          small ones that are not readable. If the two parameters are
    //          equals, then the minimal display size will be 0. And if they
    //          are both equal to 0, then there is no mapping, and the radius
    //          of the nodes will be their size.
    minEdgeSize: 0.5,
    maxEdgeSize: 1,
    minNodeSize: 1,
    maxNodeSize: 8,




    /**
     * CAPTORS SETTINGS:
     * *****************
     */
    // {boolean}
    touchEnabled: true,
    // {boolean}
    mouseEnabled: true,
    // {boolean}
    mouseWheelEnabled: true,
    // {boolean}
    doubleClickEnabled: true,
    // {boolean} Defines whether the custom events such as "clickNode" can be
    //           used.
    eventsEnabled: true,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms with the mouse-wheel.
    zoomingRatio: 1.7,
    // {number} Defines by how much multiplicating the zooming level when the
    //          user zooms by double clicking.
    doubleClickZoomingRatio: 2.2,
    // {number} The minimum zooming level.
    zoomMin: 0.0625,
    // {number} The maximum zooming level.
    zoomMax: 2,
    // {number} The duration of animations following a mouse scrolling.
    mouseZoomDuration: 200,
    // {number} The duration of animations following a mouse double click.
    doubleClickZoomDuration: 200,
    // {number} The duration of animations following a mouse dropping.
    mouseInertiaDuration: 200,
    // {number} The inertia power (mouse captor).
    mouseInertiaRatio: 3,
    // {number} The duration of animations following a touch dropping.
    touchInertiaDuration: 200,
    // {number} The inertia power (touch captor).
    touchInertiaRatio: 3,
    // {number} The maximum time between two clicks to make it a double click.
    doubleClickTimeout: 300,
    // {number} The maximum time between two taps to make it a double tap.
    doubleTapTimeout: 300,
    // {number} The maximum time of dragging to trigger intertia.
    dragTimeout: 200,




    /**
     * GLOBAL SETTINGS:
     * ****************
     */
    // {boolean} Determines whether the instance has to refresh itself
    //           automatically when a "resize" event is dispatched from the
    //           window object.
    autoResize: true,
    // {boolean} Determines whether the "rescale" middleware has to be called
    //           automatically for each camera on refresh.
    autoRescale: true,
    // {boolean} If set to false, the camera method "goTo" will basically do
    //           nothing.
    enableCamera: true,
    // {boolean} If set to false, the nodes cannot be hovered.
    enableHovering: true,
    // {boolean} If set to true, the edges can be hovered.
    enableEdgeHovering: false,
    // {number} The size of the area around the edges to activate hovering.
    edgeHoverPrecision: 5,
    // {boolean} If set to true, the rescale middleware will ignore node sizes
    //           to determine the graphs boundings.
    rescaleIgnoreSize: false,
    // {boolean} Determines if the core has to try to catch errors on
    //           rendering.
    skipErrors: false,




    /**
     * CAMERA SETTINGS:
     * ****************
     */
    // {number} The power degrees applied to the nodes/edges size relatively to
    //          the zooming level. Basically:
    //           > onScreenR = Math.pow(zoom, nodesPowRatio) * R
    //           > onScreenT = Math.pow(zoom, edgesPowRatio) * T
    nodesPowRatio: 0.5,
    edgesPowRatio: 0.5,




    /**
     * ANIMATIONS SETTINGS:
     * ********************
     */
    // {number} The default animation time.
    animationsTime: 200
  };

  // Export the previously designed settings:
  sigma.settings = sigma.utils.extend(sigma.settings || {}, settings);
}).call(this);

;(function() {
  'use strict';

  /**
   * Dispatcher constructor.
   *
   * @return {dispatcher} The new dispatcher instance.
   */
  var dispatcher = function() {
    Object.defineProperty(this, '_handlers', {
      value: {}
    });
  };




  /**
   * Will execute the handler everytime that the indicated event (or the
   * indicated events) will be triggered.
   *
   * @param  {string}           events  The name of the event (or the events
   *                                    separated by spaces).
   * @param  {function(Object)} handler The handler to bind.
   * @return {dispatcher}               Returns the instance itself.
   */
  dispatcher.prototype.bind = function(events, handler) {
    var i,
        l,
        event,
        eArray;

    if (
      arguments.length === 1 &&
      typeof arguments[0] === 'object'
    )
      for (events in arguments[0])
        this.bind(events, arguments[0][events]);
    else if (
      arguments.length === 2 &&
      typeof arguments[1] === 'function'
    ) {
      eArray = typeof events === 'string' ? events.split(' ') : events;

      for (i = 0, l = eArray.length; i !== l; i += 1) {
        event = eArray[i];

        // Check that event is not '':
        if (!event)
          continue;

        if (!this._handlers[event])
          this._handlers[event] = [];

        // Using an object instead of directly the handler will make possible
        // later to add flags
        this._handlers[event].push({
          handler: handler
        });
      }
    } else
      throw 'bind: Wrong arguments.';

    return this;
  };

  /**
   * Removes the handler from a specified event (or specified events).
   *
   * @param  {?string}           events  The name of the event (or the events
   *                                     separated by spaces). If undefined,
   *                                     then all handlers are removed.
   * @param  {?function(object)} handler The handler to unbind. If undefined,
   *                                     each handler bound to the event or the
   *                                     events will be removed.
   * @return {dispatcher}                Returns the instance itself.
   */
  dispatcher.prototype.unbind = function(events, handler) {
    var i,
        n,
        j,
        m,
        k,
        a,
        event,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    if (!arguments.length) {
      for (k in this._handlers)
        delete this._handlers[k];
      return this;
    }

    if (handler) {
      for (i = 0, n = eArray.length; i !== n; i += 1) {
        event = eArray[i];
        if (this._handlers[event]) {
          a = [];
          for (j = 0, m = this._handlers[event].length; j !== m; j += 1)
            if (this._handlers[event][j].handler !== handler)
              a.push(this._handlers[event][j]);

          this._handlers[event] = a;
        }

        if (this._handlers[event] && this._handlers[event].length === 0)
          delete this._handlers[event];
      }
    } else
      for (i = 0, n = eArray.length; i !== n; i += 1)
        delete this._handlers[eArray[i]];

    return this;
  };

  /**
   * Executes each handler bound to the event
   *
   * @param  {string}     events The name of the event (or the events separated
   *                             by spaces).
   * @param  {?object}    data   The content of the event (optional).
   * @return {dispatcher}        Returns the instance itself.
   */
  dispatcher.prototype.dispatchEvent = function(events, data) {
    var i,
        n,
        j,
        m,
        a,
        event,
        eventName,
        self = this,
        eArray = typeof events === 'string' ? events.split(' ') : events;

    data = data === undefined ? {} : data;

    for (i = 0, n = eArray.length; i !== n; i += 1) {
      eventName = eArray[i];

      if (this._handlers[eventName]) {
        event = self.getEvent(eventName, data);
        a = [];

        for (j = 0, m = this._handlers[eventName].length; j !== m; j += 1) {
          this._handlers[eventName][j].handler(event);
          if (!this._handlers[eventName][j].one)
            a.push(this._handlers[eventName][j]);
        }

        this._handlers[eventName] = a;
      }
    }

    return this;
  };

  /**
   * Return an event object.
   *
   * @param  {string}  events The name of the event.
   * @param  {?object} data   The content of the event (optional).
   * @return {object}         Returns the instance itself.
   */
  dispatcher.prototype.getEvent = function(event, data) {
    return {
      type: event,
      data: data || {},
      target: this
    };
  };

  /**
   * A useful function to deal with inheritance. It will make the target
   * inherit the prototype of the class dispatcher as well as its constructor.
   *
   * @param {object} target The target.
   */
  dispatcher.extend = function(target, args) {
    var k;

    for (k in dispatcher.prototype)
      if (dispatcher.prototype.hasOwnProperty(k))
        target[k] = dispatcher.prototype[k];

    dispatcher.apply(target, args);
  };




  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.dispatcher = dispatcher;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = dispatcher;
    exports.dispatcher = dispatcher;
  } else
    this.dispatcher = dispatcher;
}).call(this);

;(function() {
  'use strict';

  /**
   * This utils aims to facilitate the manipulation of each instance setting.
   * Using a function instead of an object brings two main advantages: First,
   * it will be easier in the future to catch settings updates through a
   * function than an object. Second, giving it a full object will "merge" it
   * to the settings object properly, keeping us to have to always add a loop.
   *
   * @return {configurable} The "settings" function.
   */
  var configurable = function() {
    var i,
        l,
        data = {},
        datas = Array.prototype.slice.call(arguments, 0);

    /**
     * The method to use to set or get any property of this instance.
     *
     * @param  {string|object}    a1 If it is a string and if a2 is undefined,
     *                               then it will return the corresponding
     *                               property. If it is a string and if a2 is
     *                               set, then it will set a2 as the property
     *                               corresponding to a1, and return this. If
     *                               it is an object, then each pair string +
     *                               object(or any other type) will be set as a
     *                               property.
     * @param  {*?}               a2 The new property corresponding to a1 if a1
     *                               is a string.
     * @return {*|configurable}      Returns itself or the corresponding
     *                               property.
     *
     * Polymorphism:
     * *************
     * Here are some basic use examples:
     *
     *  > settings = new configurable();
     *  > settings('mySetting', 42);
     *  > settings('mySetting'); // Logs: 42
     *  > settings('mySetting', 123);
     *  > settings('mySetting'); // Logs: 123
     *  > settings({mySetting: 456});
     *  > settings('mySetting'); // Logs: 456
     *
     * Also, it is possible to use the function as a fallback:
     *  > settings({mySetting: 'abc'}, 'mySetting');  // Logs: 'abc'
     *  > settings({hisSetting: 'abc'}, 'mySetting'); // Logs: 456
     */
    var settings = function(a1, a2) {
      var o,
          i,
          l,
          k;

      if (arguments.length === 1 && typeof a1 === 'string') {
        if (data[a1] !== undefined)
          return data[a1];
        for (i = 0, l = datas.length; i < l; i++)
          if (datas[i][a1] !== undefined)
            return datas[i][a1];
        return undefined;
      } else if (typeof a1 === 'object' && typeof a2 === 'string') {
        return (a1 || {})[a2] !== undefined ? a1[a2] : settings(a2);
      } else {
        o = (typeof a1 === 'object' && a2 === undefined) ? a1 : {};

        if (typeof a1 === 'string')
          o[a1] = a2;

        for (i = 0, k = Object.keys(o), l = k.length; i < l; i++)
          data[k[i]] = o[k[i]];

        return this;
      }
    };

    /**
     * This method returns a new configurable function, with new objects
     *
     * @param  {object*}  Any number of objects to search in.
     * @return {function} Returns the function. Check its documentation to know
     *                    more about how it works.
     */
    settings.embedObjects = function() {
      var args = datas.concat(
        data
      ).concat(
        Array.prototype.splice.call(arguments, 0)
      );

      return configurable.apply({}, args);
    };

    // Initialize
    for (i = 0, l = arguments.length; i < l; i++)
      settings(arguments[i]);

    return settings;
  };

  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.configurable = configurable;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = configurable;
    exports.configurable = configurable;
  } else
    this.configurable = configurable;
}).call(this);

;(function(undefined) {
  'use strict';

  var _methods = Object.create(null),
      _indexes = Object.create(null),
      _initBindings = Object.create(null),
      _methodBindings = Object.create(null),
      _methodBeforeBindings = Object.create(null),
      _defaultSettings = {
        immutable: true,
        clone: true
      },
      _defaultSettingsFunction = function(key) {
        return _defaultSettings[key];
      };

  /**
   * The graph constructor. It initializes the data and the indexes, and binds
   * the custom indexes and methods to its own scope.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {boolean} clone     Indicates if the data have to be cloned in methods
   *                       to add nodes or edges.
   *   {boolean} immutable Indicates if nodes "id" values and edges "id",
   *                       "source" and "target" values must be set as
   *                       immutable.
   *
   * @param  {?configurable} settings Eventually a settings function.
   * @return {graph}                  The new graph instance.
   */
  var graph = function(settings) {
    var k,
        fn,
        data;

    /**
     * DATA:
     * *****
     * Every data that is callable from graph methods are stored in this "data"
     * object. This object will be served as context for all these methods,
     * and it is possible to add other type of data in it.
     */
    data = {
      /**
       * SETTINGS FUNCTION:
       * ******************
       */
      settings: settings || _defaultSettingsFunction,

      /**
       * MAIN DATA:
       * **********
       */
      nodesArray: [],
      edgesArray: [],

      /**
       * GLOBAL INDEXES:
       * ***************
       * These indexes just index data by ids.
       */
      nodesIndex: Object.create(null),
      edgesIndex: Object.create(null),

      /**
       * LOCAL INDEXES:
       * **************
       * These indexes refer from node to nodes. Each key is an id, and each
       * value is the array of the ids of related nodes.
       */
      inNeighborsIndex: Object.create(null),
      outNeighborsIndex: Object.create(null),
      allNeighborsIndex: Object.create(null),

      inNeighborsCount: Object.create(null),
      outNeighborsCount: Object.create(null),
      allNeighborsCount: Object.create(null)
    };

    // Execute bindings:
    for (k in _initBindings)
      _initBindings[k].call(data);

    // Add methods to both the scope and the data objects:
    for (k in _methods) {
      fn = __bindGraphMethod(k, data, _methods[k]);
      this[k] = fn;
      data[k] = fn;
    }
  };




  /**
   * A custom tool to bind methods such that function that are bound to it will
   * be executed anytime the method is called.
   *
   * @param  {string}   methodName The name of the method to bind.
   * @param  {object}   scope      The scope where the method must be executed.
   * @param  {function} fn         The method itself.
   * @return {function}            The new method.
   */
  function __bindGraphMethod(methodName, scope, fn) {
    var result = function() {
      var k,
          res;

      // Execute "before" bound functions:
      for (k in _methodBeforeBindings[methodName])
        _methodBeforeBindings[methodName][k].apply(scope, arguments);

      // Apply the method:
      res = fn.apply(scope, arguments);

      // Execute bound functions:
      for (k in _methodBindings[methodName])
        _methodBindings[methodName][k].apply(scope, arguments);

      // Return res:
      return res;
    };

    return result;
  }

  /**
   * This custom tool function removes every pair key/value from an hash. The
   * goal is to avoid creating a new object while some other references are
   * still hanging in some scopes...
   *
   * @param  {object} obj The object to empty.
   * @return {object}     The empty object.
   */
  function __emptyObject(obj) {
    var k;

    for (k in obj)
      if (!('hasOwnProperty' in obj) || obj.hasOwnProperty(k))
        delete obj[k];

    return obj;
  }




  /**
   * This global method adds a method that will be bound to the futurly created
   * graph instances.
   *
   * Since these methods will be bound to their scope when the instances are
   * created, it does not use the prototype. Because of that, methods have to
   * be added before instances are created to make them available.
   *
   * Here is an example:
   *
   *  > graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesArray.length;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *
   * @param  {string}   methodName The name of the method.
   * @param  {function} fn         The method itself.
   * @return {object}              The global graph constructor.
   */
  graph.addMethod = function(methodName, fn) {
    if (
      typeof methodName !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length !== 2
    )
      throw 'addMethod: Wrong arguments.';

    if (_methods[methodName] || graph[methodName])
      throw 'The method "' + methodName + '" already exists.';

    _methods[methodName] = fn;
    _methodBindings[methodName] = Object.create(null);
    _methodBeforeBindings[methodName] = Object.create(null);

    return this;
  };

  /**
   * This global method returns true if the method has already been added, and
   * false else.
   *
   * Here are some examples:
   *
   *  > graph.hasMethod('addNode'); // returns true
   *  > graph.hasMethod('hasMethod'); // returns true
   *  > graph.hasMethod('unexistingMethod'); // returns false
   *
   * @param  {string}  methodName The name of the method.
   * @return {boolean}            The result.
   */
  graph.hasMethod = function(methodName) {
    return !!(_methods[methodName] || graph[methodName]);
  };

  /**
   * This global methods attaches a function to a method. Anytime the specified
   * method is called, the attached function is called right after, with the
   * same arguments and in the same scope. The attached function is called
   * right before if the last argument is true, unless the method is the graph
   * constructor.
   *
   * To attach a function to the graph constructor, use 'constructor' as the
   * method name (first argument).
   *
   * The main idea is to have a clean way to keep custom indexes up to date,
   * for instance:
   *
   *  > var timesAddNodeCalled = 0;
   *  > graph.attach('addNode', 'timesAddNodeCalledInc', function() {
   *  >   timesAddNodeCalled++;
   *  > });
   *  >
   *  > var myGraph = new graph();
   *  > console.log(timesAddNodeCalled); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(timesAddNodeCalled); // outputs 2
   *
   * The idea for calling a function before is to provide pre-processors, for
   * instance:
   *
   *  > var colorPalette = { Person: '#C3CBE1', Place: '#9BDEBD' };
   *  > graph.attach('addNode', 'applyNodeColorPalette', function(n) {
   *  >   n.color = colorPalette[n.category];
   *  > }, true);
   *  >
   *  > var myGraph = new graph();
   *  > myGraph.addNode({ id: 'n0', category: 'Person' });
   *  > console.log(myGraph.nodes('n0').color); // outputs '#C3CBE1'
   *
   * @param  {string}   methodName The name of the related method or
   *                               "constructor".
   * @param  {string}   key        The key to identify the function to attach.
   * @param  {function} fn         The function to bind.
   * @param  {boolean}  before     If true the function is called right before.
   * @return {object}              The global graph constructor.
   */
  graph.attach = function(methodName, key, fn, before) {
    if (
      typeof methodName !== 'string' ||
      typeof key !== 'string' ||
      typeof fn !== 'function' ||
      arguments.length < 3 ||
      arguments.length > 4
    )
      throw 'attach: Wrong arguments.';

    var bindings;

    if (methodName === 'constructor')
      bindings = _initBindings;
    else {
      if (before) {
        if (!_methodBeforeBindings[methodName])
        throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBeforeBindings[methodName];
      }
      else {
        if (!_methodBindings[methodName])
          throw 'The method "' + methodName + '" does not exist.';

        bindings = _methodBindings[methodName];
      }
    }

    if (bindings[key])
      throw 'A function "' + key + '" is already attached ' +
            'to the method "' + methodName + '".';

    bindings[key] = fn;

    return this;
  };

  /**
   * Alias of attach(methodName, key, fn, true).
   */
  graph.attachBefore = function(methodName, key, fn) {
    return this.attach(methodName, key, fn, true);
  };

  /**
   * This methods is just an helper to deal with custom indexes. It takes as
   * arguments the name of the index and an object containing all the different
   * functions to bind to the methods.
   *
   * Here is a basic example, that creates an index to keep the number of nodes
   * in the current graph. It also adds a method to provide a getter on that
   * new index:
   *
   *  > sigma.classes.graph.addIndex('nodesCount', {
   *  >   constructor: function() {
   *  >     this.nodesCount = 0;
   *  >   },
   *  >   addNode: function() {
   *  >     this.nodesCount++;
   *  >   },
   *  >   dropNode: function() {
   *  >     this.nodesCount--;
   *  >   }
   *  > });
   *  >
   *  > sigma.classes.graph.addMethod('getNodesCount', function() {
   *  >   return this.nodesCount;
   *  > });
   *  >
   *  > var myGraph = new sigma.classes.graph();
   *  > console.log(myGraph.getNodesCount()); // outputs 0
   *  >
   *  > myGraph.addNode({ id: '1' }).addNode({ id: '2' });
   *  > console.log(myGraph.getNodesCount()); // outputs 2
   *
   * @param  {string} name     The name of the index.
   * @param  {object} bindings The object containing the functions to bind.
   * @return {object}          The global graph constructor.
   */
  graph.addIndex = function(name, bindings) {
    if (
      typeof name !== 'string' ||
      Object(bindings) !== bindings ||
      arguments.length !== 2
    )
      throw 'addIndex: Wrong arguments.';

    if (_indexes[name])
      throw 'The index "' + name + '" already exists.';

    var k;

    // Store the bindings:
    _indexes[name] = bindings;

    // Attach the bindings:
    for (k in bindings)
      if (typeof bindings[k] !== 'function')
        throw 'The bindings must be functions.';
      else
        graph.attach(k, name, bindings[k]);

    return this;
  };




  /**
   * This method adds a node to the graph. The node must be an object, with a
   * string under the key "id". Except for this, it is possible to add any
   * other attribute, that will be preserved all along the manipulations.
   *
   * If the graph option "clone" has a truthy value, the node will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id will be defined as immutable.
   *
   * @param  {object} node The node to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addNode', function(node) {
    // Check that the node is an object and has an id:
    if (Object(node) !== node || arguments.length !== 1)
      throw 'addNode: Wrong arguments.';

    if (typeof node.id !== 'string' && typeof node.id !== 'number')
      throw 'The node must have a string or number id.';

    if (this.nodesIndex[node.id])
      throw 'The node "' + node.id + '" already exists.';

    var k,
        id = node.id,
        validNode = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in node)
        if (k !== 'id')
          validNode[k] = node[k];
    } else
      validNode = node;

    // Check the "immutable" option:
    if (this.settings('immutable'))
      Object.defineProperty(validNode, 'id', {
        value: id,
        enumerable: true
      });
    else
      validNode.id = id;

    // Add empty containers for edges indexes:
    this.inNeighborsIndex[id] = Object.create(null);
    this.outNeighborsIndex[id] = Object.create(null);
    this.allNeighborsIndex[id] = Object.create(null);

    this.inNeighborsCount[id] = 0;
    this.outNeighborsCount[id] = 0;
    this.allNeighborsCount[id] = 0;

    // Add the node to indexes:
    this.nodesArray.push(validNode);
    this.nodesIndex[validNode.id] = validNode;

    // Return the current instance:
    return this;
  });

  /**
   * This method adds an edge to the graph. The edge must be an object, with a
   * string under the key "id", and strings under the keys "source" and
   * "target" that design existing nodes. Except for this, it is possible to
   * add any other attribute, that will be preserved all along the
   * manipulations.
   *
   * If the graph option "clone" has a truthy value, the edge will be cloned
   * when added to the graph. Also, if the graph option "immutable" has a
   * truthy value, its id, source and target will be defined as immutable.
   *
   * @param  {object} edge The edge to add.
   * @return {object}      The graph instance.
   */
  graph.addMethod('addEdge', function(edge) {
    // Check that the edge is an object and has an id:
    if (Object(edge) !== edge || arguments.length !== 1)
      throw 'addEdge: Wrong arguments.';

    if (typeof edge.id !== 'string' && typeof edge.id !== 'number')
      throw 'The edge must have a string or number id.';

    if ((typeof edge.source !== 'string' && typeof edge.source !== 'number') ||
        !this.nodesIndex[edge.source])
      throw 'The edge source must have an existing node id.';

    if ((typeof edge.target !== 'string' && typeof edge.target !== 'number') ||
        !this.nodesIndex[edge.target])
      throw 'The edge target must have an existing node id.';

    if (this.edgesIndex[edge.id])
      throw 'The edge "' + edge.id + '" already exists.';

    var k,
        validEdge = Object.create(null);

    // Check the "clone" option:
    if (this.settings('clone')) {
      for (k in edge)
        if (k !== 'id' && k !== 'source' && k !== 'target')
          validEdge[k] = edge[k];
    } else
      validEdge = edge;

    // Check the "immutable" option:
    if (this.settings('immutable')) {
      Object.defineProperty(validEdge, 'id', {
        value: edge.id,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'source', {
        value: edge.source,
        enumerable: true
      });

      Object.defineProperty(validEdge, 'target', {
        value: edge.target,
        enumerable: true
      });
    } else {
      validEdge.id = edge.id;
      validEdge.source = edge.source;
      validEdge.target = edge.target;
    }

    // Add the edge to indexes:
    this.edgesArray.push(validEdge);
    this.edgesIndex[validEdge.id] = validEdge;

    if (!this.inNeighborsIndex[validEdge.target][validEdge.source])
      this.inNeighborsIndex[validEdge.target][validEdge.source] =
        Object.create(null);
    this.inNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
      validEdge;

    if (!this.outNeighborsIndex[validEdge.source][validEdge.target])
      this.outNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.outNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (!this.allNeighborsIndex[validEdge.source][validEdge.target])
      this.allNeighborsIndex[validEdge.source][validEdge.target] =
        Object.create(null);
    this.allNeighborsIndex[validEdge.source][validEdge.target][validEdge.id] =
      validEdge;

    if (validEdge.target !== validEdge.source) {
      if (!this.allNeighborsIndex[validEdge.target][validEdge.source])
        this.allNeighborsIndex[validEdge.target][validEdge.source] =
          Object.create(null);
      this.allNeighborsIndex[validEdge.target][validEdge.source][validEdge.id] =
        validEdge;
    }

    // Keep counts up to date:
    this.inNeighborsCount[validEdge.target]++;
    this.outNeighborsCount[validEdge.source]++;
    this.allNeighborsCount[validEdge.target]++;
    this.allNeighborsCount[validEdge.source]++;

    return this;
  });

  /**
   * This method drops a node from the graph. It also removes each edge that is
   * bound to it, through the dropEdge method. An error is thrown if the node
   * does not exist.
   *
   * @param  {string} id The node id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropNode', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropNode: Wrong arguments.';

    if (!this.nodesIndex[id])
      throw 'The node "' + id + '" does not exist.';

    var i, k, l;

    // Remove the node from indexes:
    delete this.nodesIndex[id];
    for (i = 0, l = this.nodesArray.length; i < l; i++)
      if (this.nodesArray[i].id === id) {
        this.nodesArray.splice(i, 1);
        break;
      }

    // Remove related edges:
    for (i = this.edgesArray.length - 1; i >= 0; i--)
      if (this.edgesArray[i].source === id || this.edgesArray[i].target === id)
        this.dropEdge(this.edgesArray[i].id);

    // Remove related edge indexes:
    delete this.inNeighborsIndex[id];
    delete this.outNeighborsIndex[id];
    delete this.allNeighborsIndex[id];

    delete this.inNeighborsCount[id];
    delete this.outNeighborsCount[id];
    delete this.allNeighborsCount[id];

    for (k in this.nodesIndex) {
      delete this.inNeighborsIndex[k][id];
      delete this.outNeighborsIndex[k][id];
      delete this.allNeighborsIndex[k][id];
    }

    return this;
  });

  /**
   * This method drops an edge from the graph. An error is thrown if the edge
   * does not exist.
   *
   * @param  {string} id The edge id.
   * @return {object}    The graph instance.
   */
  graph.addMethod('dropEdge', function(id) {
    // Check that the arguments are valid:
    if ((typeof id !== 'string' && typeof id !== 'number') ||
        arguments.length !== 1)
      throw 'dropEdge: Wrong arguments.';

    if (!this.edgesIndex[id])
      throw 'The edge "' + id + '" does not exist.';

    var i, l, edge;

    // Remove the edge from indexes:
    edge = this.edgesIndex[id];
    delete this.edgesIndex[id];
    for (i = 0, l = this.edgesArray.length; i < l; i++)
      if (this.edgesArray[i].id === id) {
        this.edgesArray.splice(i, 1);
        break;
      }

    delete this.inNeighborsIndex[edge.target][edge.source][edge.id];
    if (!Object.keys(this.inNeighborsIndex[edge.target][edge.source]).length)
      delete this.inNeighborsIndex[edge.target][edge.source];

    delete this.outNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.outNeighborsIndex[edge.source][edge.target]).length)
      delete this.outNeighborsIndex[edge.source][edge.target];

    delete this.allNeighborsIndex[edge.source][edge.target][edge.id];
    if (!Object.keys(this.allNeighborsIndex[edge.source][edge.target]).length)
      delete this.allNeighborsIndex[edge.source][edge.target];

    if (edge.target !== edge.source) {
      delete this.allNeighborsIndex[edge.target][edge.source][edge.id];
      if (!Object.keys(this.allNeighborsIndex[edge.target][edge.source]).length)
        delete this.allNeighborsIndex[edge.target][edge.source];
    }

    this.inNeighborsCount[edge.target]--;
    this.outNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.source]--;
    this.allNeighborsCount[edge.target]--;

    return this;
  });

  /**
   * This method destroys the current instance. It basically empties each index
   * and methods attached to the graph.
   */
  graph.addMethod('kill', function() {
    // Delete arrays:
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;
    delete this.nodesArray;
    delete this.edgesArray;

    // Delete indexes:
    delete this.nodesIndex;
    delete this.edgesIndex;
    delete this.inNeighborsIndex;
    delete this.outNeighborsIndex;
    delete this.allNeighborsIndex;
    delete this.inNeighborsCount;
    delete this.outNeighborsCount;
    delete this.allNeighborsCount;
  });

  /**
   * This method empties the nodes and edges arrays, as well as the different
   * indexes.
   *
   * @return {object} The graph instance.
   */
  graph.addMethod('clear', function() {
    this.nodesArray.length = 0;
    this.edgesArray.length = 0;

    // Due to GC issues, I prefer not to create new object. These objects are
    // only available from the methods and attached functions, but still, it is
    // better to prevent ghost references to unrelevant data...
    __emptyObject(this.nodesIndex);
    __emptyObject(this.edgesIndex);
    __emptyObject(this.nodesIndex);
    __emptyObject(this.inNeighborsIndex);
    __emptyObject(this.outNeighborsIndex);
    __emptyObject(this.allNeighborsIndex);
    __emptyObject(this.inNeighborsCount);
    __emptyObject(this.outNeighborsCount);
    __emptyObject(this.allNeighborsCount);

    return this;
  });

  /**
   * This method reads an object and adds the nodes and edges, through the
   * proper methods "addNode" and "addEdge".
   *
   * Here is an example:
   *
   *  > var myGraph = new graph();
   *  > myGraph.read({
   *  >   nodes: [
   *  >     { id: 'n0' },
   *  >     { id: 'n1' }
   *  >   ],
   *  >   edges: [
   *  >     {
   *  >       id: 'e0',
   *  >       source: 'n0',
   *  >       target: 'n1'
   *  >     }
   *  >   ]
   *  > });
   *  >
   *  > console.log(
   *  >   myGraph.nodes().length,
   *  >   myGraph.edges().length
   *  > ); // outputs 2 1
   *
   * @param  {object} g The graph object.
   * @return {object}   The graph instance.
   */
  graph.addMethod('read', function(g) {
    var i,
        a,
        l;

    a = g.nodes || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addNode(a[i]);

    a = g.edges || [];
    for (i = 0, l = a.length; i < l; i++)
      this.addEdge(a[i]);

    return this;
  });

  /**
   * This methods returns one or several nodes, depending on how it is called.
   *
   * To get the array of nodes, call "nodes" without argument. To get a
   * specific node, call it with the id of the node. The get multiple node,
   * call it with an array of ids, and it will return the array of nodes, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related node or array of nodes.
   */
  graph.addMethod('nodes', function(v) {
    // Clone the array of nodes and return it:
    if (!arguments.length)
      return this.nodesArray.slice(0);

    // Return the related node:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.nodesIndex[v];

    // Return an array of the related node:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.nodesIndex[v[i]]);
        else
          throw 'nodes: Wrong arguments.';

      return a;
    }

    throw 'nodes: Wrong arguments.';
  });

  /**
   * This methods returns the degree of one or several nodes, depending on how
   * it is called. It is also possible to get incoming or outcoming degrees
   * instead by specifying 'in' or 'out' as a second argument.
   *
   * @param  {string|array} v     One id, an array of ids.
   * @param  {?string}      which Which degree is required. Values are 'in',
   *                              'out', and by default the normal degree.
   * @return {number|array}       The related degree or array of degrees.
   */
  graph.addMethod('degree', function(v, which) {
    // Check which degree is required:
    which = {
      'in': this.inNeighborsCount,
      'out': this.outNeighborsCount
    }[which || ''] || this.allNeighborsCount;

    // Return the related node:
    if (typeof v === 'string' || typeof v === 'number')
      return which[v];

    // Return an array of the related node:
    if (Object.prototype.toString.call(v) === '[object Array]') {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(which[v[i]]);
        else
          throw 'degree: Wrong arguments.';

      return a;
    }

    throw 'degree: Wrong arguments.';
  });

  /**
   * This methods returns one or several edges, depending on how it is called.
   *
   * To get the array of edges, call "edges" without argument. To get a
   * specific edge, call it with the id of the edge. The get multiple edge,
   * call it with an array of ids, and it will return the array of edges, in
   * the same order.
   *
   * @param  {?(string|array)} v Eventually one id, an array of ids.
   * @return {object|array}      The related edge or array of edges.
   */
  graph.addMethod('edges', function(v) {
    // Clone the array of edges and return it:
    if (!arguments.length)
      return this.edgesArray.slice(0);

    // Return the related edge:
    if (arguments.length === 1 &&
        (typeof v === 'string' || typeof v === 'number'))
      return this.edgesIndex[v];

    // Return an array of the related edge:
    if (
      arguments.length === 1 &&
      Object.prototype.toString.call(v) === '[object Array]'
    ) {
      var i,
          l,
          a = [];

      for (i = 0, l = v.length; i < l; i++)
        if (typeof v[i] === 'string' || typeof v[i] === 'number')
          a.push(this.edgesIndex[v[i]]);
        else
          throw 'edges: Wrong arguments.';

      return a;
    }

    throw 'edges: Wrong arguments.';
  });


  /**
   * EXPORT:
   * *******
   */
  if (typeof sigma !== 'undefined') {
    sigma.classes = sigma.classes || Object.create(null);
    sigma.classes.graph = graph;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = graph;
    exports.graph = graph;
  } else
    this.graph = graph;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.classes');

  /**
   * The camera constructor. It just initializes its attributes and methods.
   *
   * @param  {string}       id       The id.
   * @param  {sigma.classes.graph}  graph    The graph.
   * @param  {configurable} settings The settings function.
   * @param  {?object}      options  Eventually some overriding options.
   * @return {camera}                Returns the fresh new camera instance.
   */
  sigma.classes.camera = function(id, graph, settings, options) {
    sigma.classes.dispatcher.extend(this);

    Object.defineProperty(this, 'graph', {
      value: graph
    });
    Object.defineProperty(this, 'id', {
      value: id
    });
    Object.defineProperty(this, 'readPrefix', {
      value: 'read_cam' + id + ':'
    });
    Object.defineProperty(this, 'prefix', {
      value: 'cam' + id + ':'
    });

    this.x = 0;
    this.y = 0;
    this.ratio = 1;
    this.angle = 0;
    this.isAnimated = false;
    this.settings = (typeof options === 'object' && options) ?
      settings.embedObject(options) :
      settings;
  };

  /**
   * Updates the camera position.
   *
   * @param  {object} coordinates The new coordinates object.
   * @return {camera}             Returns the camera.
   */
  sigma.classes.camera.prototype.goTo = function(coordinates) {
    if (!this.settings('enableCamera'))
      return this;

    var i,
        l,
        c = coordinates || {},
        keys = ['x', 'y', 'ratio', 'angle'];

    for (i = 0, l = keys.length; i < l; i++)
      if (c[keys[i]] !== undefined) {
        if (typeof c[keys[i]] === 'number' && !isNaN(c[keys[i]]))
          this[keys[i]] = c[keys[i]];
        else
          throw 'Value for "' + keys[i] + '" is not a number.';
      }

    this.dispatchEvent('coordinatesUpdated');
    return this;
  };

  /**
   * This method takes a graph and computes for each node and edges its
   * coordinates relatively to the center of the camera. Basically, it will
   * compute the coordinates that will be used by the graphic renderers.
   *
   * Since it should be possible to use different cameras and different
   * renderers, it is possible to specify a prefix to put before the new
   * coordinates (to get something like "node.camera1_x")
   *
   * @param  {?string} read    The prefix of the coordinates to read.
   * @param  {?string} write   The prefix of the coordinates to write.
   * @param  {?object} options Eventually an object of options. Those can be:
   *                           - A restricted nodes array.
   *                           - A restricted edges array.
   *                           - A width.
   *                           - A height.
   * @return {camera}        Returns the camera.
   */
  sigma.classes.camera.prototype.applyView = function(read, write, options) {
    options = options || {};
    write = write !== undefined ? write : this.prefix;
    read = read !== undefined ? read : this.readPrefix;

    var nodes = options.nodes || this.graph.nodes(),
        edges = options.edges || this.graph.edges();

    var i,
        l,
        node,
        relCos = Math.cos(this.angle) / this.ratio,
        relSin = Math.sin(this.angle) / this.ratio,
        nodeRatio = Math.pow(this.ratio, this.settings('nodesPowRatio')),
        edgeRatio = Math.pow(this.ratio, this.settings('edgesPowRatio')),
        xOffset = (options.width || 0) / 2 - this.x * relCos - this.y * relSin,
        yOffset = (options.height || 0) / 2 - this.y * relCos + this.x * relSin;

    for (i = 0, l = nodes.length; i < l; i++) {
      node = nodes[i];
      node[write + 'x'] =
        (node[read + 'x'] || 0) * relCos +
        (node[read + 'y'] || 0) * relSin +
        xOffset;
      node[write + 'y'] =
        (node[read + 'y'] || 0) * relCos -
        (node[read + 'x'] || 0) * relSin +
        yOffset;
      node[write + 'size'] =
        (node[read + 'size'] || 0) /
        nodeRatio;
    }

    for (i = 0, l = edges.length; i < l; i++) {
      edges[i][write + 'size'] =
        (edges[i][read + 'size'] || 0) /
        edgeRatio;
    }

    return this;
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * camera to the frame of the graph.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    camera.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    camera.
   * @return {object}   The point coordinates in the frame of the graph.
   */
  sigma.classes.camera.prototype.graphPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: (x * cos + y * sin) / this.ratio + X,
      y: (y * cos - x * sin) / this.ratio + Y
    };
  };

  /**
   * This function converts the coordinates of a point from the frame of the
   * graph to the frame of the camera.
   *
   * @param  {number} x The X coordinate of the point in the frame of the
   *                    graph.
   * @param  {number} y The Y coordinate of the point in the frame of the
   *                    graph.
   * @return {object}   The point coordinates in the frame of the camera.
   */
  sigma.classes.camera.prototype.cameraPosition = function(x, y, vector) {
    var X = 0,
        Y = 0,
        cos = Math.cos(this.angle),
        sin = Math.sin(this.angle);

    // Revert the origin differential vector:
    if (!vector) {
      X = - (this.x * cos + this.y * sin) / this.ratio;
      Y = - (this.y * cos - this.x * sin) / this.ratio;
    }

    return {
      x: ((x - X) * cos - (y - Y) * sin) * this.ratio,
      y: ((y - Y) * cos + (x - X) * sin) * this.ratio
    };
  };

  /**
   * This method returns the transformation matrix of the camera. This is
   * especially useful to apply the camera view directly in shaders, in case of
   * WebGL rendering.
   *
   * @return {array} The transformation matrix.
   */
  sigma.classes.camera.prototype.getMatrix = function() {
    var scale = sigma.utils.matrices.scale(1 / this.ratio),
        rotation = sigma.utils.matrices.rotation(this.angle),
        translation = sigma.utils.matrices.translation(-this.x, -this.y),
        matrix = sigma.utils.matrices.multiply(
          translation,
          sigma.utils.matrices.multiply(
            rotation,
            scale
          )
        );

    return matrix;
  };

  /**
   * Taking a width and a height as parameters, this method returns the
   * coordinates of the rectangle representing the camera on screen, in the
   * graph's referentiel.
   *
   * To keep displaying labels of nodes going out of the screen, the method
   * keeps a margin around the screen in the returned rectangle.
   *
   * @param  {number} width  The width of the screen.
   * @param  {number} height The height of the screen.
   * @return {object}        The rectangle as x1, y1, x2 and y2, representing
   *                         two opposite points.
   */
  sigma.classes.camera.prototype.getRectangle = function(width, height) {
    var widthVect = this.cameraPosition(width, 0, true),
        heightVect = this.cameraPosition(0, height, true),
        centerVect = this.cameraPosition(width / 2, height / 2, true),
        marginX = this.cameraPosition(width / 4, 0, true).x,
        marginY = this.cameraPosition(0, height / 4, true).y;

    return {
      x1: this.x - centerVect.x - marginX,
      y1: this.y - centerVect.y - marginY,
      x2: this.x - centerVect.x + marginX + widthVect.x,
      y2: this.y - centerVect.y - marginY + widthVect.y,
      height: Math.sqrt(
        Math.pow(heightVect.x, 2) +
        Math.pow(heightVect.y + 2 * marginY, 2)
      )
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module
   * =====================
   *
   * Author: Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 20,
      maxLevel: maxLevel || 4,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The quad API as exposed to sigma.
   */

  /**
   * The quad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree  Property holding the quadtree object.
   * property {object} _geom  Exposition of the _geom namespace for testing.
   * property {object} _cache Cache for the area method.
   */
  var quad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
  };

  /**
   * Index a graph by inserting its nodes into the quadtree.
   *
   * @param  {array}  nodes   An array of nodes to index.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for node geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  quad.prototype.index = function(nodes, params) {

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.quad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '';

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    // Inserting graph nodes into the tree
    for (var i = 0, l = nodes.length; i < l; i++) {

      // Inserting node
      _quadInsert(
        nodes[i],
        _geom.pointToSquare({
          x: nodes[i][prefix + 'x'],
          y: nodes[i][prefix + 'y'],
          size: nodes[i][prefix + 'size']
        }),
        this._tree
      );
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph nodes held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.point = function(x, y) {
    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph nodes within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of nodes retrieved.
   */
  quad.prototype.area = function(rect) {
    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving nodes
    var nodes = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var nodesArray = [];
    for (var i in nodes)
      nodesArray.push(nodes[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = nodesArray;

    return nodesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.quad = quad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = quad;
    exports.quad = quad;
  } else
    this.quad = quad;
}).call(this);

;(function(undefined) {
  'use strict';

  /**
   * Sigma Quadtree Module for edges
   * ===============================
   *
   * Author: SÃ©bastien Heymann,
   *   from the quad of Guillaume Plique (Yomguithereal)
   * Version: 0.2
   */



  /**
   * Quad Geometric Operations
   * -------------------------
   *
   * A useful batch of geometric operations used by the quadtree.
   */

  var _geom = {

    /**
     * Transforms a graph node with x, y and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph node with at least a point (x, y) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    pointToSquare: function(n) {
      return {
        x1: n.x - n.size,
        y1: n.y - n.size,
        x2: n.x + n.size,
        y2: n.y - n.size,
        height: n.size * 2
      };
    },

    /**
     * Transforms a graph edge with x1, y1, x2, y2 and size into an
     * axis-aligned square.
     *
     * @param  {object} A graph edge with at least two points
     *                  (x1, y1), (x2, y2) and a size.
     * @return {object} A square: two points (x1, y1), (x2, y2) and height.
     */
    lineToSquare: function(e) {
      if (e.y1 < e.y2) {
        // (e.x1, e.y1) on top
        if (e.x1 < e.x2) {
          // (e.x1, e.y1) on left
          return {
            x1: e.x1 - e.size,
            y1: e.y1 - e.size,
            x2: e.x2 + e.size,
            y2: e.y1 - e.size,
            height: e.y2 - e.y1 + e.size * 2
          };
        }
        // (e.x1, e.y1) on right
        return {
          x1: e.x2 - e.size,
          y1: e.y1 - e.size,
          x2: e.x1 + e.size,
          y2: e.y1 - e.size,
          height: e.y2 - e.y1 + e.size * 2
        };
      }

      // (e.x2, e.y2) on top
      if (e.x1 < e.x2) {
        // (e.x1, e.y1) on left
        return {
          x1: e.x1 - e.size,
          y1: e.y2 - e.size,
          x2: e.x2 + e.size,
          y2: e.y2 - e.size,
          height: e.y1 - e.y2 + e.size * 2
        };
      }
      // (e.x2, e.y2) on right
      return {
        x1: e.x2 - e.size,
        y1: e.y2 - e.size,
        x2: e.x1 + e.size,
        y2: e.y2 - e.size,
        height: e.y1 - e.y2 + e.size * 2
      };
    },

    /**
     * Transforms a graph edge of type 'curve' with x1, y1, x2, y2,
     * control point and size into an axis-aligned square.
     *
     * @param  {object} e  A graph edge with at least two points
     *                     (x1, y1), (x2, y2) and a size.
     * @param  {object} cp A control point (x,y).
     * @return {object}    A square: two points (x1, y1), (x2, y2) and height.
     */
    quadraticCurveToSquare: function(e, cp) {
      var pt = sigma.utils.getPointOnQuadraticCurve(
        0.5,
        e.x1,
        e.y1,
        e.x2,
        e.y2,
        cp.x,
        cp.y
      );

      // Bounding box of the two points and the point at the middle of the
      // curve:
      var minX = Math.min(e.x1, e.x2, pt.x),
          maxX = Math.max(e.x1, e.x2, pt.x),
          minY = Math.min(e.y1, e.y2, pt.y),
          maxY = Math.max(e.y1, e.y2, pt.y);

      return {
        x1: minX - e.size,
        y1: minY - e.size,
        x2: maxX + e.size,
        y2: minY - e.size,
        height: maxY - minY + e.size * 2
      };
    },

    /**
     * Transforms a graph self loop into an axis-aligned square.
     *
     * @param  {object} n A graph node with a point (x, y) and a size.
     * @return {object}   A square: two points (x1, y1), (x2, y2) and height.
     */
    selfLoopToSquare: function(n) {
      // Fitting to the curve is too costly, we compute a larger bounding box
      // using the control points:
      var cp = sigma.utils.getSelfLoopControlPoints(n.x, n.y, n.size);

      // Bounding box of the point and the two control points:
      var minX = Math.min(n.x, cp.x1, cp.x2),
          maxX = Math.max(n.x, cp.x1, cp.x2),
          minY = Math.min(n.y, cp.y1, cp.y2),
          maxY = Math.max(n.y, cp.y1, cp.y2);

      return {
        x1: minX - n.size,
        y1: minY - n.size,
        x2: maxX + n.size,
        y2: minY - n.size,
        height: maxY - minY + n.size * 2
      };
    },

    /**
     * Checks whether a rectangle is axis-aligned.
     *
     * @param  {object}  A rectangle defined by two points
     *                   (x1, y1) and (x2, y2).
     * @return {boolean} True if the rectangle is axis-aligned.
     */
    isAxisAligned: function(r) {
      return r.x1 === r.x2 || r.y1 === r.y2;
    },

    /**
     * Compute top points of an axis-aligned rectangle. This is useful in
     * cases when the rectangle has been rotated (left, right or bottom up) and
     * later operations need to know the top points.
     *
     * @param  {object} An axis-aligned rectangle defined by two points
     *                  (x1, y1), (x2, y2) and height.
     * @return {object} A rectangle: two points (x1, y1), (x2, y2) and height.
     */
    axisAlignedTopPoints: function(r) {

      // Basic
      if (r.y1 === r.y2 && r.x1 < r.x2)
        return r;

      // Rotated to right
      if (r.x1 === r.x2 && r.y2 > r.y1)
        return {
          x1: r.x1 - r.height, y1: r.y1,
          x2: r.x1, y2: r.y1,
          height: r.height
        };

      // Rotated to left
      if (r.x1 === r.x2 && r.y2 < r.y1)
        return {
          x1: r.x1, y1: r.y2,
          x2: r.x2 + r.height, y2: r.y2,
          height: r.height
        };

      // Bottom's up
      return {
        x1: r.x2, y1: r.y1 - r.height,
        x2: r.x1, y2: r.y1 - r.height,
        height: r.height
      };
    },

    /**
     * Get coordinates of a rectangle's lower left corner from its top points.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerLeftCoor: function(r) {
      var width = (
        Math.sqrt(
          Math.pow(r.x2 - r.x1, 2) +
          Math.pow(r.y2 - r.y1, 2)
        )
      );

      return {
        x: r.x1 - (r.y2 - r.y1) * r.height / width,
        y: r.y1 + (r.x2 - r.x1) * r.height / width
      };
    },

    /**
     * Get coordinates of a rectangle's lower right corner from its top points
     * and its lower left corner.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @param  {object} A corner's coordinates (x, y).
     * @return {object} Coordinates of the corner (x, y).
     */
    lowerRightCoor: function(r, llc) {
      return {
        x: llc.x - r.x1 + r.x2,
        y: llc.y - r.y1 + r.y2
      };
    },

    /**
     * Get the coordinates of all the corners of a rectangle from its top point.
     *
     * @param  {object} A rectangle defined by two points (x1, y1) and (x2, y2).
     * @return {array}  An array of the four corners' coordinates (x, y).
     */
    rectangleCorners: function(r) {
      var llc = this.lowerLeftCoor(r),
          lrc = this.lowerRightCoor(r, llc);

      return [
        {x: r.x1, y: r.y1},
        {x: r.x2, y: r.y2},
        {x: llc.x, y: llc.y},
        {x: lrc.x, y: lrc.y}
      ];
    },

    /**
     * Split a square defined by its boundaries into four.
     *
     * @param  {object} Boundaries of the square (x, y, width, height).
     * @return {array}  An array containing the four new squares, themselves
     *                  defined by an array of their four corners (x, y).
     */
    splitSquare: function(b) {
      return [
        [
          {x: b.x, y: b.y},
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2}
        ],
        [
          {x: b.x + b.width / 2, y: b.y},
          {x: b.x + b.width, y: b.y},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2}
        ],
        [
          {x: b.x, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x, y: b.y + b.height},
          {x: b.x + b.width / 2, y: b.y + b.height}
        ],
        [
          {x: b.x + b.width / 2, y: b.y + b.height / 2},
          {x: b.x + b.width, y: b.y + b.height / 2},
          {x: b.x + b.width / 2, y: b.y + b.height},
          {x: b.x + b.width, y: b.y + b.height}
        ]
      ];
    },

    /**
     * Compute the four axis between corners of rectangle A and corners of
     * rectangle B. This is needed later to check an eventual collision.
     *
     * @param  {array} An array of rectangle A's four corners (x, y).
     * @param  {array} An array of rectangle B's four corners (x, y).
     * @return {array} An array of four axis defined by their coordinates (x,y).
     */
    axis: function(c1, c2) {
      return [
        {x: c1[1].x - c1[0].x, y: c1[1].y - c1[0].y},
        {x: c1[1].x - c1[3].x, y: c1[1].y - c1[3].y},
        {x: c2[0].x - c2[2].x, y: c2[0].y - c2[2].y},
        {x: c2[0].x - c2[1].x, y: c2[0].y - c2[1].y}
      ];
    },

    /**
     * Project a rectangle's corner on an axis.
     *
     * @param  {object} Coordinates of a corner (x, y).
     * @param  {object} Coordinates of an axis (x, y).
     * @return {object} The projection defined by coordinates (x, y).
     */
    projection: function(c, a) {
      var l = (
        (c.x * a.x + c.y * a.y) /
        (Math.pow(a.x, 2) + Math.pow(a.y, 2))
      );

      return {
        x: l * a.x,
        y: l * a.y
      };
    },

    /**
     * Check whether two rectangles collide on one particular axis.
     *
     * @param  {object}   An axis' coordinates (x, y).
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide on the axis.
     */
    axisCollision: function(a, c1, c2) {
      var sc1 = [],
          sc2 = [];

      for (var ci = 0; ci < 4; ci++) {
        var p1 = this.projection(c1[ci], a),
            p2 = this.projection(c2[ci], a);

        sc1.push(p1.x * a.x + p1.y * a.y);
        sc2.push(p2.x * a.x + p2.y * a.y);
      }

      var maxc1 = Math.max.apply(Math, sc1),
          maxc2 = Math.max.apply(Math, sc2),
          minc1 = Math.min.apply(Math, sc1),
          minc2 = Math.min.apply(Math, sc2);

      return (minc2 <= maxc1 && maxc2 >= minc1);
    },

    /**
     * Check whether two rectangles collide on each one of their four axis. If
     * all axis collide, then the two rectangles do collide on the plane.
     *
     * @param  {array}    Rectangle A's corners.
     * @param  {array}    Rectangle B's corners.
     * @return {boolean}  True if the rectangles collide.
     */
    collision: function(c1, c2) {
      var axis = this.axis(c1, c2),
          col = true;

      for (var i = 0; i < 4; i++)
        col = col && this.axisCollision(axis[i], c1, c2);

      return col;
    }
  };


  /**
   * Quad Functions
   * ------------
   *
   * The Quadtree functions themselves.
   * For each of those functions, we consider that in a splitted quad, the
   * index of each node is the following:
   * 0: top left
   * 1: top right
   * 2: bottom left
   * 3: bottom right
   *
   * Moreover, the hereafter quad's philosophy is to consider that if an element
   * collides with more than one nodes, this element belongs to each of the
   * nodes it collides with where other would let it lie on a higher node.
   */

  /**
   * Get the index of the node containing the point in the quad
   *
   * @param  {object}  point      A point defined by coordinates (x, y).
   * @param  {object}  quadBounds Boundaries of the quad (x, y, width, heigth).
   * @return {integer}            The index of the node containing the point.
   */
  function _quadIndex(point, quadBounds) {
    var xmp = quadBounds.x + quadBounds.width / 2,
        ymp = quadBounds.y + quadBounds.height / 2,
        top = (point.y < ymp),
        left = (point.x < xmp);

    if (top) {
      if (left)
        return 0;
      else
        return 1;
    }
    else {
      if (left)
        return 2;
      else
        return 3;
    }
  }

  /**
   * Get a list of indexes of nodes containing an axis-aligned rectangle
   *
   * @param  {object}  rectangle   A rectangle defined by two points (x1, y1),
   *                               (x2, y2) and height.
   * @param  {array}   quadCorners An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadIndexes(rectangle, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if ((rectangle.x2 >= quadCorners[i][0].x) &&
          (rectangle.x1 <= quadCorners[i][1].x) &&
          (rectangle.y1 + rectangle.height >= quadCorners[i][0].y) &&
          (rectangle.y1 <= quadCorners[i][2].y))
        indexes.push(i);

    return indexes;
  }

  /**
   * Get a list of indexes of nodes containing a non-axis-aligned rectangle
   *
   * @param  {array}  corners      An array containing each corner of the
   *                               rectangle defined by its coordinates (x, y).
   * @param  {array}  quadCorners  An array of the quad nodes' corners.
   * @return {array}               An array of indexes containing one to
   *                               four integers.
   */
  function _quadCollision(corners, quadCorners) {
    var indexes = [];

    // Iterating through quads
    for (var i = 0; i < 4; i++)
      if (_geom.collision(corners, quadCorners[i]))
        indexes.push(i);

    return indexes;
  }

  /**
   * Subdivide a quad by creating a node at a precise index. The function does
   * not generate all four nodes not to potentially create unused nodes.
   *
   * @param  {integer}  index The index of the node to create.
   * @param  {object}   quad  The quad object to subdivide.
   * @return {object}         A new quad representing the node created.
   */
  function _quadSubdivide(index, quad) {
    var next = quad.level + 1,
        subw = Math.round(quad.bounds.width / 2),
        subh = Math.round(quad.bounds.height / 2),
        qx = Math.round(quad.bounds.x),
        qy = Math.round(quad.bounds.y),
        x,
        y;

    switch (index) {
      case 0:
        x = qx;
        y = qy;
        break;
      case 1:
        x = qx + subw;
        y = qy;
        break;
      case 2:
        x = qx;
        y = qy + subh;
        break;
      case 3:
        x = qx + subw;
        y = qy + subh;
        break;
    }

    return _quadTree(
      {x: x, y: y, width: subw, height: subh},
      next,
      quad.maxElements,
      quad.maxLevel
    );
  }

  /**
   * Recursively insert an element into the quadtree. Only points
   * with size, i.e. axis-aligned squares, may be inserted with this
   * method.
   *
   * @param  {object}  el         The element to insert in the quadtree.
   * @param  {object}  sizedPoint A sized point defined by two top points
   *                              (x1, y1), (x2, y2) and height.
   * @param  {object}  quad       The quad in which to insert the element.
   * @return {undefined}          The function does not return anything.
   */
  function _quadInsert(el, sizedPoint, quad) {
    if (quad.level < quad.maxLevel) {

      // Searching appropriate quads
      var indexes = _quadIndexes(sizedPoint, quad.corners);

      // Iterating
      for (var i = 0, l = indexes.length; i < l; i++) {

        // Subdividing if necessary
        if (quad.nodes[indexes[i]] === undefined)
          quad.nodes[indexes[i]] = _quadSubdivide(indexes[i], quad);

        // Recursion
        _quadInsert(el, sizedPoint, quad.nodes[indexes[i]]);
      }
    }
    else {

      // Pushing the element in a leaf node
      quad.elements.push(el);
    }
  }

  /**
   * Recursively retrieve every elements held by the node containing the
   * searched point.
   *
   * @param  {object}  point The searched point (x, y).
   * @param  {object}  quad  The searched quad.
   * @return {array}         An array of elements contained in the relevant
   *                         node.
   */
  function _quadRetrievePoint(point, quad) {
    if (quad.level < quad.maxLevel) {
      var index = _quadIndex(point, quad.bounds);

      // If node does not exist we return an empty list
      if (quad.nodes[index] !== undefined) {
        return _quadRetrievePoint(point, quad.nodes[index]);
      }
      else {
        return [];
      }
    }
    else {
      return quad.elements;
    }
  }

  /**
   * Recursively retrieve every elements contained within an rectangular area
   * that may or may not be axis-aligned.
   *
   * @param  {object|array} rectData       The searched area defined either by
   *                                       an array of four corners (x, y) in
   *                                       the case of a non-axis-aligned
   *                                       rectangle or an object with two top
   *                                       points (x1, y1), (x2, y2) and height.
   * @param  {object}       quad           The searched quad.
   * @param  {function}     collisionFunc  The collision function used to search
   *                                       for node indexes.
   * @param  {array?}       els            The retrieved elements.
   * @return {array}                       An array of elements contained in the
   *                                       area.
   */
  function _quadRetrieveArea(rectData, quad, collisionFunc, els) {
    els = els || {};

    if (quad.level < quad.maxLevel) {
      var indexes = collisionFunc(rectData, quad.corners);

      for (var i = 0, l = indexes.length; i < l; i++)
        if (quad.nodes[indexes[i]] !== undefined)
          _quadRetrieveArea(
            rectData,
            quad.nodes[indexes[i]],
            collisionFunc,
            els
          );
    } else
      for (var j = 0, m = quad.elements.length; j < m; j++)
        if (els[quad.elements[j].id] === undefined)
          els[quad.elements[j].id] = quad.elements[j];

    return els;
  }

  /**
   * Creates the quadtree object itself.
   *
   * @param  {object}   bounds       The boundaries of the quad defined by an
   *                                 origin (x, y), width and heigth.
   * @param  {integer}  level        The level of the quad in the tree.
   * @param  {integer}  maxElements  The max number of element in a leaf node.
   * @param  {integer}  maxLevel     The max recursion level of the tree.
   * @return {object}                The quadtree object.
   */
  function _quadTree(bounds, level, maxElements, maxLevel) {
    return {
      level: level || 0,
      bounds: bounds,
      corners: _geom.splitSquare(bounds),
      maxElements: maxElements || 40,
      maxLevel: maxLevel || 8,
      elements: [],
      nodes: []
    };
  }


  /**
   * Sigma Quad Constructor
   * ----------------------
   *
   * The edgequad API as exposed to sigma.
   */

  /**
   * The edgequad core that will become the sigma interface with the quadtree.
   *
   * property {object} _tree     Property holding the quadtree object.
   * property {object} _geom     Exposition of the _geom namespace for testing.
   * property {object} _cache    Cache for the area method.
   * property {boolean} _enabled Can index and retreive elements.
   */
  var edgequad = function() {
    this._geom = _geom;
    this._tree = null;
    this._cache = {
      query: false,
      result: false
    };
    this._enabled = true;
  };

  /**
   * Index a graph by inserting its edges into the quadtree.
   *
   * @param  {object} graph   A graph instance.
   * @param  {object} params  An object of parameters with at least the quad
   *                          bounds.
   * @return {object}         The quadtree object.
   *
   * Parameters:
   * ----------
   * bounds:      {object}   boundaries of the quad defined by its origin (x, y)
   *                         width and heigth.
   * prefix:      {string?}  a prefix for edge geometric attributes.
   * maxElements: {integer?} the max number of elements in a leaf node.
   * maxLevel:    {integer?} the max recursion level of the tree.
   */
  edgequad.prototype.index = function(graph, params) {
    if (!this._enabled)
      return this._tree;

    // Enforcing presence of boundaries
    if (!params.bounds)
      throw 'sigma.classes.edgequad.index: bounds information not given.';

    // Prefix
    var prefix = params.prefix || '',
        cp,
        source,
        target,
        n,
        e;

    // Building the tree
    this._tree = _quadTree(
      params.bounds,
      0,
      params.maxElements,
      params.maxLevel
    );

    var edges = graph.edges();

    // Inserting graph edges into the tree
    for (var i = 0, l = edges.length; i < l; i++) {
      source = graph.nodes(edges[i].source);
      target = graph.nodes(edges[i].target);
      e = {
        x1: source[prefix + 'x'],
        y1: source[prefix + 'y'],
        x2: target[prefix + 'x'],
        y2: target[prefix + 'y'],
        size: edges[i][prefix + 'size'] || 0
      };

      // Inserting edge
      if (edges[i].type === 'curve' || edges[i].type === 'curvedArrow') {
        if (source.id === target.id) {
          n = {
            x: source[prefix + 'x'],
            y: source[prefix + 'y'],
            size: source[prefix + 'size'] || 0
          };
          _quadInsert(
            edges[i],
            _geom.selfLoopToSquare(n),
            this._tree);
        }
        else {
          cp = sigma.utils.getQuadraticControlPoint(e.x1, e.y1, e.x2, e.y2);
          _quadInsert(
            edges[i],
            _geom.quadraticCurveToSquare(e, cp),
            this._tree);
        }
      }
      else {
        _quadInsert(
          edges[i],
          _geom.lineToSquare(e),
          this._tree);
      }
    }

    // Reset cache:
    this._cache = {
      query: false,
      result: false
    };

    // remove?
    return this._tree;
  };

  /**
   * Retrieve every graph edges held by the quadtree node containing the
   * searched point.
   *
   * @param  {number} x of the point.
   * @param  {number} y of the point.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.point = function(x, y) {
    if (!this._enabled)
      return [];

    return this._tree ?
      _quadRetrievePoint({x: x, y: y}, this._tree) || [] :
      [];
  };

  /**
   * Retrieve every graph edges within a rectangular area. The methods keep the
   * last area queried in cache for optimization reason and will act differently
   * for the same reason if the area is axis-aligned or not.
   *
   * @param  {object} A rectangle defined by two top points (x1, y1), (x2, y2)
   *                  and height.
   * @return {array}  An array of edges retrieved.
   */
  edgequad.prototype.area = function(rect) {
    if (!this._enabled)
      return [];

    var serialized = JSON.stringify(rect),
        collisionFunc,
        rectData;

    // Returning cache?
    if (this._cache.query === serialized)
      return this._cache.result;

    // Axis aligned ?
    if (_geom.isAxisAligned(rect)) {
      collisionFunc = _quadIndexes;
      rectData = _geom.axisAlignedTopPoints(rect);
    }
    else {
      collisionFunc = _quadCollision;
      rectData = _geom.rectangleCorners(rect);
    }

    // Retrieving edges
    var edges = this._tree ?
      _quadRetrieveArea(
        rectData,
        this._tree,
        collisionFunc
      ) :
      [];

    // Object to array
    var edgesArray = [];
    for (var i in edges)
      edgesArray.push(edges[i]);

    // Caching
    this._cache.query = serialized;
    this._cache.result = edgesArray;

    return edgesArray;
  };


  /**
   * EXPORT:
   * *******
   */
  if (typeof this.sigma !== 'undefined') {
    this.sigma.classes = this.sigma.classes || {};
    this.sigma.classes.edgequad = edgequad;
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      exports = module.exports = edgequad;
    exports.edgequad = edgequad;
  } else
    this.edgequad = edgequad;
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.mouse = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // MOUSE MANAGEMENT:
        // *****************
        // The mouse position when the user starts dragging:
        _startMouseX,
        _startMouseY,

        _isMouseDown,
        _isMoving,
        _hasDragged,
        _downStartTime,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'click', _doubleClickHandler);
    _target.addEventListener('DOMMouseScroll', _wheelHandler, false);
    _target.addEventListener('mousewheel', _wheelHandler, false);
    _target.addEventListener('mousemove', _moveHandler, false);
    _target.addEventListener('mousedown', _downHandler, false);
    _target.addEventListener('click', _clickHandler, false);
    _target.addEventListener('mouseout', _outHandler, false);
    document.addEventListener('mouseup', _upHandler, false);




    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'click');
      _target.removeEventListener('DOMMouseScroll', _wheelHandler);
      _target.removeEventListener('mousewheel', _wheelHandler);
      _target.removeEventListener('mousemove', _moveHandler);
      _target.removeEventListener('mousedown', _downHandler);
      _target.removeEventListener('click', _clickHandler);
      _target.removeEventListener('mouseout', _outHandler);
      document.removeEventListener('mouseup', _upHandler);
    };




    // MOUSE EVENTS:
    // *************

    /**
     * The handler listening to the 'move' mouse event. It will effectively
     * drag the graph.
     *
     * @param {event} e A mouse event.
     */
    function _moveHandler(e) {
      var x,
          y,
          pos;

      // Dispatch event:
      if (_settings('mouseEnabled')) {
        _self.dispatchEvent('mousemove',
          sigma.utils.mouseCoords(e));

        if (_isMouseDown) {
          _isMoving = true;
          _hasDragged = true;

          if (_movingTimeoutId)
            clearTimeout(_movingTimeoutId);

          _movingTimeoutId = setTimeout(function() {
            _isMoving = false;
          }, _settings('dragTimeout'));

          sigma.misc.animation.killAll(_camera);

          _camera.isMoving = true;
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - _startMouseX,
            sigma.utils.getY(e) - _startMouseY,
            true
          );

          x = _startCameraX - pos.x;
          y = _startCameraY - pos.y;

          if (x !== _camera.x || y !== _camera.y) {
            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _camera.goTo({
              x: x,
              y: y
            });
          }

          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;

          e.stopPropagation();
          return false;
        }
      }
    }

    /**
     * The handler listening to the 'up' mouse event. It will stop dragging the
     * graph.
     *
     * @param {event} e A mouse event.
     */
    function _upHandler(e) {
      if (_settings('mouseEnabled') && _isMouseDown) {
        _isMouseDown = false;
        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _camera.isMoving = false;

        var x = sigma.utils.getX(e),
            y = sigma.utils.getY(e);

        if (_isMoving) {
          sigma.misc.animation.killAll(_camera);
          sigma.misc.animation.camera(
            _camera,
            {
              x: _camera.x +
                _settings('mouseInertiaRatio') * (_camera.x - _lastCameraX),
              y: _camera.y +
                _settings('mouseInertiaRatio') * (_camera.y - _lastCameraY)
            },
            {
              easing: 'quadraticOut',
              duration: _settings('mouseInertiaDuration')
            }
          );
        } else if (
          _startMouseX !== x ||
          _startMouseY !== y
        )
          _camera.goTo({
            x: _camera.x,
            y: _camera.y
          });

        _self.dispatchEvent('mouseup',
          sigma.utils.mouseCoords(e));

        // Update _isMoving flag:
        _isMoving = false;
      }
    }

    /**
     * The handler listening to the 'down' mouse event. It will start observing
     * the mouse position for dragging the graph.
     *
     * @param {event} e A mouse event.
     */
    function _downHandler(e) {
      if (_settings('mouseEnabled')) {
        _startCameraX = _camera.x;
        _startCameraY = _camera.y;

        _lastCameraX = _camera.x;
        _lastCameraY = _camera.y;

        _startMouseX = sigma.utils.getX(e);
        _startMouseY = sigma.utils.getY(e);

        _hasDragged = false;
        _downStartTime = (new Date()).getTime();

        switch (e.which) {
          case 2:
            // Middle mouse button pressed
            // Do nothing.
            break;
          case 3:
            // Right mouse button pressed
            _self.dispatchEvent('rightclick',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
            break;
          // case 1:
          default:
            // Left mouse button pressed
            _isMouseDown = true;

            _self.dispatchEvent('mousedown',
              sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));
        }
      }
    }

    /**
     * The handler listening to the 'out' mouse event. It will just redispatch
     * the event.
     *
     * @param {event} e A mouse event.
     */
    function _outHandler(e) {
      if (_settings('mouseEnabled'))
        _self.dispatchEvent('mouseout');
    }

    /**
     * The handler listening to the 'click' mouse event. It will redispatch the
     * click event, but with normalized X and Y coordinates.
     *
     * @param {event} e A mouse event.
     */
    function _clickHandler(e) {
      if (_settings('mouseEnabled')) {
        var event = sigma.utils.mouseCoords(e);
        event.isDragging =
          (((new Date()).getTime() - _downStartTime) > 100) && _hasDragged;
        _self.dispatchEvent('click', event);
      }

      if (e.preventDefault)
        e.preventDefault();
      else
        e.returnValue = false;

      e.stopPropagation();
      return false;
    }

    /**
     * The handler listening to the double click custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _doubleClickHandler(e) {
      var pos,
          ratio,
          animation;

      if (_settings('mouseEnabled')) {
        ratio = 1 / _settings('doubleClickZoomingRatio');

        _self.dispatchEvent('doubleclick',
            sigma.utils.mouseCoords(e, _startMouseX, _startMouseY));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
            sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration')
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }

    /**
     * The handler listening to the 'wheel' mouse event. It will basically zoom
     * in or not into the graph.
     *
     * @param {event} e A mouse event.
     */
    function _wheelHandler(e) {
      var pos,
          ratio,
          animation,
          wheelDelta = sigma.utils.getDelta(e);

      if (_settings('mouseEnabled') && _settings('mouseWheelEnabled') && wheelDelta !== 0) {
        ratio = wheelDelta > 0 ?
          1 / _settings('zoomingRatio') :
          _settings('zoomingRatio');

        pos = _camera.cameraPosition(
          sigma.utils.getX(e) - sigma.utils.getCenter(e).x,
          sigma.utils.getY(e) - sigma.utils.getCenter(e).y,
          true
        );

        animation = {
          duration: _settings('mouseZoomDuration')
        };

        sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.captors');

  /**
   * The user inputs default captor. It deals with mouse events, keyboards
   * events and touch events.
   *
   * @param  {DOMElement}   target   The DOM element where the listeners will be
   *                                 bound.
   * @param  {camera}       camera   The camera related to the target.
   * @param  {configurable} settings The settings function.
   * @return {sigma.captor}          The fresh new captor instance.
   */
  sigma.captors.touch = function(target, camera, settings) {
    var _self = this,
        _target = target,
        _camera = camera,
        _settings = settings,

        // CAMERA MANAGEMENT:
        // ******************
        // The camera position when the user starts dragging:
        _startCameraX,
        _startCameraY,
        _startCameraAngle,
        _startCameraRatio,

        // The latest stage position:
        _lastCameraX,
        _lastCameraY,
        _lastCameraAngle,
        _lastCameraRatio,

        // TOUCH MANAGEMENT:
        // *****************
        // Touches that are down:
        _downTouches = [],

        _startTouchX0,
        _startTouchY0,
        _startTouchX1,
        _startTouchY1,
        _startTouchAngle,
        _startTouchDistance,

        _touchMode,

        _isMoving,
        _doubleTap,
        _movingTimeoutId;

    sigma.classes.dispatcher.extend(this);

    sigma.utils.doubleClick(_target, 'touchstart', _doubleTapHandler);
    _target.addEventListener('touchstart', _handleStart, false);
    _target.addEventListener('touchend', _handleLeave, false);
    _target.addEventListener('touchcancel', _handleLeave, false);
    _target.addEventListener('touchleave', _handleLeave, false);
    _target.addEventListener('touchmove', _handleMove, false);

    function position(e) {
      var offset = sigma.utils.getOffset(_target);

      return {
        x: e.pageX - offset.left,
        y: e.pageY - offset.top
      };
    }

    /**
     * This method unbinds every handlers that makes the captor work.
     */
    this.kill = function() {
      sigma.utils.unbindDoubleClick(_target, 'touchstart');
      _target.addEventListener('touchstart', _handleStart);
      _target.addEventListener('touchend', _handleLeave);
      _target.addEventListener('touchcancel', _handleLeave);
      _target.addEventListener('touchleave', _handleLeave);
      _target.addEventListener('touchmove', _handleMove);
    };

    // TOUCH EVENTS:
    // *************
    /**
     * The handler listening to the 'touchstart' event. It will set the touch
     * mode ("_touchMode") and start observing the user touch moves.
     *
     * @param {event} e A touch event.
     */
    function _handleStart(e) {
      if (_settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            pos0,
            pos1;

        _downTouches = e.touches;

        switch (_downTouches.length) {
          case 1:
            _camera.isMoving = true;
            _touchMode = 1;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            pos0 = position(_downTouches[0]);
            _startTouchX0 = pos0.x;
            _startTouchY0 = pos0.y;

            break;
          case 2:
            _camera.isMoving = true;
            _touchMode = 2;

            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            _lastCameraX = _camera.x;
            _lastCameraY = _camera.y;

            _startCameraAngle = _camera.angle;
            _startCameraRatio = _camera.ratio;

            _startCameraX = _camera.x;
            _startCameraY = _camera.y;

            _startTouchX0 = x0;
            _startTouchY0 = y0;
            _startTouchX1 = x1;
            _startTouchY1 = y1;

            _startTouchAngle = Math.atan2(
              _startTouchY1 - _startTouchY0,
              _startTouchX1 - _startTouchX0
            );
            _startTouchDistance = Math.sqrt(
              (_startTouchY1 - _startTouchY0) *
                (_startTouchY1 - _startTouchY0) +
              (_startTouchX1 - _startTouchX0) *
                (_startTouchX1 - _startTouchX0)
            );

            e.preventDefault();
            return false;
        }
      }
    }

    /**
     * The handler listening to the 'touchend', 'touchcancel' and 'touchleave'
     * event. It will update the touch mode if there are still at least one
     * finger, and stop dragging else.
     *
     * @param {event} e A touch event.
     */
    function _handleLeave(e) {
      if (_settings('touchEnabled')) {
        _downTouches = e.touches;
        var inertiaRatio = _settings('touchInertiaRatio');

        if (_movingTimeoutId) {
          _isMoving = false;
          clearTimeout(_movingTimeoutId);
        }

        switch (_touchMode) {
          case 2:
            if (e.touches.length === 1) {
              _handleStart(e);

              e.preventDefault();
              break;
            }
            /* falls through */
          case 1:
            _camera.isMoving = false;
            _self.dispatchEvent('stopDrag');

            if (_isMoving) {
              _doubleTap = false;
              sigma.misc.animation.camera(
                _camera,
                {
                  x: _camera.x +
                    inertiaRatio * (_camera.x - _lastCameraX),
                  y: _camera.y +
                    inertiaRatio * (_camera.y - _lastCameraY)
                },
                {
                  easing: 'quadraticOut',
                  duration: _settings('touchInertiaDuration')
                }
              );
            }

            _isMoving = false;
            _touchMode = 0;
            break;
        }
      }
    }

    /**
     * The handler listening to the 'touchmove' event. It will effectively drag
     * the graph, and eventually zooms and turn it if the user is using two
     * fingers.
     *
     * @param {event} e A touch event.
     */
    function _handleMove(e) {
      if (!_doubleTap && _settings('touchEnabled')) {
        var x0,
            x1,
            y0,
            y1,
            cos,
            sin,
            end,
            pos0,
            pos1,
            diff,
            start,
            dAngle,
            dRatio,
            newStageX,
            newStageY,
            newStageRatio,
            newStageAngle;

        _downTouches = e.touches;
        _isMoving = true;

        if (_movingTimeoutId)
          clearTimeout(_movingTimeoutId);

        _movingTimeoutId = setTimeout(function() {
          _isMoving = false;
        }, _settings('dragTimeout'));

        switch (_touchMode) {
          case 1:
            pos0 = position(_downTouches[0]);
            x0 = pos0.x;
            y0 = pos0.y;

            diff = _camera.cameraPosition(
              x0 - _startTouchX0,
              y0 - _startTouchY0,
              true
            );

            newStageX = _startCameraX - diff.x;
            newStageY = _startCameraY - diff.y;

            if (newStageX !== _camera.x || newStageY !== _camera.y) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;

              _camera.goTo({
                x: newStageX,
                y: newStageY
              });

              _self.dispatchEvent('mousemove',
                sigma.utils.mouseCoords(e, pos0.x, pos0.y));

              _self.dispatchEvent('drag');
            }
            break;
          case 2:
            pos0 = position(_downTouches[0]);
            pos1 = position(_downTouches[1]);
            x0 = pos0.x;
            y0 = pos0.y;
            x1 = pos1.x;
            y1 = pos1.y;

            start = _camera.cameraPosition(
              (_startTouchX0 + _startTouchX1) / 2 -
                sigma.utils.getCenter(e).x,
              (_startTouchY0 + _startTouchY1) / 2 -
                sigma.utils.getCenter(e).y,
              true
            );
            end = _camera.cameraPosition(
              (x0 + x1) / 2 - sigma.utils.getCenter(e).x,
              (y0 + y1) / 2 - sigma.utils.getCenter(e).y,
              true
            );

            dAngle = Math.atan2(y1 - y0, x1 - x0) - _startTouchAngle;
            dRatio = Math.sqrt(
              (y1 - y0) * (y1 - y0) + (x1 - x0) * (x1 - x0)
            ) / _startTouchDistance;

            // Translation:
            x0 = start.x;
            y0 = start.y;

            // Homothetic transformation:
            newStageRatio = _startCameraRatio / dRatio;
            x0 = x0 * dRatio;
            y0 = y0 * dRatio;

            // Rotation:
            newStageAngle = _startCameraAngle - dAngle;
            cos = Math.cos(-dAngle);
            sin = Math.sin(-dAngle);
            x1 = x0 * cos + y0 * sin;
            y1 = y0 * cos - x0 * sin;
            x0 = x1;
            y0 = y1;

            // Finalize:
            newStageX = x0 - end.x + _startCameraX;
            newStageY = y0 - end.y + _startCameraY;

            if (
              newStageRatio !== _camera.ratio ||
              newStageAngle !== _camera.angle ||
              newStageX !== _camera.x ||
              newStageY !== _camera.y
            ) {
              _lastCameraX = _camera.x;
              _lastCameraY = _camera.y;
              _lastCameraAngle = _camera.angle;
              _lastCameraRatio = _camera.ratio;

              _camera.goTo({
                x: newStageX,
                y: newStageY,
                angle: newStageAngle,
                ratio: newStageRatio
              });

              _self.dispatchEvent('drag');
            }

            break;
        }

        e.preventDefault();
        return false;
      }
    }

    /**
     * The handler listening to the double tap custom event. It will
     * basically zoom into the graph.
     *
     * @param {event} e A touch event.
     */
    function _doubleTapHandler(e) {
      var pos,
          ratio,
          animation;

      if (e.touches && e.touches.length === 1 && _settings('touchEnabled')) {
        _doubleTap = true;

        ratio = 1 / _settings('doubleClickZoomingRatio');

        pos = position(e.touches[0]);
        _self.dispatchEvent('doubleclick',
          sigma.utils.mouseCoords(e, pos.x, pos.y));

        if (_settings('doubleClickEnabled')) {
          pos = _camera.cameraPosition(
            pos.x - sigma.utils.getCenter(e).x,
            pos.y - sigma.utils.getCenter(e).y,
            true
          );

          animation = {
            duration: _settings('doubleClickZoomDuration'),
            onComplete: function() {
              _doubleTap = false;
            }
          };

          sigma.utils.zoomTo(_camera, pos.x, pos.y, ratio, animation);
        }

        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;

        e.stopPropagation();
        return false;
      }
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.canvas = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.canvas: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Node indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Conrad related attributes:
    this.jobs = {};

    // Find the prefix:
    this.options.prefix = 'renderer' + this.conradId + ':';

    // Initialize the DOM elements:
    if (
      !this.settings('batchEdgesDrawing')
    ) {
      this.initDOM('canvas', 'scene');
      this.contexts.edges = this.contexts.scene;
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    } else {
      this.initDOM('canvas', 'edges');
      this.initDOM('canvas', 'scene');
      this.contexts.nodes = this.contexts.scene;
      this.contexts.labels = this.contexts.scene;
    }

    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.options.prefix);
    sigma.misc.drawHovers.call(this, this.options.prefix);

    this.resize(false);
  };




  /**
   * This method renders the graph on the canvases.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.canvas}         Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        l,
        o,
        id,
        end,
        job,
        start,
        edges,
        renderers,
        rendererType,
        batchSize,
        tempGCO,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdgeLabels = this.settings(options, 'drawEdgeLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix
        });

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Clear canvases:
    this.clear();

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    // Find which nodes are on screen:
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Draw edges:
    // - If settings('batchEdgesDrawing') is true, the edges are displayed per
    //   batches. If not, they are drawn in one frame.
    if (drawEdges) {
      // First, let's identify which edges to draw. To do this, we just keep
      // every edges that have at least one extremity displayed according to
      // the quadtree and the "hidden" attribute. We also do not keep hidden
      // edges.
      for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
        o = a[i];
        if (
          (index[o.source] || index[o.target]) &&
          (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
        )
          this.edgesOnScreen.push(o);
      }

      // If the "batchEdgesDrawing" settings is true, edges are batched:
      if (this.settings(options, 'batchEdgesDrawing')) {
        id = 'edges_' + this.conradId;
        batchSize = embedSettings('canvasEdgesBatchSize');

        edges = this.edgesOnScreen;
        l = edges.length;

        start = 0;
        end = Math.min(edges.length, start + batchSize);

        job = function() {
          tempGCO = this.contexts.edges.globalCompositeOperation;
          this.contexts.edges.globalCompositeOperation = 'destination-over';

          renderers = sigma.canvas.edges;
          for (i = start; i < end; i++) {
            o = edges[i];
            (renderers[
              o.type || this.settings(options, 'defaultEdgeType')
            ] || renderers.def)(
              o,
              graph.nodes(o.source),
              graph.nodes(o.target),
              this.contexts.edges,
              embedSettings
            );
          }

          // Draw edge labels:
          if (drawEdgeLabels) {
            renderers = sigma.canvas.edges.labels;
            for (i = start; i < end; i++) {
              o = edges[i];
              if (!o.hidden)
                (renderers[
                  o.type || this.settings(options, 'defaultEdgeType')
                ] || renderers.def)(
                  o,
                  graph.nodes(o.source),
                  graph.nodes(o.target),
                  this.contexts.labels,
                  embedSettings
                );
            }
          }

          // Restore original globalCompositeOperation:
          this.contexts.edges.globalCompositeOperation = tempGCO;

          // Catch job's end:
          if (end === edges.length) {
            delete this.jobs[id];
            return false;
          }

          start = end + 1;
          end = Math.min(edges.length, start + batchSize);
          return true;
        };

        this.jobs[id] = job;
        conrad.addJob(id, job.bind(this));

      // If not, they are drawn in one frame:
      } else {
        renderers = sigma.canvas.edges;
        for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
          o = a[i];
          (renderers[
            o.type || this.settings(options, 'defaultEdgeType')
          ] || renderers.def)(
            o,
            graph.nodes(o.source),
            graph.nodes(o.target),
            this.contexts.edges,
            embedSettings
          );
        }

        // Draw edge labels:
        // - No batching
        if (drawEdgeLabels) {
          renderers = sigma.canvas.edges.labels;
          for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++)
            if (!a[i].hidden)
              (renderers[
                a[i].type || this.settings(options, 'defaultEdgeType')
              ] || renderers.def)(
                a[i],
                graph.nodes(a[i].source),
                graph.nodes(a[i].target),
                this.contexts.labels,
                embedSettings
              );
        }
      }
    }

    // Draw nodes:
    // - No batching
    if (drawNodes) {
      renderers = sigma.canvas.nodes;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.nodes,
            embedSettings
          );
    }

    // Draw labels:
    // - No batching
    if (drawLabels) {
      renderers = sigma.canvas.labels;
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (renderers[
            a[i].type || this.settings(options, 'defaultNodeType')
          ] || renderers.def)(
            a[i],
            this.contexts.labels,
            embedSettings
          );
    }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.canvas.prototype.initDOM = function(tag, id) {
    var dom = document.createElement(tag);

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas')
      this.contexts[id] = dom.getContext('2d');
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.canvas}        Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
          this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

          if (pixelRatio !== 1)
            this.contexts[k].scale(pixelRatio, pixelRatio);
        }
      }
    }

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.canvas} Returns the instance itself.
   */
  sigma.renderers.canvas.prototype.clear = function() {
    for (var k in this.contexts) {
      this.contexts[k].clearRect(0, 0, this.width, this.height);
    }

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.canvas.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./canvas" folder.
   */
  sigma.utils.pkg('sigma.canvas.nodes');
  sigma.utils.pkg('sigma.canvas.edges');
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the canvas sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.canvas}          The renderer instance.
   */
  sigma.renderers.webgl = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.webgl: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var k,
        i,
        l,
        a,
        fn,
        _self = this;

    sigma.classes.dispatcher.extend(this);

    // Conrad related attributes:
    this.jobs = {};

    Object.defineProperty(this, 'conradId', {
      value: sigma.utils.id()
    });

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.contexts = {};
    this.domElements = {};
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Find the prefix:
    this.options.prefix = this.camera.readPrefix;

    // Initialize programs hash
    Object.defineProperty(this, 'nodePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'edgePrograms', {
      value: {}
    });
    Object.defineProperty(this, 'nodeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeFloatArrays', {
      value: {}
    });
    Object.defineProperty(this, 'edgeIndicesArrays', {
      value: {}
    });

    // Initialize the DOM elements:
    if (this.settings(options, 'batchEdgesDrawing')) {
      this.initDOM('canvas', 'edges', true);
      this.initDOM('canvas', 'nodes', true);
    } else {
      this.initDOM('canvas', 'scene', true);
      this.contexts.nodes = this.contexts.scene;
      this.contexts.edges = this.contexts.scene;
    }

    this.initDOM('canvas', 'labels');
    this.initDOM('canvas', 'mouse');
    this.contexts.hover = this.contexts.mouse;

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.mouse,
          this.camera,
          this.settings
        )
      );
    }

    // Deal with sigma events:
    sigma.misc.bindEvents.call(this, this.camera.prefix);
    sigma.misc.drawHovers.call(this, this.camera.prefix);

    this.resize();
  };




  /**
   * This method will generate the nodes and edges float arrays. This step is
   * separated from the "render" method, because to keep WebGL efficient, since
   * all the camera and middlewares are modelised as matrices and they do not
   * require the float arrays to be regenerated.
   *
   * Basically, when the user moves the camera or applies some specific linear
   * transformations, this process step will be skipped, and the "render"
   * method will efficiently refresh the rendering.
   *
   * And when the user modifies the graph colors or positions (applying a new
   * layout or filtering the colors, for instance), this "process" step will be
   * required to regenerate the float arrays.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.process = function() {
    var a,
        i,
        l,
        k,
        type,
        renderer,
        graph = this.graph,
        options = sigma.utils.extend(options, this.options),
        defaultEdgeType = this.settings(options, 'defaultEdgeType'),
        defaultNodeType = this.settings(options, 'defaultNodeType');

    // Empty float arrays:
    for (k in this.nodeFloatArrays)
      delete this.nodeFloatArrays[k];

    for (k in this.edgeFloatArrays)
      delete this.edgeFloatArrays[k];

    for (k in this.edgeIndicesArrays)
      delete this.edgeIndicesArrays[k];

    // Sort edges and nodes per types:
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultEdgeType;
      k = (type && sigma.webgl.edges[type]) ? type : 'def';

      if (!this.edgeFloatArrays[k])
        this.edgeFloatArrays[k] = {
          edges: []
        };

      this.edgeFloatArrays[k].edges.push(a[i]);
    }

    for (a = graph.nodes(), i = 0, l = a.length; i < l; i++) {
      type = a[i].type || defaultNodeType;
      k = (type && sigma.webgl.nodes[type]) ? type : 'def';

      if (!this.nodeFloatArrays[k])
        this.nodeFloatArrays[k] = {
          nodes: []
        };

      this.nodeFloatArrays[k].nodes.push(a[i]);
    }

    // Push edges:
    for (k in this.edgeFloatArrays) {
      renderer = sigma.webgl.edges[k];
      a = this.edgeFloatArrays[k].edges;

      // Creating the necessary arrays
      this.edgeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden &&
          !graph.nodes(a[i].source).hidden &&
          !graph.nodes(a[i].target).hidden
        )
          renderer.addEdge(
            a[i],
            graph.nodes(a[i].source),
            graph.nodes(a[i].target),
            this.edgeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }

      if (typeof renderer.computeIndices === 'function')
        this.edgeIndicesArrays[k] = renderer.computeIndices(
          this.edgeFloatArrays[k].array
        );
    }

    // Push nodes:
    for (k in this.nodeFloatArrays) {
      renderer = sigma.webgl.nodes[k];
      a = this.nodeFloatArrays[k].nodes;

      // Creating the necessary arrays
      this.nodeFloatArrays[k].array = new Float32Array(
        a.length * renderer.POINTS * renderer.ATTRIBUTES
      );

      for (i = 0, l = a.length; i < l; i++) {
        if (!this.nodeFloatArrays[k].array)
          this.nodeFloatArrays[k].array = new Float32Array(
            a.length * renderer.POINTS * renderer.ATTRIBUTES
          );

        // Just check that the edge and both its extremities are visible:
        if (
          !a[i].hidden
        )
          renderer.addNode(
            a[i],
            this.nodeFloatArrays[k].array,
            i * renderer.POINTS * renderer.ATTRIBUTES,
            options.prefix,
            this.settings
          );
      }
    }

    return this;
  };




  /**
   * This method renders the graph. It basically calls each program (and
   * generate them if they do not exist yet) to render nodes and edges, batched
   * per renderer.
   *
   * As in the canvas renderer, it is possible to display edges, nodes and / or
   * labels in batches, to make the whole thing way more scalable.
   *
   * @param  {?object}               params Eventually an object of options.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.render = function(params) {
    var a,
        i,
        l,
        k,
        o,
        program,
        renderer,
        self = this,
        graph = this.graph,
        nodesGl = this.contexts.nodes,
        edgesGl = this.contexts.edges,
        matrix = this.camera.getMatrix(),
        options = sigma.utils.extend(params, this.options),
        drawLabels = this.settings(options, 'drawLabels'),
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes');

    // Call the resize function:
    this.resize(false);

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Clear canvases:
    this.clear();

    // Translate matrix to [width/2, height/2]:
    matrix = sigma.utils.matrices.multiply(
      matrix,
      sigma.utils.matrices.translation(this.width / 2, this.height / 2)
    );

    // Kill running jobs:
    for (k in this.jobs)
      if (conrad.hasJob(k))
        conrad.killJob(k);

    if (drawEdges) {
      if (this.settings(options, 'batchEdgesDrawing'))
        (function() {
          var a,
              k,
              i,
              id,
              job,
              arr,
              end,
              start,
              indices,
              renderer,
              batchSize,
              currentProgram;

          id = 'edges_' + this.conradId;
          batchSize = this.settings(options, 'webglEdgesBatchSize');
          a = Object.keys(this.edgeFloatArrays);

          if (!a.length)
            return;
          i = 0;
          renderer = sigma.webgl.edges[a[i]];
          arr = this.edgeFloatArrays[a[i]].array;
          indices = this.edgeIndicesArrays[a[i]];
          start = 0;
          end = Math.min(
            start + batchSize * renderer.POINTS,
            arr.length / renderer.ATTRIBUTES
          );

          job = function() {
            // Check program:
            if (!this.edgePrograms[a[i]])
              this.edgePrograms[a[i]] = renderer.initProgram(edgesGl);

            if (start < end) {
              edgesGl.useProgram(this.edgePrograms[a[i]]);
              renderer.render(
                edgesGl,
                this.edgePrograms[a[i]],
                arr,
                {
                  settings: this.settings,
                  matrix: matrix,
                  width: this.width,
                  height: this.height,
                  ratio: this.camera.ratio,
                  scalingRatio: this.settings(
                    options,
                    'webglOversamplingRatio'
                  ),
                  start: start,
                  count: end - start,
                  indicesData: indices
                }
              );
            }

            // Catch job's end:
            if (
              end >= arr.length / renderer.ATTRIBUTES &&
              i === a.length - 1
            ) {
              delete this.jobs[id];
              return false;
            }

            if (end >= arr.length / renderer.ATTRIBUTES) {
              i++;
              arr = this.edgeFloatArrays[a[i]].array;
              renderer = sigma.webgl.edges[a[i]];
              start = 0;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            } else {
              start = end;
              end = Math.min(
                start + batchSize * renderer.POINTS,
                arr.length / renderer.ATTRIBUTES
              );
            }

            return true;
          };

          this.jobs[id] = job;
          conrad.addJob(id, job.bind(this));
        }).call(this);
      else {
        for (k in this.edgeFloatArrays) {
          renderer = sigma.webgl.edges[k];

          // Check program:
          if (!this.edgePrograms[k])
            this.edgePrograms[k] = renderer.initProgram(edgesGl);

          // Render
          if (this.edgeFloatArrays[k]) {
            edgesGl.useProgram(this.edgePrograms[k]);
            renderer.render(
              edgesGl,
              this.edgePrograms[k],
              this.edgeFloatArrays[k].array,
              {
                settings: this.settings,
                matrix: matrix,
                width: this.width,
                height: this.height,
                ratio: this.camera.ratio,
                scalingRatio: this.settings(options, 'webglOversamplingRatio'),
                indicesData: this.edgeIndicesArrays[k]
              }
            );
          }
        }
      }
    }

    if (drawNodes) {
      // Enable blending:
      nodesGl.blendFunc(nodesGl.SRC_ALPHA, nodesGl.ONE_MINUS_SRC_ALPHA);
      nodesGl.enable(nodesGl.BLEND);

      for (k in this.nodeFloatArrays) {
        renderer = sigma.webgl.nodes[k];

        // Check program:
        if (!this.nodePrograms[k])
          this.nodePrograms[k] = renderer.initProgram(nodesGl);

        // Render
        if (this.nodeFloatArrays[k]) {
          nodesGl.useProgram(this.nodePrograms[k]);
          renderer.render(
            nodesGl,
            this.nodePrograms[k],
            this.nodeFloatArrays[k].array,
            {
              settings: this.settings,
              matrix: matrix,
              width: this.width,
              height: this.height,
              ratio: this.camera.ratio,
              scalingRatio: this.settings(options, 'webglOversamplingRatio')
            }
          );
        }
      }
    }

    if (drawLabels) {
      a = this.camera.quadtree.area(
        this.camera.getRectangle(this.width, this.height)
      );

      // Apply camera view to these nodes:
      this.camera.applyView(
        undefined,
        undefined,
        {
          nodes: a,
          edges: [],
          width: this.width,
          height: this.height
        }
      );

      o = function(key) {
        return self.settings({
          prefix: self.camera.prefix
        }, key);
      };

      for (i = 0, l = a.length; i < l; i++)
        if (!a[i].hidden)
          (
            sigma.canvas.labels[
              a[i].type ||
              this.settings(options, 'defaultNodeType')
            ] || sigma.canvas.labels.def
          )(a[i], this.contexts.labels, o);
    }

    this.dispatchEvent('render');

    return this;
  };




  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string}   tag   The label tag.
   * @param  {string}   id    The id of the element (to store it in
   *                          "domElements").
   * @param  {?boolean} webgl Will init the WebGL context if true.
   */
  sigma.renderers.webgl.prototype.initDOM = function(tag, id, webgl) {
    var gl,
        dom = document.createElement(tag),
        self = this;

    dom.style.position = 'absolute';
    dom.setAttribute('class', 'sigma-' + id);

    this.domElements[id] = dom;
    this.container.appendChild(dom);

    if (tag.toLowerCase() === 'canvas') {
      this.contexts[id] = dom.getContext(webgl ? 'experimental-webgl' : '2d', {
        preserveDrawingBuffer: true
      });

      // Adding webgl context loss listeners
      if (webgl) {
        dom.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        }, false);

        dom.addEventListener('webglcontextrestored', function(e) {
          self.render();
        }, false);
      }
    }
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}               width  The new width of the container.
   * @param  {?number}               height The new height of the container.
   * @return {sigma.renderers.webgl}        Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.resize = function(w, h) {
    var k,
        oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = sigma.utils.getPixelRatio();

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      for (k in this.domElements) {
        this.domElements[k].style.width = w + 'px';
        this.domElements[k].style.height = h + 'px';

        if (this.domElements[k].tagName.toLowerCase() === 'canvas') {
          // If simple 2D canvas:
          if (this.contexts[k] && this.contexts[k].scale) {
            this.domElements[k].setAttribute('width', (w * pixelRatio) + 'px');
            this.domElements[k].setAttribute('height', (h * pixelRatio) + 'px');

            if (pixelRatio !== 1)
              this.contexts[k].scale(pixelRatio, pixelRatio);
          } else {
            this.domElements[k].setAttribute(
              'width',
              (w * this.settings('webglOversamplingRatio')) + 'px'
            );
            this.domElements[k].setAttribute(
              'height',
              (h * this.settings('webglOversamplingRatio')) + 'px'
            );
          }
        }
      }
    }

    // Scale:
    for (k in this.contexts)
      if (this.contexts[k] && this.contexts[k].viewport)
        this.contexts[k].viewport(
          0,
          0,
          this.width * this.settings('webglOversamplingRatio'),
          this.height * this.settings('webglOversamplingRatio')
        );

    return this;
  };

  /**
   * This method clears each canvas.
   *
   * @return {sigma.renderers.webgl} Returns the instance itself.
   */
  sigma.renderers.webgl.prototype.clear = function() {
    this.contexts.labels.clearRect(0, 0, this.width, this.height);
    this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
    this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);

    return this;
  };

  /**
   * This method kills contexts and other attributes.
   */
  sigma.renderers.webgl.prototype.kill = function() {
    var k,
        captor;

    // Kill captors:
    while ((captor = this.captors.pop()))
      captor.kill();
    delete this.captors;

    // Kill contexts:
    for (k in this.domElements) {
      this.domElements[k].parentNode.removeChild(this.domElements[k]);
      delete this.domElements[k];
      delete this.contexts[k];
    }
    delete this.domElements;
    delete this.contexts;
  };




  /**
   * The object "sigma.webgl.nodes" contains the different WebGL node
   * renderers. The default one draw nodes as discs. Here are the attributes
   * any node renderer must have:
   *
   * {number}   POINTS      The number of points required to draw a node.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addNode     A function that adds a node to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       node
   *                        > {number}       index   The node index in the
   *                                                 nodes array.
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the nodes
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.nodes.def or sigma.webgl.nodes.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.nodes');




  /**
   * The object "sigma.webgl.edges" contains the different WebGL edge
   * renderers. The default one draw edges as direct lines. Here are the
   * attributes any edge renderer must have:
   *
   * {number}   POINTS      The number of points required to draw an edge.
   * {number}   ATTRIBUTES  The number of attributes needed to draw one point.
   * {function} addEdge     A function that adds an edge to the data stack that
   *                        will be given to the buffer. Here is the arguments:
   *                        > {object}       edge
   *                        > {object}       source
   *                        > {object}       target
   *                        > {Float32Array} data    The stack.
   *                        > {object}       options Some options.
   * {function} render      The function that will effectively render the edges
   *                        into the buffer.
   *                        > {WebGLRenderingContext} gl
   *                        > {WebGLProgram}          program
   *                        > {Float32Array} data    The stack to give to the
   *                                                 buffer.
   *                        > {object}       params  An object containing some
   *                                                 options, like width,
   *                                                 height, the camera ratio.
   * {function} initProgram The function that will initiate the program, with
   *                        the relevant shaders and parameters. It must return
   *                        the newly created program.
   *
   * Check sigma.webgl.edges.def or sigma.webgl.edges.fast to see how it
   * works more precisely.
   */
  sigma.utils.pkg('sigma.webgl.edges');




  /**
   * The object "sigma.canvas.labels" contains the different
   * label renderers for the WebGL renderer. Since displaying texts in WebGL is
   * definitely painful and since there a way less labels to display than nodes
   * or edges, the default renderer simply renders them in a canvas.
   *
   * A labels renderer is a simple function, taking as arguments the related
   * node, the renderer and a settings function.
   */
  sigma.utils.pkg('sigma.canvas.labels');
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  if (typeof conrad === 'undefined')
    throw 'conrad is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  /**
   * This function is the constructor of the svg sigma's renderer.
   *
   * @param  {sigma.classes.graph}            graph    The graph to render.
   * @param  {sigma.classes.camera}           camera   The camera.
   * @param  {configurable}           settings The sigma instance settings
   *                                           function.
   * @param  {object}                 object   The options object.
   * @return {sigma.renderers.svg}             The renderer instance.
   */
  sigma.renderers.svg = function(graph, camera, settings, options) {
    if (typeof options !== 'object')
      throw 'sigma.renderers.svg: Wrong arguments.';

    if (!(options.container instanceof HTMLElement))
      throw 'Container not found.';

    var i,
        l,
        a,
        fn,
        self = this;

    sigma.classes.dispatcher.extend(this);

    // Initialize main attributes:
    this.graph = graph;
    this.camera = camera;
    this.domElements = {
      graph: null,
      groups: {},
      nodes: {},
      edges: {},
      labels: {},
      hovers: {}
    };
    this.measurementCanvas = null;
    this.options = options;
    this.container = this.options.container;
    this.settings = (
        typeof options.settings === 'object' &&
        options.settings
      ) ?
        settings.embedObjects(options.settings) :
        settings;

    // Is the renderer meant to be freestyle?
    this.settings('freeStyle', !!this.options.freeStyle);

    // SVG xmlns
    this.settings('xmlns', 'http://www.w3.org/2000/svg');

    // Indexes:
    this.nodesOnScreen = [];
    this.edgesOnScreen = [];

    // Find the prefix:
    this.options.prefix = 'renderer' + sigma.utils.id() + ':';

    // Initialize the DOM elements
    this.initDOM('svg');

    // Initialize captors:
    this.captors = [];
    a = this.options.captors || [sigma.captors.mouse, sigma.captors.touch];
    for (i = 0, l = a.length; i < l; i++) {
      fn = typeof a[i] === 'function' ? a[i] : sigma.captors[a[i]];
      this.captors.push(
        new fn(
          this.domElements.graph,
          this.camera,
          this.settings
        )
      );
    }

    // Bind resize:
    window.addEventListener('resize', function() {
      self.resize();
    });

    // Deal with sigma events:
    // TODO: keep an option to override the DOM events?
    sigma.misc.bindDOMEvents.call(this, this.domElements.graph);
    this.bindHovers(this.options.prefix);

    // Resize
    this.resize(false);
  };

  /**
   * This method renders the graph on the svg scene.
   *
   * @param  {?object}                options Eventually an object of options.
   * @return {sigma.renderers.svg}            Returns the instance itself.
   */
  sigma.renderers.svg.prototype.render = function(options) {
    options = options || {};

    var a,
        i,
        k,
        e,
        l,
        o,
        source,
        target,
        start,
        edges,
        renderers,
        subrenderers,
        index = {},
        graph = this.graph,
        nodes = this.graph.nodes,
        prefix = this.options.prefix || '',
        drawEdges = this.settings(options, 'drawEdges'),
        drawNodes = this.settings(options, 'drawNodes'),
        drawLabels = this.settings(options, 'drawLabels'),
        embedSettings = this.settings.embedObjects(options, {
          prefix: this.options.prefix,
          forceLabels: this.options.forceLabels
        });

    // Check the 'hideEdgesOnMove' setting:
    if (this.settings(options, 'hideEdgesOnMove'))
      if (this.camera.isAnimated || this.camera.isMoving)
        drawEdges = false;

    // Apply the camera's view:
    this.camera.applyView(
      undefined,
      this.options.prefix,
      {
        width: this.width,
        height: this.height
      }
    );

    // Hiding everything
    // TODO: find a more sensible way to perform this operation
    this.hideDOMElements(this.domElements.nodes);
    this.hideDOMElements(this.domElements.edges);
    this.hideDOMElements(this.domElements.labels);

    // Find which nodes are on screen
    this.edgesOnScreen = [];
    this.nodesOnScreen = this.camera.quadtree.area(
      this.camera.getRectangle(this.width, this.height)
    );

    // Node index
    for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++)
      index[a[i].id] = a[i];

    // Find which edges are on screen
    for (a = graph.edges(), i = 0, l = a.length; i < l; i++) {
      o = a[i];
      if (
        (index[o.source] || index[o.target]) &&
        (!o.hidden && !nodes(o.source).hidden && !nodes(o.target).hidden)
      )
        this.edgesOnScreen.push(o);
    }

    // Display nodes
    //---------------
    renderers = sigma.svg.nodes;
    subrenderers = sigma.svg.labels;

    //-- First we create the nodes which are not already created
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!a[i].hidden && !this.domElements.nodes[a[i].id]) {

          // Node
          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.nodes[a[i].id] = e;
          this.domElements.groups.nodes.appendChild(e);

          // Label
          e = (subrenderers[a[i].type] || subrenderers.def).create(
            a[i],
            embedSettings
          );

          this.domElements.labels[a[i].id] = e;
          this.domElements.groups.labels.appendChild(e);
        }
      }

    //-- Second we update the nodes
    if (drawNodes)
      for (a = this.nodesOnScreen, i = 0, l = a.length; i < l; i++) {

        if (a[i].hidden)
          continue;

        // Node
        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.nodes[a[i].id],
          embedSettings
        );

        // Label
        (subrenderers[a[i].type] || subrenderers.def).update(
          a[i],
          this.domElements.labels[a[i].id],
          embedSettings
        );
      }

    // Display edges
    //---------------
    renderers = sigma.svg.edges;

    //-- First we create the edges which are not already created
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        if (!this.domElements.edges[a[i].id]) {
          source = nodes(a[i].source);
          target = nodes(a[i].target);

          e = (renderers[a[i].type] || renderers.def).create(
            a[i],
            source,
            target,
            embedSettings
          );

          this.domElements.edges[a[i].id] = e;
          this.domElements.groups.edges.appendChild(e);
        }
       }

    //-- Second we update the edges
    if (drawEdges)
      for (a = this.edgesOnScreen, i = 0, l = a.length; i < l; i++) {
        source = nodes(a[i].source);
        target = nodes(a[i].target);

        (renderers[a[i].type] || renderers.def).update(
          a[i],
          this.domElements.edges[a[i].id],
          source,
          target,
          embedSettings
        );
       }

    this.dispatchEvent('render');

    return this;
  };

  /**
   * This method creates a DOM element of the specified type, switches its
   * position to "absolute", references it to the domElements attribute, and
   * finally appends it to the container.
   *
   * @param  {string} tag The label tag.
   * @param  {string} id  The id of the element (to store it in "domElements").
   */
  sigma.renderers.svg.prototype.initDOM = function(tag) {
    var dom = document.createElementNS(this.settings('xmlns'), tag),
        c = this.settings('classPrefix'),
        g,
        l,
        i;

    dom.style.position = 'absolute';
    dom.setAttribute('class', c + '-svg');

    // Setting SVG namespace
    dom.setAttribute('xmlns', this.settings('xmlns'));
    dom.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
    dom.setAttribute('version', '1.1');

    // Creating the measurement canvas
    var canvas = document.createElement('canvas');
    canvas.setAttribute('class', c + '-measurement-canvas');

    // Appending elements
    this.domElements.graph = this.container.appendChild(dom);

    // Creating groups
    var groups = ['edges', 'nodes', 'labels', 'hovers'];
    for (i = 0, l = groups.length; i < l; i++) {
      g = document.createElementNS(this.settings('xmlns'), 'g');

      g.setAttributeNS(null, 'id', c + '-group-' + groups[i]);
      g.setAttributeNS(null, 'class', c + '-group');

      this.domElements.groups[groups[i]] =
        this.domElements.graph.appendChild(g);
    }

    // Appending measurement canvas
    this.container.appendChild(canvas);
    this.measurementCanvas = canvas.getContext('2d');
  };

  /**
   * This method hides a batch of SVG DOM elements.
   *
   * @param  {array}                  elements  An array of elements to hide.
   * @param  {object}                 renderer  The renderer to use.
   * @return {sigma.renderers.svg}              Returns the instance itself.
   */
  sigma.renderers.svg.prototype.hideDOMElements = function(elements) {
    var o,
        i;

    for (i in elements) {
      o = elements[i];
      sigma.svg.utils.hide(o);
    }

    return this;
  };

  /**
   * This method binds the hover events to the renderer.
   *
   * @param  {string} prefix The renderer prefix.
   */
  // TODO: add option about whether to display hovers or not
  sigma.renderers.svg.prototype.bindHovers = function(prefix) {
    var renderers = sigma.svg.hovers,
        self = this,
        hoveredNode;

    function overNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      var hover = (renderers[node.type] || renderers.def).create(
        node,
        self.domElements.nodes[node.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[node.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
      hoveredNode = node;
    }

    function outNode(e) {
      var node = e.data.node,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      if (!embedSettings('enableHovering'))
        return;

      // Deleting element
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[node.id]
      );
      hoveredNode = null;
      delete self.domElements.hovers[node.id];

      // Reinstate
      self.domElements.groups.nodes.appendChild(
        self.domElements.nodes[node.id]
      );
    }

    // OPTIMIZE: perform a real update rather than a deletion
    function update() {
      if (!hoveredNode)
        return;

      var embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Deleting element before update
      self.domElements.groups.hovers.removeChild(
        self.domElements.hovers[hoveredNode.id]
      );
      delete self.domElements.hovers[hoveredNode.id];

      var hover = (renderers[hoveredNode.type] || renderers.def).create(
        hoveredNode,
        self.domElements.nodes[hoveredNode.id],
        self.measurementCanvas,
        embedSettings
      );

      self.domElements.hovers[hoveredNode.id] = hover;

      // Inserting the hover in the dom
      self.domElements.groups.hovers.appendChild(hover);
    }

    // Binding events
    this.bind('overNode', overNode);
    this.bind('outNode', outNode);

    // Update on render
    this.bind('render', update);
  };

  /**
   * This method resizes each DOM elements in the container and stores the new
   * dimensions. Then, it renders the graph.
   *
   * @param  {?number}                width  The new width of the container.
   * @param  {?number}                height The new height of the container.
   * @return {sigma.renderers.svg}           Returns the instance itself.
   */
  sigma.renderers.svg.prototype.resize = function(w, h) {
    var oldWidth = this.width,
        oldHeight = this.height,
        pixelRatio = 1;

    if (w !== undefined && h !== undefined) {
      this.width = w;
      this.height = h;
    } else {
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;

      w = this.width;
      h = this.height;
    }

    if (oldWidth !== this.width || oldHeight !== this.height) {
      this.domElements.graph.style.width = w + 'px';
      this.domElements.graph.style.height = h + 'px';

      if (this.domElements.graph.tagName.toLowerCase() === 'svg') {
        this.domElements.graph.setAttribute('width', (w * pixelRatio));
        this.domElements.graph.setAttribute('height', (h * pixelRatio));
      }
    }

    return this;
  };


  /**
   * The labels, nodes and edges renderers are stored in the three following
   * objects. When an element is drawn, its type will be checked and if a
   * renderer with the same name exists, it will be used. If not found, the
   * default renderer will be used instead.
   *
   * They are stored in different files, in the "./svg" folder.
   */
  sigma.utils.pkg('sigma.svg.nodes');
  sigma.utils.pkg('sigma.svg.edges');
  sigma.utils.pkg('sigma.svg.labels');
}).call(this);

;(function(global) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.renderers');

  // Check if WebGL is enabled:
  var canvas,
      webgl = !!global.WebGLRenderingContext;
  if (webgl) {
    canvas = document.createElement('canvas');
    try {
      webgl = !!(
        canvas.getContext('webgl') ||
        canvas.getContext('experimental-webgl')
      );
    } catch (e) {
      webgl = false;
    }
  }

  // Copy the good renderer:
  sigma.renderers.def = webgl ?
    sigma.renderers.webgl :
    sigma.renderers.canvas;
})(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes as discs, shaped in triangles with
   * the gl.TRIANGLES display mode. So, to be more precise, to draw one node,
   * it will store three times the center of node, with the color and the size,
   * and an angle indicating which "corner" of the triangle to draw.
   *
   * The fragment shader does not deal with anti-aliasing, so make sure that
   * you deal with it somewhere else in the code (by default, the WebGL
   * renderer will oversample the rendering through the webglOversamplingRatio
   * value).
   */
  sigma.webgl.nodes.def = {
    POINTS: 3,
    ATTRIBUTES: 5,
    addNode: function(node, data, i, prefix, settings) {
      var color = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 0;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 2 * Math.PI / 3;

      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = color;
      data[i++] = 4 * Math.PI / 3;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          angleLocation =
            gl.getAttribLocation(program, 'a_angle'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(angleLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );
      gl.vertexAttribPointer(
        angleLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',
          'attribute float a_angle;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main() {',
            // Multiply the point size twice:
            'radius = a_size * u_ratio;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'vec2 position = (u_matrix * vec3(a_position, 1)).xy;',
            // 'center = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',
            'center = position * u_scale;',
            'center = vec2(center.x, u_scale * u_resolution.y - center.y);',

            'position = position +',
              '2.0 * radius * vec2(cos(a_angle), sin(a_angle));',
            'position = (position / u_resolution * 2.0 - 1.0) * vec2(1, -1);',

            'radius = radius * u_scale;',

            'gl_Position = vec4(position, 0, 1);',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',
          'varying vec2 center;',
          'varying float radius;',

          'void main(void) {',
            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',

            'vec2 m = gl_FragCoord.xy - center;',
            'float diff = radius - sqrt(m.x * m.x + m.y * m.y);',

            // Here is how we draw a disc instead of a square:
            'if (diff > 0.0)',
              'gl_FragColor = color;',
            'else',
              'gl_FragColor = color0;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.nodes');

  /**
   * This node renderer will display nodes in the fastest way: Nodes are basic
   * squares, drawn through the gl.POINTS drawing method. The size of the nodes
   * are represented with the "gl_PointSize" value in the vertex shader.
   *
   * It is the fastest node renderer here since the buffer just takes one line
   * to draw each node (with attributes "x", "y", "size" and "color").
   *
   * Nevertheless, this method has some problems, especially due to some issues
   * with the gl.POINTS:
   *  - First, if the center of a node is outside the scene, the point will not
   *    be drawn, even if it should be partly on screen.
   *  - I tried applying a fragment shader similar to the one in the default
   *    node renderer to display them as discs, but it did not work fine on
   *    some computers settings, filling the discs with weird gradients not
   *    depending on the actual color.
   */
  sigma.webgl.nodes.fast = {
    POINTS: 1,
    ATTRIBUTES: 4,
    addNode: function(node, data, i, prefix, settings) {
      data[i++] = node[prefix + 'x'];
      data[i++] = node[prefix + 'y'];
      data[i++] = node[prefix + 'size'];
      data[i++] = sigma.utils.floatColor(
        node.color || settings('defaultNodeColor')
      );
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          sizeLocation =
            gl.getAttribLocation(program, 'a_size'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        1 / Math.pow(params.ratio, params.settings('nodesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(sizeLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(
        positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(
        sizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(
        colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        12
      );

      gl.drawArrays(
        gl.POINTS,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_size;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Multiply the point size twice:
            //  - x SCALING_RATIO to correct the canvas scaling
            //  - x 2 to correct the formulae
            'gl_PointSize = a_size * u_ratio * u_scale * 2.0;',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'float border = 0.01;',
            'float radius = 0.5;',

            'vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);',
            'vec2 m = gl_PointCoord - vec2(0.5, 0.5);',
            'float dist = radius - sqrt(m.x * m.x + m.y * m.y);',

            'float t = 0.0;',
            'if (dist > border)',
              't = 1.0;',
            'else if (dist > 0.0)',
              't = dist / border;',

            'gl_FragColor = mix(color0, color, t);',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * two triangles forming rectangles, with the gl.TRIANGLES drawing mode.
   *
   * It is expensive, since drawing a single edge requires 6 points, each
   * having 7 attributes (source position, target position, thickness, color
   * and a flag indicating which vertice of the rectangle it is).
   */
  sigma.webgl.edges.def = {
    POINTS: 6,
    ATTRIBUTES: 7,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 1.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = 0.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation1 =
            gl.getAttribLocation(program, 'a_position1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_position2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(colorLocation);
      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(minusLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position1;',
          'attribute vec2 a_position2;',
          'attribute float a_thickness;',
          'attribute float a_minus;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 position = a_thickness * u_ratio *',
              'normalize(a_position2 - a_position1);',

            'mat2 matrix = a_minus * u_matrixHalfPiMinus +',
              '(1.0 - a_minus) * u_matrixHalfPi;',

            'position = matrix * position + a_position1;',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as lines with the gl.LINES display
   * mode. Since this mode does not support well thickness, edges are all drawn
   * with the same thickness (3px), independantly of the edge attributes or the
   * zooming ratio.
   */
  sigma.webgl.edges.fast = {
    POINTS: 2,
    ATTRIBUTES: 3,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          positionLocation =
            gl.getAttribLocation(program, 'a_position'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);

      gl.enableVertexAttribArray(positionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );

      gl.lineWidth(3);
      gl.drawArrays(
        gl.LINES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_position;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform mat3 u_matrix;',

          'varying vec4 color;',

          'void main() {',
            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(a_position, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.webgl.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   * to the target node. To deal with edge thicknesses, the lines are made of
   * three triangles: two forming rectangles, with the gl.TRIANGLES drawing
   * mode.
   *
   * It is expensive, since drawing a single edge requires 9 points, each
   * having a lot of attributes.
   */
  sigma.webgl.edges.arrow = {
    POINTS: 9,
    ATTRIBUTES: 11,
    addEdge: function(edge, source, target, data, i, prefix, settings) {
      var w = (edge[prefix + 'size'] || 1) / 2,
          x1 = source[prefix + 'x'],
          y1 = source[prefix + 'y'],
          x2 = target[prefix + 'x'],
          y2 = target[prefix + 'y'],
          targetSize = target[prefix + 'size'],
          color = edge.color;

      if (!color)
        switch (settings('edgeColor')) {
          case 'source':
            color = source.color || settings('defaultNodeColor');
            break;
          case 'target':
            color = target.color || settings('defaultNodeColor');
            break;
          default:
            color = settings('defaultEdgeColor');
            break;
        }

      // Normalize color:
      color = sigma.utils.floatColor(color);

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x1;
      data[i++] = y1;
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = 0.0;
      data[i++] = color;

      // Arrow head:
      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = -1.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = color;

      data[i++] = x2;
      data[i++] = y2;
      data[i++] = x1;
      data[i++] = y1;
      data[i++] = w;
      data[i++] = targetSize;
      data[i++] = 1.0;
      data[i++] = 0.0;
      data[i++] = 1.0;
      data[i++] = 1.0;
      data[i++] = color;
    },
    render: function(gl, program, data, params) {
      var buffer;

      // Define attributes:
      var positionLocation1 =
            gl.getAttribLocation(program, 'a_pos1'),
          positionLocation2 =
            gl.getAttribLocation(program, 'a_pos2'),
          thicknessLocation =
            gl.getAttribLocation(program, 'a_thickness'),
          targetSizeLocation =
            gl.getAttribLocation(program, 'a_tSize'),
          delayLocation =
            gl.getAttribLocation(program, 'a_delay'),
          minusLocation =
            gl.getAttribLocation(program, 'a_minus'),
          headLocation =
            gl.getAttribLocation(program, 'a_head'),
          headPositionLocation =
            gl.getAttribLocation(program, 'a_headPosition'),
          colorLocation =
            gl.getAttribLocation(program, 'a_color'),
          resolutionLocation =
            gl.getUniformLocation(program, 'u_resolution'),
          matrixLocation =
            gl.getUniformLocation(program, 'u_matrix'),
          matrixHalfPiLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPi'),
          matrixHalfPiMinusLocation =
            gl.getUniformLocation(program, 'u_matrixHalfPiMinus'),
          ratioLocation =
            gl.getUniformLocation(program, 'u_ratio'),
          nodeRatioLocation =
            gl.getUniformLocation(program, 'u_nodeRatio'),
          arrowHeadLocation =
            gl.getUniformLocation(program, 'u_arrowHead'),
          scaleLocation =
            gl.getUniformLocation(program, 'u_scale');

      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      gl.uniform2f(resolutionLocation, params.width, params.height);
      gl.uniform1f(
        ratioLocation,
        params.ratio / Math.pow(params.ratio, params.settings('edgesPowRatio'))
      );
      gl.uniform1f(
        nodeRatioLocation,
        Math.pow(params.ratio, params.settings('nodesPowRatio')) /
        params.ratio
      );
      gl.uniform1f(arrowHeadLocation, 5.0);
      gl.uniform1f(scaleLocation, params.scalingRatio);
      gl.uniformMatrix3fv(matrixLocation, false, params.matrix);
      gl.uniformMatrix2fv(
        matrixHalfPiLocation,
        false,
        sigma.utils.matrices.rotation(Math.PI / 2, true)
      );
      gl.uniformMatrix2fv(
        matrixHalfPiMinusLocation,
        false,
        sigma.utils.matrices.rotation(-Math.PI / 2, true)
      );

      gl.enableVertexAttribArray(positionLocation1);
      gl.enableVertexAttribArray(positionLocation2);
      gl.enableVertexAttribArray(thicknessLocation);
      gl.enableVertexAttribArray(targetSizeLocation);
      gl.enableVertexAttribArray(delayLocation);
      gl.enableVertexAttribArray(minusLocation);
      gl.enableVertexAttribArray(headLocation);
      gl.enableVertexAttribArray(headPositionLocation);
      gl.enableVertexAttribArray(colorLocation);

      gl.vertexAttribPointer(positionLocation1,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        0
      );
      gl.vertexAttribPointer(positionLocation2,
        2,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        8
      );
      gl.vertexAttribPointer(thicknessLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        16
      );
      gl.vertexAttribPointer(targetSizeLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        20
      );
      gl.vertexAttribPointer(delayLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        24
      );
      gl.vertexAttribPointer(minusLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        28
      );
      gl.vertexAttribPointer(headLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        32
      );
      gl.vertexAttribPointer(headPositionLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        36
      );
      gl.vertexAttribPointer(colorLocation,
        1,
        gl.FLOAT,
        false,
        this.ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT,
        40
      );

      gl.drawArrays(
        gl.TRIANGLES,
        params.start || 0,
        params.count || (data.length / this.ATTRIBUTES)
      );
    },
    initProgram: function(gl) {
      var vertexShader,
          fragmentShader,
          program;

      vertexShader = sigma.utils.loadShader(
        gl,
        [
          'attribute vec2 a_pos1;',
          'attribute vec2 a_pos2;',
          'attribute float a_thickness;',
          'attribute float a_tSize;',
          'attribute float a_delay;',
          'attribute float a_minus;',
          'attribute float a_head;',
          'attribute float a_headPosition;',
          'attribute float a_color;',

          'uniform vec2 u_resolution;',
          'uniform float u_ratio;',
          'uniform float u_nodeRatio;',
          'uniform float u_arrowHead;',
          'uniform float u_scale;',
          'uniform mat3 u_matrix;',
          'uniform mat2 u_matrixHalfPi;',
          'uniform mat2 u_matrixHalfPiMinus;',

          'varying vec4 color;',

          'void main() {',
            // Find the good point:
            'vec2 pos = normalize(a_pos2 - a_pos1);',

            'mat2 matrix = (1.0 - a_head) *',
              '(',
                'a_minus * u_matrixHalfPiMinus +',
                '(1.0 - a_minus) * u_matrixHalfPi',
              ') + a_head * (',
                'a_headPosition * u_matrixHalfPiMinus * 0.6 +',
                '(a_headPosition * a_headPosition - 1.0) * mat2(1.0)',
              ');',

            'pos = a_pos1 + (',
              // Deal with body:
              '(1.0 - a_head) * a_thickness * u_ratio * matrix * pos +',
              // Deal with head:
              'a_head * u_arrowHead * a_thickness * u_ratio * matrix * pos +',
              // Deal with delay:
              'a_delay * pos * (',
                'a_tSize / u_nodeRatio +',
                'u_arrowHead * a_thickness * u_ratio',
              ')',
            ');',

            // Scale from [[-1 1] [-1 1]] to the container:
            'gl_Position = vec4(',
              '((u_matrix * vec3(pos, 1)).xy /',
                'u_resolution * 2.0 - 1.0) * vec2(1, -1),',
              '0,',
              '1',
            ');',

            // Extract the color:
            'float c = a_color;',
            'color.b = mod(c, 256.0); c = floor(c / 256.0);',
            'color.g = mod(c, 256.0); c = floor(c / 256.0);',
            'color.r = mod(c, 256.0); c = floor(c / 256.0); color /= 255.0;',
            'color.a = 1.0;',
          '}'
        ].join('\n'),
        gl.VERTEX_SHADER
      );

      fragmentShader = sigma.utils.loadShader(
        gl,
        [
          'precision mediump float;',

          'varying vec4 color;',

          'void main(void) {',
            'gl_FragColor = color;',
          '}'
        ].join('\n'),
        gl.FRAGMENT_SHADER
      );

      program = sigma.utils.loadProgram(gl, [vertexShader, fragmentShader]);

      return program;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.labels');

  /**
   * This label renderer will just display the label on the right of the node.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.labels.def = function(node, context, settings) {
    var fontSize,
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'];

    if (size < settings('labelThreshold'))
      return;

    if (!node.label || typeof node.label !== 'string')
      return;

    fontSize = (settings('labelSize') === 'fixed') ?
      settings('defaultLabelSize') :
      settings('labelSizeRatio') * size;

    context.font = (settings('fontStyle') ? settings('fontStyle') + ' ' : '') +
      fontSize + 'px ' + settings('font');
    context.fillStyle = (settings('labelColor') === 'node') ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultLabelColor');

    context.fillText(
      node.label,
      Math.round(node[prefix + 'x'] + size + 3),
      Math.round(node[prefix + 'y'] + fontSize / 3)
    );
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.hovers');

  /**
   * This hover renderer will basically display the label with a background.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.hovers.def = function(node, context, settings) {
    var x,
        y,
        w,
        h,
        e,
        fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
        prefix = settings('prefix') || '',
        size = node[prefix + 'size'],
        fontSize = (settings('labelSize') === 'fixed') ?
          settings('defaultLabelSize') :
          settings('labelSizeRatio') * size;

    // Label background:
    context.font = (fontStyle ? fontStyle + ' ' : '') +
      fontSize + 'px ' + (settings('hoverFont') || settings('font'));

    context.beginPath();
    context.fillStyle = settings('labelHoverBGColor') === 'node' ?
      (node.color || settings('defaultNodeColor')) :
      settings('defaultHoverLabelBGColor');

    if (node.label && settings('labelHoverShadow')) {
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 8;
      context.shadowColor = settings('labelHoverShadowColor');
    }

    if (node.label && typeof node.label === 'string') {
      x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
      y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
      w = Math.round(
        context.measureText(node.label).width + fontSize / 2 + size + 7
      );
      h = Math.round(fontSize + 4);
      e = Math.round(fontSize / 2 + 2);

      context.moveTo(x, y + e);
      context.arcTo(x, y, x + e, y, e);
      context.lineTo(x + w, y);
      context.lineTo(x + w, y + h);
      context.lineTo(x + e, y + h);
      context.arcTo(x, y + h, x, y + h - e, e);
      context.lineTo(x, y + e);

      context.closePath();
      context.fill();

      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      context.shadowBlur = 0;
    }

    // Node border:
    if (settings('borderSize') > 0) {
      context.beginPath();
      context.fillStyle = settings('nodeBorderColor') === 'node' ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultNodeBorderColor');
      context.arc(
        node[prefix + 'x'],
        node[prefix + 'y'],
        size + settings('borderSize'),
        0,
        Math.PI * 2,
        true
      );
      context.closePath();
      context.fill();
    }

    // Node:
    var nodeRenderer = sigma.canvas.nodes[node.type] || sigma.canvas.nodes.def;
    nodeRenderer(node, context, settings);

    // Display the label:
    if (node.label && typeof node.label === 'string') {
      context.fillStyle = (settings('labelHoverColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelHoverColor');

      context.fillText(
        node.label,
        Math.round(node[prefix + 'x'] + size + 3),
        Math.round(node[prefix + 'y'] + fontSize / 3)
      );
    }
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   *
   * @param  {object}                   node     The node object.
   * @param  {CanvasRenderingContext2D} context  The canvas context.
   * @param  {configurable}             settings The settings function.
   */
  sigma.canvas.nodes.def = function(node, context, settings) {
    var prefix = settings('prefix') || '';

    context.fillStyle = node.color || settings('defaultNodeColor');
    context.beginPath();
    context.arc(
      node[prefix + 'x'],
      node[prefix + 'y'],
      node[prefix + 'size'],
      0,
      Math.PI * 2,
      true
    );

    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * The default edge renderer. It renders the edge as a simple line.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.def = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edges');

  /**
   * This edge renderer will display edges as arrows going from the source node
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edges.arrow = function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        aSize = Math.max(size * 2.5, settings('minArrowSize')),
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.def =
    function(edge, source, target, context, settings) {
      var color = edge.color,
        prefix = settings('prefix') || '',
        size = edge[prefix + 'size'] || 1,
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor');

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }
    size *= settings('edgeHoverSizeRatio');

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(
      source[prefix + 'x'],
      source[prefix + 'y']
    );
    context.lineTo(
      target[prefix + 'x'],
      target[prefix + 'y']
    );
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curve =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        sSize = source[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, sSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x1, cp.y1, cp.x2, cp.y2, tX, tY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, tX, tY);
    }
    context.stroke();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.arrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        size = edge[prefix + 'size'] || 1,
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'];

    size = (edge.hover) ?
      settings('edgeHoverSizeRatio') * size : size;
    var aSize = size * 2.5,
        d = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2)),
        aX = sX + (tX - sX) * (d - aSize - tSize) / d,
        aY = sY + (tY - sY) * (d - aSize - tSize) / d,
        vX = (tX - sX) * aSize / d,
        vY = (tY - sY) * aSize / d;

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    context.lineTo(
      aX,
      aY
    );
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.canvas.edgehovers');

  /**
   * This hover renderer will display the edge with a different color or size.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.edgehovers.curvedArrow =
    function(edge, source, target, context, settings) {
    var color = edge.color,
        prefix = settings('prefix') || '',
        edgeColor = settings('edgeColor'),
        defaultNodeColor = settings('defaultNodeColor'),
        defaultEdgeColor = settings('defaultEdgeColor'),
        cp = {},
        size = settings('edgeHoverSizeRatio') * (edge[prefix + 'size'] || 1),
        tSize = target[prefix + 'size'],
        sX = source[prefix + 'x'],
        sY = source[prefix + 'y'],
        tX = target[prefix + 'x'],
        tY = target[prefix + 'y'],
        d,
        aSize,
        aX,
        aY,
        vX,
        vY;

    cp = (source.id === target.id) ?
      sigma.utils.getSelfLoopControlPoints(sX, sY, tSize) :
      sigma.utils.getQuadraticControlPoint(sX, sY, tX, tY);

    if (source.id === target.id) {
      d = Math.sqrt(Math.pow(tX - cp.x1, 2) + Math.pow(tY - cp.y1, 2));
      aSize = size * 2.5;
      aX = cp.x1 + (tX - cp.x1) * (d - aSize - tSize) / d;
      aY = cp.y1 + (tY - cp.y1) * (d - aSize - tSize) / d;
      vX = (tX - cp.x1) * aSize / d;
      vY = (tY - cp.y1) * aSize / d;
    }
    else {
      d = Math.sqrt(Math.pow(tX - cp.x, 2) + Math.pow(tY - cp.y, 2));
      aSize = size * 2.5;
      aX = cp.x + (tX - cp.x) * (d - aSize - tSize) / d;
      aY = cp.y + (tY - cp.y) * (d - aSize - tSize) / d;
      vX = (tX - cp.x) * aSize / d;
      vY = (tY - cp.y) * aSize / d;
    }

    if (!color)
      switch (edgeColor) {
        case 'source':
          color = source.color || defaultNodeColor;
          break;
        case 'target':
          color = target.color || defaultNodeColor;
          break;
        default:
          color = defaultEdgeColor;
          break;
      }

    if (settings('edgeHoverColor') === 'edge') {
      color = edge.hover_color || color;
    } else {
      color = edge.hover_color || settings('defaultEdgeHoverColor') || color;
    }

    context.strokeStyle = color;
    context.lineWidth = size;
    context.beginPath();
    context.moveTo(sX, sY);
    if (source.id === target.id) {
      context.bezierCurveTo(cp.x2, cp.y2, cp.x1, cp.y1, aX, aY);
    } else {
      context.quadraticCurveTo(cp.x, cp.y, aX, aY);
    }
    context.stroke();

    context.fillStyle = color;
    context.beginPath();
    context.moveTo(aX + vX, aY + vY);
    context.lineTo(aX + vY * 0.6, aY - vX * 0.6);
    context.lineTo(aX - vY * 0.6, aY + vX * 0.6);
    context.lineTo(aX + vX, aY + vY);
    context.closePath();
    context.fill();
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.canvas.extremities');

  /**
   * The default renderer for hovered edge extremities. It renders the edge
   * extremities as hovered.
   *
   * @param  {object}                   edge         The edge object.
   * @param  {object}                   source node  The edge source node.
   * @param  {object}                   target node  The edge target node.
   * @param  {CanvasRenderingContext2D} context      The canvas context.
   * @param  {configurable}             settings     The settings function.
   */
  sigma.canvas.extremities.def =
    function(edge, source, target, context, settings) {
    // Source Node:
    (
      sigma.canvas.hovers[source.type] ||
      sigma.canvas.hovers.def
    ) (
      source, context, settings
    );

    // Target Node:
    (
      sigma.canvas.hovers[target.type] ||
      sigma.canvas.hovers.def
    ) (
      target, context, settings
    );
  };
}).call(this);

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.utils');

  /**
   * Some useful functions used by sigma's SVG renderer.
   */
  sigma.svg.utils = {

    /**
     * SVG Element show.
     *
     * @param  {DOMElement}               element   The DOM element to show.
     */
    show: function(element) {
      element.style.display = '';
      return this;
    },

    /**
     * SVG Element hide.
     *
     * @param  {DOMElement}               element   The DOM element to hide.
     */
    hide: function(element) {
      element.style.display = 'none';
      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.nodes');

  /**
   * The default node renderer. It renders the node as a simple disc.
   */
  sigma.svg.nodes.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node     The node object.
     * @param  {configurable}             settings The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          circle = document.createElementNS(settings('xmlns'), 'circle');

      // Defining the node's circle
      circle.setAttributeNS(null, 'data-node-id', node.id);
      circle.setAttributeNS(null, 'class', settings('classPrefix') + '-node');
      circle.setAttributeNS(
        null, 'fill', node.color || settings('defaultNodeColor'));

      // Returning the DOM Element
      return circle;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               circle   The node DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, circle, settings) {
      var prefix = settings('prefix') || '';

      // Applying changes
      // TODO: optimize - check if necessary
      circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
      circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
      circle.setAttributeNS(null, 'r', node[prefix + 'size']);

      // Updating only if not freestyle
      if (!settings('freeStyle'))
        circle.setAttributeNS(
          null, 'fill', node.color || settings('defaultNodeColor'));

      // Showing
      circle.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The default edge renderer. It renders the node as a simple line.
   */
  sigma.svg.edges.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var line = document.createElementNS(settings('xmlns'), 'line');

      // Attributes
      line.setAttributeNS(null, 'data-edge-id', edge.id);
      line.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      line.setAttributeNS(null, 'stroke', color);

      return line;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, line, source, target, settings) {
      var prefix = settings('prefix') || '';

      line.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);
      line.setAttributeNS(null, 'x1', source[prefix + 'x']);
      line.setAttributeNS(null, 'y1', source[prefix + 'y']);
      line.setAttributeNS(null, 'x2', target[prefix + 'x']);
      line.setAttributeNS(null, 'y2', target[prefix + 'y']);

      // Showing
      line.style.display = '';

      return this;
    }
  };
})();

;(function() {
  'use strict';

  sigma.utils.pkg('sigma.svg.edges');

  /**
   * The curve edge renderer. It renders the node as a bezier curve.
   */
  sigma.svg.edges.curve = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(edge, source, target, settings) {
      var color = edge.color,
          prefix = settings('prefix') || '',
          edgeColor = settings('edgeColor'),
          defaultNodeColor = settings('defaultNodeColor'),
          defaultEdgeColor = settings('defaultEdgeColor');

      if (!color)
        switch (edgeColor) {
          case 'source':
            color = source.color || defaultNodeColor;
            break;
          case 'target':
            color = target.color || defaultNodeColor;
            break;
          default:
            color = defaultEdgeColor;
            break;
        }

      var path = document.createElementNS(settings('xmlns'), 'path');

      // Attributes
      path.setAttributeNS(null, 'data-edge-id', edge.id);
      path.setAttributeNS(null, 'class', settings('classPrefix') + '-edge');
      path.setAttributeNS(null, 'stroke', color);

      return path;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   edge       The edge object.
     * @param  {DOMElement}               line       The line DOM Element.
     * @param  {object}                   source     The source node object.
     * @param  {object}                   target     The target node object.
     * @param  {configurable}             settings   The settings function.
     */
    update: function(edge, path, source, target, settings) {
      var prefix = settings('prefix') || '';

      path.setAttributeNS(null, 'stroke-width', edge[prefix + 'size'] || 1);

      // Control point
      var cx = (source[prefix + 'x'] + target[prefix + 'x']) / 2 +
        (target[prefix + 'y'] - source[prefix + 'y']) / 4,
          cy = (source[prefix + 'y'] + target[prefix + 'y']) / 2 +
        (source[prefix + 'x'] - target[prefix + 'x']) / 4;

      // Path
      var p = 'M' + source[prefix + 'x'] + ',' + source[prefix + 'y'] + ' ' +
              'Q' + cx + ',' + cy + ' ' +
              target[prefix + 'x'] + ',' + target[prefix + 'y'];

      // Updating attributes
      path.setAttributeNS(null, 'd', p);
      path.setAttributeNS(null, 'fill', 'none');

      // Showing
      path.style.display = '';

      return this;
    }
  };
})();

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.labels');

  /**
   * The default label renderer. It renders the label as a simple text.
   */
  sigma.svg.labels.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}                   node       The node object.
     * @param  {configurable}             settings   The settings function.
     */
    create: function(node, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          text = document.createElementNS(settings('xmlns'), 'text');

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      var fontColor = (settings('labelColor') === 'node') ?
        (node.color || settings('defaultNodeColor')) :
        settings('defaultLabelColor');

      text.setAttributeNS(null, 'data-label-target', node.id);
      text.setAttributeNS(null, 'class', settings('classPrefix') + '-label');
      text.setAttributeNS(null, 'font-size', fontSize);
      text.setAttributeNS(null, 'font-family', settings('font'));
      text.setAttributeNS(null, 'fill', fontColor);

      text.innerHTML = node.label;
      text.textContent = node.label;

      return text;
    },

    /**
     * SVG Element update.
     *
     * @param  {object}                   node     The node object.
     * @param  {DOMElement}               text     The label DOM element.
     * @param  {configurable}             settings The settings function.
     */
    update: function(node, text, settings) {
      var prefix = settings('prefix') || '',
          size = node[prefix + 'size'];

      var fontSize = (settings('labelSize') === 'fixed') ?
        settings('defaultLabelSize') :
        settings('labelSizeRatio') * size;

      // Case when we don't want to display the label
      if (!settings('forceLabels') && size < settings('labelThreshold'))
        return;

      if (typeof node.label !== 'string')
        return;

      // Updating
      text.setAttributeNS(null, 'x',
        Math.round(node[prefix + 'x'] + size + 3));
      text.setAttributeNS(null, 'y',
        Math.round(node[prefix + 'y'] + fontSize / 3));

      // Showing
      text.style.display = '';

      return this;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.svg.hovers');

  /**
   * The default hover renderer.
   */
  sigma.svg.hovers.def = {

    /**
     * SVG Element creation.
     *
     * @param  {object}           node               The node object.
     * @param  {CanvasElement}    measurementCanvas  A fake canvas handled by
     *                            the svg to perform some measurements and
     *                            passed by the renderer.
     * @param  {DOMElement}       nodeCircle         The node DOM Element.
     * @param  {configurable}     settings           The settings function.
     */
    create: function(node, nodeCircle, measurementCanvas, settings) {

      // Defining visual properties
      var x,
          y,
          w,
          h,
          e,
          d,
          fontStyle = settings('hoverFontStyle') || settings('fontStyle'),
          prefix = settings('prefix') || '',
          size = node[prefix + 'size'],
          fontSize = (settings('labelSize') === 'fixed') ?
            settings('defaultLabelSize') :
            settings('labelSizeRatio') * size,
          fontColor = (settings('labelHoverColor') === 'node') ?
                        (node.color || settings('defaultNodeColor')) :
                        settings('defaultLabelHoverColor');

      // Creating elements
      var group = document.createElementNS(settings('xmlns'), 'g'),
          rectangle = document.createElementNS(settings('xmlns'), 'rect'),
          circle = document.createElementNS(settings('xmlns'), 'circle'),
          text = document.createElementNS(settings('xmlns'), 'text');

      // Defining properties
      group.setAttributeNS(null, 'class', settings('classPrefix') + '-hover');
      group.setAttributeNS(null, 'data-node-id', node.id);

      if (typeof node.label === 'string') {

        // Text
        text.innerHTML = node.label;
        text.textContent = node.label;
        text.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-label');
        text.setAttributeNS(null, 'font-size', fontSize);
        text.setAttributeNS(null, 'font-family', settings('font'));
        text.setAttributeNS(null, 'fill', fontColor);
        text.setAttributeNS(null, 'x',
          Math.round(node[prefix + 'x'] + size + 3));
        text.setAttributeNS(null, 'y',
          Math.round(node[prefix + 'y'] + fontSize / 3));

        // Measures
        // OPTIMIZE: Find a better way than a measurement canvas
        x = Math.round(node[prefix + 'x'] - fontSize / 2 - 2);
        y = Math.round(node[prefix + 'y'] - fontSize / 2 - 2);
        w = Math.round(
          measurementCanvas.measureText(node.label).width +
            fontSize / 2 + size + 9
        );
        h = Math.round(fontSize + 4);
        e = Math.round(fontSize / 2 + 2);

        // Circle
        circle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        circle.setAttributeNS(null, 'fill', '#fff');
        circle.setAttributeNS(null, 'cx', node[prefix + 'x']);
        circle.setAttributeNS(null, 'cy', node[prefix + 'y']);
        circle.setAttributeNS(null, 'r', e);

        // Rectangle
        rectangle.setAttributeNS(
            null,
            'class',
            settings('classPrefix') + '-hover-area');
        rectangle.setAttributeNS(null, 'fill', '#fff');
        rectangle.setAttributeNS(null, 'x', node[prefix + 'x'] + e / 4);
        rectangle.setAttributeNS(null, 'y', node[prefix + 'y'] - e);
        rectangle.setAttributeNS(null, 'width', w);
        rectangle.setAttributeNS(null, 'height', h);
      }

      // Appending childs
      group.appendChild(circle);
      group.appendChild(rectangle);
      group.appendChild(text);
      group.appendChild(nodeCircle);

      return group;
    }
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');
  sigma.utils.pkg('sigma.utils');

  /**
   * This middleware will rescale the graph such that it takes an optimal space
   * on the renderer.
   *
   * As each middleware, this function is executed in the scope of the sigma
   * instance.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   * @param {object}  options     The parameters.
   */
  sigma.middlewares.rescale = function(readPrefix, writePrefix, options) {
    var i,
        l,
        a,
        b,
        c,
        d,
        scale,
        margin,
        n = this.graph.nodes(),
        e = this.graph.edges(),
        settings = this.settings.embedObjects(options || {}),
        bounds = settings('bounds') || sigma.utils.getBoundaries(
          this.graph,
          readPrefix,
          true
        ),
        minX = bounds.minX,
        minY = bounds.minY,
        maxX = bounds.maxX,
        maxY = bounds.maxY,
        sizeMax = bounds.sizeMax,
        weightMax = bounds.weightMax,
        w = settings('width') || 1,
        h = settings('height') || 1,
        rescaleSettings = settings('autoRescale'),
        validSettings = {
          nodePosition: 1,
          nodeSize: 1,
          edgeSize: 1
        };

    /**
     * What elements should we rescale?
     */
    if (!(rescaleSettings instanceof Array))
      rescaleSettings = ['nodePosition', 'nodeSize', 'edgeSize'];

    for (i = 0, l = rescaleSettings.length; i < l; i++)
      if (!validSettings[rescaleSettings[i]])
        throw new Error(
          'The rescale setting "' + rescaleSettings[i] + '" is not recognized.'
        );

    var np = ~rescaleSettings.indexOf('nodePosition'),
        ns = ~rescaleSettings.indexOf('nodeSize'),
        es = ~rescaleSettings.indexOf('edgeSize');

    /**
     * First, we compute the scaling ratio, without considering the sizes
     * of the nodes : Each node will have its center in the canvas, but might
     * be partially out of it.
     */
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    /**
     * Then, we correct that scaling ratio considering a margin, which is
     * basically the size of the biggest node.
     * This has to be done as a correction since to compare the size of the
     * biggest node to the X and Y values, we have to first get an
     * approximation of the scaling ratio.
     **/
    margin =
      (
        settings('rescaleIgnoreSize') ?
          0 :
          (settings('maxNodeSize') || sizeMax) / scale
      ) +
      (settings('sideMargin') || 0);
    maxX += margin;
    minX -= margin;
    maxY += margin;
    minY -= margin;

    // Fix the scaling with the new extrema:
    scale = settings('scalingMode') === 'outside' ?
      Math.max(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      ) :
      Math.min(
        w / Math.max(maxX - minX, 1),
        h / Math.max(maxY - minY, 1)
      );

    // Size homothetic parameters:
    if (!settings('maxNodeSize') && !settings('minNodeSize')) {
      a = 1;
      b = 0;
    } else if (settings('maxNodeSize') === settings('minNodeSize')) {
      a = 0;
      b = +settings('maxNodeSize');
    } else {
      a = (settings('maxNodeSize') - settings('minNodeSize')) / sizeMax;
      b = +settings('minNodeSize');
    }

    if (!settings('maxEdgeSize') && !settings('minEdgeSize')) {
      c = 1;
      d = 0;
    } else if (settings('maxEdgeSize') === settings('minEdgeSize')) {
      c = 0;
      d = +settings('minEdgeSize');
    } else {
      c = (settings('maxEdgeSize') - settings('minEdgeSize')) / weightMax;
      d = +settings('minEdgeSize');
    }

    // Rescale the nodes and edges:
    for (i = 0, l = e.length; i < l; i++)
      e[i][writePrefix + 'size'] =
        e[i][readPrefix + 'size'] * (es ? c : 1) + (es ? d : 0);

    for (i = 0, l = n.length; i < l; i++) {
      n[i][writePrefix + 'size'] =
        n[i][readPrefix + 'size'] * (ns ? a : 1) + (ns ? b : 0);
      n[i][writePrefix + 'x'] =
        (n[i][readPrefix + 'x'] - (maxX + minX) / 2) * (np ? scale : 1);
      n[i][writePrefix + 'y'] =
        (n[i][readPrefix + 'y'] - (maxY + minY) / 2) * (np ? scale : 1);
    }
  };

  sigma.utils.getBoundaries = function(graph, prefix, doEdges) {
    var i,
        l,
        e = graph.edges(),
        n = graph.nodes(),
        weightMax = -Infinity,
        sizeMax = -Infinity,
        minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;

    if (doEdges)
      for (i = 0, l = e.length; i < l; i++)
        weightMax = Math.max(e[i][prefix + 'size'], weightMax);

    for (i = 0, l = n.length; i < l; i++) {
      sizeMax = Math.max(n[i][prefix + 'size'], sizeMax);
      maxX = Math.max(n[i][prefix + 'x'], maxX);
      minX = Math.min(n[i][prefix + 'x'], minX);
      maxY = Math.max(n[i][prefix + 'y'], maxY);
      minY = Math.min(n[i][prefix + 'y'], minY);
    }

    weightMax = weightMax || 1;
    sizeMax = sizeMax || 1;

    return {
      weightMax: weightMax,
      sizeMax: sizeMax,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    };
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.middlewares');

  /**
   * This middleware will just copy the graphic properties.
   *
   * @param {?string} readPrefix  The read prefix.
   * @param {?string} writePrefix The write prefix.
   */
  sigma.middlewares.copy = function(readPrefix, writePrefix) {
    var i,
        l,
        a;

    if (writePrefix + '' === readPrefix + '')
      return;

    a = this.graph.nodes();
    for (i = 0, l = a.length; i < l; i++) {
      a[i][writePrefix + 'x'] = a[i][readPrefix + 'x'];
      a[i][writePrefix + 'y'] = a[i][readPrefix + 'y'];
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
    }

    a = this.graph.edges();
    for (i = 0, l = a.length; i < l; i++)
      a[i][writePrefix + 'size'] = a[i][readPrefix + 'size'];
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc.animation.running');

  /**
   * Generates a unique ID for the animation.
   *
   * @return {string} Returns the new ID.
   */
  var _getID = (function() {
    var id = 0;
    return function() {
      return '' + (++id);
    };
  })();

  /**
   * This function animates a camera. It has to be called with the camera to
   * animate, the values of the coordinates to reach and eventually some
   * options. It returns a number id, that you can use to kill the animation,
   * with the method sigma.misc.animation.kill(id).
   *
   * The available options are:
   *
   *   {?number}            duration   The duration of the animation.
   *   {?function}          onNewFrame A callback to execute when the animation
   *                                   enter a new frame.
   *   {?function}          onComplete A callback to execute when the animation
   *                                   is completed or killed.
   *   {?(string|function)} easing     The name of a function from the package
   *                                   sigma.utils.easings, or a custom easing
   *                                   function.
   *
   * @param  {camera}  camera  The camera to animate.
   * @param  {object}  target  The coordinates to reach.
   * @param  {?object} options Eventually an object to specify some options to
   *                           the function. The available options are
   *                           presented in the description of the function.
   * @return {number}          The animation id, to make it easy to kill
   *                           through the method "sigma.misc.animation.kill".
   */
  sigma.misc.animation.camera = function(camera, val, options) {
    if (
      !(camera instanceof sigma.classes.camera) ||
      typeof val !== 'object' ||
      !val
    )
      throw 'animation.camera: Wrong arguments.';

    if (
      typeof val.x !== 'number' &&
      typeof val.y !== 'number' &&
      typeof val.ratio !== 'number' &&
      typeof val.angle !== 'number'
    )
      throw 'There must be at least one valid coordinate in the given val.';

    var fn,
        id,
        anim,
        easing,
        duration,
        initialVal,
        o = options || {},
        start = sigma.utils.dateNow();

    // Store initial values:
    initialVal = {
      x: camera.x,
      y: camera.y,
      ratio: camera.ratio,
      angle: camera.angle
    };

    duration = o.duration;
    easing = typeof o.easing !== 'function' ?
      sigma.utils.easings[o.easing || 'quadraticInOut'] :
      o.easing;

    fn = function() {
      var coef,
          t = o.duration ? (sigma.utils.dateNow() - start) / o.duration : 1;

      // If the animation is over:
      if (t >= 1) {
        camera.isAnimated = false;
        camera.goTo({
          x: val.x !== undefined ? val.x : initialVal.x,
          y: val.y !== undefined ? val.y : initialVal.y,
          ratio: val.ratio !== undefined ? val.ratio : initialVal.ratio,
          angle: val.angle !== undefined ? val.angle : initialVal.angle
        });

        cancelAnimationFrame(id);
        delete sigma.misc.animation.running[id];

        // Check callbacks:
        if (typeof o.onComplete === 'function')
          o.onComplete();

      // Else, let's keep going:
      } else {
        coef = easing(t);
        camera.isAnimated = true;
        camera.goTo({
          x: val.x !== undefined ?
            initialVal.x + (val.x - initialVal.x) * coef :
            initialVal.x,
          y: val.y !== undefined ?
            initialVal.y + (val.y - initialVal.y) * coef :
            initialVal.y,
          ratio: val.ratio !== undefined ?
            initialVal.ratio + (val.ratio - initialVal.ratio) * coef :
            initialVal.ratio,
          angle: val.angle !== undefined ?
            initialVal.angle + (val.angle - initialVal.angle) * coef :
            initialVal.angle
        });

        // Check callbacks:
        if (typeof o.onNewFrame === 'function')
          o.onNewFrame();

        anim.frameId = requestAnimationFrame(fn);
      }
    };

    id = _getID();
    anim = {
      frameId: requestAnimationFrame(fn),
      target: camera,
      type: 'camera',
      options: o,
      fn: fn
    };
    sigma.misc.animation.running[id] = anim;

    return id;
  };

  /**
   * Kills a running animation. It triggers the eventual onComplete callback.
   *
   * @param  {number} id  The id of the animation to kill.
   * @return {object}     Returns the sigma.misc.animation package.
   */
  sigma.misc.animation.kill = function(id) {
    if (arguments.length !== 1 || typeof id !== 'number')
      throw 'animation.kill: Wrong arguments.';

    var o = sigma.misc.animation.running[id];

    if (o) {
      cancelAnimationFrame(id);
      delete sigma.misc.animation.running[o.frameId];

      if (o.type === 'camera')
        o.target.isAnimated = false;

      // Check callbacks:
      if (typeof (o.options || {}).onComplete === 'function')
        o.options.onComplete();
    }

    return this;
  };

  /**
   * Kills every running animations, or only the one with the specified type,
   * if a string parameter is given.
   *
   * @param  {?(string|object)} filter A string to filter the animations to kill
   *                                   on their type (example: "camera"), or an
   *                                   object to filter on their target.
   * @return {number}                  Returns the number of animations killed
   *                                   that way.
   */
  sigma.misc.animation.killAll = function(filter) {
    var o,
        id,
        count = 0,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      ) {
        o = sigma.misc.animation.running[id];
        cancelAnimationFrame(o.frameId);
        delete sigma.misc.animation.running[id];

        if (o.type === 'camera')
          o.target.isAnimated = false;

        // Increment counter:
        count++;

        // Check callbacks:
        if (typeof (o.options || {}).onComplete === 'function')
          o.options.onComplete();
      }

    return count;
  };

  /**
   * Returns "true" if any animation that is currently still running matches
   * the filter given to the function.
   *
   * @param  {string|object} filter A string to filter the animations to kill
   *                                on their type (example: "camera"), or an
   *                                object to filter on their target.
   * @return {boolean}              Returns true if any running animation
   *                                matches.
   */
  sigma.misc.animation.has = function(filter) {
    var id,
        type = typeof filter === 'string' ? filter : null,
        target = typeof filter === 'object' ? filter : null,
        running = sigma.misc.animation.running;

    for (id in running)
      if (
        (!type || running[id].type === type) &&
        (!target || running[id].target === target)
      )
        return true;

    return false;
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any no-DOM renderer (for instance canvas or WebGL)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindEvents = function(prefix) {
    var i,
        l,
        mX,
        mY,
        captor,
        self = this;

    function getNodes(e) {
      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          n,
          x,
          y,
          s,
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          nodes = self.camera.quadtree.point(
            point.x,
            point.y
          );

      if (nodes.length)
        for (i = 0, l = nodes.length; i < l; i++) {
          n = nodes[i];
          x = n[prefix + 'x'];
          y = n[prefix + 'y'];
          s = n[prefix + 'size'];

          if (
            !n.hidden &&
            modifiedX > x - s &&
            modifiedX < x + s &&
            modifiedY > y - s &&
            modifiedY < y + s &&
            Math.sqrt(
              Math.pow(modifiedX - x, 2) +
              Math.pow(modifiedY - y, 2)
            ) < s
          ) {
            // Insert the node:
            inserted = false;

            for (j = 0; j < selected.length; j++)
              if (n.size > selected[j].size) {
                selected.splice(j, 0, n);
                inserted = true;
                break;
              }

            if (!inserted)
              selected.push(n);
          }
        }

      return selected;
    }


    function getEdges(e) {
      if (!self.settings('enableEdgeHovering')) {
        // No event if the setting is off:
        return [];
      }

      var isCanvas = (
        sigma.renderers.canvas && self instanceof sigma.renderers.canvas);

      if (!isCanvas) {
        // A quick hardcoded rule to prevent people from using this feature
        // with the WebGL renderer (which is not good enough at the moment):
        throw new Error(
          'The edge events feature is not compatible with the WebGL renderer'
        );
      }

      if (e) {
        mX = 'x' in e.data ? e.data.x : mX;
        mY = 'y' in e.data ? e.data.y : mY;
      }

      var i,
          j,
          l,
          a,
          edge,
          s,
          maxEpsilon = self.settings('edgeHoverPrecision'),
          source,
          target,
          cp,
          nodeIndex = {},
          inserted,
          selected = [],
          modifiedX = mX + self.width / 2,
          modifiedY = mY + self.height / 2,
          point = self.camera.cameraPosition(
            mX,
            mY
          ),
          edges = [];

      if (isCanvas) {
        var nodesOnScreen = self.camera.quadtree.area(
          self.camera.getRectangle(self.width, self.height)
        );
        for (a = nodesOnScreen, i = 0, l = a.length; i < l; i++)
          nodeIndex[a[i].id] = a[i];
      }

      if (self.camera.edgequadtree !== undefined) {
        edges = self.camera.edgequadtree.point(
          point.x,
          point.y
        );
      }

      function insertEdge(selected, edge) {
        inserted = false;

        for (j = 0; j < selected.length; j++)
          if (edge.size > selected[j].size) {
            selected.splice(j, 0, edge);
            inserted = true;
            break;
          }

        if (!inserted)
          selected.push(edge);
      }

      if (edges.length)
        for (i = 0, l = edges.length; i < l; i++) {
          edge = edges[i];
          source = self.graph.nodes(edge.source);
          target = self.graph.nodes(edge.target);
          // (HACK) we can't get edge[prefix + 'size'] on WebGL renderer:
          s = edge[prefix + 'size'] ||
              edge['read_' + prefix + 'size'];

          // First, let's identify which edges are drawn. To do this, we keep
          // every edges that have at least one extremity displayed according to
          // the quadtree and the "hidden" attribute. We also do not keep hidden
          // edges.
          // Then, let's check if the mouse is on the edge (we suppose that it
          // is a line segment).

          if (
            !edge.hidden &&
            !source.hidden && !target.hidden &&
            (!isCanvas ||
              (nodeIndex[edge.source] || nodeIndex[edge.target])) &&
            sigma.utils.getDistance(
              source[prefix + 'x'],
              source[prefix + 'y'],
              modifiedX,
              modifiedY) > source[prefix + 'size'] &&
            sigma.utils.getDistance(
              target[prefix + 'x'],
              target[prefix + 'y'],
              modifiedX,
              modifiedY) > target[prefix + 'size']
          ) {
            if (edge.type == 'curve' || edge.type == 'curvedArrow') {
              if (source.id === target.id) {
                cp = sigma.utils.getSelfLoopControlPoints(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  source[prefix + 'size']
                );
                if (
                  sigma.utils.isPointOnBezierCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x1,
                  cp.y1,
                  cp.x2,
                  cp.y2,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
              else {
                cp = sigma.utils.getQuadraticControlPoint(
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y']);
                if (
                  sigma.utils.isPointOnQuadraticCurve(
                  modifiedX,
                  modifiedY,
                  source[prefix + 'x'],
                  source[prefix + 'y'],
                  target[prefix + 'x'],
                  target[prefix + 'y'],
                  cp.x,
                  cp.y,
                  Math.max(s, maxEpsilon)
                )) {
                  insertEdge(selected, edge);
                }
              }
            } else if (
                sigma.utils.isPointOnSegment(
                modifiedX,
                modifiedY,
                source[prefix + 'x'],
                source[prefix + 'y'],
                target[prefix + 'x'],
                target[prefix + 'y'],
                Math.max(s, maxEpsilon)
              )) {
              insertEdge(selected, edge);
            }
          }
        }

      return selected;
    }


    function bindCaptor(captor) {
      var nodes,
          edges,
          overNodes = {},
          overEdges = {};

      function onClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('click', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('clickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('clickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('clickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('clickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('clickStage', {captor: e.data});
      }

      function onDoubleClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('doubleClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('doubleClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('doubleClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('doubleClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('doubleClickStage', {captor: e.data});
      }

      function onRightClick(e) {
        if (!self.settings('eventsEnabled'))
          return;

        self.dispatchEvent('rightClick', e.data);

        nodes = getNodes(e);
        edges = getEdges(e);

        if (nodes.length) {
          self.dispatchEvent('rightClickNode', {
            node: nodes[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickNodes', {
            node: nodes,
            captor: e.data
          });
        } else if (edges.length) {
          self.dispatchEvent('rightClickEdge', {
            edge: edges[0],
            captor: e.data
          });
          self.dispatchEvent('rightClickEdges', {
            edge: edges,
            captor: e.data
          });
        } else
          self.dispatchEvent('rightClickStage', {captor: e.data});
      }

      function onOut(e) {
        if (!self.settings('eventsEnabled'))
          return;

        var k,
            i,
            l,
            le,
            outNodes = [],
            outEdges = [];

        for (k in overNodes)
          outNodes.push(overNodes[k]);

        overNodes = {};
        // Dispatch both single and multi events:
        for (i = 0, l = outNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: outNodes[i],
            captor: e.data
          });
        if (outNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: outNodes,
            captor: e.data
          });

        overEdges = {};
        // Dispatch both single and multi events:
        for (i = 0, le = outEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: outEdges[i],
            captor: e.data
          });
        if (outEdges.length)
          self.dispatchEvent('outEdges', {
            edges: outEdges,
            captor: e.data
          });
      }

      function onMove(e) {
        if (!self.settings('eventsEnabled'))
          return;

        nodes = getNodes(e);
        edges = getEdges(e);

        var i,
            k,
            node,
            edge,
            newOutNodes = [],
            newOverNodes = [],
            currentOverNodes = {},
            l = nodes.length,
            newOutEdges = [],
            newOverEdges = [],
            currentOverEdges = {},
            le = edges.length;

        // Check newly overred nodes:
        for (i = 0; i < l; i++) {
          node = nodes[i];
          currentOverNodes[node.id] = node;
          if (!overNodes[node.id]) {
            newOverNodes.push(node);
            overNodes[node.id] = node;
          }
        }

        // Check no more overred nodes:
        for (k in overNodes)
          if (!currentOverNodes[k]) {
            newOutNodes.push(overNodes[k]);
            delete overNodes[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, l = newOverNodes.length; i < l; i++)
          self.dispatchEvent('overNode', {
            node: newOverNodes[i],
            captor: e.data
          });
        for (i = 0, l = newOutNodes.length; i < l; i++)
          self.dispatchEvent('outNode', {
            node: newOutNodes[i],
            captor: e.data
          });
        if (newOverNodes.length)
          self.dispatchEvent('overNodes', {
            nodes: newOverNodes,
            captor: e.data
          });
        if (newOutNodes.length)
          self.dispatchEvent('outNodes', {
            nodes: newOutNodes,
            captor: e.data
          });

        // Check newly overred edges:
        for (i = 0; i < le; i++) {
          edge = edges[i];
          currentOverEdges[edge.id] = edge;
          if (!overEdges[edge.id]) {
            newOverEdges.push(edge);
            overEdges[edge.id] = edge;
          }
        }

        // Check no more overred edges:
        for (k in overEdges)
          if (!currentOverEdges[k]) {
            newOutEdges.push(overEdges[k]);
            delete overEdges[k];
          }

        // Dispatch both single and multi events:
        for (i = 0, le = newOverEdges.length; i < le; i++)
          self.dispatchEvent('overEdge', {
            edge: newOverEdges[i],
            captor: e.data
          });
        for (i = 0, le = newOutEdges.length; i < le; i++)
          self.dispatchEvent('outEdge', {
            edge: newOutEdges[i],
            captor: e.data
          });
        if (newOverEdges.length)
          self.dispatchEvent('overEdges', {
            edges: newOverEdges,
            captor: e.data
          });
        if (newOutEdges.length)
          self.dispatchEvent('outEdges', {
            edges: newOutEdges,
            captor: e.data
          });
      }

      // Bind events:
      captor.bind('click', onClick);
      captor.bind('mousedown', onMove);
      captor.bind('mouseup', onMove);
      captor.bind('mousemove', onMove);
      captor.bind('mouseout', onOut);
      captor.bind('doubleclick', onDoubleClick);
      captor.bind('rightclick', onRightClick);
      self.bind('render', onMove);
    }

    for (i = 0, l = this.captors.length; i < l; i++)
      bindCaptor(this.captors[i]);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This helper will bind any DOM renderer (for instance svg)
   * to its captors, to properly dispatch the good events to the sigma instance
   * to manage clicking, hovering etc...
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.bindDOMEvents = function(container) {
    var self = this,
        graph = this.graph;

    // DOMElement abstraction
    function Element(domElement) {

      // Helpers
      this.attr = function(attrName) {
        return domElement.getAttributeNS(null, attrName);
      };

      // Properties
      this.tag = domElement.tagName;
      this.class = this.attr('class');
      this.id = this.attr('id');

      // Methods
      this.isNode = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-node');
      };

      this.isEdge = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-edge');
      };

      this.isHover = function() {
        return !!~this.class.indexOf(self.settings('classPrefix') + '-hover');
      };
    }

    // Click
    function click(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('click', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('clickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('clickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // Double click
    function doubleClick(e) {
      if (!self.settings('eventsEnabled'))
        return;

      // Generic event
      self.dispatchEvent('doubleClick', e);

      // Are we on a node?
      var element = new Element(e.target);

      if (element.isNode())
        self.dispatchEvent('doubleClickNode', {
          node: graph.nodes(element.attr('data-node-id'))
        });
      else
        self.dispatchEvent('doubleClickStage');

      e.preventDefault();
      e.stopPropagation();
    }

    // On over
    function onOver(e) {
      var target = e.toElement || e.target;

      if (!self.settings('eventsEnabled') || !target)
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('overNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('overEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // On out
    function onOut(e) {
      var target = e.fromElement || e.originalTarget;

      if (!self.settings('eventsEnabled'))
        return;

      var el = new Element(target);

      if (el.isNode()) {
        self.dispatchEvent('outNode', {
          node: graph.nodes(el.attr('data-node-id'))
        });
      }
      else if (el.isEdge()) {
        var edge = graph.edges(el.attr('data-edge-id'));
        self.dispatchEvent('outEdge', {
          edge: edge,
          source: graph.nodes(edge.source),
          target: graph.nodes(edge.target)
        });
      }
    }

    // Registering Events:

    // Click
    container.addEventListener('click', click, false);
    sigma.utils.doubleClick(container, 'click', doubleClick);

    // Touch counterparts
    container.addEventListener('touchstart', click, false);
    sigma.utils.doubleClick(container, 'touchstart', doubleClick);

    // Mouseover
    container.addEventListener('mouseover', onOver, true);

    // Mouseout
    container.addEventListener('mouseout', onOut, true);
  };
}).call(this);

;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  // Initialize packages:
  sigma.utils.pkg('sigma.misc');

  /**
   * This method listens to "overNode", "outNode", "overEdge" and "outEdge"
   * events from a renderer and renders the nodes differently on the top layer.
   * The goal is to make any node label readable with the mouse, and to
   * highlight hovered nodes and edges.
   *
   * It has to be called in the scope of the related renderer.
   */
  sigma.misc.drawHovers = function(prefix) {
    var self = this,
        hoveredNodes = {},
        hoveredEdges = {};

    this.bind('overNode', function(event) {
      var node = event.data.node;
      if (!node.hidden) {
        hoveredNodes[node.id] = node;
        draw();
      }
    });

    this.bind('outNode', function(event) {
      delete hoveredNodes[event.data.node.id];
      draw();
    });

    this.bind('overEdge', function(event) {
      var edge = event.data.edge;
      if (!edge.hidden) {
        hoveredEdges[edge.id] = edge;
        draw();
      }
    });

    this.bind('outEdge', function(event) {
      delete hoveredEdges[event.data.edge.id];
      draw();
    });

    this.bind('render', function(event) {
      draw();
    });

    function draw() {

      var k,
          source,
          target,
          hoveredNode,
          hoveredEdge,
          c = self.contexts.hover.canvas,
          defaultNodeType = self.settings('defaultNodeType'),
          defaultEdgeType = self.settings('defaultEdgeType'),
          nodeRenderers = sigma.canvas.hovers,
          edgeRenderers = sigma.canvas.edgehovers,
          extremitiesRenderers = sigma.canvas.extremities,
          embedSettings = self.settings.embedObjects({
            prefix: prefix
          });

      // Clear self.contexts.hover:
      self.contexts.hover.clearRect(0, 0, c.width, c.height);

      // Node render: single hover
      if (
        embedSettings('enableHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredNodes).length
      ) {
        hoveredNode = hoveredNodes[Object.keys(hoveredNodes)[0]];
        (
          nodeRenderers[hoveredNode.type] ||
          nodeRenderers[defaultNodeType] ||
          nodeRenderers.def
        )(
          hoveredNode,
          self.contexts.hover,
          embedSettings
        );
      }

      // Node render: multiple hover
      if (
        embedSettings('enableHovering') &&
        !embedSettings('singleHover')
      )
        for (k in hoveredNodes)
          (
            nodeRenderers[hoveredNodes[k].type] ||
            nodeRenderers[defaultNodeType] ||
            nodeRenderers.def
          )(
            hoveredNodes[k],
            self.contexts.hover,
            embedSettings
          );

      // Edge render: single hover
      if (
        embedSettings('enableEdgeHovering') &&
        embedSettings('singleHover') &&
        Object.keys(hoveredEdges).length
      ) {
        hoveredEdge = hoveredEdges[Object.keys(hoveredEdges)[0]];
        source = self.graph.nodes(hoveredEdge.source);
        target = self.graph.nodes(hoveredEdge.target);

        if (! hoveredEdge.hidden) {
          (
            edgeRenderers[hoveredEdge.type] ||
            edgeRenderers[defaultEdgeType] ||
            edgeRenderers.def
          ) (
            hoveredEdge,
            source,
            target,
            self.contexts.hover,
            embedSettings
          );

          if (embedSettings('edgeHoverExtremities')) {
            (
              extremitiesRenderers[hoveredEdge.type] ||
              extremitiesRenderers.def
            )(
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

          } else {
            // Avoid edges rendered over nodes:
            (
              sigma.canvas.nodes[source.type] ||
              sigma.canvas.nodes.def
            ) (
              source,
              self.contexts.hover,
              embedSettings
            );
            (
              sigma.canvas.nodes[target.type] ||
              sigma.canvas.nodes.def
            ) (
              target,
              self.contexts.hover,
              embedSettings
            );
          }
        }
      }

      // Edge render: multiple hover
      if (
        embedSettings('enableEdgeHovering') &&
        !embedSettings('singleHover')
      ) {
        for (k in hoveredEdges) {
          hoveredEdge = hoveredEdges[k];
          source = self.graph.nodes(hoveredEdge.source);
          target = self.graph.nodes(hoveredEdge.target);

          if (!hoveredEdge.hidden) {
            (
              edgeRenderers[hoveredEdge.type] ||
              edgeRenderers[defaultEdgeType] ||
              edgeRenderers.def
            ) (
              hoveredEdge,
              source,
              target,
              self.contexts.hover,
              embedSettings
            );

            if (embedSettings('edgeHoverExtremities')) {
              (
                extremitiesRenderers[hoveredEdge.type] ||
                extremitiesRenderers.def
              )(
                hoveredEdge,
                source,
                target,
                self.contexts.hover,
                embedSettings
              );
            } else {
              // Avoid edges rendered over nodes:
              (
                sigma.canvas.nodes[source.type] ||
                sigma.canvas.nodes.def
              ) (
                source,
                self.contexts.hover,
                embedSettings
              );
              (
                sigma.canvas.nodes[target.type] ||
                sigma.canvas.nodes.def
              ) (
                target,
                self.contexts.hover,
                embedSettings
              );
            }
          }
        }
      }
    }
  };
}).call(this);

},{}],9:[function(require,module,exports){
;(function(undefined) {
  'use strict';

  if (typeof sigma === 'undefined')
    throw new Error('sigma is not declared');

  // Initialize package:
  sigma.utils.pkg('sigma.layout.noverlap');

  /**
   * Noverlap Layout
   * ===============================
   *
   * Author: @apitts / Andrew Pitts
   * Algorithm: @jacomyma / Mathieu Jacomy (originally contributed to Gephi and ported to sigma.js under the MIT license by @andpitts with permission)
   * Acknowledgement: @sheyman / SÃ©bastien Heymann (some inspiration has been taken from other MIT licensed layout algorithms authored by @sheyman)
   * Version: 0.1
   */

  var settings = {
    speed: 3,
    scaleNodes: 1.2,
    nodeMargin: 5.0,
    gridSize: 20,
    permittedExpansion: 1.1,
    rendererIndex: 0,
    maxIterations: 500
  };

  var _instance = {};

  /**
   * Event emitter Object
   * ------------------
   */
  var _eventEmitter = {};

   /**
   * Noverlap Object
   * ------------------
   */
  function Noverlap() {
    var self = this;

    this.init = function (sigInst, options) {
      options = options || {};

      // Properties
      this.sigInst = sigInst;
      this.config = sigma.utils.extend(options, settings);
      this.easing = options.easing;
      this.duration = options.duration;

      if (options.nodes) {
        this.nodes = options.nodes;
        delete options.nodes;
      }

      if (!sigma.plugins || typeof sigma.plugins.animate === 'undefined') {
        throw new Error('sigma.plugins.animate is not declared');
      }

      // State
      this.running = false;
    };

    /**
     * Single layout iteration.
     */
    this.atomicGo = function () {
      if (!this.running || this.iterCount < 1) return false;

      var nodes = this.nodes || this.sigInst.graph.nodes(),
          nodesCount = nodes.length,
          i,
          n,
          n1,
          n2,
          xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity,
          xwidth,
          yheight,
          xcenter,
          ycenter,
          grid,
          row,
          col,
          minXBox,
          maxXBox,
          minYBox,
          maxYBox,
          adjacentNodes,
          subRow,
          subCol,
          nxmin,
          nxmax,
          nymin,
          nymax;

      this.iterCount--;
      this.running = false;

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        n.dn.dx = 0;
        n.dn.dy = 0;

        //Find the min and max for both x and y across all nodes
        xmin = Math.min(xmin, n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        xmax = Math.max(xmax, n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymin = Math.min(ymin, n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );
        ymax = Math.max(ymax, n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin) );

      }

      xwidth = xmax - xmin;
      yheight = ymax - ymin;
      xcenter = (xmin + xmax) / 2;
      ycenter = (ymin + ymax) / 2;
      xmin = xcenter - self.config.permittedExpansion*xwidth / 2;
      xmax = xcenter + self.config.permittedExpansion*xwidth / 2;
      ymin = ycenter - self.config.permittedExpansion*yheight / 2;
      ymax = ycenter + self.config.permittedExpansion*yheight / 2;

      grid = {}; //An object of objects where grid[row][col] is an array of node ids representing nodes that fall in that grid. Nodes can fall in more than one grid

      for(row = 0; row < self.config.gridSize; row++) {
        grid[row] = {};
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col] = [];
        }
      }

      //Place nodes in grid
      for (i=0; i < nodesCount; i++) {
        n = nodes[i];

        nxmin = n.dn_x - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nxmax = n.dn_x + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymin = n.dn_y - (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);
        nymax = n.dn_y + (n.dn_size*self.config.scaleNodes + self.config.nodeMargin);

        minXBox = Math.floor(self.config.gridSize* (nxmin - xmin) / (xmax - xmin) );
        maxXBox = Math.floor(self.config.gridSize* (nxmax - xmin) / (xmax - xmin) );
        minYBox = Math.floor(self.config.gridSize* (nymin - ymin) / (ymax - ymin) );
        maxYBox = Math.floor(self.config.gridSize* (nymax - ymin) / (ymax - ymin) );
        for(col = minXBox; col <= maxXBox; col++) {
          for(row = minYBox; row <= maxYBox; row++) {
            grid[row][col].push(n.id);
          }
        }
      }


      adjacentNodes = {}; //An object that stores the node ids of adjacent nodes (either in same grid box or adjacent grid box) for all nodes

      for(row = 0; row < self.config.gridSize; row++) {
        for(col = 0; col < self.config.gridSize; col++) {
          grid[row][col].forEach(function(nodeId) {
            if(!adjacentNodes[nodeId]) {
              adjacentNodes[nodeId] = [];
            }
            for(subRow = Math.max(0, row - 1); subRow <= Math.min(row + 1, self.config.gridSize - 1); subRow++) {
              for(subCol = Math.max(0, col - 1); subCol <= Math.min(col + 1,  self.config.gridSize - 1); subCol++) {
                grid[subRow][subCol].forEach(function(subNodeId) {
                  if(subNodeId !== nodeId && adjacentNodes[nodeId].indexOf(subNodeId) === -1) {
                    adjacentNodes[nodeId].push(subNodeId);
                  }
                });
              }
            }
          });
        }
      }

      //If two nodes overlap then repulse them
      for (i=0; i < nodesCount; i++) {
        n1 = nodes[i];
        adjacentNodes[n1.id].forEach(function(nodeId) {
          var n2 = self.sigInst.graph.nodes(nodeId);
          var xDist = n2.dn_x - n1.dn_x;
          var yDist = n2.dn_y - n1.dn_y;
          var dist = Math.sqrt(xDist*xDist + yDist*yDist);
          var collision = (dist < ((n1.dn_size*self.config.scaleNodes + self.config.nodeMargin) + (n2.dn_size*self.config.scaleNodes + self.config.nodeMargin)));
          if(collision) {
            self.running = true;
            if(dist > 0) {
              n2.dn.dx += xDist / dist * (1 + n1.dn_size);
              n2.dn.dy += yDist / dist * (1 + n1.dn_size);
            } else {
              n2.dn.dx += xwidth * 0.01 * (0.5 - Math.random());
              n2.dn.dy += yheight * 0.01 * (0.5 - Math.random());
            }
          }
        });
      }

      for (i=0; i < nodesCount; i++) {
        n = nodes[i];
        if(!n.fixed) {
          n.dn_x = n.dn_x + n.dn.dx * 0.1 * self.config.speed;
          n.dn_y = n.dn_y + n.dn.dy * 0.1 * self.config.speed;
        }
      }

      if(this.running && this.iterCount < 1) {
        this.running = false;
      }

      return this.running;
    };

    this.go = function () {
      this.iterCount = this.config.maxIterations;

      while (this.running) {
        this.atomicGo();
      };

      this.stop();
    };

    this.start = function() {
      if (this.running) return;

      var nodes = this.sigInst.graph.nodes();

      var prefix = this.sigInst.renderers[self.config.rendererIndex].options.prefix;

      this.running = true;

      // Init nodes
      for (var i = 0; i < nodes.length; i++) {
        nodes[i].dn_x = nodes[i][prefix + 'x'];
        nodes[i].dn_y = nodes[i][prefix + 'y'];
        nodes[i].dn_size = nodes[i][prefix + 'size'];
        nodes[i].dn = {
          dx: 0,
          dy: 0
        };
      }
      _eventEmitter[self.sigInst.id].dispatchEvent('start');
      this.go();
    };

    this.stop = function() {
      var nodes = this.sigInst.graph.nodes();

      this.running = false;

      if (this.easing) {
        _eventEmitter[self.sigInst.id].dispatchEvent('interpolate');
        sigma.plugins.animate(
          self.sigInst,
          {
            x: 'dn_x',
            y: 'dn_y'
          },
          {
            easing: self.easing,
            onComplete: function() {
              self.sigInst.refresh();
              for (var i = 0; i < nodes.length; i++) {
                nodes[i].dn = null;
                nodes[i].dn_x = null;
                nodes[i].dn_y = null;
              }
              _eventEmitter[self.sigInst.id].dispatchEvent('stop');
            },
            duration: self.duration
          }
        );
      }
      else {
        // Apply changes
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].x = nodes[i].dn_x;
          nodes[i].y = nodes[i].dn_y;
        }

        this.sigInst.refresh();

        for (var i = 0; i < nodes.length; i++) {
          nodes[i].dn = null;
          nodes[i].dn_x = null;
          nodes[i].dn_y = null;
        }
        _eventEmitter[self.sigInst.id].dispatchEvent('stop');
      }
    };

    this.kill = function() {
      this.sigInst = null;
      this.config = null;
      this.easing = null;
    };
  };

  /**
   * Interface
   * ----------
   */

  /**
   * Configure the layout algorithm.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object:
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */
  sigma.prototype.configNoverlap = function(config) {

    var sigInst = this;

    if (!config) throw new Error('Missing argument: "config"');

    // Create instance if undefined
    if (!_instance[sigInst.id]) {
      _instance[sigInst.id] = new Noverlap();

      _eventEmitter[sigInst.id] = {};
      sigma.classes.dispatcher.extend(_eventEmitter[sigInst.id]);

      // Binding on kill to clear the references
      sigInst.bind('kill', function() {
        _instance[sigInst.id].kill();
        _instance[sigInst.id] = null;
        _eventEmitter[sigInst.id] = null;
      });
    }

    _instance[sigInst.id].init(sigInst, config);

    return _eventEmitter[sigInst.id];
  };

  /**
   * Start the layout algorithm. It will use the existing configuration if no
   * new configuration is passed.

   * Recognized options:
   * **********************
   * Here is the exhaustive list of every accepted parameter in the settings
   * object
   *
   *   {?number}            speed               A larger value increases the convergence speed at the cost of precision
   *   {?number}            scaleNodes          The ratio to scale nodes by - a larger ratio will lead to more space around larger nodes
   *   {?number}            nodeMargin          A fixed margin to apply around nodes regardless of size
   *   {?number}            maxIterations       The maximum number of iterations to perform before the layout completes.
   *   {?integer}           gridSize            The number of rows and columns to use when partioning nodes into a grid for efficient computation
   *   {?number}            permittedExpansion  A permitted expansion factor to the overall size of the network applied at each iteration
   *   {?integer}           rendererIndex       The index of the renderer to use for node co-ordinates. Defaults to zero.
   *   {?(function|string)} easing              Either the name of an easing in the sigma.utils.easings package or a function. If not specified, the
   *                                            quadraticInOut easing from this package will be used instead.
   *   {?number}            duration            The duration of the animation. If not specified, the "animationsTime" setting value of the sigma instance will be used instead.
   *
   *
   *
   * @param  {object} config  The optional configuration object.
   *
   * @return {sigma.classes.dispatcher} Returns an event emitter.
   */

  sigma.prototype.startNoverlap = function(config) {

    var sigInst = this;

    if (config) {
      this.configNoverlap(sigInst, config);
    }

    _instance[sigInst.id].start();

    return _eventEmitter[sigInst.id];
  };

  /**
   * Returns true if the layout has started and is not completed.
   *
   * @return {boolean}
   */
  sigma.prototype.isNoverlapRunning = function() {

    var sigInst = this;

    return !!_instance[sigInst.id] && _instance[sigInst.id].running;
  };

}).call(this);
},{}],10:[function(require,module,exports){
/**
 * This plugin provides a method to animate a sigma instance by interpolating
 * some node properties. Check the sigma.plugins.animate function doc or the
 * examples/animate.html code sample to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');

  var _id = 0,
      _cache = {};

  // TOOLING FUNCTIONS:
  // ******************
  function parseColor(val) {
    if (_cache[val])
      return _cache[val];

    var result = [0, 0, 0];

    if (val.match(/^#/)) {
      val = (val || '').replace(/^#/, '');
      result = (val.length === 3) ?
        [
          parseInt(val.charAt(0) + val.charAt(0), 16),
          parseInt(val.charAt(1) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(2), 16)
        ] :
        [
          parseInt(val.charAt(0) + val.charAt(1), 16),
          parseInt(val.charAt(2) + val.charAt(3), 16),
          parseInt(val.charAt(4) + val.charAt(5), 16)
        ];
    } else if (val.match(/^ *rgba? *\(/)) {
      val = val.match(
        /^ *rgba? *\( *([0-9]*) *, *([0-9]*) *, *([0-9]*) *(,.*)?\) *$/
      );
      result = [
        +val[1],
        +val[2],
        +val[3]
      ];
    }

    _cache[val] = {
      r: result[0],
      g: result[1],
      b: result[2]
    };

    return _cache[val];
  }

  function interpolateColors(c1, c2, p) {
    c1 = parseColor(c1);
    c2 = parseColor(c2);

    var c = {
      r: c1.r * (1 - p) + c2.r * p,
      g: c1.g * (1 - p) + c2.g * p,
      b: c1.b * (1 - p) + c2.b * p
    };

    return 'rgb(' + [c.r | 0, c.g | 0, c.b | 0].join(',') + ')';
  }

  /**
   * This function will animate some specified node properties. It will
   * basically call requestAnimationFrame, interpolate the values and call the
   * refresh method during a specified duration.
   *
   * Recognized parameters:
   * **********************
   * Here is the exhaustive list of every accepted parameters in the settings
   * object:
   *
   *   {?array}             nodes      An array of node objects or node ids. If
   *                                   not specified, all nodes of the graph
   *                                   will be animated.
   *   {?(function|string)} easing     Either the name of an easing in the
   *                                   sigma.utils.easings package or a
   *                                   function. If not specified, the
   *                                   quadraticInOut easing from this package
   *                                   will be used instead.
   *   {?number}            duration   The duration of the animation. If not
   *                                   specified, the "animationsTime" setting
   *                                   value of the sigma instance will be used
   *                                   instead.
   *   {?function}          onComplete Eventually a function to call when the
   *                                   animation is ended.
   *
   * @param  {sigma}   s       The related sigma instance.
   * @param  {object}  animate An hash with the keys being the node properties
   *                           to interpolate, and the values being the related
   *                           target values.
   * @param  {?object} options Eventually an object with options.
   */
  sigma.plugins.animate = function(s, animate, options) {
    var o = options || {},
        id = ++_id,
        duration = o.duration || s.settings('animationsTime'),
        easing = typeof o.easing === 'string' ?
          sigma.utils.easings[o.easing] :
          typeof o.easing === 'function' ?
          o.easing :
          sigma.utils.easings.quadraticInOut,
        start = sigma.utils.dateNow(),
        nodes,
        startPositions;

    if (o.nodes && o.nodes.length) {
      if (typeof o.nodes[0] === 'object')
        nodes = o.nodes;
      else
        nodes = s.graph.nodes(o.nodes); // argument is an array of IDs
    }
    else
      nodes = s.graph.nodes();

    // Store initial positions:
    startPositions = nodes.reduce(function(res, node) {
      var k;
      res[node.id] = {};
      for (k in animate)
        if (k in node)
          res[node.id][k] = node[k];
      return res;
    }, {});

    s.animations = s.animations || Object.create({});
    sigma.plugins.kill(s);

    // Do not refresh edgequadtree during drag:
    var k,
        c;
    for (k in s.cameras) {
      c = s.cameras[k];
      c.edgequadtree._enabled = false;
    }

    function step() {
      var p = (sigma.utils.dateNow() - start) / duration;

      if (p >= 1) {
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate)
              node[k] = node[animate[k]];
        });

        // Allow to refresh edgequadtree:
        var k,
            c;
        for (k in s.cameras) {
          c = s.cameras[k];
          c.edgequadtree._enabled = true;
        }

        s.refresh();
        if (typeof o.onComplete === 'function')
          o.onComplete();
      } else {
        p = easing(p);
        nodes.forEach(function(node) {
          for (var k in animate)
            if (k in animate) {
              if (k.match(/color$/))
                node[k] = interpolateColors(
                  startPositions[node.id][k],
                  node[animate[k]],
                  p
                );
              else
                node[k] =
                  node[animate[k]] * p +
                  startPositions[node.id][k] * (1 - p);
            }
        });

        s.refresh();
        s.animations[id] = requestAnimationFrame(step);
      }
    }

    step();
  };

  sigma.plugins.kill = function(s) {
    for (var k in (s.animations || {}))
      cancelAnimationFrame(s.animations[k]);

    // Allow to refresh edgequadtree:
    var k,
        c;
    for (k in s.cameras) {
      c = s.cameras[k];
      c.edgequadtree._enabled = true;
    }
  };
}).call(window);

},{}],11:[function(require,module,exports){
/**
 * This plugin provides a method to drag & drop nodes. Check the
 * sigma.plugins.dragNodes function doc or the examples/basic.html &
 * examples/api-candy.html code samples to know more.
 */
(function() {
  'use strict';

  if (typeof sigma === 'undefined')
    throw 'sigma is not declared';

  sigma.utils.pkg('sigma.plugins');


  /**
   * This function will add `mousedown`, `mouseup` & `mousemove` events to the
   * nodes in the `overNode`event to perform drag & drop operations. It uses
   * `linear interpolation` [http://en.wikipedia.org/wiki/Linear_interpolation]
   * and `rotation matrix` [http://en.wikipedia.org/wiki/Rotation_matrix] to
   * calculate the X and Y coordinates from the `cam` or `renderer` node
   * attributes. These attributes represent the coordinates of the nodes in
   * the real container, not in canvas.
   *
   * Fired events:
   * *************
   * startdrag  Fired at the beginning of the drag.
   * drag       Fired while the node is dragged.
   * drop       Fired at the end of the drag if the node has been dragged.
   * dragend    Fired at the end of the drag.
   *
   * Recognized parameters:
   * **********************
   * @param  {sigma}    s        The related sigma instance.
   * @param  {renderer} renderer The related renderer instance.
   */
  function DragNodes(s, renderer) {
    sigma.classes.dispatcher.extend(this);

    // A quick hardcoded rule to prevent people from using this plugin with the
    // WebGL renderer (which is impossible at the moment):
    // if (
    //   sigma.renderers.webgl &&
    //   renderer instanceof sigma.renderers.webgl
    // )
    //   throw new Error(
    //     'The sigma.plugins.dragNodes is not compatible with the WebGL renderer'
    //   );

    // Init variables:
    var _self = this,
      _s = s,
      _body = document.body,
      _renderer = renderer,
      _mouse = renderer.container.lastChild,
      _camera = renderer.camera,
      _node = null,
      _prefix = '',
      _hoverStack = [],
      _hoverIndex = {},
      _isMouseDown = false,
      _isMouseOverCanvas = false,
      _drag = false;

    if (renderer instanceof sigma.renderers.svg) {
        _mouse = renderer.container.firstChild;
    }

    // It removes the initial substring ('read_') if it's a WegGL renderer.
    if (renderer instanceof sigma.renderers.webgl) {
      _prefix = renderer.options.prefix.substr(5);
    } else {
      _prefix = renderer.options.prefix;
    }

    renderer.bind('overNode', nodeMouseOver);
    renderer.bind('outNode', treatOutNode);
    renderer.bind('click', click);

    _s.bind('kill', function() {
      _self.unbindAll();
    });

    /**
     * Unbind all event listeners.
     */
    this.unbindAll = function() {
      _mouse.removeEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);
      _renderer.unbind('overNode', nodeMouseOver);
      _renderer.unbind('outNode', treatOutNode);
    }

    // Calculates the global offset of the given element more accurately than
    // element.offsetTop and element.offsetLeft.
    function calculateOffset(element) {
      var style = window.getComputedStyle(element);
      var getCssProperty = function(prop) {
        return parseInt(style.getPropertyValue(prop).replace('px', '')) || 0;
      };
      return {
        left: element.getBoundingClientRect().left + getCssProperty('padding-left'),
        top: element.getBoundingClientRect().top + getCssProperty('padding-top')
      };
    };

    function click(event) {
      // event triggered at the end of the click
      _isMouseDown = false;
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      if (!_hoverStack.length) {
        _node = null;
      }
    };

    function nodeMouseOver(event) {
      // Don't treat the node if it is already registered
      if (_hoverIndex[event.data.node.id]) {
        return;
      }

      // Add node to array of current nodes over
      _hoverStack.push(event.data.node);
      _hoverIndex[event.data.node.id] = true;

      if(_hoverStack.length && ! _isMouseDown) {
        // Set the current node to be the last one in the array
        _node = _hoverStack[_hoverStack.length - 1];
        _mouse.addEventListener('mousedown', nodeMouseDown);
      }
    };

    function treatOutNode(event) {
      // Remove the node from the array
      var indexCheck = _hoverStack.map(function(e) { return e; }).indexOf(event.data.node);
      _hoverStack.splice(indexCheck, 1);
      delete _hoverIndex[event.data.node.id];

      if(_hoverStack.length && ! _isMouseDown) {
        // On out, set the current node to be the next stated in array
        _node = _hoverStack[_hoverStack.length - 1];
      } else {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
      }
    };

    function nodeMouseDown(event) {
      _isMouseDown = true;
      var size = _s.graph.nodes().length;

      // when there is only node in the graph, the plugin cannot apply
      // linear interpolation. So treat it as if a user is dragging
      // the graph
      if (_node && size > 1) {
        _mouse.removeEventListener('mousedown', nodeMouseDown);
        _body.addEventListener('mousemove', nodeMouseMove);
        _body.addEventListener('mouseup', nodeMouseUp);

        // Do not refresh edgequadtree during drag:
        var k,
            c;
        for (k in _s.cameras) {
          c = _s.cameras[k];
          if (c.edgequadtree !== undefined) {
            c.edgequadtree._enabled = false;
          }
        }

        // Deactivate drag graph.
        _renderer.settings({mouseEnabled: false, enableHovering: false});
        _s.refresh();

        _self.dispatchEvent('startdrag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };

    function nodeMouseUp(event) {
      _isMouseDown = false;
      _mouse.addEventListener('mousedown', nodeMouseDown);
      _body.removeEventListener('mousemove', nodeMouseMove);
      _body.removeEventListener('mouseup', nodeMouseUp);

      // Allow to refresh edgequadtree:
      var k,
          c;
      for (k in _s.cameras) {
        c = _s.cameras[k];
        if (c.edgequadtree !== undefined) {
          c.edgequadtree._enabled = true;
        }
      }

      // Activate drag graph.
      _renderer.settings({mouseEnabled: true, enableHovering: true});
      _s.refresh();

      if (_drag) {
        _self.dispatchEvent('drop', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
      _self.dispatchEvent('dragend', {
        node: _node,
        captor: event,
        renderer: _renderer
      });

      _drag = false;
      _node = null;
    };

    function nodeMouseMove(event) {
      if(navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        clearTimeout(timeOut);
        var timeOut = setTimeout(executeNodeMouseMove, 0);
      } else {
        executeNodeMouseMove();
      }

      function executeNodeMouseMove() {
        var offset = calculateOffset(_renderer.container),
            x = event.clientX - offset.left,
            y = event.clientY - offset.top,
            cos = Math.cos(_camera.angle),
            sin = Math.sin(_camera.angle),
            nodes = _s.graph.nodes(),
            ref = [];

        // Getting and derotating the reference coordinates.
        for (var i = 0; i < 2; i++) {
          var n = nodes[i];
          var aux = {
            x: n.x * cos + n.y * sin,
            y: n.y * cos - n.x * sin,
            renX: n[_prefix + 'x'],
            renY: n[_prefix + 'y'],
          };
          ref.push(aux);
        }

        // Applying linear interpolation.
        // if the nodes are on top of each other, we use the camera ratio to interpolate
        if (ref[0].x === ref[1].x && ref[0].y === ref[1].y) {
          var xRatio = (ref[0].renX === 0) ? 1 : ref[0].renX;
          var yRatio = (ref[0].renY === 0) ? 1 : ref[0].renY;
          x = (ref[0].x / xRatio) * (x - ref[0].renX) + ref[0].x;
          y = (ref[0].y / yRatio) * (y - ref[0].renY) + ref[0].y;
        } else {
          var xRatio = (ref[1].renX - ref[0].renX) / (ref[1].x - ref[0].x);
          var yRatio = (ref[1].renY - ref[0].renY) / (ref[1].y - ref[0].y);

          // if the coordinates are the same, we use the other ratio to interpolate
          if (ref[1].x === ref[0].x) {
            xRatio = yRatio;
          }

          if (ref[1].y === ref[0].y) {
            yRatio = xRatio;
          }

          x = (x - ref[0].renX) / xRatio + ref[0].x;
          y = (y - ref[0].renY) / yRatio + ref[0].y;
        }

        // Rotating the coordinates.
        _node.x = x * cos - y * sin;
        _node.y = y * cos + x * sin;

        _s.refresh();

        _drag = true;
        _self.dispatchEvent('drag', {
          node: _node,
          captor: event,
          renderer: _renderer
        });
      }
    };
  };

  /**
   * Interface
   * ------------------
   *
   * > var dragNodesListener = sigma.plugins.dragNodes(s, s.renderers[0]);
   */
  var _instance = {};

  /**
   * @param  {sigma} s The related sigma instance.
   * @param  {renderer} renderer The related renderer instance.
   */
  sigma.plugins.dragNodes = function(s, renderer) {
    // Create object if undefined
    if (!_instance[s.id]) {
      _instance[s.id] = new DragNodes(s, renderer);
    }

    s.bind('kill', function() {
      sigma.plugins.killDragNodes(s);
    });

    return _instance[s.id];
  };

  /**
   * This method removes the event listeners and kills the dragNodes instance.
   *
   * @param  {sigma} s The related sigma instance.
   */
  sigma.plugins.killDragNodes = function(s) {
    if (_instance[s.id] instanceof DragNodes) {
      _instance[s.id].unbindAll();
      delete _instance[s.id];
    }
  };

}).call(window);

},{}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var arrays = require("./arrays");
var LinkedList = /** @class */ (function () {
    /**
    * Creates an empty Linked List.
    * @class A linked list is a data structure consisting of a group of nodes
    * which together represent a sequence.
    * @constructor
    */
    function LinkedList() {
        /**
        * First node in the list
        * @type {Object}
        * @private
        */
        this.firstNode = null;
        /**
        * Last node in the list
        * @type {Object}
        * @private
        */
        this.lastNode = null;
        /**
        * Number of elements in the list
        * @type {number}
        * @private
        */
        this.nElements = 0;
    }
    /**
    * Adds an element to this list.
    * @param {Object} item element to be added.
    * @param {number=} index optional index to add the element. If no index is specified
    * the element is added to the end of this list.
    * @return {boolean} true if the element was added or false if the index is invalid
    * or if the element is undefined.
    */
    LinkedList.prototype.add = function (item, index) {
        if (util.isUndefined(index)) {
            index = this.nElements;
        }
        if (index < 0 || index > this.nElements || util.isUndefined(item)) {
            return false;
        }
        var newNode = this.createNode(item);
        if (this.nElements === 0 || this.lastNode === null) {
            // First node in the list.
            this.firstNode = newNode;
            this.lastNode = newNode;
        }
        else if (index === this.nElements) {
            // Insert at the end.
            this.lastNode.next = newNode;
            this.lastNode = newNode;
        }
        else if (index === 0) {
            // Change first node.
            newNode.next = this.firstNode;
            this.firstNode = newNode;
        }
        else {
            var prev = this.nodeAtIndex(index - 1);
            if (prev == null) {
                return false;
            }
            newNode.next = prev.next;
            prev.next = newNode;
        }
        this.nElements++;
        return true;
    };
    /**
    * Returns the first element in this list.
    * @return {*} the first element of the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.first = function () {
        if (this.firstNode !== null) {
            return this.firstNode.element;
        }
        return undefined;
    };
    /**
    * Returns the last element in this list.
    * @return {*} the last element in the list or undefined if the list is
    * empty.
    */
    LinkedList.prototype.last = function () {
        if (this.lastNode !== null) {
            return this.lastNode.element;
        }
        return undefined;
    };
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index desired index.
     * @return {*} the element at the given index or undefined if the index is
     * out of bounds.
     */
    LinkedList.prototype.elementAtIndex = function (index) {
        var node = this.nodeAtIndex(index);
        if (node === null) {
            return undefined;
        }
        return node.element;
    };
    /**
     * Returns the index in this list of the first occurrence of the
     * specified element, or -1 if the List does not contain this element.
     * <p>If the elements inside this list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {number} the index in this list of the first occurrence
     * of the specified element, or -1 if this list does not contain the
     * element.
     */
    LinkedList.prototype.indexOf = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (util.isUndefined(item)) {
            return -1;
        }
        var currentNode = this.firstNode;
        var index = 0;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                return index;
            }
            index++;
            currentNode = currentNode.next;
        }
        return -1;
    };
    /**
       * Returns true if this list contains the specified element.
       * <p>If the elements inside the list are
       * not comparable with the === operator a custom equals function should be
       * provided to perform searches, the function must receive two arguments and
       * return true if they are equal, false otherwise. Example:</p>
       *
       * <pre>
       * const petsAreEqualByName = function(pet1, pet2) {
       *  return pet1.name === pet2.name;
       * }
       * </pre>
       * @param {Object} item element to search for.
       * @param {function(Object,Object):boolean=} equalsFunction Optional
       * function used to check if two elements are equal.
       * @return {boolean} true if this list contains the specified element, false
       * otherwise.
       */
    LinkedList.prototype.contains = function (item, equalsFunction) {
        return (this.indexOf(item, equalsFunction) >= 0);
    };
    /**
     * Removes the first occurrence of the specified element in this list.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to be removed from this list, if present.
     * @return {boolean} true if the list contained the specified element.
     */
    LinkedList.prototype.remove = function (item, equalsFunction) {
        var equalsF = equalsFunction || util.defaultEquals;
        if (this.nElements < 1 || util.isUndefined(item)) {
            return false;
        }
        var previous = null;
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (equalsF(currentNode.element, item)) {
                if (previous == null) {
                    this.firstNode = currentNode.next;
                    if (currentNode === this.lastNode) {
                        this.lastNode = null;
                    }
                }
                else if (currentNode === this.lastNode) {
                    this.lastNode = previous;
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                else {
                    previous.next = currentNode.next;
                    currentNode.next = null;
                }
                this.nElements--;
                return true;
            }
            previous = currentNode;
            currentNode = currentNode.next;
        }
        return false;
    };
    /**
     * Removes all of the elements from this list.
     */
    LinkedList.prototype.clear = function () {
        this.firstNode = null;
        this.lastNode = null;
        this.nElements = 0;
    };
    /**
     * Returns true if this list is equal to the given list.
     * Two lists are equal if they have the same elements in the same order.
     * @param {LinkedList} other the other list.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function used to check if two elements are equal. If the elements in the lists
     * are custom objects you should provide a function, otherwise
     * the === operator is used to check equality between elements.
     * @return {boolean} true if this list is equal to the given list.
     */
    LinkedList.prototype.equals = function (other, equalsFunction) {
        var eqF = equalsFunction || util.defaultEquals;
        if (!(other instanceof LinkedList)) {
            return false;
        }
        if (this.size() !== other.size()) {
            return false;
        }
        return this.equalsAux(this.firstNode, other.firstNode, eqF);
    };
    /**
    * @private
    */
    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {
        while (n1 !== null && n2 !== null) {
            if (!eqF(n1.element, n2.element)) {
                return false;
            }
            n1 = n1.next;
            n2 = n2.next;
        }
        return true;
    };
    /**
     * Removes the element at the specified position in this list.
     * @param {number} index given index.
     * @return {*} removed element or undefined if the index is out of bounds.
     */
    LinkedList.prototype.removeElementAtIndex = function (index) {
        if (index < 0 || index >= this.nElements || this.firstNode === null || this.lastNode === null) {
            return undefined;
        }
        var element;
        if (this.nElements === 1) {
            //First node in the list.
            element = this.firstNode.element;
            this.firstNode = null;
            this.lastNode = null;
        }
        else {
            var previous = this.nodeAtIndex(index - 1);
            if (previous === null) {
                element = this.firstNode.element;
                this.firstNode = this.firstNode.next;
            }
            else if (previous.next === this.lastNode) {
                element = this.lastNode.element;
                this.lastNode = previous;
            }
            if (previous !== null && previous.next !== null) {
                element = previous.next.element;
                previous.next = previous.next.next;
            }
        }
        this.nElements--;
        return element;
    };
    /**
     * Executes the provided function once for each element present in this list in order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    LinkedList.prototype.forEach = function (callback) {
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            if (callback(currentNode.element) === false) {
                break;
            }
            currentNode = currentNode.next;
        }
    };
    /**
     * Reverses the order of the elements in this linked list (makes the last
     * element first, and the first element last).
     */
    LinkedList.prototype.reverse = function () {
        var previous = null;
        var current = this.firstNode;
        var temp = null;
        while (current !== null) {
            temp = current.next;
            current.next = previous;
            previous = current;
            current = temp;
        }
        temp = this.firstNode;
        this.firstNode = this.lastNode;
        this.lastNode = temp;
    };
    /**
     * Returns an array containing all of the elements in this list in proper
     * sequence.
     * @return {Array.<*>} an array containing all of the elements in this list,
     * in proper sequence.
     */
    LinkedList.prototype.toArray = function () {
        var array = [];
        var currentNode = this.firstNode;
        while (currentNode !== null) {
            array.push(currentNode.element);
            currentNode = currentNode.next;
        }
        return array;
    };
    /**
     * Returns the number of elements in this list.
     * @return {number} the number of elements in this list.
     */
    LinkedList.prototype.size = function () {
        return this.nElements;
    };
    /**
     * Returns true if this list contains no elements.
     * @return {boolean} true if this list contains no elements.
     */
    LinkedList.prototype.isEmpty = function () {
        return this.nElements <= 0;
    };
    LinkedList.prototype.toString = function () {
        return arrays.toString(this.toArray());
    };
    /**
     * @private
     */
    LinkedList.prototype.nodeAtIndex = function (index) {
        if (index < 0 || index >= this.nElements) {
            return null;
        }
        if (index === (this.nElements - 1)) {
            return this.lastNode;
        }
        var node = this.firstNode;
        for (var i = 0; i < index && node != null; i++) {
            node = node.next;
        }
        return node;
    };
    /**
     * @private
     */
    LinkedList.prototype.createNode = function (item) {
        return {
            element: item,
            next: null
        };
    };
    return LinkedList;
}()); // End of linked list
exports.default = LinkedList;

},{"./arrays":14,"./util":15}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinkedList_1 = require("./LinkedList");
var Queue = /** @class */ (function () {
    /**
     * Creates an empty queue.
     * @class A queue is a First-In-First-Out (FIFO) data structure, the first
     * element added to the queue will be the first one to be removed. This
     * implementation uses a linked list as a container.
     * @constructor
     */
    function Queue() {
        this.list = new LinkedList_1.default();
    }
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.enqueue = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Inserts the specified element into the end of this queue.
     * @param {Object} elem the element to insert.
     * @return {boolean} true if the element was inserted, or false if it is undefined.
     */
    Queue.prototype.add = function (elem) {
        return this.list.add(elem);
    };
    /**
     * Retrieves and removes the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.dequeue = function () {
        if (this.list.size() !== 0) {
            var el = this.list.first();
            this.list.removeElementAtIndex(0);
            return el;
        }
        return undefined;
    };
    /**
     * Retrieves, but does not remove, the head of this queue.
     * @return {*} the head of this queue, or undefined if this queue is empty.
     */
    Queue.prototype.peek = function () {
        if (this.list.size() !== 0) {
            return this.list.first();
        }
        return undefined;
    };
    /**
     * Returns the number of elements in this queue.
     * @return {number} the number of elements in this queue.
     */
    Queue.prototype.size = function () {
        return this.list.size();
    };
    /**
     * Returns true if this queue contains the specified element.
     * <p>If the elements inside this stack are
     * not comparable with the === operator, a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName (pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} elem element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function to check if two elements are equal.
     * @return {boolean} true if this queue contains the specified element,
     * false otherwise.
     */
    Queue.prototype.contains = function (elem, equalsFunction) {
        return this.list.contains(elem, equalsFunction);
    };
    /**
     * Checks if this queue is empty.
     * @return {boolean} true if and only if this queue contains no items; false
     * otherwise.
     */
    Queue.prototype.isEmpty = function () {
        return this.list.size() <= 0;
    };
    /**
     * Removes all of the elements from this queue.
     */
    Queue.prototype.clear = function () {
        this.list.clear();
    };
    /**
     * Executes the provided function once for each element present in this queue in
     * FIFO order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    Queue.prototype.forEach = function (callback) {
        this.list.forEach(callback);
    };
    return Queue;
}()); // End of queue
exports.default = Queue;

},{"./LinkedList":12}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
/**
 * Returns the position of the first occurrence of the specified item
 * within the specified array.4
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the first occurrence of the specified element
 * within the specified array, or -1 if not found.
 */
function indexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.indexOf = indexOf;
/**
 * Returns the position of the last occurrence of the specified element
 * within the specified array.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the position of the last occurrence of the specified element
 * within the specified array or -1 if not found.
 */
function lastIndexOf(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    for (var i = length - 1; i >= 0; i--) {
        if (equals(array[i], item)) {
            return i;
        }
    }
    return -1;
}
exports.lastIndexOf = lastIndexOf;
/**
 * Returns true if the specified array contains the specified element.
 * @param {*} array the array in which to search the element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the specified array contains the specified element.
 */
function contains(array, item, equalsFunction) {
    return indexOf(array, item, equalsFunction) >= 0;
}
exports.contains = contains;
/**
 * Removes the first ocurrence of the specified element from the specified array.
 * @param {*} array the array in which to search element.
 * @param {Object} item the element to search.
 * @param {function(Object,Object):boolean=} equalsFunction optional function to
 * check equality between 2 elements.
 * @return {boolean} true if the array changed after this call.
 */
function remove(array, item, equalsFunction) {
    var index = indexOf(array, item, equalsFunction);
    if (index < 0) {
        return false;
    }
    array.splice(index, 1);
    return true;
}
exports.remove = remove;
/**
 * Returns the number of elements in the specified array equal
 * to the specified object.
 * @param {Array} array the array in which to determine the frequency of the element.
 * @param {Object} item the element whose frequency is to be determined.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between 2 elements.
 * @return {number} the number of elements in the specified array
 * equal to the specified object.
 */
function frequency(array, item, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    var length = array.length;
    var freq = 0;
    for (var i = 0; i < length; i++) {
        if (equals(array[i], item)) {
            freq++;
        }
    }
    return freq;
}
exports.frequency = frequency;
/**
 * Returns true if the two specified arrays are equal to one another.
 * Two arrays are considered equal if both arrays contain the same number
 * of elements, and all corresponding pairs of elements in the two
 * arrays are equal and are in the same order.
 * @param {Array} array1 one array to be tested for equality.
 * @param {Array} array2 the other array to be tested for equality.
 * @param {function(Object,Object):boolean=} equalsFunction optional function used to
 * check equality between elemements in the arrays.
 * @return {boolean} true if the two arrays are equal
 */
function equals(array1, array2, equalsFunction) {
    var equals = equalsFunction || util.defaultEquals;
    if (array1.length !== array2.length) {
        return false;
    }
    var length = array1.length;
    for (var i = 0; i < length; i++) {
        if (!equals(array1[i], array2[i])) {
            return false;
        }
    }
    return true;
}
exports.equals = equals;
/**
 * Returns shallow a copy of the specified array.
 * @param {*} array the array to copy.
 * @return {Array} a copy of the specified array
 */
function copy(array) {
    return array.concat();
}
exports.copy = copy;
/**
 * Swaps the elements at the specified positions in the specified array.
 * @param {Array} array The array in which to swap elements.
 * @param {number} i the index of one element to be swapped.
 * @param {number} j the index of the other element to be swapped.
 * @return {boolean} true if the array is defined and the indexes are valid.
 */
function swap(array, i, j) {
    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
        return false;
    }
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
    return true;
}
exports.swap = swap;
function toString(array) {
    return '[' + array.toString() + ']';
}
exports.toString = toString;
/**
 * Executes the provided function once for each element present in this array
 * starting from index 0 to length - 1.
 * @param {Array} array The array in which to iterate.
 * @param {function(Object):*} callback function to execute, it is
 * invoked with one argument: the element value, to break the iteration you can
 * optionally return false.
 */
function forEach(array, callback) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var ele = array_1[_i];
        if (callback(ele) === false) {
            return;
        }
    }
}
exports.forEach = forEach;

},{"./util":15}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _hasOwnProperty = Object.prototype.hasOwnProperty;
exports.has = function (obj, prop) {
    return _hasOwnProperty.call(obj, prop);
};
/**
 * Default function to compare element order.
 * @function
 */
function defaultCompare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a === b) {
        return 0;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
/**
 * Default function to test equality.
 * @function
 */
function defaultEquals(a, b) {
    return a === b;
}
exports.defaultEquals = defaultEquals;
/**
 * Default function to convert an object to a string.
 * @function
 */
function defaultToString(item) {
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return '$s' + item;
    }
    else {
        return '$o' + item.toString();
    }
}
exports.defaultToString = defaultToString;
/**
* Joins all the properies of the object using the provided join string
*/
function makeString(item, join) {
    if (join === void 0) { join = ','; }
    if (item === null) {
        return 'COLLECTION_NULL';
    }
    else if (isUndefined(item)) {
        return 'COLLECTION_UNDEFINED';
    }
    else if (isString(item)) {
        return item.toString();
    }
    else {
        var toret = '{';
        var first = true;
        for (var prop in item) {
            if (exports.has(item, prop)) {
                if (first) {
                    first = false;
                }
                else {
                    toret = toret + join;
                }
                toret = toret + prop + ':' + item[prop];
            }
        }
        return toret + '}';
    }
}
exports.makeString = makeString;
/**
 * Checks if the given argument is a function.
 * @function
 */
function isFunction(func) {
    return (typeof func) === 'function';
}
exports.isFunction = isFunction;
/**
 * Checks if the given argument is undefined.
 * @function
 */
function isUndefined(obj) {
    return (typeof obj) === 'undefined';
}
exports.isUndefined = isUndefined;
/**
 * Checks if the given argument is a string.
 * @function
 */
function isString(obj) {
    return Object.prototype.toString.call(obj) === '[object String]';
}
exports.isString = isString;
/**
 * Reverses a compare function.
 * @function
 */
function reverseCompareFunction(compareFunction) {
    if (isUndefined(compareFunction) || !isFunction(compareFunction)) {
        return function (a, b) {
            if (a < b) {
                return 1;
            }
            else if (a === b) {
                return 0;
            }
            else {
                return -1;
            }
        };
    }
    else {
        return function (d, v) {
            return compareFunction(d, v) * -1;
        };
    }
}
exports.reverseCompareFunction = reverseCompareFunction;
/**
 * Returns an equal function given a compare function.
 * @function
 */
function compareToEquals(compareFunction) {
    return function (a, b) {
        return compareFunction(a, b) === 0;
    };
}
exports.compareToEquals = compareToEquals;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("typescript-collections/dist/lib/Queue");
const util_1 = require("typescript-collections/dist/lib/util");
let sigma = require('sigma');
window.sigma = sigma;
require('sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes');
require('sigma/plugins/sigma.plugins.animate/sigma.plugins.animate');
require('sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap');
var Status;
(function (Status) {
    Status[Status["RUNNING"] = 0] = "RUNNING";
    Status[Status["SUCCESS"] = 1] = "SUCCESS";
    Status[Status["FAILURE"] = 2] = "FAILURE";
})(Status = exports.Status || (exports.Status = {}));
function terminateAndReturn(id, blackboard, status) {
    delete blackboard[id];
    return status;
}
var blackboard = {};
function getActionTick(id) {
    return (precondition, effect, ticksRequired = 1) => {
        return () => {
            if (precondition()) {
                if (!blackboard[id]) {
                    blackboard[id] = {};
                    blackboard[id].ticksDone = ticksRequired;
                }
                if (blackboard[id].ticksDone > 0) {
                    blackboard[id].ticksDone--;
                    return Status.RUNNING;
                }
                else {
                    effect();
                    return terminateAndReturn(id, blackboard, Status.SUCCESS);
                }
            }
            else {
                return Status.FAILURE;
            }
        };
    };
}
function getGuardTick() {
    return (precondition, astTick, negate = false) => {
        return () => {
            let proceed = negate ? !precondition() : precondition();
            return proceed ? execute(astTick) : Status.FAILURE;
        };
    };
}
function getSequenceTick(id) {
    return (astTicks) => {
        return () => {
            if (!blackboard[id]) {
                blackboard[id] = {};
                blackboard[id].currentIndex = 0;
            }
            while (blackboard[id].currentIndex < astTicks.length) {
                var childStatus = execute(astTicks[blackboard[id].currentIndex]);
                if (childStatus == Status.RUNNING)
                    return Status.RUNNING;
                else if (childStatus == Status.FAILURE)
                    return terminateAndReturn(id, blackboard, Status.FAILURE);
                else if (childStatus == Status.SUCCESS)
                    blackboard[id].currentIndex += 1;
            }
            return terminateAndReturn(id, blackboard, Status.SUCCESS);
        };
    };
}
function getSelectorTick(id) {
    return (astTicks) => {
        return () => {
            if (!blackboard[id]) {
                blackboard[id] = {};
                blackboard[id].currentIndex = 0;
            }
            while (blackboard[id].currentIndex < astTicks.length) {
                var childStatus = execute(astTicks[blackboard[id].currentIndex]);
                if (childStatus == Status.RUNNING)
                    return Status.RUNNING;
                else if (childStatus == Status.SUCCESS)
                    return terminateAndReturn(id, blackboard, Status.SUCCESS);
                else if (childStatus == Status.FAILURE)
                    blackboard[id].currentIndex += 1;
            }
            return terminateAndReturn(id, blackboard, Status.FAILURE);
        };
    };
}
function execute(astTick) {
    return astTick();
}
exports.execute = execute;
var globalIdCounter = 0;
function action(precondition, effect, ticksRequired) {
    return getActionTick(globalIdCounter++)(precondition, effect, ticksRequired);
}
exports.action = action;
function guard(precondition, astTick) {
    return getGuardTick()(precondition, astTick);
}
exports.guard = guard;
function neg_guard(precondition, astTick) {
    return getGuardTick()(precondition, astTick, true);
}
exports.neg_guard = neg_guard;
/**
 * Cycles over its children: iterates to the next child on success of a child
 * Succeeds if all succeed, else fails
 * @param {Tick[]} astTicks
 * @returns {Tick}
 */
function sequence(astTicks) {
    return getSequenceTick(globalIdCounter++)(astTicks);
}
exports.sequence = sequence;
/**
 * Cycles over its children: iterates to the next child on failure of a child(think of it as if-else blocks)
 * Succeeds if even one succeeds, else fails
 * @param {Tick[]} astTicks
 * @returns {Tick}
 */
function selector(astTicks) {
    return getSelectorTick(globalIdCounter++)(astTicks);
}
exports.selector = selector;
/*--------------- APIs --------------- */
//0. utilities
// min and max are inclusive
function getRandNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
exports.getRandNumber = getRandNumber;
//1. story instance
//1.1 locations
exports.locationGraph = {};
//add to both sides
function addLocation(locationName, adjacentLocations) {
    if (exports.locationGraph[locationName] == undefined) {
        exports.locationGraph[locationName] = [];
    }
    exports.locationGraph[locationName] = exports.locationGraph[locationName].concat(adjacentLocations);
    for (var i = 0; i < adjacentLocations.length; i++) {
        if (exports.locationGraph[adjacentLocations[i]] == undefined) {
            exports.locationGraph[adjacentLocations[i]] = [];
        }
        exports.locationGraph[adjacentLocations[i]].push(locationName);
    }
}
exports.addLocation = addLocation;
function areAdjacent(location1, location2) {
    console.log("Are adjacent: " + location1 + ", " + location2);
    if (exports.locationGraph[location1] == undefined || exports.locationGraph[location2] == undefined) {
        console.log("Either one/both locations undefined");
        return false;
    }
    for (var i = 0; i < exports.locationGraph[location1].length; i++) {
        if (exports.locationGraph[location1][i] == location2) {
            return true;
        }
    }
    return false;
}
exports.areAdjacent = areAdjacent;
//pathfinding primitives
function getNextLocation(start, destination) {
    var visited = {};
    var previous = {};
    for (var key in exports.locationGraph) {
        visited[key] = false;
    }
    visited[start] = true;
    var myQueue = new Queue_1.default();
    myQueue.enqueue(start);
    while (!myQueue.isEmpty()) {
        var current = myQueue.dequeue();
        if (current === destination) {
            break;
        }
        var neighbors = exports.locationGraph[current];
        for (var i = 0; i < neighbors.length; i++) {
            if (!visited[neighbors[i]]) {
                myQueue.enqueue(neighbors[i]);
                visited[neighbors[i]] = true;
                previous[neighbors[i]] = current;
            }
        }
    }
    var current = destination;
    if (current == start)
        return current;
    while (previous[current] != start) {
        current = previous[current];
    }
    return current;
}
exports.getNextLocation = getNextLocation;
//1.2 agents
exports.agents = [];
function addAgent(agentName) {
    exports.agents.push(agentName);
    return agentName;
}
exports.addAgent = addAgent;
//1.3 items
exports.items = [];
function addItem(itemName) {
    exports.items.push(itemName);
    return itemName;
}
exports.addItem = addItem;
//1.4 variables
var variables = {};
var agentVariables = {};
var itemVariables = {};
function setVariable(varName, value) {
    variables[varName] = value;
    return varName;
}
exports.setVariable = setVariable;
function setAgentVariable(agent, varName, value) {
    if (util_1.isUndefined(agentVariables[agent]))
        agentVariables[agent] = {};
    agentVariables[agent][varName] = value;
    return value;
}
exports.setAgentVariable = setAgentVariable;
function getVariable(varName) {
    if (util_1.isUndefined(variables[varName])) {
        console.log("Variable " + varName + " not set!");
        return;
    }
    return variables[varName];
}
exports.getVariable = getVariable;
function getAgentVariable(agent, varName) {
    if (util_1.isUndefined(agentVariables[agent]) || util_1.isUndefined(agentVariables[agent][varName])) {
        console.log("Variable " + varName + " for agent " + agent + " not set!");
        return;
    }
    return agentVariables[agent][varName];
}
exports.getAgentVariable = getAgentVariable;
function isVariableNotSet(varName) {
    return util_1.isUndefined(variables[varName]);
}
exports.isVariableNotSet = isVariableNotSet;
function isAgentVariableNotSet(agent, varName) {
    return util_1.isUndefined(agentVariables[agent]) || util_1.isUndefined(agentVariables[agent][varName]);
}
exports.isAgentVariableNotSet = isAgentVariableNotSet;
function setItemVariable(item, varName, value) {
    if (util_1.isUndefined(itemVariables[item]))
        itemVariables[item] = {};
    itemVariables[item][varName] = value;
    return value;
}
exports.setItemVariable = setItemVariable;
function getItemVariable(item, varName) {
    if (util_1.isUndefined(itemVariables[item]) || util_1.isUndefined(itemVariables[item][varName])) {
        console.log("Variable " + varName + " for item " + item + " not set!");
        return;
    }
    return itemVariables[item][varName];
}
exports.getItemVariable = getItemVariable;
//2
//agent-behavior tree mapping
var agentTrees = {};
function attachTreeToAgent(agent, tree) {
    agentTrees[agent] = tree;
}
exports.attachTreeToAgent = attachTreeToAgent;
//3.1
//user actions
//TODO add variables to user action texts
var userInteractionObject = {
    text: "",
    userActionsText: [],
    actionEffectsText: ""
};
var userInteractionTrees = [];
var userActions = {};
function runUserInteractionTrees() {
    userInteractionObject.text = "";
    userInteractionObject.userActionsText = [];
    userActions = {}; //{"Go to location X" : effect
    for (var i = 0; i < userInteractionTrees.length; i++) {
        execute(userInteractionTrees[i]);
    }
}
exports.displayDescriptionAction = (text) => action(() => true, () => userInteractionObject.text += "\n" + text, 0);
exports.displayActionEffectText = (text) => userInteractionObject.actionEffectsText += "\n" + text;
exports.addUserActionTree = (text, effectTree) => action(() => true, () => mapUserActionToTree(text, effectTree), 0);
exports.addUserAction = (text, effect) => action(() => true, () => mapUserActionToTree(text, action(() => true, effect, 0)), 0);
function mapUserActionToTree(text, tree) {
    userActions[text] = tree;
    userInteractionObject.userActionsText.push(text);
}
function addUserInteractionTree(tick) {
    userInteractionTrees.push(tick);
}
exports.addUserInteractionTree = addUserInteractionTree;
function executeUserAction(text) {
    //execute the user action
    userInteractionObject.actionEffectsText = "";
    var userActionEffectTree = userActions[text];
    execute(userActionEffectTree);
}
exports.executeUserAction = executeUserAction;
//4.
function initialize() {
    runUserInteractionTrees();
}
exports.initialize = initialize;
function getUserInteractionObject() {
    return userInteractionObject;
}
exports.getUserInteractionObject = getUserInteractionObject;
function worldTick() {
    //all agent ticks
    for (var i = 0; i < exports.agents.length; i++) {
        var tree = agentTrees[exports.agents[i]];
        if (!util_1.isUndefined(tree)) {
            setVariable("executingAgent", exports.agents[i]);
            execute(tree);
        }
    }
    runUserInteractionTrees();
}
exports.worldTick = worldTick;

},{"sigma":8,"sigma/plugins/sigma.layout.noverlap/sigma.layout.noverlap":9,"sigma/plugins/sigma.plugins.animate/sigma.plugins.animate":10,"sigma/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes":11,"typescript-collections/dist/lib/Queue":13,"typescript-collections/dist/lib/util":15}],17:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const scripting_1 = require("./scripting");
const util_1 = require("typescript-collections/dist/lib/util");
//require all the library needed
let sigma = require('linkurious');
window.sigma = sigma;
require('linkurious/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes');
require('linkurious/plugins/sigma.plugins.animate/sigma.plugins.animate');
require('linkurious/plugins/sigma.layouts.noverlap/sigma.layouts.noverlap');
require('linkurious/plugins/sigma.renderers.linkurious/canvas/sigma.canvas.nodes.def');
require('linkurious/plugins/sigma.plugins.tooltips/sigma.plugins.tooltips');
require('linkurious/plugins/sigma.plugins.design/sigma.plugins.design');
//File names
let filePrefix = "../data/";
let files = ["cfgGramma.csv", "Prefix.csv", "NPCconstraint.txt"];
//A structure for hierarchical generation
class cfgTrees {
    constructor(name, rule, prefix, prevName) {
        let cleanName;
        let idpre = '';
        let labelpre = '';
        this.branches = null;
        this.idLabel = {};
        this.assortedDict = {};
        this.items = null;
        this.prevName = prevName;
        //$ means the names has a prefix as previous name
        //# means the location is expandable
        //! means the names are items
        if (name.startsWith('!')) {
            let itemname = name.substring(1);
            this.items = [];
            this.items.push(prevName + " " + itemname);
            this.idLabel[prevName + " " + itemname] = itemname;
            this.val = 'item';
        }
        else {
            if (name.endsWith('$')) {
                cleanName = name.substring(0, name.length - 1);
                idpre = prevName + " ";
            }
            else {
                cleanName = name;
                idpre = retRand(prefix) + ' ';
                labelpre = idpre;
            }
            if (name.startsWith('#')) {
                this.branches = [];
                cleanName = cleanName.substring(1);
                let children = processRand(rule[cleanName]);
                for (let value of children) {
                    let newBranch = new cfgTrees(value, rule, prefix, idpre + cleanName);
                    combine(this.idLabel, newBranch.idLabel);
                    combine(this.assortedDict, newBranch.assortedDict);
                    this.branches.push(newBranch);
                }
            }
            this.val = idpre + cleanName;
            this.idLabel[this.val] = labelpre + cleanName;
            if (util_1.isUndefined(this.assortedDict[cleanName.toLowerCase()])) {
                this.assortedDict[cleanName.toLowerCase()] = [];
            }
            this.assortedDict[cleanName.toLowerCase()].push(this.val);
        }
    }
    getValue() {
        return this.val;
    }
    getBranches() {
        return this.branches;
    }
    getIdLabelPair() {
        return this.idLabel;
    }
    // return the children's location names
    getBranchValues() {
        let ret = [];
        if (this.branches != null) {
            for (let value of this.branches) {
                if (value.val != 'item') {
                    ret.push(value.val);
                }
            }
        }
        return ret;
    }
    //return a dict for expandable locations and their children
    getExpandList() {
        let expandList = {};
        if (this.branches != null) {
            expandList[this.val] = this.getBranchValues();
            for (let tree of this.branches) {
                combine(expandList, tree.getExpandList());
            }
        }
        return expandList;
    }
    //return a pair of each location and their parents' location
    getPrevnameList() {
        let PrevnameList = {};
        for (let name of this.getBranchValues()) {
            PrevnameList[name] = this.val;
        }
        if (this.branches != null) {
            for (let tree of this.branches) {
                combine(PrevnameList, tree.getPrevnameList());
            }
        }
        return PrevnameList;
    }
    //return a dict for assorted types
    getAssortedDict() {
        return this.assortedDict;
    }
    //return a dict for the location and items corresponding to each location.
    getItemsList() {
        let ret = {};
        if (this.items != null) {
            ret[this.prevName] = this.items;
        }
        if (this.branches != null) {
            for (let tree of this.branches) {
                combine(ret, tree.getItemsList());
            }
        }
        return ret;
    }
    //return a list of all locations in the map
    getAlllocations() {
        let ret = [];
        ret.push(this.getValue());
        if (this.branches != null) {
            for (let child of this.branches) {
                ret = ret.concat(child.getAlllocations());
            }
        }
        return ret;
    }
    print() {
        console.log(this.getValue());
        if (this.branches != null) {
            for (let value of this.branches) {
                value.print();
            }
        }
    }
}
//A function for combining to dictionary
function combine(dict1, dict2) {
    for (let val of Object.keys(dict2)) {
        if (util_1.isUndefined(dict1[val])) {
            dict1[val] = dict2[val];
        }
        else {
            dict1[val] = dict1[val].concat(dict2[val]);
        }
    }
    return dict1;
}
//A function for return and delete a random number from a list
function retRand(list) {
    let index = scripting_1.getRandNumber(0, list.length - 1);
    let ret = list[index];
    list.splice(index, 1);
    return ret;
}
//Reading the files
function readFiles() {
    return __awaiter(this, void 0, void 0, function* () {
        let data = {};
        for (let file of files) {
            yield new Promise(function (resolve, reject) {
                let req = new XMLHttpRequest();
                req.onreadystatechange = function () {
                    if (this.readyState == 4) {
                        if (this.status == 200) {
                            let lines = this.responseText.split(/\n|\r\n/);
                            data[file] = lines;
                            resolve(lines);
                        }
                        else {
                            reject(Error(req.statusText));
                        }
                    }
                };
                req.open("GET", filePrefix + file, true);
                req.responseType = "text";
                req.send(null);
            });
        }
        return Promise.resolve(data);
    });
}
//call all the functions needed
readFiles().then(function (value) {
    let tree = generateTree(value);
    //tree.print();
    // let condition: constrain = processCondition(value);
    InitializeVilillane(tree);
});
//From the raw data to generate the context-free grammar trees for the map
function generateTree(data) {
    let Prefix = data['Prefix.csv'];
    let newRule = {};
    let rawRule = data['cfgGramma.csv'];
    for (let i = 0; i < rawRule.length; i++) {
        let rows = rawRule[i].split(',');
        newRule[rows[0]] = rows[1];
    }
    return new cfgTrees('#University Map$', newRule, Prefix, '');
}
//For each elements of context free grammar, generate a random number of certain type
// of buildings according to the minimum and maximum
function processRand(data) {
    let children = data.split(';');
    let result = [];
    for (let j = 0; j < children.length; j++) {
        let elements = children[j].split('.');
        let num = scripting_1.getRandNumber(Number(elements[1]), Number(elements[2]));
        for (let k = 0; k < num; k++) {
            result.push(elements[0]);
        }
    }
    return result;
}
//Randomly generate a connected graphs from a list of nodes
//The connected graph is one-direction for the addLocation function of villanelle
function connectNodes(location) {
    let nodes = {};
    let visited = {};
    for (let i = 0; i < location.length; i++) {
        visited[location[i]] = false;
    }
    let stack = [];
    let rest = [];
    //randomly generate a graph
    for (let i = 0; i < location.length; i++) {
        if (util_1.isUndefined(nodes[location[i]])) {
            nodes[location[i]] = [];
        }
        for (let j = i + 1; j < location.length; j++) {
            if (util_1.isUndefined(nodes[location[j]])) {
                nodes[location[j]] = [];
            }
            if (Math.random() < (2 / location.length)) {
                nodes[location[i]].push(location[j]);
            }
        }
    }
    //making sure it is connected
    //Using dfs to differentiate clusters
    for (let i = 0; i < location.length; i++) {
        if (visited[location[i]] == false) {
            let item = location[i];
            stack.push(location[i]);
            while (stack.length > 0) {
                let cur = stack.pop();
                if (cur !== undefined) {
                    if (visited[cur] == false) {
                        visited[cur] = true;
                        if (Math.random() < 0.3) {
                            item = cur;
                        }
                        for (let val of nodes[cur]) {
                            stack.push(val);
                        }
                    }
                }
            }
            rest.push(item);
        }
    }
    //Connect the clusters
    for (let i = 0; i < rest.length - 1; i++) {
        nodes[rest[i]].push(rest[i + 1]);
    }
    return nodes;
}
function InitializeVilillane(Tree) {
    //get itemList for display items
    let itemsList = Tree.getItemsList();
    //get expandList to generate a expand graph
    let expandList = Tree.getExpandList();
    //get the initialized id pair
    let idLabelPair = Tree.getIdLabelPair();
    //get the initialized prevname pairs
    let PrevnameList = Tree.getPrevnameList();
    // agents
    let NPC = scripting_1.addAgent("NPC");
    //items
    //add items to the villanelle
    for (let key of Object.keys(itemsList)) {
        for (let i = 0; i < itemsList[key].length; i++) {
            scripting_1.addItem(itemsList[key][i]);
            scripting_1.setItemVariable(itemsList[key][i], "currentLocation", key);
        }
    }
    //Generate the expandGraph from the modified expandList
    //For each expandable location, the dictionary contains a randomly connected graph for all its children
    //The graph is one direction
    let expandGraph = {};
    for (let keys of Object.keys(expandList)) {
        expandGraph[keys] = connectNodes(expandList[keys]);
    }
    //Add locations to villanelle
    function addLocationGraph(graph) {
        for (let key in graph) {
            if (key !== Tree.getValue()) {
                scripting_1.addLocation(key, graph[key]);
            }
        }
    }
    addLocationGraph(expandList);
    for (let key in expandGraph) {
        addLocationGraph(expandGraph[key]);
    }
    //Initialize locations to assign items and agent
    let locations = Object.keys(scripting_1.locationGraph);
    //Initialize player to be at one of the entrance of all universities
    let allUniversity = expandList[Tree.getValue()];
    // variables
    let itemDisplay = scripting_1.setVariable("itemDisplay", false);
    let inventory = scripting_1.setVariable("inventory", []);
    let selected = scripting_1.setVariable("selected", false);
    let endGame = scripting_1.setVariable("endGame", false);
    let selectedUniversity = scripting_1.setVariable("selectedUniversity", false);
    let meet = scripting_1.setVariable("meet", false);
    //NPC
    scripting_1.setAgentVariable(NPC, "currentLocation", retRand(locations));
    //player
    let playerLocation = scripting_1.setVariable("playerLocation", retRand(allUniversity));
    // 2. Define BTs
    //recover the array of all universities and location
    locations = Object.keys(scripting_1.locationGraph);
    allUniversity = expandList[Tree.getValue()];
    let setRandNumber = scripting_1.action(() => true, () => {
        scripting_1.setVariable("randNumber", scripting_1.getRandNumber(1, locations.length));
    }, 0);
    //Initialize behavior tree for NPCs
    let BTlist = [];
    for (let i = 0; i < locations.length; i++) {
        //console.log(locations[i]);
        let actions = scripting_1.action(() => scripting_1.getVariable("randNumber") == i + 1, () => scripting_1.setVariable("destination", locations[i]), 0);
        BTlist.push(actions);
    }
    let atDestination = () => scripting_1.getVariable("destination") == scripting_1.getAgentVariable(NPC, "currentLocation");
    let setDestinationPrecond = () => scripting_1.isVariableNotSet("destination") || atDestination();
    // create behavior trees
    let setNextDestination = scripting_1.sequence([
        setRandNumber,
        scripting_1.selector(BTlist),
    ]);
    let gotoNextLocation = scripting_1.action(() => true, () => {
        scripting_1.setAgentVariable(NPC, "currentLocation", scripting_1.getNextLocation(scripting_1.getAgentVariable(NPC, "currentLocation"), scripting_1.getVariable("destination")));
        console.log("NPC is at: " + scripting_1.getAgentVariable(NPC, "currentLocation"));
    }, 0);
    //agents BT for player meeting the agents
    let setRandNumber_2 = scripting_1.action(() => true, () => {
        scripting_1.setVariable("randNumber", scripting_1.getRandNumber(1, 3));
    }, 0);
    let meetPlayer = scripting_1.sequence([setRandNumber_2,
        scripting_1.guard(() => scripting_1.getAgentVariable(NPC, "currentLocation") == scripting_1.getVariable(playerLocation), scripting_1.selector([
            scripting_1.action(() => scripting_1.getVariable("randNumber") == 1, () => {
                scripting_1.setVariable('endMethod', 'love');
                scripting_1.setVariable(selectedUniversity, get_uni(scripting_1.getVariable(playerLocation)));
                scripting_1.setVariable(endGame, true);
            }, 0),
            scripting_1.action(() => scripting_1.getVariable("randNumber") == 2, () => {
                scripting_1.setVariable('endMethod', 'die');
                scripting_1.setVariable(endGame, true);
            }, 0),
            scripting_1.action(() => scripting_1.getVariable("randNumber") == 3, () => scripting_1.setVariable(meet, true), 0)
        ]))]);
    let search = scripting_1.sequence([
        scripting_1.selector([
            scripting_1.guard(setDestinationPrecond, setNextDestination),
            scripting_1.action(() => true, () => {
            }, 0)
        ]),
        gotoNextLocation,
    ]);
    let NPCBT = scripting_1.selector([
        meetPlayer,
        scripting_1.sequence([
            search, meetPlayer
        ])
    ]);
    //attach behaviour trees to agents
    scripting_1.attachTreeToAgent(NPC, NPCBT);
    //a function to determine which university the current location is in
    function get_uni(loc) {
        var uni = loc;
        while (PrevnameList[uni] != Tree.getValue()) {
            uni = PrevnameList[uni];
        }
        return uni;
    }
    // 3. Construct story
    // create user actions from the graphs
    for (let key in scripting_1.locationGraph) {
        let seq = [];
        seq.push(scripting_1.displayDescriptionAction("You enter the " + idLabelPair[key] + "."));
        seq.push(scripting_1.addUserAction("Select University.", () => scripting_1.setVariable(selected, true)));
        seq.push(scripting_1.addUserAction("Stay where you are.", () => {
        }));
        //Check whether it's in a lower layer
        if (Object.keys(scripting_1.locationGraph).includes(PrevnameList[key])) {
            seq.push(scripting_1.addUserAction("Go outside to " + idLabelPair[PrevnameList[key]] + ".", () => {
                scripting_1.setVariable(playerLocation, PrevnameList[key]);
            }));
        }
        //Check whether it's has a children
        if (Object.keys(expandList).includes(key)) {
            seq.push(scripting_1.addUserAction("Go inside " + idLabelPair[key] + " to enter " + idLabelPair[expandList[key][0]] + ".", () => scripting_1.setVariable(playerLocation, expandList[key][0])));
        }
        let graph = completeGraph(expandGraph[PrevnameList[key]]);
        for (let adj of graph[key]) {
            seq.push(scripting_1.addUserAction("Enter the " + idLabelPair[adj] + ".", () => scripting_1.setVariable(playerLocation, adj)));
        }
        let StateBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == key &&
            scripting_1.getVariable(itemDisplay) == false &&
            scripting_1.getVariable(selected) == false &&
            scripting_1.getVariable(endGame) == false, scripting_1.sequence(seq));
        scripting_1.addUserInteractionTree(StateBT);
    }
    //Behavior tree for displaying items
    let showitemBT = scripting_1.guard(() => !util_1.isUndefined(itemsList[scripting_1.getVariable(playerLocation)]) && itemsList[scripting_1.getVariable(playerLocation)].length != 0 && scripting_1.getVariable(itemDisplay) == false, scripting_1.sequence([
        scripting_1.displayDescriptionAction("You notice items lying around."),
        scripting_1.addUserAction("show all the items", () => scripting_1.setVariable(itemDisplay, true))
    ]));
    //attach the bt to thr tree
    scripting_1.addUserInteractionTree(showitemBT);
    //Create behavior trees for every items
    for (let i = 0; i < scripting_1.items.length; i++) {
        let ItemBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == scripting_1.getItemVariable(scripting_1.items[i], "currentLocation")
            && scripting_1.getVariable(itemDisplay) == true, scripting_1.sequence([
            scripting_1.addUserAction("Pick up the " + idLabelPair[scripting_1.items[i]] + ".", () => {
                scripting_1.setVariable(itemDisplay, false);
                let curInv = scripting_1.getVariable(inventory);
                curInv.push(scripting_1.items[i]);
                itemsList[scripting_1.getVariable(playerLocation)].splice(itemsList[scripting_1.getVariable(playerLocation)].indexOf(scripting_1.items[i]), 1);
                scripting_1.displayActionEffectText("You pick up the " + scripting_1.items[i] + ".");
                scripting_1.setItemVariable(scripting_1.items[i], "currentLocation", "player");
                scripting_1.setVariable(inventory, curInv);
            })
        ]));
        scripting_1.addUserInteractionTree(ItemBT);
    }
    //BT for selecting universities
    var universitySeq = [];
    for (let i = 0; i < allUniversity.length; i++) {
        universitySeq.push(scripting_1.addUserAction("select " + allUniversity[i] + ".", () => {
            scripting_1.setVariable(selectedUniversity, allUniversity[i]);
            scripting_1.setVariable('endMethod', 'select');
            scripting_1.setVariable(endGame, true);
        }));
    }
    let universityBT = scripting_1.guard(() => scripting_1.getVariable(selected) == true && scripting_1.getVariable(endGame) == false, scripting_1.sequence(universitySeq));
    scripting_1.addUserInteractionTree(universityBT);
    //Interaction BT for displaying meeting description 
    let meetBT = scripting_1.guard(() => scripting_1.getVariable(meet) == true, scripting_1.sequence([
        scripting_1.action(() => true, () => scripting_1.setVariable(meet, false), 0),
        scripting_1.displayDescriptionAction("Nothing happens between you and the stranger")
    ]));
    scripting_1.addUserInteractionTree(meetBT);
    //BT for location description
    for (let i = 0; i < locations.length; i++) {
        let rand = Math.random();
        if (rand < 0.1) {
            let brokenBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == locations[i] &&
                scripting_1.getVariable(itemDisplay) == false &&
                scripting_1.getVariable(selected) == false &&
                scripting_1.getVariable(endGame) == false, scripting_1.sequence([
                scripting_1.displayDescriptionAction('The place you enter is broken!')
            ]));
            scripting_1.addUserInteractionTree(brokenBT);
        }
        else if (rand < 0.2) {
            let fancyBT = scripting_1.guard(() => scripting_1.getVariable(playerLocation) == locations[i] &&
                scripting_1.getVariable(itemDisplay) == false &&
                scripting_1.getVariable(selected) == false &&
                scripting_1.getVariable(endGame) == false, scripting_1.sequence([
                scripting_1.displayDescriptionAction('The place you enter is fancy!')
            ]));
            scripting_1.addUserInteractionTree(fancyBT);
        }
    }
    //BT for end of the game
    //The game may end when the player select university 
    //Or the player meet an agent and fall in love with him 
    //Or the player meet an agent and accidentally killed by him
    let gameOver = scripting_1.guard(() => scripting_1.getVariable(endGame) == true, scripting_1.selector([
        scripting_1.action(() => scripting_1.getVariable('endMethod') == 'select', () => {
            userInteractionObject.text += "\n" + "You decide to go to " + scripting_1.getVariable(selectedUniversity) + "!";
        }, 0),
        scripting_1.action(() => scripting_1.getVariable('endMethod') == 'love', () => {
            userInteractionObject.text += "\n" + "You fall in love with the one you met, finally decide go to " +
                scripting_1.getVariable(selectedUniversity) + '!';
        }, 0),
        scripting_1.guard(() => scripting_1.getVariable('endMethod') == 'die', scripting_1.displayDescriptionAction("Sadly, You are killed by the stranger you meet!"))
    ]));
    scripting_1.addUserInteractionTree(gameOver);
    //Initialize sigma for player and NPC
    let sigmaPlayer = new sigma({
        graph: {
            nodes: [],
            edges: []
        },
        renderer: {
            type: 'canvas',
            container: 'player-container'
        },
        settings: {
            nodeBorderSize: 5,
            defaultNodeBorderColor: '#fff',
            defaultNodeHoverBorderColor: '#fff',
            defaultNodeColor: '#000',
            defaultLabelColor: '#fff',
            defaultEdgeColor: '#fff',
            edgeColor: 'default',
            maxNodeSize: 20,
            sideMargin: 15
        }
    });
    let sigmaNPC = new sigma({
        graph: {
            nodes: [],
            edges: []
        },
        renderer: {
            type: 'canvas',
            container: 'NPC-container'
        },
        settings: {
            nodeBorderSize: 5,
            defaultNodeBorderColor: '#fff',
            defaultNodeColor: '#000',
            defaultLabelColor: '#fff',
            defaultEdgeColor: '#fff',
            edgeColor: 'default',
            maxNodeSize: 20,
            sideMargin: 15
        }
    });
    //A unique ID for each edge.
    let edgeID = 0;
    //Clear up the graph.
    function clear(sigma) {
        let nodes = sigma.graph.nodes();
        for (let node of nodes) {
            sigma.graph.dropNode(node.id);
        }
    }
    //The graph generate by connect-node is one direction
    //This function make it two-direction
    function completeGraph(graph) {
        let retGraph = {};
        for (let key in graph) {
            if (util_1.isUndefined(retGraph[key])) {
                retGraph[key] = [];
            }
            retGraph[key] = retGraph[key].concat(graph[key]);
            for (let loc of graph[key]) {
                if (util_1.isUndefined(retGraph[loc])) {
                    retGraph[loc] = [];
                }
                retGraph[loc].push(key);
            }
        }
        return retGraph;
    }
    //Show the adjacent node of the input node
    function showAround(input, sigmaInstance) {
        let graph = completeGraph(expandGraph[PrevnameList[input]]);
        let adjacent = graph[input];
        let numberLayer = adjacent.length;
        if (util_1.isUndefined(sigmaInstance.graph.nodes(input))) {
            sigmaInstance.graph.addNode({
                // Main attributes:
                id: input,
                label: idLabelPair[input],
                x: 0,
                y: 0,
                size: 15,
            });
        }
        for (let i = 0; i < numberLayer; i++) {
            if (util_1.isUndefined(sigmaInstance.graph.nodes(adjacent[i]))) {
                sigmaInstance.graph.addNode({
                    // Main attributes:
                    id: adjacent[i],
                    label: idLabelPair[adjacent[i]],
                    x: Math.cos(Math.PI * 2 * (i - 1 / 3) / numberLayer) * 40 + sigmaInstance.graph.nodes(input).x,
                    y: Math.sin(Math.PI * 2 * (i - 1 / 3) / numberLayer) * 40 + sigmaInstance.graph.nodes(input).y,
                    size: 15,
                });
            }
            sigmaInstance.graph.addEdge({
                id: 'edge' + (edgeID++).toString(),
                source: adjacent[i],
                target: sigmaInstance.graph.nodes(input).id,
                size: 1,
                color: "#fff"
            });
        }
    }
    function show(inputid, sigmaInstance) {
        let graph = completeGraph(expandGraph[PrevnameList[inputid]]);
        let adjacent = graph[inputid];
        showAround(inputid, sigmaInstance);
        //Show additional nodes if all the node in this layer is small enough
        if (Object.keys(graph).length < 10) {
            for (let layer1 of adjacent) {
                showAround(layer1, sigmaInstance);
                let newAdjacent = graph[layer1];
                for (let layer2 of newAdjacent) {
                    showAround(layer2, sigmaInstance);
                }
            }
        }
    }
    //for dragging the nodes.
    let dragListener1 = sigma.plugins.dragNodes(sigmaPlayer, sigmaPlayer.renderers[0]);
    dragListener1.bind('startdrag', function (event) {
        console.log(event);
    });
    dragListener1.bind('drag', function (event) {
        console.log(event);
    });
    dragListener1.bind('drop', function (event) {
        console.log(event);
    });
    dragListener1.bind('dragend', function (event) {
        console.log(event);
    });
    let dragListener2 = sigma.plugins.dragNodes(sigmaNPC, sigmaNPC.renderers[0]);
    dragListener2.bind('startdrag', function (event) {
        console.log(event);
    });
    dragListener2.bind('drag', function (event) {
        console.log(event);
    });
    dragListener2.bind('drop', function (event) {
        console.log(event);
    });
    dragListener2.bind('dragend', function (event) {
        console.log(event);
    });
    //4. Run the world
    scripting_1.initialize();
    let userInteractionObject = scripting_1.getUserInteractionObject();
    //RENDERING-----
    //let displayPanel = {x: 500, y: 0};
    let textPanel = { x: 450, y: 350 };
    let actionsPanel = { x: 470, y: 375 };
    function render() {
        //get all the parents locations of the agents
        let NPCPrevs = [];
        let playerPrevs = [];
        let NPCPrevLocs;
        let PlayerPrevLocs;
        //get agents' current location
        let NPCLocation = scripting_1.getAgentVariable(NPC, "currentLocation");
        let playerL = scripting_1.getVariable(playerLocation);
        //generate all the parents locations of the NPC
        NPCPrevLocs = PrevnameList[NPCLocation];
        while (NPCPrevLocs != Tree.getValue()) {
            NPCPrevs.push(NPCPrevLocs);
            NPCPrevLocs = PrevnameList[NPCPrevLocs];
        }
        //generate all the parents locations of the player
        PlayerPrevLocs = PrevnameList[playerL];
        while (PlayerPrevLocs != Tree.getValue()) {
            playerPrevs.push(PlayerPrevLocs);
            PlayerPrevLocs = PrevnameList[PlayerPrevLocs];
        }
        //Clear the previous scene
        clear(sigmaPlayer);
        clear(sigmaNPC);
        //Show
        show(playerL, sigmaPlayer);
        show(NPCLocation, sigmaNPC);
        //Modify the level indicator for player perspective
        var playerText = document.getElementsByClassName("lefttext");
        var playerinnerHtml = '';
        for (var i = 0; i <= playerPrevs.length; i++) {
            playerinnerHtml += '<span class="playerdot"></span>';
        }
        //adding higher level location names for player perspective
        if (PrevnameList[playerL] == Tree.getValue()) {
            playerinnerHtml += '  ' + Tree.getValue() + '/';
        }
        else {
            playerinnerHtml += '  ' + PrevnameList[PrevnameList[playerL]] + '/';
            playerinnerHtml += PrevnameList[playerL] + '/';
        }
        //Modify the level indicator for player perspective
        playerText[0].innerHTML = playerinnerHtml;
        var AgentText = document.getElementsByClassName("righttext");
        var AgentinnerHtml = '';
        for (var i = 0; i <= NPCPrevs.length; i++) {
            AgentinnerHtml += '<span class="agentdot"></span>';
        }
        //adding higher level location names for agent perspective
        if (PrevnameList[NPCLocation] == Tree.getValue()) {
            AgentinnerHtml += '  ' + Tree.getValue() + '/';
        }
        else {
            AgentinnerHtml += '  ' + PrevnameList[PrevnameList[NPCLocation]] + '/';
            AgentinnerHtml += PrevnameList[NPCLocation] + '/';
        }
        AgentText[0].innerHTML = AgentinnerHtml;
        //show the locations of player and agents on the graph
        //the image of boy from http://www.urltarget.com/icon-symbol-people-boy-man-male-cartoon-scout.html
        for (let node of sigmaPlayer.graph.nodes()) {
            if (node.id == NPCLocation) {
                node.image = { url: '../images/boy.png' };
            }
            if (node.id == playerL) {
                node.image = { url: '../images/player2.png' };
            }
            if (NPCPrevs.includes(node.id)) {
                node.border_color = '#ff0000';
            }
            if (!util_1.isUndefined(itemsList[node.id]) && itemsList[node.id].length != 0) {
                node.border_color = '#0000FF';
            }
        }
        for (let node of sigmaNPC.graph.nodes()) {
            if (node.id == playerL) {
                node.image = { url: '../images/player2.png' };
            }
            if (node.id == NPCLocation) {
                node.image = { url: '../images/boy.png' };
            }
            if (playerPrevs.includes(node.id)) {
                node.border_color = '#ADFF2F';
            }
        }
        sigmaPlayer.refresh();
        sigmaNPC.refresh();
        //algorithm for no lapping layout.
        let config = {
            nodeMargin: 50,
            gridSize: 5,
        };
        //Configure the algorithm
        let listener1 = sigmaPlayer.configNoverlap(config);
        let listener2 = sigmaNPC.configNoverlap(config);
        //Bind all events:
        listener1.bind('start stop interpolate', function (event) {
            console.log(event.type);
        });
        listener2.bind('start stop interpolate', function (event) {
            console.log(event.type);
        });
        //Start the algorithm:
        sigmaPlayer.startNoverlap();
        sigmaNPC.startNoverlap();
        displayTextAndActions();
    }
    //Get canvas
    let canvas = document.getElementById('display');
    let context = canvas.getContext('2d');
    let currentSelection;
    let yOffset = actionsPanel.y + 25;
    let yOffsetIncrement = 30;
    function displayTextAndActions() {
        context.clearRect(textPanel.x, textPanel.y, 1000, 1000);
        yOffset = actionsPanel.y + 25;
        context.font = "15pt Calibri";
        context.fillStyle = 'white';
        console.log("Actions effect text: " + userInteractionObject.actionEffectsText);
        let textToDisplay = userInteractionObject.actionEffectsText.length != 0 ? userInteractionObject.actionEffectsText : userInteractionObject.text;
        context.fillText(textToDisplay, textPanel.x, textPanel.y + 20);
        context.font = "15pt Calibri";
        context.fillStyle = 'white';
        for (let i = 0; i < userInteractionObject.userActionsText.length; i++) {
            let userActionText = userInteractionObject.userActionsText[i];
            context.fillText(userActionText, actionsPanel.x + 20, yOffset);
            if (i == 0) {
                currentSelection = i;
            }
            yOffset += yOffsetIncrement;
        }
        displayArrow();
    }
    function displayArrow() {
        if (userInteractionObject.userActionsText.length != 0) {
            context.clearRect(actionsPanel.x, actionsPanel.y, 20, 1000);
            context.fillText("> ", 470, actionsPanel.y + 25 + (currentSelection * yOffsetIncrement));
        }
    }
    //User input
    function keyPress(e) {
        if (e.keyCode == 13) {
            let selectedAction = userInteractionObject.userActionsText[currentSelection];
            if (!util_1.isUndefined(selectedAction)) {
                scripting_1.executeUserAction(selectedAction);
                scripting_1.worldTick();
                render();
            }
        }
    }
    function keyDown(e) {
        if (e.keyCode == 40) { //down
            if (userInteractionObject.userActionsText.length != 0) {
                currentSelection++;
                currentSelection = currentSelection % userInteractionObject.userActionsText.length;
                displayArrow();
            }
        }
        else if (e.keyCode == 38) { //up
            if (userInteractionObject.userActionsText.length != 0) {
                currentSelection--;
                if (currentSelection < 0)
                    currentSelection = userInteractionObject.userActionsText.length - 1;
                displayArrow();
            }
        }
    }
    //Initialize the visualization
    render();
    document.addEventListener("keypress", keyPress, false);
    document.addEventListener("keydown", keyDown, false);
}

},{"./scripting":16,"linkurious":1,"linkurious/plugins/sigma.layouts.noverlap/sigma.layouts.noverlap":2,"linkurious/plugins/sigma.plugins.animate/sigma.plugins.animate":3,"linkurious/plugins/sigma.plugins.design/sigma.plugins.design":4,"linkurious/plugins/sigma.plugins.dragNodes/sigma.plugins.dragNodes":5,"linkurious/plugins/sigma.plugins.tooltips/sigma.plugins.tooltips":6,"linkurious/plugins/sigma.renderers.linkurious/canvas/sigma.canvas.nodes.def":7,"typescript-collections/dist/lib/util":15}]},{},[17])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9kaXN0L3NpZ21hLnJlcXVpcmUuanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9wbHVnaW5zL3NpZ21hLmxheW91dHMubm92ZXJsYXAvc2lnbWEubGF5b3V0cy5ub3ZlcmxhcC5qcyIsIm5vZGVfbW9kdWxlcy9saW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5hbmltYXRlL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9saW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5kZXNpZ24vc2lnbWEucGx1Z2lucy5kZXNpZ24uanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzLmpzIiwibm9kZV9tb2R1bGVzL2xpbmt1cmlvdXMvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLnRvb2x0aXBzL3NpZ21hLnBsdWdpbnMudG9vbHRpcHMuanMiLCJub2RlX21vZHVsZXMvbGlua3VyaW91cy9wbHVnaW5zL3NpZ21hLnJlbmRlcmVycy5saW5rdXJpb3VzL2NhbnZhcy9zaWdtYS5jYW52YXMubm9kZXMuZGVmLmpzIiwibm9kZV9tb2R1bGVzL3NpZ21hL2J1aWxkL3NpZ21hLnJlcXVpcmUuanMiLCJub2RlX21vZHVsZXMvc2lnbWEvcGx1Z2lucy9zaWdtYS5sYXlvdXQubm92ZXJsYXAvc2lnbWEubGF5b3V0Lm5vdmVybGFwLmpzIiwibm9kZV9tb2R1bGVzL3NpZ21hL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5hbmltYXRlL3NpZ21hLnBsdWdpbnMuYW5pbWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zaWdtYS9wbHVnaW5zL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzL3NpZ21hLnBsdWdpbnMuZHJhZ05vZGVzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvTGlua2VkTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWNvbGxlY3Rpb25zL2Rpc3QvbGliL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvYXJyYXlzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtY29sbGVjdGlvbnMvZGlzdC9saWIvdXRpbC5qcyIsInNyYy9zY3JpcHRpbmcudHMiLCJzcmMvdW5pdmVyc2l0eUxheWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDhYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1eVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1SUEsaUVBQTBEO0FBQzFELCtEQUFpRTtBQUNqRSxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkIsTUFBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDNUIsT0FBTyxDQUFDLCtEQUErRCxDQUFDLENBQUM7QUFDekUsT0FBTyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7QUFDckUsT0FBTyxDQUFDLDJEQUEyRCxDQUFDLENBQUM7QUFFckUsSUFBWSxNQUlYO0FBSkQsV0FBWSxNQUFNO0lBQ2QseUNBQU8sQ0FBQTtJQUNQLHlDQUFPLENBQUE7SUFDUCx5Q0FBTyxDQUFBO0FBQ1gsQ0FBQyxFQUpXLE1BQU0sR0FBTixjQUFNLEtBQU4sY0FBTSxRQUlqQjtBQUVELDRCQUE0QixFQUFVLEVBQUUsVUFBZSxFQUFFLE1BQWM7SUFDbkUsT0FBTyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdEIsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQWVELElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUVwQix1QkFBdUIsRUFBVTtJQUM3QixPQUFPLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRSxhQUFhLEdBQUcsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLFlBQVksRUFBRSxFQUFFO2dCQUNoQixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO29CQUNqQixVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUNwQixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQztpQkFDNUM7Z0JBRUQsSUFBSSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsRUFBRTtvQkFDOUIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO29CQUMzQixPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUM7aUJBQ3pCO3FCQUFNO29CQUNILE1BQU0sRUFBRSxDQUFDO29CQUNULE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzdEO2FBQ0o7aUJBQU07Z0JBQ0gsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO2FBQ3pCO1FBQ0wsQ0FBQyxDQUFBO0lBQ0wsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVEO0lBQ0ksT0FBTyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFBRSxFQUFFO1FBQzdDLE9BQU8sR0FBRyxFQUFFO1lBQ1IsSUFBSSxPQUFPLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUN4RCxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3ZELENBQUMsQ0FBQTtJQUNMLENBQUMsQ0FBQTtBQUNMLENBQUM7QUFFRCx5QkFBeUIsRUFBVTtJQUMvQixPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDaEIsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUNqQixVQUFVLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNwQixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQzthQUNuQztZQUVELE9BQU8sVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFO2dCQUNsRCxJQUFJLFdBQVcsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUVqRSxJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsT0FBTztvQkFDN0IsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDO3FCQUNyQixJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsT0FBTztvQkFDbEMsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztxQkFDekQsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQ2xDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO2FBQ3hDO1lBQ0QsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUE7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBRUQseUJBQXlCLEVBQVU7SUFDL0IsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFO1FBQ2hCLE9BQU8sR0FBRyxFQUFFO1lBQ1IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDakIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDcEIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7YUFDbkM7WUFFRCxPQUFPLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRTtnQkFDbEQsSUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFFakUsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQzdCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztxQkFDckIsSUFBSSxXQUFXLElBQUksTUFBTSxDQUFDLE9BQU87b0JBQ2xDLE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQ3pELElBQUksV0FBVyxJQUFJLE1BQU0sQ0FBQyxPQUFPO29CQUNsQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQzthQUN4QztZQUNELE9BQU8sa0JBQWtCLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFBO0lBQ0wsQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQUVELGlCQUF3QixPQUFhO0lBQ2pDLE9BQU8sT0FBTyxFQUFFLENBQUM7QUFDckIsQ0FBQztBQUZELDBCQUVDO0FBRUQsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBRXhCLGdCQUF1QixZQUEwQixFQUFFLE1BQWMsRUFBRSxhQUFzQjtJQUNyRixPQUFPLGFBQWEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLFlBQVksRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUE7QUFDaEYsQ0FBQztBQUZELHdCQUVDO0FBRUQsZUFBc0IsWUFBMEIsRUFBRSxPQUFhO0lBQzNELE9BQU8sWUFBWSxFQUFFLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFGRCxzQkFFQztBQUVELG1CQUEwQixZQUEwQixFQUFFLE9BQWE7SUFDL0QsT0FBTyxZQUFZLEVBQUUsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFGRCw4QkFFQztBQUVEOzs7OztHQUtHO0FBQ0gsa0JBQXlCLFFBQWdCO0lBQ3JDLE9BQU8sZUFBZSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUZELDRCQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxrQkFBeUIsUUFBZ0I7SUFDckMsT0FBTyxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRkQsNEJBRUM7QUFHRCx5Q0FBeUM7QUFHekMsY0FBYztBQUNkLDRCQUE0QjtBQUM1Qix1QkFBOEIsR0FBVyxFQUFFLEdBQVc7SUFDbEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDN0QsQ0FBQztBQUZELHNDQUVDO0FBRUQsbUJBQW1CO0FBRW5CLGVBQWU7QUFDSixRQUFBLGFBQWEsR0FBRyxFQUFFLENBQUM7QUFFOUIsbUJBQW1CO0FBQ25CLHFCQUE0QixZQUFvQixFQUFFLGlCQUEyQjtJQUN6RSxJQUFJLHFCQUFhLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxFQUFFO1FBQzFDLHFCQUFhLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3BDO0lBQ0QscUJBQWEsQ0FBQyxZQUFZLENBQUMsR0FBRyxxQkFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXBGLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsSUFBSSxxQkFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxFQUFFO1lBQ2xELHFCQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDNUM7UUFDRCxxQkFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQzFEO0FBQ0wsQ0FBQztBQVpELGtDQVlDO0FBRUQscUJBQTRCLFNBQWlCLEVBQUUsU0FBaUI7SUFDNUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsSUFBSSxHQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNELElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEVBQUM7UUFDL0UsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLHFCQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RELElBQUkscUJBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLEVBQUM7WUFDekMsT0FBTyxJQUFJLENBQUM7U0FDZjtLQUNKO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQWJELGtDQWFDO0FBRUQsd0JBQXdCO0FBQ3hCLHlCQUFnQyxLQUFhLEVBQUUsV0FBbUI7SUFDOUQsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNsQixLQUFLLElBQUksR0FBRyxJQUFJLHFCQUFhLEVBQUU7UUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUN4QjtJQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7SUFFdEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxlQUFLLEVBQVUsQ0FBQztJQUNsQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXZCLE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDdkIsSUFBSSxPQUFPLEdBQVcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3hDLElBQUksT0FBTyxLQUFLLFdBQVcsRUFBRTtZQUN6QixNQUFNO1NBQ1Q7UUFDRCxJQUFJLFNBQVMsR0FBRyxxQkFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXZDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3hCLE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQzdCLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7YUFDcEM7U0FDSjtLQUNKO0lBRUQsSUFBSSxPQUFPLEdBQVcsV0FBVyxDQUFDO0lBQ2xDLElBQUksT0FBTyxJQUFJLEtBQUs7UUFDaEIsT0FBTyxPQUFPLENBQUM7SUFDbkIsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxFQUFFO1FBQy9CLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDL0I7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBbkNELDBDQW1DQztBQUVELFlBQVk7QUFDRCxRQUFBLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFFdkIsa0JBQXlCLFNBQWlCO0lBQ3RDLGNBQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdkIsT0FBTyxTQUFTLENBQUM7QUFDckIsQ0FBQztBQUhELDRCQUdDO0FBRUQsV0FBVztBQUNBLFFBQUEsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUV0QixpQkFBd0IsUUFBZ0I7SUFDcEMsYUFBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNyQixPQUFPLFFBQVEsQ0FBQztBQUNwQixDQUFDO0FBSEQsMEJBR0M7QUFFRCxlQUFlO0FBQ2YsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO0FBQ25CLElBQUksY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUN4QixJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUM7QUFFdkIscUJBQTRCLE9BQWUsRUFBRSxLQUFVO0lBQ25ELFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDM0IsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQztBQUhELGtDQUdDO0FBRUQsMEJBQWlDLEtBQWEsRUFBRSxPQUFlLEVBQUUsS0FBVTtJQUN2RSxJQUFJLGtCQUFXLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xDLGNBQWMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7SUFFL0IsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUN2QyxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDO0FBTkQsNENBTUM7QUFFRCxxQkFBNEIsT0FBZTtJQUN2QyxJQUFJLGtCQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7UUFDakMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsT0FBTyxHQUFHLFdBQVcsQ0FBQyxDQUFDO1FBQ2pELE9BQU87S0FDVjtJQUNELE9BQU8sU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFORCxrQ0FNQztBQUVELDBCQUFpQyxLQUFhLEVBQUUsT0FBZTtJQUMzRCxJQUFJLGtCQUFXLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksa0JBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUNuRixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsR0FBRyxPQUFPLEdBQUcsYUFBYSxHQUFHLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQTtRQUN4RSxPQUFPO0tBQ1Y7SUFDRCxPQUFPLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMxQyxDQUFDO0FBTkQsNENBTUM7QUFFRCwwQkFBaUMsT0FBZTtJQUM1QyxPQUFPLGtCQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUZELDRDQUVDO0FBRUQsK0JBQXNDLEtBQWEsRUFBRSxPQUFlO0lBQ2hFLE9BQU8sa0JBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQzdGLENBQUM7QUFGRCxzREFFQztBQUVELHlCQUFnQyxJQUFZLEVBQUUsT0FBZSxFQUFFLEtBQVU7SUFDckUsSUFBSSxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRTdCLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDckMsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQU5ELDBDQU1DO0FBRUQseUJBQWdDLElBQVksRUFBRSxPQUFlO0lBQ3pELElBQUksa0JBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQy9FLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLE9BQU8sR0FBRyxZQUFZLEdBQUcsSUFBSSxHQUFHLFdBQVcsQ0FBQyxDQUFBO1FBQ3RFLE9BQU87S0FDVjtJQUNELE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFORCwwQ0FNQztBQUdELEdBQUc7QUFDSCw2QkFBNkI7QUFDN0IsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBRXBCLDJCQUFrQyxLQUFhLEVBQUUsSUFBVTtJQUN2RCxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDO0FBQzdCLENBQUM7QUFGRCw4Q0FFQztBQUVELEtBQUs7QUFDTCxjQUFjO0FBQ2QseUNBQXlDO0FBQ3pDLElBQUkscUJBQXFCLEdBQUc7SUFDeEIsSUFBSSxFQUFFLEVBQUU7SUFDUixlQUFlLEVBQUUsRUFBRTtJQUNuQixpQkFBaUIsRUFBRSxFQUFFO0NBQ3hCLENBQUE7QUFDRCxJQUFJLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztBQUM5QixJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFFckI7SUFDSSxxQkFBcUIsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2hDLHFCQUFxQixDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7SUFDM0MsV0FBVyxHQUFHLEVBQUUsQ0FBQyxDQUFBLDhCQUE4QjtJQUMvQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2xELE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BDO0FBQ0wsQ0FBQztBQUVVLFFBQUEsd0JBQXdCLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRSxDQUNuRCxNQUFNLENBQ0YsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUNWLEdBQUcsRUFBRSxDQUFDLHFCQUFxQixDQUFDLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FDckQsQ0FBQztBQUNLLFFBQUEsdUJBQXVCLEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBRSxDQUFDLHFCQUFxQixDQUFDLGlCQUFpQixJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7QUFFbkcsUUFBQSxpQkFBaUIsR0FBRyxDQUFDLElBQVksRUFBRSxVQUFnQixFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQ3JFLEdBQUcsRUFBRSxDQUFDLElBQUksRUFDVixHQUFHLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUNqRCxDQUFDO0FBRVMsUUFBQSxhQUFhLEdBQUcsQ0FBQyxJQUFZLEVBQUUsTUFBaUIsRUFBRSxFQUFFLENBQzNELE1BQU0sQ0FDRixHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQ1YsR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxHQUFFLEVBQUUsQ0FBQSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUNsRSxDQUFDO0FBRU4sNkJBQTZCLElBQVksRUFBRSxJQUFVO0lBQ2pELFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDekIscUJBQXFCLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyRCxDQUFDO0FBRUQsZ0NBQXVDLElBQVU7SUFDN0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFGRCx3REFFQztBQUVELDJCQUFrQyxJQUFZO0lBQzFDLHlCQUF5QjtJQUN6QixxQkFBcUIsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7SUFDN0MsSUFBSSxvQkFBb0IsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0MsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDbEMsQ0FBQztBQUxELDhDQUtDO0FBRUQsSUFBSTtBQUNKO0lBQ0ksdUJBQXVCLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBRkQsZ0NBRUM7QUFFRDtJQUNJLE9BQU8scUJBQXFCLENBQUM7QUFDakMsQ0FBQztBQUZELDREQUVDO0FBRUQ7SUFFSSxpQkFBaUI7SUFDakIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGNBQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDcEMsSUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFDLGNBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxrQkFBVyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3BCLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxjQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDakI7S0FDSjtJQUNELHVCQUF1QixFQUFFLENBQUM7QUFDOUIsQ0FBQztBQVhELDhCQVdDOzs7Ozs7Ozs7Ozs7O0FDdFlELDJDQU1xQjtBQUNyQiwrREFBaUU7QUFDakUsZ0NBQWdDO0FBQ2hDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUM1QixNQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUM1QixPQUFPLENBQUMsb0VBQW9FLENBQUMsQ0FBQztBQUM5RSxPQUFPLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztBQUMxRSxPQUFPLENBQUMsa0VBQWtFLENBQUMsQ0FBQztBQUM1RSxPQUFPLENBQUMsNkVBQTZFLENBQUMsQ0FBQztBQUN2RixPQUFPLENBQUMsa0VBQWtFLENBQUMsQ0FBQztBQUM1RSxPQUFPLENBQUMsOERBQThELENBQUMsQ0FBQztBQUt4RSxZQUFZO0FBQ1osSUFBSSxVQUFVLEdBQUcsVUFBVSxDQUFDO0FBQzVCLElBQUksS0FBSyxHQUFHLENBQUMsZUFBZSxFQUFFLFlBQVksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0FBRWpFLHlDQUF5QztBQUN6QztJQWVJLFlBQVksSUFBWSxFQUFFLElBQStCLEVBQUUsTUFBZ0IsRUFBRSxRQUFnQjtRQUN6RixJQUFJLFNBQWlCLENBQUM7UUFDdEIsSUFBSSxLQUFLLEdBQVcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksUUFBUSxHQUFXLEVBQUUsQ0FBQztRQUMxQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNyQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixpREFBaUQ7UUFDakQsb0NBQW9DO1FBQ3BDLDZCQUE2QjtRQUM3QixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdEIsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqQyxJQUFJLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUMsR0FBRyxRQUFRLENBQUM7WUFDbkQsSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7U0FDckI7YUFBTTtZQUNILElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDcEIsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQy9DLEtBQUssR0FBRyxRQUFRLEdBQUcsR0FBRyxDQUFDO2FBQzFCO2lCQUFNO2dCQUNILFNBQVMsR0FBRyxJQUFJLENBQUM7Z0JBQ2pCLEtBQUssR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDO2dCQUM5QixRQUFRLEdBQUcsS0FBSyxDQUFDO2FBQ3BCO1lBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUN0QixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztnQkFDbkIsU0FBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ25DLElBQUksUUFBUSxHQUFhLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDdEQsS0FBSyxJQUFJLEtBQUssSUFBSSxRQUFRLEVBQUU7b0JBQ3hCLElBQUksU0FBUyxHQUFHLElBQUksUUFBUSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssR0FBRyxTQUFTLENBQUMsQ0FBQztvQkFDckUsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUN6QyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7b0JBQ25ELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUNqQzthQUNKO1lBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsU0FBUyxDQUFDO1lBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsR0FBRyxTQUFTLENBQUM7WUFDOUMsSUFBSSxrQkFBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsRUFBRTtnQkFDekQsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7YUFDbkQ7WUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDN0Q7SUFDTCxDQUFDO0lBRUQsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNwQixDQUFDO0lBRUQsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDO0lBRUQsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN4QixDQUFDO0lBRUQsdUNBQXVDO0lBQ3ZDLGVBQWU7UUFDWCxJQUFJLEdBQUcsR0FBYSxFQUFFLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksRUFBRTtZQUN2QixLQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQzdCLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxNQUFNLEVBQUU7b0JBQ3JCLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUN2QjthQUNKO1NBQ0o7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRCwyREFBMkQ7SUFDM0QsYUFBYTtRQUNULElBQUksVUFBVSxHQUFTLEVBQUUsQ0FBQztRQUMxQixJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFO1lBQ3ZCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQzlDLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDNUIsT0FBTyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQzthQUM3QztTQUNKO1FBQ0QsT0FBTyxVQUFVLENBQUM7SUFDdEIsQ0FBQztJQUVELDREQUE0RDtJQUM1RCxlQUFlO1FBQ1gsSUFBSSxZQUFZLEdBQThCLEVBQUUsQ0FBQztRQUNqRCxLQUFLLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFBRTtZQUNyQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUNqQztRQUNELElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLEVBQUU7WUFDdkIsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUM1QixPQUFPLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO2FBQ2pEO1NBQ0o7UUFDRCxPQUFPLFlBQVksQ0FBQztJQUN4QixDQUFDO0lBRUQsa0NBQWtDO0lBQ2xDLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDN0IsQ0FBQztJQUVELDBFQUEwRTtJQUMxRSxZQUFZO1FBQ1IsSUFBSSxHQUFHLEdBQVMsRUFBRSxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7WUFDcEIsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFBO1NBQ2xDO1FBQ0QsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksRUFBRTtZQUN2QixLQUFLLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQzVCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7YUFDckM7U0FDSjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVELDJDQUEyQztJQUMzQyxlQUFlO1FBQ1gsSUFBSSxHQUFHLEdBQWEsRUFBRSxDQUFDO1FBQ3ZCLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDMUIsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksRUFBRTtZQUN2QixLQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7Z0JBQzdCLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO2FBQzdDO1NBQ0o7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFRCxLQUFLO1FBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM3QixJQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxFQUFFO1lBQ3ZCLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDN0IsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ2pCO1NBQ0o7SUFDTCxDQUFDO0NBRUo7QUFFRCx3Q0FBd0M7QUFDeEMsaUJBQWlCLEtBQTZCLEVBQUUsS0FBNkI7SUFDekUsS0FBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ2hDLElBQUksa0JBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtZQUN6QixLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO2FBQU07WUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM5QztLQUNKO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVELDhEQUE4RDtBQUM5RCxpQkFBaUIsSUFBVztJQUN4QixJQUFJLEtBQUssR0FBRyx5QkFBYSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzlDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN0QixPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7QUFFRCxtQkFBbUI7QUFDbkI7O1FBQ0ksSUFBSSxJQUFJLEdBQVMsRUFBRSxDQUFDO1FBRXBCLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxFQUFFO1lBQ3BCLE1BQU0sSUFBSSxPQUFPLENBQUMsVUFBVSxPQUFPLEVBQUUsTUFBTTtnQkFDbkMsSUFBSSxHQUFHLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztnQkFDL0IsR0FBRyxDQUFDLGtCQUFrQixHQUFHO29CQUNyQixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxFQUFFO3dCQUN0QixJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFOzRCQUNwQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzs0QkFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQzs0QkFDbkIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO3lCQUNsQjs2QkFBTTs0QkFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO3lCQUNqQztxQkFDSjtnQkFDTCxDQUFDLENBQUM7Z0JBQ0YsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsVUFBVSxHQUFHLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDekMsR0FBRyxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUM7Z0JBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkIsQ0FBQyxDQUNKLENBQUM7U0FDTDtRQUVELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNqQyxDQUFDO0NBQUE7QUFFRCwrQkFBK0I7QUFDL0IsU0FBUyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsS0FBSztJQUM1QixJQUFJLElBQUksR0FBYSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekMsZUFBZTtJQUNmLHNEQUFzRDtJQUN0RCxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQztBQUVILDBFQUEwRTtBQUMxRSxzQkFBc0IsSUFBVTtJQUM1QixJQUFJLE1BQU0sR0FBYSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDMUMsSUFBSSxPQUFPLEdBQThCLEVBQUUsQ0FBQztJQUM1QyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDckMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNqQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzlCO0lBQ0QsT0FBTyxJQUFJLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ2pFLENBQUM7QUFFRCxxRkFBcUY7QUFDckYsb0RBQW9EO0FBQ3BELHFCQUFxQixJQUFZO0lBQzdCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsSUFBSSxNQUFNLEdBQWEsRUFBRSxDQUFDO0lBQzFCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUksUUFBUSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEMsSUFBSSxHQUFHLEdBQUcseUJBQWEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMxQixNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzVCO0tBQ0o7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNsQixDQUFDO0FBR0QsMkRBQTJEO0FBQzNELGlGQUFpRjtBQUNqRixzQkFBc0IsUUFBa0I7SUFDcEMsSUFBSSxLQUFLLEdBQVMsRUFBRSxDQUFDO0lBQ3JCLElBQUksT0FBTyxHQUErQixFQUFFLENBQUM7SUFDN0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUNoQztJQUNELElBQUksS0FBSyxHQUFhLEVBQUUsQ0FBQztJQUN6QixJQUFJLElBQUksR0FBYSxFQUFFLENBQUM7SUFFeEIsMkJBQTJCO0lBQzNCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUksa0JBQVcsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNqQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFBO1NBQzFCO1FBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzFDLElBQUksa0JBQVcsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDakMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUMzQjtZQUNELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDdkMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUN4QztTQUNKO0tBQ0o7SUFDRCw2QkFBNkI7SUFDN0IscUNBQXFDO0lBQ3JDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssRUFBRTtZQUMvQixJQUFJLElBQUksR0FBVyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0IsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4QixPQUFPLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNyQixJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQ3RCLElBQUksR0FBRyxLQUFLLFNBQVMsRUFBRTtvQkFDbkIsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxFQUFFO3dCQUN2QixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO3dCQUNwQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUU7NEJBQ3JCLElBQUksR0FBRyxHQUFHLENBQUM7eUJBQ2Q7d0JBQ0QsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7NEJBQ3hCLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7eUJBQ25CO3FCQUNKO2lCQUNKO2FBQ0o7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25CO0tBQ0o7SUFDRCxzQkFBc0I7SUFDdEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3RDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BDO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUdELDZCQUE2QixJQUFjO0lBQ3ZDLGdDQUFnQztJQUNoQyxJQUFJLFNBQVMsR0FBUyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDMUMsMkNBQTJDO0lBQzNDLElBQUksVUFBVSxHQUFTLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUM1Qyw2QkFBNkI7SUFDN0IsSUFBSSxXQUFXLEdBQThCLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUNuRSxvQ0FBb0M7SUFDcEMsSUFBSSxZQUFZLEdBQThCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUNyRSxTQUFTO0lBQ1QsSUFBSSxHQUFHLEdBQUcsb0JBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQixPQUFPO0lBQ1AsNkJBQTZCO0lBQzdCLEtBQUssSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUNwQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUM1QyxtQkFBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNCLDJCQUFlLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQzlEO0tBQ0o7SUFFRCx1REFBdUQ7SUFDdkQsdUdBQXVHO0lBQ3ZHLDRCQUE0QjtJQUM1QixJQUFJLFdBQVcsR0FBNEIsRUFBRSxDQUFDO0lBQzlDLEtBQUssSUFBSSxJQUFJLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUN0QyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3REO0lBRUQsNkJBQTZCO0lBQzdCLDBCQUEwQixLQUFXO1FBQ2pDLEtBQUssSUFBSSxHQUFHLElBQUksS0FBSyxFQUFFO1lBQ25CLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRTtnQkFDekIsdUJBQVcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7U0FDSjtJQUNMLENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUU3QixLQUFLLElBQUksR0FBRyxJQUFJLFdBQVcsRUFBRTtRQUN6QixnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUN0QztJQUVELGdEQUFnRDtJQUNoRCxJQUFJLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMsQ0FBQztJQUMzQyxvRUFBb0U7SUFDcEUsSUFBSSxhQUFhLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBRXBELFlBQVk7SUFDUixJQUFJLFdBQVcsR0FBRyx1QkFBVyxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwRCxJQUFJLFNBQVMsR0FBRyx1QkFBVyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM3QyxJQUFJLFFBQVEsR0FBRyx1QkFBVyxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM5QyxJQUFJLE9BQU8sR0FBRyx1QkFBVyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM1QyxJQUFJLGtCQUFrQixHQUFHLHVCQUFXLENBQUMsb0JBQW9CLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDbEUsSUFBSSxJQUFJLEdBQUcsdUJBQVcsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFHMUMsS0FBSztJQUNELDRCQUFnQixDQUFDLEdBQUcsRUFBRSxpQkFBaUIsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUNqRSxRQUFRO0lBQ0osSUFBSSxjQUFjLEdBQUcsdUJBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUUvRSxnQkFBZ0I7SUFFWixvREFBb0Q7SUFDcEQsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxDQUFDO0lBQ3ZDLGFBQWEsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFFNUMsSUFBSSxhQUFhLEdBQUcsa0JBQU0sQ0FDdEIsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUNWLEdBQUcsRUFBRTtRQUNELHVCQUFXLENBQUMsWUFBWSxFQUFFLHlCQUFhLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUMsRUFDRCxDQUFDLENBQ0osQ0FBQztJQUNGLG1DQUFtQztJQUNuQyxJQUFJLE1BQU0sR0FBVyxFQUFFLENBQUM7SUFDeEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdkMsNEJBQTRCO1FBQzVCLElBQUksT0FBTyxHQUFTLGtCQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hILE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDeEI7SUFDRCxJQUFJLGFBQWEsR0FBaUIsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSw0QkFBZ0IsQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUMvRyxJQUFJLHFCQUFxQixHQUFpQixHQUFHLEVBQUUsQ0FBQyw0QkFBZ0IsQ0FBQyxhQUFhLENBQUMsSUFBSSxhQUFhLEVBQUUsQ0FBQztJQUV2Ryx3QkFBd0I7SUFDcEIsSUFBSSxrQkFBa0IsR0FBRyxvQkFBUSxDQUFDO1FBQzlCLGFBQWE7UUFDYixvQkFBUSxDQUFDLE1BQU0sQ0FBQztLQUNuQixDQUFDLENBQUM7SUFFSCxJQUFJLGdCQUFnQixHQUFHLGtCQUFNLENBQ3pCLEdBQUcsRUFBRSxDQUFDLElBQUksRUFDVixHQUFHLEVBQUU7UUFDRCw0QkFBZ0IsQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLEVBQUUsMkJBQWUsQ0FBQyw0QkFBZ0IsQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLENBQUMsRUFBRSx1QkFBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoSSxPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsR0FBRyw0QkFBZ0IsQ0FBQyxHQUFHLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFBO0lBQ3pFLENBQUMsRUFDRCxDQUFDLENBQ0osQ0FBQztJQUNGLHlDQUF5QztJQUN6QyxJQUFJLGVBQWUsR0FBRyxrQkFBTSxDQUN4QixHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQ1YsR0FBRyxFQUFFO1FBQ0QsdUJBQVcsQ0FBQyxZQUFZLEVBQUUseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRCxDQUFDLEVBQ0QsQ0FBQyxDQUNKLENBQUM7SUFDRixJQUFJLFVBQVUsR0FBRyxvQkFBUSxDQUFDLENBQUMsZUFBZTtRQUN0QyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLDRCQUFnQixDQUFDLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJLHVCQUFXLENBQUMsY0FBYyxDQUFDLEVBQy9FLG9CQUFRLENBQUM7WUFDTCxrQkFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRTtnQkFDOUMsdUJBQVcsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQ2pDLHVCQUFXLENBQUMsa0JBQWtCLEVBQUUsT0FBTyxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN0RSx1QkFBVyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMvQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ0wsa0JBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUU7Z0JBQzlDLHVCQUFXLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyx1QkFBVyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUMvQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ0wsa0JBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FDOUMsdUJBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ2xDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUdkLElBQUksTUFBTSxHQUFHLG9CQUFRLENBQUM7UUFDbEIsb0JBQVEsQ0FBQztZQUNMLGlCQUFLLENBQUMscUJBQXFCLEVBQUUsa0JBQWtCLENBQUM7WUFDaEQsa0JBQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFO1lBQ3hCLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDUixDQUFDO1FBQ0YsZ0JBQWdCO0tBQ25CLENBQUMsQ0FBQztJQUVILElBQUksS0FBSyxHQUFHLG9CQUFRLENBQUM7UUFDakIsVUFBVTtRQUNWLG9CQUFRLENBQUM7WUFDTCxNQUFNLEVBQUUsVUFBVTtTQUNyQixDQUFDO0tBQ0wsQ0FBQyxDQUFDO0lBRVAsa0NBQWtDO0lBQzlCLDZCQUFpQixDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUU5QixxRUFBcUU7SUFDckUsaUJBQWlCLEdBQVc7UUFDeEIsSUFBSSxHQUFHLEdBQVcsR0FBRyxDQUFDO1FBQ3RCLE9BQU8sWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUN6QyxHQUFHLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDZixDQUFDO0lBRUQscUJBQXFCO0lBRXJCLHNDQUFzQztJQUN0QyxLQUFLLElBQUksR0FBRyxJQUFJLHlCQUFhLEVBQUU7UUFDM0IsSUFBSSxHQUFHLEdBQVUsRUFBRSxDQUFDO1FBQ3BCLEdBQUcsQ0FBQyxJQUFJLENBQUMsb0NBQXdCLENBQUMsZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDOUUsR0FBRyxDQUFDLElBQUksQ0FBQyx5QkFBYSxDQUFDLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRixHQUFHLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMscUJBQXFCLEVBQUUsR0FBRyxFQUFFO1FBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDSixxQ0FBcUM7UUFDckMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMsQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDeEQsR0FBRyxDQUFDLElBQUksQ0FBQyx5QkFBYSxDQUFDLGdCQUFnQixHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxFQUFFO2dCQUNqRix1QkFBVyxDQUFDLGNBQWMsRUFBRSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ1A7UUFDRCxtQ0FBbUM7UUFDbkMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN2QyxHQUFHLENBQUMsSUFBSSxDQUFDLHlCQUFhLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxZQUFZLEdBQUcsV0FBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLGNBQWMsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDMUs7UUFFRCxJQUFJLEtBQUssR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUQsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyx5QkFBYSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxRztRQUVELElBQUksT0FBTyxHQUFHLGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxjQUFjLENBQUMsSUFBSSxHQUFHO1lBQ3hELHVCQUFXLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSztZQUNqQyx1QkFBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUs7WUFDOUIsdUJBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLEVBQzdCLG9CQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQixrQ0FBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNuQztJQUVELG9DQUFvQztJQUNwQyxJQUFJLFVBQVUsR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsa0JBQVcsQ0FBQyxTQUFTLENBQUMsdUJBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLHVCQUFXLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxFQUN4SyxvQkFBUSxDQUFDO1FBQ0Qsb0NBQXdCLENBQUMsZ0NBQWdDLENBQUM7UUFDMUQseUJBQWEsQ0FBQyxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1RSxDQUNKLENBQUMsQ0FBQztJQUNQLDJCQUEyQjtJQUMzQixrQ0FBc0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVuQyx1Q0FBdUM7SUFDdkMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGlCQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLElBQUksTUFBTSxHQUFHLGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxjQUFjLENBQUMsSUFBSSwyQkFBZSxDQUFDLGlCQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUM7ZUFDN0YsdUJBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxJQUFJLEVBQ25DLG9CQUFRLENBQUM7WUFDTCx5QkFBYSxDQUFDLGNBQWMsR0FBRyxXQUFXLENBQUMsaUJBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUU7Z0JBQzdELHVCQUFXLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLE1BQU0sR0FBRyx1QkFBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUNwQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEIsU0FBUyxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsaUJBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUMzRyxtQ0FBdUIsQ0FBQyxrQkFBa0IsR0FBRyxpQkFBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUM3RCwyQkFBZSxDQUFDLGlCQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ3ZELHVCQUFXLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFBO1lBQ2xDLENBQUMsQ0FBQztTQUFDLENBQ04sQ0FBQyxDQUFDO1FBQ1Asa0NBQXNCLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDbEM7SUFFRCwrQkFBK0I7SUFDL0IsSUFBSSxhQUFhLEdBQVUsRUFBRSxDQUFDO0lBQzlCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzNDLGFBQWEsQ0FBQyxJQUFJLENBQUMseUJBQWEsQ0FBQyxTQUFTLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLEVBQUU7WUFDdEUsdUJBQVcsQ0FBQyxrQkFBa0IsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRCx1QkFBVyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUNuQyx1QkFBVyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ1A7SUFDRCxJQUFJLFlBQVksR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxJQUFJLHVCQUFXLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxFQUN6RixvQkFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDN0Isa0NBQXNCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDckMsb0RBQW9EO0lBQ3BELElBQUksTUFBTSxHQUFHLGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQzlDLG9CQUFRLENBQUM7UUFDTCxrQkFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckQsb0NBQXdCLENBQUMsOENBQThDLENBQUM7S0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwRixrQ0FBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUUvQiw2QkFBNkI7SUFDN0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdkMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3pCLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRTtZQUNaLElBQUksUUFBUSxHQUFHLGlCQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsdUJBQVcsQ0FBQyxjQUFjLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNsRSx1QkFBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUs7Z0JBQ2pDLHVCQUFXLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSztnQkFDOUIsdUJBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxLQUFLLEVBQzdCLG9CQUFRLENBQUM7Z0JBQ0wsb0NBQXdCLENBQUMsZ0NBQWdDLENBQUM7YUFDN0QsQ0FBQyxDQUFDLENBQUM7WUFDUixrQ0FBc0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNwQzthQUFNLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRTtZQUNuQixJQUFJLE9BQU8sR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsY0FBYyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDakUsdUJBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFLO2dCQUNqQyx1QkFBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUs7Z0JBQzlCLHVCQUFXLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxFQUM3QixvQkFBUSxDQUFDO2dCQUNMLG9DQUF3QixDQUFDLCtCQUErQixDQUFDO2FBQzVELENBQUMsQ0FBQyxDQUFDO1lBQ1Isa0NBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDbkM7S0FDSjtJQUNELHdCQUF3QjtJQUN4QixxREFBcUQ7SUFDckQsd0RBQXdEO0lBQ3hELDREQUE0RDtJQUM1RCxJQUFJLFFBQVEsR0FBRyxpQkFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxFQUNuRCxvQkFBUSxDQUFDO1FBQ0Qsa0JBQU0sQ0FDRixHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLFFBQVEsRUFDMUMsR0FBRyxFQUFFO1lBQ0QscUJBQXFCLENBQUMsSUFBSSxJQUFJLElBQUksR0FBRyxzQkFBc0IsR0FBRyx1QkFBVyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsR0FBRyxDQUFBO1FBQ3ZHLENBQUMsRUFBRSxDQUFDLENBQ1A7UUFDRCxrQkFBTSxDQUNGLEdBQUcsRUFBRSxDQUFDLHVCQUFXLENBQUMsV0FBVyxDQUFDLElBQUksTUFBTSxFQUN4QyxHQUFHLEVBQUU7WUFDRCxxQkFBcUIsQ0FBQyxJQUFJLElBQUksSUFBSSxHQUFHLDhEQUE4RDtnQkFDL0YsdUJBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEdBQUcsQ0FBQTtRQUM3QyxDQUFDLEVBQUUsQ0FBQyxDQUNQO1FBQ0QsaUJBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssRUFDekMsb0NBQXdCLENBQUMsaURBQWlELENBQUMsQ0FBQztLQUNuRixDQUNKLENBQUMsQ0FDTDtJQUNELGtDQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRXJDLHFDQUFxQztJQUNqQyxJQUFJLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQztRQUN4QixLQUFLLEVBQUU7WUFDSCxLQUFLLEVBQUUsRUFBRTtZQUNULEtBQUssRUFBRSxFQUFFO1NBQ1o7UUFDRCxRQUFRLEVBQUU7WUFDTixJQUFJLEVBQUUsUUFBUTtZQUNkLFNBQVMsRUFBRSxrQkFBa0I7U0FDaEM7UUFDRCxRQUFRLEVBQUU7WUFDTixjQUFjLEVBQUUsQ0FBQztZQUNqQixzQkFBc0IsRUFBRSxNQUFNO1lBQzlCLDJCQUEyQixFQUFFLE1BQU07WUFDbkMsZ0JBQWdCLEVBQUUsTUFBTTtZQUN4QixpQkFBaUIsRUFBRSxNQUFNO1lBQ3pCLGdCQUFnQixFQUFFLE1BQU07WUFDeEIsU0FBUyxFQUFFLFNBQVM7WUFDcEIsV0FBVyxFQUFFLEVBQUU7WUFDZixVQUFVLEVBQUUsRUFBRTtTQUNqQjtLQUNKLENBQUMsQ0FBQztJQUVILElBQUksUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDO1FBQ3JCLEtBQUssRUFBRTtZQUNILEtBQUssRUFBRSxFQUFFO1lBQ1QsS0FBSyxFQUFFLEVBQUU7U0FDWjtRQUNELFFBQVEsRUFBRTtZQUNOLElBQUksRUFBRSxRQUFRO1lBQ2QsU0FBUyxFQUFFLGVBQWU7U0FDN0I7UUFDRCxRQUFRLEVBQUU7WUFDTixjQUFjLEVBQUUsQ0FBQztZQUNqQixzQkFBc0IsRUFBRSxNQUFNO1lBQzlCLGdCQUFnQixFQUFFLE1BQU07WUFDeEIsaUJBQWlCLEVBQUUsTUFBTTtZQUN6QixnQkFBZ0IsRUFBRSxNQUFNO1lBQ3hCLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLFdBQVcsRUFBRSxFQUFFO1lBQ2YsVUFBVSxFQUFFLEVBQUU7U0FDakI7S0FDSixDQUFDLENBQUM7SUFFSCw0QkFBNEI7SUFDNUIsSUFBSSxNQUFNLEdBQVcsQ0FBQyxDQUFDO0lBRXZCLHFCQUFxQjtJQUNyQixlQUFlLEtBQVU7UUFDckIsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNoQyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssRUFBRTtZQUNwQixLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDakM7SUFDTCxDQUFDO0lBRUQscURBQXFEO0lBQ3JELHFDQUFxQztJQUNyQyx1QkFBdUIsS0FBVztRQUM5QixJQUFJLFFBQVEsR0FBUyxFQUFFLENBQUM7UUFDeEIsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7WUFDbkIsSUFBSSxrQkFBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUM1QixRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO2FBQ3RCO1lBQ0QsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakQsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksa0JBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDNUIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztpQkFDdEI7Z0JBQ0QsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMzQjtTQUNKO1FBQ0QsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQztJQUVELDBDQUEwQztJQUMxQyxvQkFBb0IsS0FBYSxFQUFFLGFBQWtCO1FBQ2pELElBQUksS0FBSyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUIsSUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUNsQyxJQUFJLGtCQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUMvQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDeEIsbUJBQW1CO2dCQUNuQixFQUFFLEVBQUUsS0FBSztnQkFDVCxLQUFLLEVBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQztnQkFDekIsQ0FBQyxFQUFFLENBQUM7Z0JBQ0osQ0FBQyxFQUFFLENBQUM7Z0JBQ0osSUFBSSxFQUFFLEVBQUU7YUFDWCxDQUFDLENBQUM7U0FDTjtRQUNELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEMsSUFBSSxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3JELGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO29CQUN4QixtQkFBbUI7b0JBQ25CLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO29CQUNmLEtBQUssRUFBRSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUMvQixDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQzlGLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztvQkFDOUYsSUFBSSxFQUFFLEVBQUU7aUJBQ1gsQ0FBQyxDQUFBO2FBQ0w7WUFDRCxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztnQkFDeEIsRUFBRSxFQUFFLE1BQU0sR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFO2dCQUNsQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDbkIsTUFBTSxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQzNDLElBQUksRUFBRSxDQUFDO2dCQUNQLEtBQUssRUFBRSxNQUFNO2FBQ2hCLENBQUMsQ0FBQztTQUNOO0lBQ0wsQ0FBQztJQUVELGNBQWMsT0FBZSxFQUFFLGFBQWtCO1FBQzdDLElBQUksS0FBSyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUIsVUFBVSxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsQ0FBQTtRQUNsQyxxRUFBcUU7UUFDckUsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7WUFDaEMsS0FBSyxJQUFJLE1BQU0sSUFBSSxRQUFRLEVBQUU7Z0JBQ3pCLFVBQVUsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7Z0JBQ2xDLElBQUksV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDaEMsS0FBSyxJQUFJLE1BQU0sSUFBSSxXQUFXLEVBQUU7b0JBQzVCLFVBQVUsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7aUJBQ3JDO2FBQ0o7U0FDSjtJQUNMLENBQUM7SUFFRCx5QkFBeUI7SUFDekIsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQ3ZDLFdBQVcsRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFM0MsYUFBYSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsVUFBVSxLQUFhO1FBQ25ELE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFDSCxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxVQUFVLEtBQWE7UUFDOUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUNILGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsS0FBYTtRQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsVUFBVSxLQUFhO1FBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FDdkMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVyQyxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFVLEtBQWE7UUFDbkQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUNILGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsS0FBYTtRQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsVUFBVSxLQUFhO1FBQzlDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFDSCxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxVQUFVLEtBQWE7UUFDakQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUdQLGtCQUFrQjtJQUNkLHNCQUFVLEVBQUUsQ0FBQztJQUNiLElBQUkscUJBQXFCLEdBQUcsb0NBQXdCLEVBQUUsQ0FBQztJQUUzRCxnQkFBZ0I7SUFDaEIsb0NBQW9DO0lBQ2hDLElBQUksU0FBUyxHQUFHLEVBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFDLENBQUM7SUFDakMsSUFBSSxZQUFZLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUMsQ0FBQztJQUVwQztRQUNJLDZDQUE2QztRQUM3QyxJQUFJLFFBQVEsR0FBYSxFQUFFLENBQUM7UUFDNUIsSUFBSSxXQUFXLEdBQWEsRUFBRSxDQUFDO1FBQy9CLElBQUksV0FBbUIsQ0FBQztRQUN4QixJQUFJLGNBQXNCLENBQUM7UUFDM0IsOEJBQThCO1FBQzlCLElBQUksV0FBVyxHQUFHLDRCQUFnQixDQUFDLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQzNELElBQUksT0FBTyxHQUFHLHVCQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDMUMsK0NBQStDO1FBQy9DLFdBQVcsR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDeEMsT0FBTyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ25DLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDM0IsV0FBVyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUMzQztRQUNELGtEQUFrRDtRQUNsRCxjQUFjLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZDLE9BQU8sY0FBYyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUN0QyxXQUFXLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ2pDLGNBQWMsR0FBRyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDakQ7UUFDRCwwQkFBMEI7UUFDMUIsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ25CLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoQixNQUFNO1FBQ04sSUFBSSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQzVCLG1EQUFtRDtRQUNuRCxJQUFJLFVBQVUsR0FBRyxRQUFRLENBQUMsc0JBQXNCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0QsSUFBSSxlQUFlLEdBQVcsRUFBRSxDQUFDO1FBQ2pDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzFDLGVBQWUsSUFBSSxpQ0FBaUMsQ0FBQztTQUN4RDtRQUNELDJEQUEyRDtRQUMzRCxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDMUMsZUFBZSxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxDQUFDO1NBQ25EO2FBQU07WUFDSCxlQUFlLElBQUksSUFBSSxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDcEUsZUFBZSxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDbEQ7UUFDRCxtREFBbUQ7UUFDbkQsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUM7UUFDMUMsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLHNCQUFzQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdELElBQUksY0FBYyxHQUFXLEVBQUUsQ0FBQztRQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxjQUFjLElBQUksZ0NBQWdDLENBQUM7U0FDdEQ7UUFDRCwwREFBMEQ7UUFDMUQsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQzlDLGNBQWMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLEdBQUcsQ0FBQztTQUNsRDthQUFNO1lBQ0gsY0FBYyxJQUFJLElBQUksR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ3ZFLGNBQWMsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQ3JEO1FBQ0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsR0FBRyxjQUFjLENBQUM7UUFDeEMsc0RBQXNEO1FBQ3RELG1HQUFtRztRQUNuRyxLQUFLLElBQUksSUFBSSxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUU7WUFDeEMsSUFBSSxJQUFJLENBQUMsRUFBRSxJQUFJLFdBQVcsRUFBRTtnQkFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFDLEdBQUcsRUFBRSxtQkFBbUIsRUFBQyxDQUFDO2FBQzNDO1lBQ0QsSUFBSSxJQUFJLENBQUMsRUFBRSxJQUFJLE9BQU8sRUFBRTtnQkFDcEIsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFDLEdBQUcsRUFBRSx1QkFBdUIsRUFBQyxDQUFDO2FBQy9DO1lBQ0QsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDNUIsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLENBQUM7YUFDakM7WUFDRCxJQUFJLENBQUMsa0JBQVcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO2dCQUNwRSxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQzthQUNqQztTQUNKO1FBQ0QsS0FBSyxJQUFJLElBQUksSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFO1lBQ3JDLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxPQUFPLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBQyxHQUFHLEVBQUUsdUJBQXVCLEVBQUMsQ0FBQzthQUMvQztZQUNELElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxXQUFXLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBQyxHQUFHLEVBQUUsbUJBQW1CLEVBQUMsQ0FBQzthQUMzQztZQUNELElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7Z0JBQy9CLElBQUksQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDO2FBQ2pDO1NBQ0o7UUFDRCxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEIsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRW5CLGtDQUFrQztRQUNsQyxJQUFJLE1BQU0sR0FBRztZQUNULFVBQVUsRUFBRSxFQUFFO1lBQ2QsUUFBUSxFQUFFLENBQUM7U0FDZCxDQUFDO1FBRUYseUJBQXlCO1FBQ3pCLElBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkQsSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUdoRCxrQkFBa0I7UUFDbEIsU0FBUyxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxVQUFVLEtBQVU7WUFDekQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFDSCxTQUFTLENBQUMsSUFBSSxDQUFDLHdCQUF3QixFQUFFLFVBQVUsS0FBVTtZQUN6RCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUVILHNCQUFzQjtRQUN0QixXQUFXLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDNUIsUUFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXpCLHFCQUFxQixFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELFlBQVk7SUFDWixJQUFJLE1BQU0sR0FBdUIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRSxJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXRDLElBQUksZ0JBQWdCLENBQUM7SUFDckIsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbEMsSUFBSSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFFMUI7UUFDSSxPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEQsT0FBTyxHQUFHLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTlCLE9BQU8sQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDO1FBQzlCLE9BQU8sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsdUJBQXVCLEdBQUcscUJBQXFCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUMvRSxJQUFJLGFBQWEsR0FBRyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDO1FBQy9JLE9BQU8sQ0FBQyxRQUFRLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUUvRCxPQUFPLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztRQUM5QixPQUFPLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztRQUM1QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNuRSxJQUFJLGNBQWMsR0FBRyxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNSLGdCQUFnQixHQUFHLENBQUMsQ0FBQzthQUN4QjtZQUNELE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQztTQUMvQjtRQUVELFlBQVksRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDtRQUNJLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7WUFDbkQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzVELE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxZQUFZLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBQztTQUM1RjtJQUNMLENBQUM7SUFFTCxZQUFZO0lBQ1Isa0JBQWtCLENBQUM7UUFDZixJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxFQUFFO1lBQ2pCLElBQUksY0FBYyxHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQzdFLElBQUksQ0FBQyxrQkFBVyxDQUFDLGNBQWMsQ0FBQyxFQUFFO2dCQUM5Qiw2QkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDbEMscUJBQVMsRUFBRSxDQUFDO2dCQUNaLE1BQU0sRUFBRSxDQUFDO2FBQ1o7U0FDSjtJQUNMLENBQUM7SUFFRCxpQkFBaUIsQ0FBQztRQUNkLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUUsRUFBQyxNQUFNO1lBQ3hCLElBQUkscUJBQXFCLENBQUMsZUFBZSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7Z0JBQ25ELGdCQUFnQixFQUFFLENBQUM7Z0JBQ25CLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUM7Z0JBQ25GLFlBQVksRUFBRSxDQUFDO2FBQ2xCO1NBQ0o7YUFBTSxJQUFJLENBQUMsQ0FBQyxPQUFPLElBQUksRUFBRSxFQUFFLEVBQUMsSUFBSTtZQUM3QixJQUFJLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO2dCQUNuRCxnQkFBZ0IsRUFBRSxDQUFDO2dCQUNuQixJQUFJLGdCQUFnQixHQUFHLENBQUM7b0JBQ3BCLGdCQUFnQixHQUFHLHFCQUFxQixDQUFDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2dCQUN4RSxZQUFZLEVBQUUsQ0FBQzthQUNsQjtTQUNKO0lBQ0wsQ0FBQztJQUNELDhCQUE4QjtJQUM5QixNQUFNLEVBQUUsQ0FBQztJQUVULFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3ZELFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3pELENBQUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCI7KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIF9faW5zdGFuY2VzID0ge307XHJcblxyXG4gIC8vIERlYWwgd2l0aCByZXNpemUuICBza2lwIHRoaXMgZm9yIG5vZGUuanMgYXBwc1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKVxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gX19pbnN0YW5jZXMpIHtcclxuICAgICAgICBpZiAoX19pbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gX19pbnN0YW5jZXNba2V5XTtcclxuICAgICAgICAgIGluc3RhbmNlLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIHRoZSBzaWdtYSBpbnN0YW5jZXMgY29uc3RydWN0b3IuIE9uZSBpbnN0YW5jZSBvZiBzaWdtYSByZXByZXNlbnRcclxuICAgKiBvbmUgZ3JhcGguIEl0IGlzIHBvc3NpYmxlIHRvIHJlcHJlc2VudCB0aGlzIGdyYXDEpSB3aXRoIHNldmVyYWwgcmVuZGVyZXJzXHJcbiAgICogYXQgdGhlIHNhbWUgdGltZS4gQnkgZGVmYXVsdCwgdGhlIGRlZmF1bHQgcmVuZGVyZXIgKFdlYkdMICsgQ2FudmFzXHJcbiAgICogcG9seWZpbGwpIHdpbGwgYmUgdXNlZCBhcyB0aGUgb25seSByZW5kZXJlciwgd2l0aCB0aGUgY29udGFpbmVyIHNwZWNpZmllZFxyXG4gICAqIGluIHRoZSBjb25maWd1cmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Pyp9ICAgIGNvbmYgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGluc3RhbmNlLiBUaGVyZSBhcmUgYSBsb3Qgb2ZcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbnQgcmVjb2duaXplZCBmb3JtcyB0byBpbnN0YW50aWF0ZSBzaWdtYSwgY2hlY2tcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBleGFtcGxlIGZpbGVzLCBkb2N1bWVudGF0aW9uIGluIHRoaXMgZmlsZSBhbmQgdW5pdFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIHRlc3RzIHRvIGtub3cgbW9yZS5cclxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICBUaGUgZnJlc2ggbmV3IHNpZ21hIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogSW5zdGFuY2lhdGluZyBzaWdtYTpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqIElmIG5vIHBhcmFtZXRlciBpcyBnaXZlbiB0byB0aGUgY29uc3RydWN0b3IsIHRoZSBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgKiB3aXRob3V0IGFueSByZW5kZXJlciBvciBjYW1lcmEuIEl0IHdpbGwganVzdCBpbnN0YW50aWF0ZSB0aGUgZ3JhcGgsIGFuZFxyXG4gICAqIG90aGVyIG1vZHVsZXMgd2lsbCBoYXZlIHRvIGJlIGluc3RhbnRpYXRlZCB0aHJvdWdoIHRoZSBwdWJsaWMgbWV0aG9kcyxcclxuICAgKiBsaWtlIFwiYWRkUmVuZGVyZXJcIiBldGM6XHJcbiAgICpcclxuICAgKiAgPiBzMCA9IG5ldyBzaWdtYSgpO1xyXG4gICAqICA+IHMwLmFkZFJlbmRlcmVyKHtcclxuICAgKiAgPiAgIHR5cGU6ICdjYW52YXMnLFxyXG4gICAqICA+ICAgY29udGFpbmVyOiAnbXktY29udGFpbmVyLWlkJ1xyXG4gICAqICA+IH0pO1xyXG4gICAqXHJcbiAgICogSW4gbW9zdCBvZiB0aGUgY2FzZXMsIHNpZ21hIHdpbGwgc2ltcGx5IGJlIHVzZWQgd2l0aCB0aGUgZGVmYXVsdCByZW5kZXJlci5cclxuICAgKiBUaGVuLCBzaW5jZSB0aGUgb25seSByZXF1aXJlZCBwYXJhbWV0ZXIgaXMgdGhlIERPTSBjb250YWluZXIsIHRoZXJlIGFyZVxyXG4gICAqIHNvbWUgc2ltcGxlciB3YXkgdG8gY2FsbCB0aGUgY29uc3RydWN0b3IuIFRoZSBmb3VyIGZvbGxvd2luZyBjYWxscyBkbyB0aGVcclxuICAgKiBleGFjdCBzYW1lIHRoaW5nczpcclxuICAgKlxyXG4gICAqICA+IHMxID0gbmV3IHNpZ21hKCdteS1jb250YWluZXItaWQnKTtcclxuICAgKiAgPiBzMiA9IG5ldyBzaWdtYShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJykpO1xyXG4gICAqICA+IHMzID0gbmV3IHNpZ21hKHtcclxuICAgKiAgPiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXHJcbiAgICogID4gfSk7XHJcbiAgICogID4gczQgPSBuZXcgc2lnbWEoe1xyXG4gICAqICA+ICAgcmVuZGVyZXJzOiBbe1xyXG4gICAqICA+ICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1jb250YWluZXItaWQnKVxyXG4gICAqICA+ICAgfV1cclxuICAgKiAgPiB9KTtcclxuICAgKlxyXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMsIHdoZW4gY2FsbGluZyB0aGVcclxuICAgKiBjb25zdHJ1Y3RvciB3aXRoIHRvIHRvcCBsZXZlbCBjb25maWd1cmF0aW9uIG9iamVjdCAoZm91cnRoIGNhc2UgaW4gdGhlXHJcbiAgICogcHJldmlvdXMgZXhhbXBsZXMpOlxyXG4gICAqXHJcbiAgICogICB7P3N0cmluZ30gaWQgICAgICAgIFRoZSBpZCBvZiB0aGUgaW5zdGFuY2UuIEl0IHdpbGwgYmUgZ2VuZXJhdGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgaWYgbm90IHNwZWNpZmllZC5cclxuICAgKiAgIHs/YXJyYXl9ICByZW5kZXJlcnMgQW4gYXJyYXkgY29udGFpbmluZyBvYmplY3RzIGRlc2NyaWJpbmcgcmVuZGVyZXJzLlxyXG4gICAqICAgez9vYmplY3R9IGdyYXBoICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhbiBhcnJheSBvZiBub2RlcyBhbmQgYW4gYXJyYXlcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2YgZWRnZXMsIHRvIGF2b2lkIGhhdmluZyB0byBhZGQgdGhlbSBieSBoYW5kIGxhdGVyLlxyXG4gICAqICAgez9vYmplY3R9IHNldHRpbmdzICBBbiBvYmplY3QgY29udGFpbmluZyBpbnN0YW5jZSBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb25lcyBkZWZpbmVkIGluIHRoZSBvYmplY3RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEuc2V0dGluZ3MuXHJcbiAgICovXHJcbiAgdmFyIHNpZ21hID0gZnVuY3Rpb24oY29uZikge1xyXG4gICAgLy8gTG9jYWwgdmFyaWFibGVzOlxyXG4gICAgLy8gKioqKioqKioqKioqKioqKlxyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGMsXHJcbiAgICAgICAgbyxcclxuICAgICAgICBpZDtcclxuXHJcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIFByaXZhdGUgYXR0cmlidXRlczpcclxuICAgIC8vICoqKioqKioqKioqKioqKioqKipcclxuICAgIHZhciBfY29uZiA9IGNvbmYgfHwge307XHJcblxyXG4gICAgLy8gTGl0dGxlIHNob3J0Y3V0OlxyXG4gICAgLy8gKioqKioqKioqKioqKioqKlxyXG4gICAgLy8gVGhlIGNvbmZpZ3VyYXRpb24gaXMgc3VwcG9zZWQgdG8gaGF2ZSBhIGxpc3Qgb2YgdGhlIGNvbmZpZ3VyYXRpb25cclxuICAgIC8vIG9iamVjdHMgZm9yIGVhY2ggcmVuZGVyZXIuXHJcbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gY29uZmlndXJhdGlvbiBhdCBhbGwsIHRoZW4gbm90aGluZyBpcyBkb25lLlxyXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3QsIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uIG9iamVjdCB3aWxsIGJlXHJcbiAgICAvLyAgICBjb25zaWRlcmVkIGFzIGRlc2NyaWJpbmcgdGhlIGZpcnN0IGFuZCBvbmx5IHJlbmRlcmVyLlxyXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3Qgbm9yIFwiY29udGFpbmVyXCIgb2JqZWN0LCBpdCB3aWxsIGJlXHJcbiAgICAvLyAgICBjb25zaWRlcmVkIGFzIHRoZSBjb250YWluZXIgaXRzZWxmIChhIERPTSBlbGVtZW50KS5cclxuICAgIC8vICAtIElmIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc2lnbWEoKSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBjb25zaWRlcmVkXHJcbiAgICAvLyAgICBhcyB0aGUgSUQgb2YgdGhlIERPTSBjb250YWluZXIuXHJcbiAgICBpZiAoXHJcbiAgICAgIHR5cGVvZiBfY29uZiA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgX2NvbmYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxyXG4gICAgKVxyXG4gICAgICBfY29uZiA9IHtcclxuICAgICAgICByZW5kZXJlcnM6IFtfY29uZl1cclxuICAgICAgfTtcclxuICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChfY29uZikgPT09ICdbb2JqZWN0IEFycmF5XScpXHJcbiAgICAgIF9jb25mID0ge1xyXG4gICAgICAgIHJlbmRlcmVyczogX2NvbmZcclxuICAgICAgfTtcclxuXHJcbiAgICAvLyBBbHNvIGNoZWNrIFwicmVuZGVyZXJcIiBhbmQgXCJjb250YWluZXJcIiBrZXlzOlxyXG4gICAgbyA9IF9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlciB8fCBfY29uZi5jb250YWluZXI7XHJcbiAgICBpZiAoIV9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlcnMubGVuZ3RoID09PSAwKVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIG8gPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8XHJcbiAgICAgICAgKHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiAnY29udGFpbmVyJyBpbiBvKVxyXG4gICAgICApXHJcbiAgICAgICAgX2NvbmYucmVuZGVyZXJzID0gW29dO1xyXG5cclxuICAgIC8vIFJlY2Vuc2UgdGhlIGluc3RhbmNlOlxyXG4gICAgaWYgKF9jb25mLmlkKSB7XHJcbiAgICAgIGlmIChfX2luc3RhbmNlc1tfY29uZi5pZF0pXHJcbiAgICAgICAgdGhyb3cgJ3NpZ21hOiBJbnN0YW5jZSBcIicgKyBfY29uZi5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xyXG4gICAgICAgIHZhbHVlOiBfY29uZi5pZFxyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlkID0gMDtcclxuICAgICAgd2hpbGUgKF9faW5zdGFuY2VzW2lkXSlcclxuICAgICAgICBpZCsrO1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xyXG4gICAgICAgIHZhbHVlOiAnJyArIGlkXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX19pbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgc2V0dGluZ3MgZnVuY3Rpb246XHJcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IHNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlKFxyXG4gICAgICBzaWdtYS5zZXR0aW5ncyxcclxuICAgICAgX2NvbmYuc2V0dGluZ3MgfHwge31cclxuICAgICk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBsb2NrZWQgYXR0cmlidXRlczpcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ3JhcGgnLCB7XHJcbiAgICAgIHZhbHVlOiBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCh0aGlzLnNldHRpbmdzKSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWlkZGxld2FyZXMnLCB7XHJcbiAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY2FtZXJhcycsIHtcclxuICAgICAgdmFsdWU6IHt9LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZW5kZXJlcnMnLCB7XHJcbiAgICAgIHZhbHVlOiB7fSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzUGVyQ2FtZXJhJywge1xyXG4gICAgICB2YWx1ZToge30sXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYUZyYW1lcycsIHtcclxuICAgICAgdmFsdWU6IHt9LFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmEnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhc1swXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2V2ZW50cycsIHtcclxuICAgICAgdmFsdWU6IFtcclxuICAgICAgICAnY2xpY2snLFxyXG4gICAgICAgICdyaWdodENsaWNrJyxcclxuICAgICAgICAnY2xpY2tTdGFnZScsXHJcbiAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxyXG4gICAgICAgICdyaWdodENsaWNrU3RhZ2UnLFxyXG4gICAgICAgICdjbGlja05vZGUnLFxyXG4gICAgICAgICdjbGlja05vZGVzJyxcclxuICAgICAgICAnZG91YmxlQ2xpY2tOb2RlJyxcclxuICAgICAgICAnZG91YmxlQ2xpY2tOb2RlcycsXHJcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcclxuICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcclxuICAgICAgICAnaG92ZXJzJyxcclxuICAgICAgICAnZG93bk5vZGUnLFxyXG4gICAgICAgICdkb3duTm9kZXMnLFxyXG4gICAgICAgICd1cE5vZGUnLFxyXG4gICAgICAgICd1cE5vZGVzJ1xyXG4gICAgICBdLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFkZCBhIGN1c3RvbSBoYW5kbGVyLCB0byByZWRpc3BhdGNoIGV2ZW50cyBmcm9tIHJlbmRlcmVyczpcclxuICAgIHRoaXMuX2hhbmRsZXIgPSAoZnVuY3Rpb24oZSkge1xyXG4gICAgICB2YXIgayxcclxuICAgICAgICAgIGRhdGEgPSB7fTtcclxuXHJcbiAgICAgIGZvciAoayBpbiBlLmRhdGEpXHJcbiAgICAgICAgZGF0YVtrXSA9IGUuZGF0YVtrXTtcclxuXHJcbiAgICAgIGRhdGEucmVuZGVyZXIgPSBlLnRhcmdldDtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUudHlwZSwgZGF0YSk7XHJcbiAgICB9KS5iaW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgcmVuZGVyZXJzOlxyXG4gICAgYSA9IF9jb25mLnJlbmRlcmVycyB8fCBbXTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgdGhpcy5hZGRSZW5kZXJlcihhW2ldKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIG1pZGRsZXdhcmVzOlxyXG4gICAgYSA9IF9jb25mLm1pZGRsZXdhcmVzIHx8IFtdO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goXHJcbiAgICAgICAgdHlwZW9mIGFbaV0gPT09ICdzdHJpbmcnID9cclxuICAgICAgICAgIHNpZ21hLm1pZGRsZXdhcmVzW2FbaV1dIDpcclxuICAgICAgICAgIGFbaV1cclxuICAgICAgKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgZ3JhcGggdG8gZmlsbCBpbjpcclxuICAgIGlmICh0eXBlb2YgX2NvbmYuZ3JhcGggPT09ICdvYmplY3QnICYmIF9jb25mLmdyYXBoKSB7XHJcbiAgICAgIHRoaXMuZ3JhcGgucmVhZChfY29uZi5ncmFwaCk7XHJcblxyXG4gICAgICAvLyBJZiBhIGdyYXBoIGlzIGdpdmVuIHRvIHRoZSB0byB0aGUgaW5zdGFuY2UsIHRoZSBcInJlZnJlc2hcIiBtZXRob2QgaXNcclxuICAgICAgLy8gZGlyZWN0bHkgY2FsbGVkOlxyXG4gICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2RzIHdpbGwgaW5zdGFudGlhdGUgYW5kIHJlZmVyZW5jZSBhIG5ldyBjYW1lcmEuIElmIG5vIGlkIGlzXHJcbiAgICogc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICAgICBpZCBFdmVudHVhbGx5IHRoZSBjYW1lcmEgaWQuXHJcbiAgICogQHJldHVybiB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgIFRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnByb3RvdHlwZS5hZGRDYW1lcmEgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGNhbWVyYTtcclxuXHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgaWQgPSAwO1xyXG4gICAgICB3aGlsZSAodGhpcy5jYW1lcmFzWycnICsgaWRdKVxyXG4gICAgICAgIGlkKys7XHJcbiAgICAgIGlkID0gJycgKyBpZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5jYW1lcmFzW2lkXSlcclxuICAgICAgdGhyb3cgJ3NpZ21hLmFkZENhbWVyYTogVGhlIGNhbWVyYSBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xyXG5cclxuICAgIGNhbWVyYSA9IG5ldyBzaWdtYS5jbGFzc2VzLmNhbWVyYShpZCwgdGhpcy5ncmFwaCwgdGhpcy5zZXR0aW5ncyk7XHJcbiAgICB0aGlzLmNhbWVyYXNbaWRdID0gY2FtZXJhO1xyXG5cclxuICAgIC8vIEFkZCBhIHF1YWR0cmVlIHRvIHRoZSBjYW1lcmE6XHJcbiAgICBjYW1lcmEucXVhZHRyZWUgPSBuZXcgc2lnbWEuY2xhc3Nlcy5xdWFkKCk7XHJcblxyXG4gICAgLy8gQWRkIGFuIGVkZ2VxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxyXG4gICAgaWYgKHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjYW1lcmEuZWRnZXF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQoKTtcclxuICAgIH1cclxuXHJcbiAgICBjYW1lcmEuYmluZCgnY29vcmRpbmF0ZXNVcGRhdGVkJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2Nvb3JkaW5hdGVzVXBkYXRlZCcpO1xyXG4gICAgICBzZWxmLnJlbmRlckNhbWVyYShjYW1lcmEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbaWRdID0gW107XHJcblxyXG4gICAgcmV0dXJuIGNhbWVyYTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBhIGNhbWVyYSwgYW5kIGV2ZXJ5IHJlbmRlcmVyIGF0dGFjaGVkIHRvIGl0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfGNhbWVyYX0gdiBUaGUgY2FtZXJhIHRvIGtpbGwgb3IgaXRzIElELlxyXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLmtpbGxDYW1lcmEgPSBmdW5jdGlvbih2KSB7XHJcbiAgICB2ID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdGhpcy5jYW1lcmFzW3ZdIDogdjtcclxuXHJcbiAgICBpZiAoIXYpXHJcbiAgICAgIHRocm93ICdzaWdtYS5raWxsQ2FtZXJhOiBUaGUgY2FtZXJhIGlzIHVuZGVmaW5lZC4nO1xyXG5cclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xyXG5cclxuICAgIGZvciAobCA9IGEubGVuZ3RoLCBpID0gbCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcihhW2ldKTtcclxuXHJcbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5pZF07XHJcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFGcmFtZXNbdi5pZF07XHJcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFzW3YuaWRdO1xyXG5cclxuICAgIGlmICh2LmtpbGwpXHJcbiAgICAgIHYua2lsbCgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kcyB3aWxsIGluc3RhbnRpYXRlIGFuZCByZWZlcmVuY2UgYSBuZXcgcmVuZGVyZXIuIFRoZSBcInR5cGVcIlxyXG4gICAqIGFyZ3VtZW50IGNhbiBiZSB0aGUgY29uc3RydWN0b3Igb3IgaXRzIG5hbWUgaW4gdGhlIFwic2lnbWEucmVuZGVyZXJzXCJcclxuICAgKiBwYWNrYWdlLiBJZiBubyB0eXBlIGlzIHNwZWNpZmllZCwgdGhlbiBcInNpZ21hLnJlbmRlcmVycy5kZWZcIiB3aWxsIGJlIHVzZWQuXHJcbiAgICogSWYgbm8gaWQgaXMgc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlbmRlcmVyXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IuXHJcbiAgICogQHJldHVybiB7cmVuZGVyZXJ9ICAgICAgICAgVGhlIGZyZXNoIG5ldyByZW5kZXJlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXHJcbiAgICogb2JqZWN0OlxyXG4gICAqXHJcbiAgICogICB7P3N0cmluZ30gICAgICAgICAgICBpZCAgICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgaWQuXHJcbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSB0eXBlICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgY29uc3RydWN0b3Igb3IgaXRzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIiBwYWNrYWdlLlxyXG4gICAqICAgez8oY2FtZXJhfHN0cmluZyl9ICAgY2FtZXJhIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNhbWVyYSBvciBpdHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZC5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUuYWRkUmVuZGVyZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB2YXIgaWQsXHJcbiAgICAgICAgZm4sXHJcbiAgICAgICAgY2FtZXJhLFxyXG4gICAgICAgIHJlbmRlcmVyLFxyXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8vIFBvbHltb3JwaGlzbTpcclxuICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpXHJcbiAgICAgIG8gPSB7XHJcbiAgICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvKVxyXG4gICAgICB9O1xyXG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxyXG4gICAgICBvID0ge1xyXG4gICAgICAgIGNvbnRhaW5lcjogb1xyXG4gICAgICB9O1xyXG5cclxuICAgIC8vIElmIHRoZSBjb250YWluZXIgc3RpbGwgaXMgYSBzdHJpbmcsIHdlIGdldCBpdCBieSBpZFxyXG4gICAgaWYgKHR5cGVvZiBvLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpXHJcbiAgICAgIG8uY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoby5jb250YWluZXIpO1xyXG5cclxuICAgIC8vIFJlZmVyZW5jZSB0aGUgbmV3IHJlbmRlcmVyOlxyXG4gICAgaWYgKCEoJ2lkJyBpbiBvKSkge1xyXG4gICAgICBpZCA9IDA7XHJcbiAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVyc1snJyArIGlkXSlcclxuICAgICAgICBpZCsrO1xyXG4gICAgICBpZCA9ICcnICsgaWQ7XHJcbiAgICB9IGVsc2VcclxuICAgICAgaWQgPSBvLmlkO1xyXG5cclxuICAgIGlmICh0aGlzLnJlbmRlcmVyc1tpZF0pXHJcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIHJlbmRlcmVyIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcblxyXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjb25zdHJ1Y3RvcjpcclxuICAgIGZuID0gdHlwZW9mIG8udHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IG8udHlwZSA6IHNpZ21hLnJlbmRlcmVyc1tvLnR5cGVdO1xyXG4gICAgZm4gPSBmbiB8fCBzaWdtYS5yZW5kZXJlcnMuZGVmO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGdvb2QgY2FtZXJhOlxyXG4gICAgY2FtZXJhID0gJ2NhbWVyYScgaW4gbyA/XHJcbiAgICAgIChcclxuICAgICAgICBvLmNhbWVyYSBpbnN0YW5jZW9mIHNpZ21hLmNsYXNzZXMuY2FtZXJhID9cclxuICAgICAgICAgIG8uY2FtZXJhIDpcclxuICAgICAgICAgIHRoaXMuY2FtZXJhc1tvLmNhbWVyYV0gfHwgdGhpcy5hZGRDYW1lcmEoby5jYW1lcmEpXHJcbiAgICAgICkgOlxyXG4gICAgICB0aGlzLmFkZENhbWVyYSgpO1xyXG5cclxuICAgIGlmICh0aGlzLmNhbWVyYXNbY2FtZXJhLmlkXSAhPT0gY2FtZXJhKVxyXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkUmVuZGVyZXI6IFRoZSBjYW1lcmEgaXMgbm90IHByb3Blcmx5IHJlZmVyZW5jZWQuJztcclxuXHJcbiAgICAvLyBJbnN0YW50aWF0ZTpcclxuICAgIHJlbmRlcmVyID0gbmV3IGZuKHRoaXMuZ3JhcGgsIGNhbWVyYSwgdGhpcy5zZXR0aW5ncywgbyk7XHJcbiAgICB0aGlzLnJlbmRlcmVyc1tpZF0gPSByZW5kZXJlcjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXJlciwgJ2lkJywge1xyXG4gICAgICB2YWx1ZTogaWRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEJpbmQgZXZlbnRzOlxyXG4gICAgaWYgKHJlbmRlcmVyLmJpbmQpXHJcbiAgICAgIHJlbmRlcmVyLmJpbmQoXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ2NsaWNrJyxcclxuICAgICAgICAgICdyaWdodENsaWNrJyxcclxuICAgICAgICAgICdjbGlja1N0YWdlJyxcclxuICAgICAgICAgICdkb3VibGVDbGlja1N0YWdlJyxcclxuICAgICAgICAgICdyaWdodENsaWNrU3RhZ2UnLFxyXG4gICAgICAgICAgJ2NsaWNrTm9kZScsXHJcbiAgICAgICAgICAnY2xpY2tOb2RlcycsXHJcbiAgICAgICAgICAnY2xpY2tFZGdlJyxcclxuICAgICAgICAgICdjbGlja0VkZ2VzJyxcclxuICAgICAgICAgICdkb3VibGVDbGlja05vZGUnLFxyXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZXMnLFxyXG4gICAgICAgICAgJ2RvdWJsZUNsaWNrRWRnZScsXHJcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlcycsXHJcbiAgICAgICAgICAncmlnaHRDbGlja05vZGUnLFxyXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlcycsXHJcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2UnLFxyXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tFZGdlcycsXHJcbiAgICAgICAgICAnaG92ZXJzJyxcclxuICAgICAgICAgICdkb3duTm9kZScsXHJcbiAgICAgICAgICAnZG93bk5vZGVzJyxcclxuICAgICAgICAgICdkb3duRWRnZScsXHJcbiAgICAgICAgICAnZG93bkVkZ2VzJyxcclxuICAgICAgICAgICd1cE5vZGUnLFxyXG4gICAgICAgICAgJ3VwTm9kZXMnLFxyXG4gICAgICAgICAgJ3VwRWRnZScsXHJcbiAgICAgICAgICAndXBFZGdlcydcclxuICAgICAgICBdLFxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJcclxuICAgICAgKTtcclxuXHJcbiAgICAvLyBSZWZlcmVuY2UgdGhlIHJlbmRlcmVyIGJ5IGl0cyBjYW1lcmE6XHJcbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdLnB1c2gocmVuZGVyZXIpO1xyXG5cclxuICAgIHJldHVybiByZW5kZXJlcjtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBhIHJlbmRlcmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfHJlbmRlcmVyfSB2IFRoZSByZW5kZXJlciB0byBraWxsIG9yIGl0cyBJRC5cclxuICAgKiBAcmV0dXJuIHtzaWdtYX0gICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLmtpbGxSZW5kZXJlciA9IGZ1bmN0aW9uKHYpIHtcclxuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLnJlbmRlcmVyc1t2XSA6IHY7XHJcblxyXG4gICAgaWYgKCF2KVxyXG4gICAgICB0aHJvdyAnc2lnbWEua2lsbFJlbmRlcmVyOiBUaGUgcmVuZGVyZXIgaXMgdW5kZWZpbmVkLic7XHJcblxyXG4gICAgdmFyIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmNhbWVyYS5pZF0sXHJcbiAgICAgICAgaSA9IGEuaW5kZXhPZih2KTtcclxuXHJcbiAgICBpZiAoaSA+PSAwKVxyXG4gICAgICBhLnNwbGljZShpLCAxKTtcclxuXHJcbiAgICBpZiAodi5raWxsKVxyXG4gICAgICB2LmtpbGwoKTtcclxuXHJcbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnNbdi5pZF07XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIsIHdpdGggdGhlIHNhbWVcclxuICAgKiBhcmd1bWVudHMgdGhhbiB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJ1dCB3aWxsIGFsc28gY2hlY2sgaWYgdGhlIHJlbmRlcmVyXHJcbiAgICogaGFzIGEgXCJwcm9jZXNzXCIgbWV0aG9kLCBhbmQgY2FsbCBpdCBpZiBpdCBleGlzdHMuXHJcbiAgICpcclxuICAgKiBJdCBpcyB1c2VmdWwgZm9yIHF1YWR0cmVlcyBvciBXZWJHTCBwcm9jZXNzaW5nLCBmb3IgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgb3B0aW9ucyBFdmVudHVhbGx5IHNvbWUgb3B0aW9ucyB0byBnaXZlIHRvIHRoZSByZWZyZXNoXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKlxyXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXHJcbiAgICogb2JqZWN0OlxyXG4gICAqXHJcbiAgICogICB7P2Jvb2xlYW59IHNraXBJbmRleGF0aW9uIEEgZmxhZyBzcGVjaWZ5aW5nIHdldGhlciBvciBub3QgdGhlIHJlZnJlc2hcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkIHJlaW5kZXggdGhlIGdyYXBoIGluIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkdHJlZXMgb3Igbm90IChkZWZhdWx0OiBmYWxzZSkuXHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGssXHJcbiAgICAgICAgYSxcclxuICAgICAgICBjLFxyXG4gICAgICAgIGJvdW5kcyxcclxuICAgICAgICBwcmVmaXggPSAwO1xyXG5cclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8vIENhbGwgZWFjaCBtaWRkbGV3YXJlOlxyXG4gICAgYSA9IHRoaXMubWlkZGxld2FyZXMgfHwgW107XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGFbaV0uY2FsbChcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIChpID09PSAwKSA/ICcnIDogJ3RtcCcgKyBwcmVmaXggKyAnOicsXHJcbiAgICAgICAgKGkgPT09IGwgLSAxKSA/ICdyZWFkeTonIDogKCd0bXAnICsgKCsrcHJlZml4KSArICc6JylcclxuICAgICAgKTtcclxuXHJcbiAgICAvLyBUaGVuLCBmb3IgZWFjaCBjYW1lcmEsIGNhbGwgdGhlIFwicmVzY2FsZVwiIG1pZGRsZXdhcmUsIHVubGVzcyB0aGVcclxuICAgIC8vIHNldHRpbmdzIHNwZWNpZnkgbm90IHRvOlxyXG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcykge1xyXG4gICAgICBjID0gdGhpcy5jYW1lcmFzW2tdO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgYy5zZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSAmJlxyXG4gICAgICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdICYmXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF0ubGVuZ3RoXHJcbiAgICAgIClcclxuICAgICAgICBzaWdtYS5taWRkbGV3YXJlcy5yZXNjYWxlLmNhbGwoXHJcbiAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxyXG4gICAgICAgICAgYy5yZWFkUHJlZml4LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0ud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0uaGVpZ2h0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNpZ21hLm1pZGRsZXdhcmVzLmNvcHkuY2FsbChcclxuICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICBhLmxlbmd0aCA/ICdyZWFkeTonIDogJycsXHJcbiAgICAgICAgICBjLnJlYWRQcmVmaXhcclxuICAgICAgICApO1xyXG5cclxuICAgICAgaWYgKCFvcHRpb25zLnNraXBJbmRleGF0aW9uKSB7XHJcbiAgICAgICAgLy8gRmluZCBncmFwaCBib3VuZGFyaWVzOlxyXG4gICAgICAgIGJvdW5kcyA9IHNpZ21hLnV0aWxzLmdldEJvdW5kYXJpZXMoXHJcbiAgICAgICAgICB0aGlzLmdyYXBoLFxyXG4gICAgICAgICAgYy5yZWFkUHJlZml4XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gUmVmcmVzaCBxdWFkdHJlZTpcclxuICAgICAgICBjLnF1YWR0cmVlLmluZGV4KHRoaXMuZ3JhcGgsIHtcclxuICAgICAgICAgIHByZWZpeDogYy5yZWFkUHJlZml4LFxyXG4gICAgICAgICAgbWF4TGV2ZWw6IGMuc2V0dGluZ3MoJ25vZGVRdWFkdHJlZU1heExldmVsJyksXHJcbiAgICAgICAgICBib3VuZHM6IHtcclxuICAgICAgICAgICAgeDogYm91bmRzLm1pblgsXHJcbiAgICAgICAgICAgIHk6IGJvdW5kcy5taW5ZLFxyXG4gICAgICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZHMubWF4WSAtIGJvdW5kcy5taW5ZXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFJlZnJlc2ggZWRnZXF1YWR0cmVlOlxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGMuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgIGMuc2V0dGluZ3MoJ2RyYXdFZGdlcycpICYmXHJcbiAgICAgICAgICAoYy5zZXR0aW5ncygnZW5hYmxlRWRnZUhvdmVyaW5nJykgfHxcclxuICAgICAgICAgICAgYy5zZXR0aW5ncygnZWRnZXNDbGlwcGluZ1dpdGhOb2RlcycpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUuaW5kZXgodGhpcy5ncmFwaCwge1xyXG4gICAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcclxuICAgICAgICAgICAgbWF4TGV2ZWw6IGMuc2V0dGluZ3MoJ2VkZ2VRdWFkdHJlZU1heExldmVsJyksXHJcbiAgICAgICAgICAgIGJvdW5kczoge1xyXG4gICAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICAgIHk6IGJvdW5kcy5taW5ZLFxyXG4gICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XHJcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBpZiAodGhpcy5yZW5kZXJlcnNbYVtpXV0ucHJvY2Vzcykge1xyXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXSArICdcIiBjcmFzaGVkIG9uIFwiLnByb2Nlc3MoKVwiJ1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcclxuICAgICAgfVxyXG5cclxuICAgIHRoaXMucmVuZGVyKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzaWdtYX0gUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBsLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgcHJlZml4ID0gMDtcclxuXHJcbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XHJcbiAgICBmb3IgKGkgaW4gdGhpcy5yZW5kZXJlcnMpXHJcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2ldLnJlbmRlcigpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgdGhpcy5yZW5kZXJlcnNbaV0gK1xyXG4gICAgICAgICAgICAgICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcnNbaV0ucmVuZGVyKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIgdGhhdCBpcyBib3VuZCB0b1xyXG4gICAqIHRoZSBzcGVjaWZpZWQgY2FtZXJhLiBUbyBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZXMsIGlmIHRoaXMgbWV0aG9kIGlzXHJcbiAgICogY2FsbGVkIHRvbyBvZnRlbiwgdGhlIG51bWJlciBvZiBlZmZlY3RpdmUgcmVuZGVyaW5ncyBpcyBsaW1pdGF0ZWQgdG8gb25lXHJcbiAgICogcGVyIGZyYW1lLCB1bmxlc3MgeW91IGFyZSB1c2luZyB0aGUgXCJmb3JjZVwiIGZsYWcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gY2FtZXJhIFRoZSBjYW1lcmEgdG8gcmVuZGVyLlxyXG4gICAqIEBwYXJhbSAgez9ib29sZWFufSAgICAgICAgICAgICBmb3JjZSAgSWYgdHJ1ZSwgd2lsbCByZW5kZXIgdGhlIGNhbWVyYVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0bHkuXHJcbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlckNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgZm9yY2UpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYSxcclxuICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF07XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInKyBhW2ldLmlkICsgJ1wiIGNyYXNoZWQgb24gXCIucmVuZGVyKClcIidcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIXRoaXMuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF0pIHtcclxuICAgICAgICBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbY2FtZXJhLmlkXTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygndmVyYm9zZScpKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXHJcbiAgICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInK2FbaV0uaWQgKydcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2FtZXJhRnJhbWVzW2NhbWVyYS5pZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBkZWxldGUgc2VsZi5jYW1lcmFGcmFtZXNbY2FtZXJhLmlkXTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcImtpbGxcIiBtZXRob2Qgb2YgZWFjaCBtb2R1bGUgYW5kIGRlc3Ryb3lzIGFueVxyXG4gICAqIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGs7XHJcblxyXG4gICAgLy8gRGlzcGF0Y2hpbmcgZXZlbnRcclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgna2lsbCcpO1xyXG5cclxuICAgIC8vIEtpbGwgZ3JhcGg6XHJcbiAgICB0aGlzLmdyYXBoLmtpbGwoKTtcclxuXHJcbiAgICAvLyBLaWxsIG1pZGRsZXdhcmVzOlxyXG4gICAgZGVsZXRlIHRoaXMubWlkZGxld2FyZXM7XHJcblxyXG4gICAgLy8gS2lsbCBlYWNoIHJlbmRlcmVyOlxyXG4gICAgZm9yIChrIGluIHRoaXMucmVuZGVyZXJzKVxyXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcih0aGlzLnJlbmRlcmVyc1trXSk7XHJcblxyXG4gICAgLy8gS2lsbCBlYWNoIGNhbWVyYTpcclxuICAgIGZvciAoayBpbiB0aGlzLmNhbWVyYXMpXHJcbiAgICAgIHRoaXMua2lsbENhbWVyYSh0aGlzLmNhbWVyYXNba10pO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVycztcclxuICAgIGRlbGV0ZSB0aGlzLmNhbWVyYXM7XHJcblxyXG4gICAgLy8gS2lsbCBldmVyeXRoaW5nIGVsc2U6XHJcbiAgICBmb3IgKGsgaW4gdGhpcylcclxuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaykpXHJcbiAgICAgICAgZGVsZXRlIHRoaXNba107XHJcblxyXG4gICAgZGVsZXRlIF9faW5zdGFuY2VzW3RoaXMuaWRdO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgaW5zdGFuY2VzIG9iamVjdCBvciBhIHNwZWNpZmljIHJ1bm5pbmcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSBpZCBFdmVudHVhbGx5IGFuIGluc3RhbmNlIElELlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFRoZSByZWxhdGVkIGluc3RhbmNlIG9yIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5cclxuICAgKi9cclxuICBzaWdtYS5pbnN0YW5jZXMgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xyXG4gICAgICBfX2luc3RhbmNlc1tpZF0gOlxyXG4gICAgICBzaWdtYS51dGlscy5leHRlbmQoe30sIF9faW5zdGFuY2VzKTtcclxuICB9O1xyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBjdXJyZW50IHZlcnNpb24gb2Ygc2lnbWE6XHJcbiAgICovXHJcbiAgc2lnbWEudmVyc2lvbiA9ICcxLjUuMic7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBEaXNhYmxlIEVTNiBmZWF0dXJlcyBpZiB0cnVlOlxyXG4gICAqL1xyXG4gIHNpZ21hLmZvcmNlRVM1ID0gZmFsc2U7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBFWFBPUlQ6XHJcbiAgICogKioqKioqKlxyXG4gICAqL1xyXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnQW4gb2JqZWN0IGNhbGxlZCBzaWdtYSBpcyBhbHJlYWR5IGluIHRoZSBnbG9iYWwgc2NvcGUuJztcclxuXHJcbiAgdGhpcy5zaWdtYSA9IHNpZ21hO1xyXG5cclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbi8qKlxyXG4gKiBjb25yYWQuanMgaXMgYSB0aW55IEphdmFTY3JpcHQgam9icyBzY2hlZHVsZXIsXHJcbiAqXHJcbiAqIFZlcnNpb246IDAuMS4wXHJcbiAqIFNvdXJjZXM6IGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qc1xyXG4gKiBEb2M6ICAgICBodHRwOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9jb25yYWQuanMjcmVhZG1lXHJcbiAqXHJcbiAqIExpY2Vuc2U6XHJcbiAqIC0tLS0tLS0tXHJcbiAqIENvcHlyaWdodCDCqSAyMDEzIEFsZXhpcyBKYWNvbXksIFNjaWVuY2VzLVBvIG3DqWRpYWxhYlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXHJcbiAqIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXHJcbiAqIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxyXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVGhlIFNvZnR3YXJlIGlzIHByb3ZpZGVkIFwiYXMgaXNcIiwgd2l0aG91dCB3YXJyYW50eSBvZiBhbnkga2luZCwgZXhwcmVzcyBvclxyXG4gKiBpbXBsaWVkLCBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIHRoZSB3YXJyYW50aWVzIG9mIG1lcmNoYW50YWJpbGl0eSxcclxuICogZml0bmVzcyBmb3IgYSBwYXJ0aWN1bGFyIHB1cnBvc2UgYW5kIG5vbmluZnJpbmdlbWVudC4gSW4gbm8gZXZlbnQgc2hhbGwgdGhlXHJcbiAqIGF1dGhvcnMgb3IgY29weXJpZ2h0IGhvbGRlcnMgYmUgbGlhYmxlIGZvciBhbnkgY2xhaW0sIGRhbWFnZXMgb3Igb3RoZXJcclxuICogbGlhYmlsaXR5LCB3aGV0aGVyIGluIGFuIGFjdGlvbiBvZiBjb250cmFjdCwgdG9ydCBvciBvdGhlcndpc2UsIGFyaXNpbmdcclxuICogZnJvbSwgb3V0IG9mIG9yIGluIGNvbm5lY3Rpb24gd2l0aCB0aGUgc29mdHdhcmUgb3IgdGhlIHVzZSBvciBvdGhlciBkZWFsaW5nc1xyXG4gKiBpbiB0aGUgU29mdHdhcmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvLyBDaGVjayB0aGF0IGNvbnJhZC5qcyBoYXMgbm90IGJlZW4gbG9hZGVkIHlldDpcclxuICBpZiAoZ2xvYmFsLmNvbnJhZClcclxuICAgIHRocm93IG5ldyBFcnJvcignY29ucmFkIGFscmVhZHkgZXhpc3RzJyk7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBQUklWQVRFIFZBUklBQkxFUzpcclxuICAgKiAqKioqKioqKioqKioqKioqKipcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBjb25yYWQgaXMgcnVubmluZyBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIHZhciBfbGFzdEZyYW1lVGltZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBjb25yYWQgaXMgcnVubmluZyBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKi9cclxuICB2YXIgX2lzUnVubmluZyA9IGZhbHNlO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgaGFzaCBvZiByZWdpc3RlcmVkIGpvYnMuIEVhY2ggam9iIG11c3QgYXQgbGVhc3QgaGF2ZSBhIHVuaXF1ZSBJRFxyXG4gICAqIHVuZGVyIHRoZSBrZXkgXCJpZFwiIGFuZCBhIGZ1bmN0aW9uIHVuZGVyIHRoZSBrZXkgXCJqb2JcIi4gVGhpcyBoYXNoXHJcbiAgICogY29udGFpbnMgZWFjaCBydW5uaW5nIGpvYiBhbmQgZWFjaCB3YWl0aW5nIGpvYi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdmFyIF9qb2JzID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBoYXNoIG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIHZhciBfcnVubmluZ0pvYnMgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMsIHNvcnRlZCBieSBwcmlvcml0eS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtBcnJheX1cclxuICAgKi9cclxuICB2YXIgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzID0gW107XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgd2FpdGluZyBqb2JzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICB2YXIgX3dhaXRpbmdKb2JzID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBhcnJheSBvZiBmaW5pc2hlZCBqb2JzLiBUaGV5IGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksIHNpbmNlIHR3byBqb2JzXHJcbiAgICogd2l0aCB0aGUgc2FtZSBcImlkXCIgY2FuIGhhcHBlbiBhdCB0d28gZGlmZmVyZW50IHRpbWVzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xyXG4gIHZhciBfZG9uZUpvYnMgPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBkaXJ0eSBmbGFnIHRvIGtlZXAgY29ucmFkIGZyb20gc3RhcnRpbmc6IEluZGVlZCwgd2hlbiBhZGRKb2IoKSBpcyBjYWxsZWRcclxuICAgKiB3aXRoIHNldmVyYWwgam9icywgY29ucmFkIG11c3QgYmUgc3RhcnRlZCBvbmx5IGF0IHRoZSBlbmQuIFRoaXMgZmxhZyBrZWVwc1xyXG4gICAqIG1lIGZyb20gZHVwbGljYXRpbmcgdGhlIGNvZGUgdGhhdCBlZmZlY3RpdmVseSBhZGRzIGEgam9iLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgdmFyIF9ub1N0YXJ0ID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGhhc2ggY29udGFpbmluZyBzb21lIGdsb2JhbCBzZXR0aW5ncyBhYm91dCBob3cgY29ucmFkLmpzIHNob3VsZFxyXG4gICAqIGJlaGF2ZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdmFyIF9wYXJhbWV0ZXJzID0ge1xyXG4gICAgZnJhbWVEdXJhdGlvbjogMjAsXHJcbiAgICBoaXN0b3J5OiB0cnVlXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBvYmplY3QgY29udGFpbnMgZXZlcnkgaGFuZGxlcnMgYm91bmQgdG8gY29ucmFkIGV2ZW50cy4gSXQgZG9lcyBub3RcclxuICAgKiByZXF1aXJlYSBhbnkgRE9NIGltcGxlbWVudGF0aW9uLCBzaW5jZSB0aGUgZXZlbnRzIGFyZSBhbGwgSmF2YVNjcmlwdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdmFyIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG5cclxuICAvKipcclxuICAgKiBQUklWQVRFIEZVTkNUSU9OUzpcclxuICAgKiAqKioqKioqKioqKioqKioqKipcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxyXG4gICAqIGluZGljYXRlZCBldmVudHMpIHdpbGwgYmUgdHJpZ2dlcmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fG9iamVjdH0gZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcGFyYXRlZCBieSBzcGFjZXMpLlxyXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKE9iamVjdCl9ICAgIGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gYmluZC5cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9iaW5kKGV2ZW50cywgaGFuZGxlcikge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgaV9lbmQsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZUFycmF5O1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgcmV0dXJuO1xyXG4gICAgZWxzZSBpZiAoXHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgT2JqZWN0KGFyZ3VtZW50c1swXSkgPT09IGFyZ3VtZW50c1swXVxyXG4gICAgKVxyXG4gICAgICBmb3IgKGV2ZW50cyBpbiBhcmd1bWVudHNbMF0pXHJcbiAgICAgICAgX2JpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XHJcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICBlQXJyYXkgPVxyXG4gICAgICAgIEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XHJcbiAgICAgICAgICBldmVudHMgOlxyXG4gICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpIHtcclxuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcclxuXHJcbiAgICAgICAgaWYgKCFfaGFuZGxlcnNbZXZlbnRdKVxyXG4gICAgICAgICAgX2hhbmRsZXJzW2V2ZW50XSA9IFtdO1xyXG5cclxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcclxuICAgICAgICAvLyBsYXRlciB0byBhZGQgZmxhZ3NcclxuICAgICAgICBfaGFuZGxlcnNbZXZlbnRdLnB1c2goe1xyXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIHRoZSBoYW5kbGVyIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQgKG9yIHNwZWNpZmllZCBldmVudHMpLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuIElmIHVuZGVmaW5lZCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cclxuICAgKiBAcGFyYW0gIHs/ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byB1bmJpbmQuIElmIHVuZGVmaW5lZCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGhhbmRsZXIgYm91bmQgdG8gdGhlIGV2ZW50IG9yIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF91bmJpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBpX2VuZCxcclxuICAgICAgICBqLFxyXG4gICAgICAgIGpfZW5kLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZUFycmF5ID0gQXJyYXkuaXNBcnJheShldmVudHMpID9cclxuICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6XHJcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcclxuXHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBlbHNlIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSkge1xyXG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xyXG4gICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdKSB7XHJcbiAgICAgICAgICBhID0gW107XHJcbiAgICAgICAgICBmb3IgKGogPSAwLCBqX2VuZCA9IF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxyXG4gICAgICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxyXG4gICAgICAgICAgICAgIGEucHVzaChfaGFuZGxlcnNbZXZlbnRdW2pdKTtcclxuXHJcbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnRdICYmIF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tldmVudF07XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZVxyXG4gICAgICBmb3IgKGkgPSAwLCBpX2VuZCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGlfZW5kOyBpICs9IDEpXHJcbiAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tlQXJyYXlbaV1dO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHMgc2VwYXJhdGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXHJcbiAgICogQHBhcmFtICB7P09iamVjdH0gZGF0YSAgIFRoZSBjb250ZW50IG9mIHRoZSBldmVudCAob3B0aW9uYWwpLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGNvbnJhZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfZGlzcGF0Y2goZXZlbnRzLCBkYXRhKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBqLFxyXG4gICAgICAgIGlfZW5kLFxyXG4gICAgICAgIGpfZW5kLFxyXG4gICAgICAgIGV2ZW50LFxyXG4gICAgICAgIGV2ZW50TmFtZSxcclxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xyXG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcclxuICAgICAgICAgICAgICAgICAgIGV2ZW50cy5zcGxpdCgvIC8pO1xyXG5cclxuICAgIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGE7XHJcblxyXG4gICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XHJcbiAgICAgIGV2ZW50TmFtZSA9IGVBcnJheVtpXTtcclxuXHJcbiAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICAgIGV2ZW50ID0ge1xyXG4gICAgICAgICAgdHlwZTogZXZlbnROYW1lLFxyXG4gICAgICAgICAgZGF0YTogZGF0YSB8fCB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0uaGFuZGxlcihldmVudCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlcyB0aGUgbW9zdCBwcmlvcml0YXJ5IGpvYiBvbmNlLCBhbmQgZGVhbHMgd2l0aCBmaWxsaW5nIHRoZSBzdGF0c1xyXG4gICAqIChkb25lLCB0aW1lLCBhdmVyYWdlVGltZSwgY3VycmVudFRpbWUsIGV0Yy4uLikuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGhhcyB0byBiZSBraWxsZWQsIG51bGwgZWxzZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfZXhlY3V0ZUZpcnN0Sm9iKCkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICB0ZXN0LFxyXG4gICAgICAgIGtpbGwsXHJcbiAgICAgICAgcHVzaGVkID0gZmFsc2UsXHJcbiAgICAgICAgdGltZSA9IF9fZGF0ZU5vdygpLFxyXG4gICAgICAgIGpvYiA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zaGlmdCgpO1xyXG5cclxuICAgIC8vIEV4ZWN1dGUgdGhlIGpvYiBhbmQgbG9vayBhdCB0aGUgcmVzdWx0OlxyXG4gICAgdGVzdCA9IGpvYi5qb2IoKTtcclxuXHJcbiAgICAvLyBEZWFsIHdpdGggc3RhdHM6XHJcbiAgICB0aW1lID0gX19kYXRlTm93KCkgLSB0aW1lO1xyXG4gICAgam9iLmRvbmUrKztcclxuICAgIGpvYi50aW1lICs9IHRpbWU7XHJcbiAgICBqb2IuY3VycmVudFRpbWUgKz0gdGltZTtcclxuICAgIGpvYi53ZWlnaHRUaW1lID0gam9iLmN1cnJlbnRUaW1lIC8gKGpvYi53ZWlnaHQgfHwgMSk7XHJcbiAgICBqb2IuYXZlcmFnZVRpbWUgPSBqb2IudGltZSAvIGpvYi5kb25lO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIHRoZSBqb2IgaGFzIHRvIGJlIGtpbGxlZDpcclxuICAgIGtpbGwgPSBqb2IuY291bnQgPyAoam9iLmNvdW50IDw9IGpvYi5kb25lKSA6ICF0ZXN0O1xyXG5cclxuICAgIC8vIFJlc2V0IHByaW9yaXRpZXM6XHJcbiAgICBpZiAoIWtpbGwpIHtcclxuICAgICAgZm9yIChpID0gMCwgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKF9zb3J0ZWRCeVByaW9yaXR5Sm9ic1tpXS53ZWlnaHRUaW1lID4gam9iLndlaWdodFRpbWUpIHtcclxuICAgICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zcGxpY2UoaSwgMCwgam9iKTtcclxuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICBpZiAoIXB1c2hlZClcclxuICAgICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMucHVzaChqb2IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBraWxsID8gam9iIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjdGl2YXRlcyBhIGpvYiwgYnkgYWRkaW5nIGl0IHRvIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0IGFuZCB0aGVcclxuICAgKiBfc29ydGVkQnlQcmlvcml0eUpvYnMgYXJyYXkuIEl0IGFsc28gaW5pdGlhbGl6ZXMgaXRzIGN1cnJlbnRUaW1lIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0fSBqb2IgVGhlIGpvYiB0byBhY3RpdmF0ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfYWN0aXZhdGVKb2Ioam9iKSB7XHJcbiAgICB2YXIgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XHJcblxyXG4gICAgLy8gQWRkIHRoZSBqb2IgdG8gdGhlIHJ1bm5pbmcgam9iczpcclxuICAgIF9ydW5uaW5nSm9ic1tqb2IuaWRdID0gam9iO1xyXG4gICAgam9iLnN0YXR1cyA9ICdydW5uaW5nJztcclxuXHJcbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcHJpb3JpdGllczpcclxuICAgIGlmIChsKSB7XHJcbiAgICAgIGpvYi53ZWlnaHRUaW1lID0gX3NvcnRlZEJ5UHJpb3JpdHlKb2JzW2wgLSAxXS53ZWlnaHRUaW1lO1xyXG4gICAgICBqb2IuY3VycmVudFRpbWUgPSBqb2Iud2VpZ2h0VGltZSAqIChqb2Iud2VpZ2h0IHx8IDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIGpvYiBhbmQgZGlzcGF0Y2g6XHJcbiAgICBqb2Iuc3RhcnRUaW1lID0gX19kYXRlTm93KCk7XHJcbiAgICBfZGlzcGF0Y2goJ2pvYlN0YXJ0ZWQnLCBfX2Nsb25lKGpvYikpO1xyXG5cclxuICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgbWFpbiBsb29wIG9mIGNvbnJhZC5qczpcclxuICAgKiAgLiBJdCBleGVjdXRlcyBqb2Igc3VjaCB0aGF0IHRoZXkgYWxsIG9jY3VwYXRlIHRoZSBzYW1lIHByb2Nlc3NpbmcgdGltZS5cclxuICAgKiAgLiBJdCBzdG9wcyBqb2JzIHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgZXhlY3V0ZWQgYW55bW9yZS5cclxuICAgKiAgLiBJdCB0cmlnZ2VycyBjYWxsYmFja3Mgd2hlbiBpdCBpcyByZWxldmFudC5cclxuICAgKiAgLiBJdCBzdGFydHMgd2FpdGluZyBqb2JzIHdoZW4gdGhleSBuZWVkIHRvIGJlIHN0YXJ0ZWQuXHJcbiAgICogIC4gSXQgaW5qZWN0cyBmcmFtZXMgdG8ga2VlcCBhIGNvbnN0YW50IGZyYXBlcyBwZXIgc2Vjb25kIHJhdGlvLlxyXG4gICAqICAuIEl0IHN0b3BzIGl0c2VsZiB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGpvYnMgdG8gZXhlY3V0ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfbG9vcCgpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICAgIG8sXHJcbiAgICAgICAgbCxcclxuICAgICAgICBqb2IsXHJcbiAgICAgICAgdGltZSxcclxuICAgICAgICBkZWFkSm9iO1xyXG5cclxuICAgIC8vIERlYWwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgam9icyAodGhlIF9qb2JzIG9iamVjdCk6XHJcbiAgICBmb3IgKGsgaW4gX2pvYnMpIHtcclxuICAgICAgam9iID0gX2pvYnNba107XHJcblxyXG4gICAgICBpZiAoam9iLmFmdGVyKVxyXG4gICAgICAgIF93YWl0aW5nSm9ic1trXSA9IGpvYjtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIF9hY3RpdmF0ZUpvYihqb2IpO1xyXG5cclxuICAgICAgZGVsZXRlIF9qb2JzW2tdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB0aGUgX2lzUnVubmluZyBmbGFnIHRvIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBydW5uaW5nIGpvYjpcclxuICAgIF9pc1J1bm5pbmcgPSAhIV9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XHJcblxyXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBydW5uaW5nIGpvYnMgKHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0KTpcclxuICAgIHdoaWxlIChcclxuICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLmxlbmd0aCAmJlxyXG4gICAgICBfX2RhdGVOb3coKSAtIF9sYXN0RnJhbWVUaW1lIDwgX3BhcmFtZXRlcnMuZnJhbWVEdXJhdGlvblxyXG4gICAgKSB7XHJcbiAgICAgIGRlYWRKb2IgPSBfZXhlY3V0ZUZpcnN0Sm9iKCk7XHJcblxyXG4gICAgICAvLyBEZWFsIHdpdGggdGhlIGNhc2Ugd2hlcmUgdGhlIGpvYiBoYXMgZW5kZWQ6XHJcbiAgICAgIGlmIChkZWFkSm9iKSB7XHJcbiAgICAgICAgX2tpbGxKb2IoZGVhZEpvYi5pZCk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciB3YWl0aW5nIGpvYnM6XHJcbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcclxuICAgICAgICAgIGlmIChfd2FpdGluZ0pvYnNba10uYWZ0ZXIgPT09IGRlYWRKb2IuaWQpIHtcclxuICAgICAgICAgICAgX2FjdGl2YXRlSm9iKF93YWl0aW5nSm9ic1trXSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBfd2FpdGluZ0pvYnNba107XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBjb25yYWQgc3RpbGwgaGFzIGpvYnMgdG8gZGVhbCB3aXRoLCBhbmQga2lsbCBpdCBpZiBub3Q6XHJcbiAgICBpZiAoX2lzUnVubmluZykge1xyXG4gICAgICAvLyBVcGRhdGUgdGhlIF9sYXN0RnJhbWVUaW1lOlxyXG4gICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xyXG5cclxuICAgICAgX2Rpc3BhdGNoKCdlbnRlckZyYW1lJyk7XHJcbiAgICAgIHNldFRpbWVvdXQoX2xvb3AsIDApO1xyXG4gICAgfSBlbHNlXHJcbiAgICAgIF9kaXNwYXRjaCgnc3RvcCcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBvbmUgb3IgbW9yZSBqb2JzLCBhbmQgc3RhcnRzIHRoZSBsb29wIGlmIG5vIGpvYiB3YXMgcnVubmluZyBiZWZvcmUuIEFcclxuICAgKiBqb2IgaXMgYXQgbGVhc3QgYSB1bmlxdWUgc3RyaW5nIFwiaWRcIiBhbmQgYSBmdW5jdGlvbiwgYW5kIHRoZXJlIGFyZSBzb21lXHJcbiAgICogcGFyYW1ldGVycyB0aGF0IHlvdSBjYW4gc3BlY2lmeSBmb3IgZWFjaCBqb2IgdG8gbW9kaWZ5IHRoZSB3YXkgY29ucmFkIHdpbGxcclxuICAgKiBleGVjdXRlIGl0LiBJZiBhIGpvYiBpcyBhZGRlZCB3aXRoIHRoZSBcImlkXCIgb2YgYW5vdGhlciBqb2IgdGhhdCBpcyB3YWl0aW5nXHJcbiAgICogb3Igc3RpbGwgcnVubmluZywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICpcclxuICAgKiBXaGVuIGEgam9iIGlzIGFkZGVkLCBpdCBpcyByZWZlcmVuY2VkIGluIHRoZSBfam9icyBvYmplY3QsIGJ5IGl0cyBpZC5cclxuICAgKiBUaGVuLCBpZiBpdCBoYXMgdG8gYmUgZXhlY3V0ZWQgcmlnaHQgbm93LCBpdCB3aWxsIGJlIGFsc28gcmVmZXJlbmNlZCBpblxyXG4gICAqIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0LiBJZiBpdCBoYXMgdG8gd2FpdCwgdGhlbiBpdCB3aWxsIGJlIGFkZGVkIGludG8gdGhlXHJcbiAgICogX3dhaXRpbmdKb2JzIG9iamVjdCwgdW50aWwgaXQgY2FuIHN0YXJ0LlxyXG4gICAqXHJcbiAgICogS2VlcCByZWFkaW5nIHRoaXMgZG9jdW1lbnRhdGlvbiB0byBzZWUgaG93IHRvIGNhbGwgdGhpcyBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxyXG4gICAqXHJcbiAgICogQWRkaW5nIG9uZSBqb2I6XHJcbiAgICogKioqKioqKioqKioqKioqXHJcbiAgICogQmFzaWNhbGx5LCBhIGpvYiBpcyBkZWZpbmVkIGJ5IGl0cyBzdHJpbmcgaWQgYW5kIGEgZnVuY3Rpb24gKHRoZSBqb2IpLiBJdFxyXG4gICAqIGlzIGFsc28gcG9zc2libGUgdG8gYWRkIHNvbWUgcGFyYW1ldGVyczpcclxuICAgKlxyXG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCBteUpvYkZ1bmN0aW9uKTtcclxuICAgKiAgPiBjb25yYWQuYWRkSm9iKCdteUpvYklkJywge1xyXG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxyXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXHJcbiAgICogID4gfSk7XHJcbiAgICogID4gY29ucmFkLmFkZEpvYih7XHJcbiAgICogID4gICBpZDogJ215Sm9iSWQnLFxyXG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxyXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXHJcbiAgICogID4gfSk7XHJcbiAgICpcclxuICAgKiBBZGRpbmcgc2V2ZXJhbCBqb2JzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqXHJcbiAgICogV2hlbiBhZGRpbmcgc2V2ZXJhbCBqb2JzIGF0IHRoZSBzYW1lIHRpbWUsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnlcclxuICAgKiBwYXJhbWV0ZXJzIGZvciBlYWNoIG9uZSBpbmRpdmlkdWFsbHkgb3IgZm9yIGFsbDpcclxuICAgKlxyXG4gICAqICA+IGNvbnJhZC5hZGRKb2IoW1xyXG4gICAqICA+ICAge1xyXG4gICAqICA+ICAgICBpZDogJ215Sm9iSWQxJyxcclxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMSxcclxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcclxuICAgKiAgPiAgIH0sXHJcbiAgICogID4gICB7XHJcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDInLFxyXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxyXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMjogc29tZVZhbHVlMlxyXG4gICAqICA+ICAgfVxyXG4gICAqICA+IF0sIHtcclxuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxyXG4gICAqICA+IH0pO1xyXG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xyXG4gICAqICA+ICAgbXlKb2JJZDE6IHssXHJcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXHJcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIxOiBzb21lVmFsdWUxXHJcbiAgICogID4gICB9LFxyXG4gICAqICA+ICAgbXlKb2JJZDI6IHssXHJcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjIsXHJcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXHJcbiAgICogID4gICB9XHJcbiAgICogID4gfSwge1xyXG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXHJcbiAgICogID4gfSk7XHJcbiAgICogID4gY29ucmFkLmFkZEpvYih7XHJcbiAgICogID4gICBteUpvYklkMTogbXlKb2JGdW5jdGlvbjEsXHJcbiAgICogID4gICBteUpvYklkMjogbXlKb2JGdW5jdGlvbjJcclxuICAgKiAgPiB9LCB7XHJcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcclxuICAgKiAgPiB9KTtcclxuICAgKlxyXG4gICAqICBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XHJcbiAgICogICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiAgSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnM6XHJcbiAgICpcclxuICAgKiAgICB7P0Z1bmN0aW9ufSBlbmQgICAgICBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgam9iIGlzIGVuZGVkLiBJdCBpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBleGVjdXRlZCBpZiB0aGUgam9iIGlzIGtpbGxlZCBpbnN0ZWFkIG9mIGVuZGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgXCJuYXR1cmFsbHlcIi5cclxuICAgKiAgICB7P0ludGVnZXJ9ICBjb3VudCAgICBUaGUgbnVtYmVyIG9mIHRpbWUgdGhlIGpvYiBoYXMgdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICogICAgez9OdW1iZXJ9ICAgd2VpZ2h0ICAgSWYgc3BlY2lmaWVkLCB0aGUgam9iIHdpbGwgYmUgZXhlY3V0ZWQgYXMgaXQgd2FzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgXCJ3ZWlnaHRcIiB0aW1lcy5cclxuICAgKiAgICB7P1N0cmluZ30gICBhZnRlciAgICBUaGUgaWQgb2YgYW5vdGhlciBqb2IgKGV2ZW50dWFsbHkgbm90IGFkZGVkIHlldCkuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgSWYgc3BlY2lmaWVkLCB0aGlzIGpvYiB3aWxsIHN0YXJ0IG9ubHkgd2hlbiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWZpZWQgXCJhZnRlclwiIGpvYiBpcyBlbmRlZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfYWRkSm9iKHYxLCB2Mikge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBvO1xyXG5cclxuICAgIC8vIEFycmF5IG9mIGpvYnM6XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2MSkpIHtcclxuICAgICAgLy8gS2VlcCBjb25yYWQgdG8gc3RhcnQgdW50aWwgdGhlIGxhc3Qgam9iIGlzIGFkZGVkOlxyXG4gICAgICBfbm9TdGFydCA9IHRydWU7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdjEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIF9hZGRKb2IodjFbaV0uaWQsIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xyXG5cclxuICAgICAgX25vU3RhcnQgPSBmYWxzZTtcclxuICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcclxuICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xyXG5cclxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XHJcbiAgICAgICAgX2xvb3AoKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIC8vIE9uZSBqb2IgKG9iamVjdCk6XHJcbiAgICAgIGlmICh0eXBlb2YgdjEuaWQgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIF9hZGRKb2IodjEuaWQsIHYxKTtcclxuXHJcbiAgICAgIC8vIEhhc2ggb2Ygam9iczpcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gS2VlcCBjb25yYWQgdG8gc3RhcnQgdW50aWwgdGhlIGxhc3Qgam9iIGlzIGFkZGVkOlxyXG4gICAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yIChpIGluIHYxKVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2MVtpXSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgX2FkZEpvYihpLCBfX2V4dGVuZCh7XHJcbiAgICAgICAgICAgICAgam9iOiB2MVtpXVxyXG4gICAgICAgICAgICB9LCB2MikpO1xyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBfYWRkSm9iKGksIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xyXG5cclxuICAgICAgICBfbm9TdGFydCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghX2lzUnVubmluZykge1xyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcclxuICAgICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XHJcblxyXG4gICAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xyXG4gICAgICAgICAgX2xvb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLyBPbmUgam9iIChzdHJpbmcsICopOlxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGlmIChfaGFzSm9iKHYxKSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnW2NvbnJhZC5hZGRKb2JdIEpvYiB3aXRoIGlkIFwiJyArIHYxICsgJ1wiIGFscmVhZHkgZXhpc3RzLidcclxuICAgICAgICApO1xyXG5cclxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBmdW5jdGlvbik6XHJcbiAgICAgIGlmICh0eXBlb2YgdjIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBvID0ge1xyXG4gICAgICAgICAgaWQ6IHYxLFxyXG4gICAgICAgICAgZG9uZTogMCxcclxuICAgICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcclxuICAgICAgICAgIGN1cnJlbnRUaW1lOiAwLFxyXG4gICAgICAgICAgYXZlcmFnZVRpbWU6IDAsXHJcbiAgICAgICAgICB3ZWlnaHRUaW1lOiAwLFxyXG4gICAgICAgICAgam9iOiB2MlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAvLyBPbmUgam9iIChzdHJpbmcsIG9iamVjdCk6XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHYyID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIG8gPSBfX2V4dGVuZChcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaWQ6IHYxLFxyXG4gICAgICAgICAgICBkb25lOiAwLFxyXG4gICAgICAgICAgICB0aW1lOiAwLFxyXG4gICAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcclxuICAgICAgICAgICAgY3VycmVudFRpbWU6IDAsXHJcbiAgICAgICAgICAgIGF2ZXJhZ2VUaW1lOiAwLFxyXG4gICAgICAgICAgICB3ZWlnaHRUaW1lOiAwXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdjJcclxuICAgICAgICApO1xyXG5cclxuICAgICAgLy8gSWYgbm9uZSBvZiB0aG9zZSBjYXNlcywgdGhyb3cgYW4gZXJyb3I6XHJcbiAgICAgIH0gZWxzZVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcclxuXHJcbiAgICAgIC8vIEVmZmVjdGl2ZWx5IGFkZCB0aGUgam9iOlxyXG4gICAgICBfam9ic1t2MV0gPSBvO1xyXG4gICAgICBfZGlzcGF0Y2goJ2pvYkFkZGVkJywgX19jbG9uZShvKSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbG9vcCBoYXMgdG8gYmUgc3RhcnRlZDpcclxuICAgICAgaWYgKCFfaXNSdW5uaW5nICYmICFfbm9TdGFydCkge1xyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XHJcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcclxuXHJcbiAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xyXG4gICAgICAgIF9sb29wKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcclxuICAgIH0gZWxzZVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tjb25yYWQuYWRkSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBLaWxscyBvbmUgb3IgbW9yZSBqb2JzLCBpbmRpY2F0ZWQgYnkgdGhlaXIgaWRzLiBJdCBpcyBvbmx5IHBvc3NpYmxlIHRvXHJcbiAgICoga2lsbCBydW5uaW5nIGpvYnMgb3Igd2FpdGluZyBqb2JzLiBJZiB5b3UgdHJ5IHRvIGtpbGwgYSBqb2IgdGhhdCBkb2VzIG5vdFxyXG4gICAqIGV4aXN0cyBvciB0aGF0IGlzIGFscmVhZHkga2lsbGVkLCBhIHdhcm5pbmcgd2lsbCBiZSB0aHJvd24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtBcnJheXxTdHJpbmd9IHYxIEEgc3RyaW5nIGpvYiBpZCBvciBhbiBhcnJheSBvZiBqb2IgaWRzLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyBjb25yYWQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2tpbGxKb2IodjEpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgayxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGpvYixcclxuICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEFycmF5IG9mIGpvYiBpZHM6XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2MSkpXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgX2tpbGxKb2IodjFbaV0pO1xyXG5cclxuICAgIC8vIE9uZSBqb2IncyBpZDpcclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYSA9IFtfcnVubmluZ0pvYnMsIF93YWl0aW5nSm9icywgX2pvYnNdO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRoZSBqb2IgZnJvbSB0aGUgaGFzaGVzOlxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKHYxIGluIGFbaV0pIHtcclxuICAgICAgICAgIGpvYiA9IGFbaV1bdjFdO1xyXG5cclxuICAgICAgICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KSB7XHJcbiAgICAgICAgICAgIGpvYi5zdGF0dXMgPSAnZG9uZSc7XHJcbiAgICAgICAgICAgIF9kb25lSm9icy5wdXNoKGpvYik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgX2Rpc3BhdGNoKCdqb2JFbmRlZCcsIF9fY2xvbmUoam9iKSk7XHJcbiAgICAgICAgICBkZWxldGUgYVtpXVt2MV07XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBqb2IuZW5kID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICBqb2IuZW5kKCk7XHJcblxyXG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgcHJpb3JpdGllcyBhcnJheTpcclxuICAgICAgYSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icztcclxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmIChhW2ldLmlkID09PSB2MSkge1xyXG4gICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICBpZiAoIWZvdW5kKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBKb2IgXCInICsgdjEgKyAnXCIgbm90IGZvdW5kLicpO1xyXG5cclxuICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxyXG4gICAgfSBlbHNlXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nLCB3YWl0aW5nLCBhbmQganVzdCBhZGRlZCBqb2JzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGNvbnJhZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfa2lsbEFsbCgpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICAgIGpvYnMgPSBfX2V4dGVuZChfam9icywgX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMpO1xyXG5cclxuICAgIC8vIFRha2UgZXZlcnkgam9icyBhbmQgcHVzaCB0aGVtIGludG8gdGhlIF9kb25lSm9icyBvYmplY3Q6XHJcbiAgICBpZiAoX3BhcmFtZXRlcnMuaGlzdG9yeSlcclxuICAgICAgZm9yIChrIGluIGpvYnMpIHtcclxuICAgICAgICBqb2JzW2tdLnN0YXR1cyA9ICdkb25lJztcclxuICAgICAgICBfZG9uZUpvYnMucHVzaChqb2JzW2tdKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBqb2JzW2tdLmVuZCA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIGpvYnNba10uZW5kKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLyBSZWluaXRpYWxpemUgdGhlIGRpZmZlcmVudCBqb2JzIGxpc3RzOlxyXG4gICAgX2pvYnMgPSB7fTtcclxuICAgIF93YWl0aW5nSm9icyA9IHt9O1xyXG4gICAgX3J1bm5pbmdKb2JzID0ge307XHJcbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcclxuXHJcbiAgICAvLyBJbiBjYXNlIHNvbWUgam9icyBhcmUgYWRkZWQgcmlnaHQgYWZ0ZXIgdGhlIGtpbGw6XHJcbiAgICBfaXNSdW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBqb2Igd2l0aCB0aGUgc3BlY2lmaWVkIGlkIGlzIGN1cnJlbnRseSBydW5uaW5nIG9yXHJcbiAgICogd2FpdGluZywgYW5kIGZhbHNlIGVsc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBpZCBUaGUgaWQgb2YgdGhlIGpvYi5cclxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGV4aXN0cy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfaGFzSm9iKGlkKSB7XHJcbiAgICB2YXIgam9iID0gX2pvYnNbaWRdIHx8IF9ydW5uaW5nSm9ic1tpZF0gfHwgX3dhaXRpbmdKb2JzW2lkXTtcclxuICAgIHJldHVybiBqb2IgPyBfX2V4dGVuZChqb2IpIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IHRoZSBzZXR0aW5nIHNwZWNpZmllZCBieSBcInYxXCIgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxyXG4gICAqIGJ5IFwidjJcIiBpZiBib3RoIGFyZSBnaXZlbiwgYW5kIGVsc2UgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZVxyXG4gICAqIHNldHRpbmdzIFwidjFcIi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICB2MSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICogQHBhcmFtICB7Pyp9ICAgICAgIHYyIEV2ZW50dWFsbHksIGEgdmFsdWUgdG8gc2V0IHRvIHRoZSBzcGVjaWZpZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fCp9IFJldHVybnMgdGhlIHNwZWNpZmllZCBzZXR0aW5ncyB2YWx1ZSBpZiBcInYyXCIgaXMgbm90XHJcbiAgICogICAgICAgICAgICAgICAgICAgIGdpdmVuLCBhbmQgY29ucmFkIGVsc2UuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3NldHRpbmdzKHYxLCB2Mikge1xyXG4gICAgdmFyIG87XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhMSA9PT0gJ3N0cmluZycgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzW2ExXTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBvID0gKHR5cGVvZiBhMSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgP1xyXG4gICAgICAgIGExIHx8IHt9IDpcclxuICAgICAgICB7fTtcclxuICAgICAgaWYgKHR5cGVvZiBhMSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgb1thMV0gPSBhMjtcclxuXHJcbiAgICAgIGZvciAodmFyIGsgaW4gbylcclxuICAgICAgICBpZiAob1trXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgX3BhcmFtZXRlcnNba10gPSBvW2tdO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGRlbGV0ZSBfcGFyYW1ldGVyc1trXTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbnJhZCBpcyBjdXJyZW50bHkgcnVubmluZywgYW5kIGZhbHNlIGVsc2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIF9pc1J1bm5pbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX2dldElzUnVubmluZygpIHtcclxuICAgIHJldHVybiBfaXNSdW5uaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW5yZWZlcmVuY2UgZXZlcnkgam9icyB0aGF0IGFyZSBzdG9yZWQgaW4gdGhlIF9kb25lSm9icyBvYmplY3QuIEl0IHdpbGxcclxuICAgKiBub3QgYmUgcG9zc2libGUgYW55bW9yZSB0byBnZXQgc3RhdHMgYWJvdXQgdGhlc2Ugam9icywgYnV0IGl0IHdpbGwgcmVsZWFzZVxyXG4gICAqIHRoZSBtZW1vcnkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9jbGVhckhpc3RvcnkoKSB7XHJcbiAgICBfZG9uZUpvYnMgPSBbXTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGV2ZXJ5IGRhdGEgYWJvdXQgam9icyB0aGF0IHdhaXQgdG8gYmUgc3RhcnRlZCwgYXJlXHJcbiAgICogY3VycmVudGx5IHJ1bm5pbmcgb3IgYXJlIGRvbmUuXHJcbiAgICpcclxuICAgKiBJdCBpcyBwb3NzaWJsZSB0byBnZXQgb25seSBydW5uaW5nLCB3YWl0aW5nIG9yIGRvbmUgam9icyBieSBnaXZpbmdcclxuICAgKiBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIgYXMgZmlzdCBhcmd1bWVudC5cclxuICAgKlxyXG4gICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGV2ZXJ5IGpvYiB3aXRoIGEgc3BlY2lmaWVkIGlkIGJ5IGdpdmluZyBpdCBhc1xyXG4gICAqIGZpcnN0IGFyZ3VtZW50LiBBbHNvLCB1c2luZyBhIFJlZ0V4cCBpbnN0ZWFkIG9mIGFuIGlkIHdpbGwgcmV0dXJuIGV2ZXJ5XHJcbiAgICogam9icyB3aG9zZSBpZHMgbWF0Y2ggdGhlIFJlZ0V4cC4gQW5kIHRoZXNlIHR3byBsYXN0IHVzZSBjYXNlcyB3b3JrIGFzIHdlbGxcclxuICAgKiBieSBnaXZpbmcgYmVmb3JlIFwicnVubmluZ1wiLCBcIndhaXRpbmdcIiBvciBcImRvbmVcIi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2YgdGhlIG1hdGNoaW5nIGpvYnMuXHJcbiAgICpcclxuICAgKiBTb21lIGNhbGwgZXhhbXBsZXM6XHJcbiAgICogKioqKioqKioqKioqKioqKioqKlxyXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycpXHJcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCd3YWl0aW5nJylcclxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ2RvbmUnKVxyXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygnbXlKb2InKVxyXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygvdGVzdC8pXHJcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJywgJ215UnVubmluZ0pvYicpXHJcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJywgL3Rlc3QvKVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9nZXRTdGF0cyh2MSwgdjIpIHtcclxuICAgIHZhciBhLFxyXG4gICAgICAgIGssXHJcbiAgICAgICAgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIHN0YXRzLFxyXG4gICAgICAgIHBhdHRlcm4sXHJcbiAgICAgICAgaXNQYXR0ZXJuU3RyaW5nO1xyXG5cclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBzdGF0cyA9IFtdO1xyXG5cclxuICAgICAgZm9yIChrIGluIF9qb2JzKVxyXG4gICAgICAgIHN0YXRzLnB1c2goX2pvYnNba10pO1xyXG5cclxuICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcclxuICAgICAgICBzdGF0cy5wdXNoKF93YWl0aW5nSm9ic1trXSk7XHJcblxyXG4gICAgICBmb3IgKGsgaW4gX3J1bm5pbmdKb2JzKVxyXG4gICAgICAgIHN0YXRzLnB1c2goX3J1bm5pbmdKb2JzW2tdKTtcclxuXHJcbiAgICAgIHN0YXRzID0gc3RhdHMuY29uY2F0KF9kb25lSm9icyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpXHJcbiAgICAgIHN3aXRjaCAodjEpIHtcclxuICAgICAgICBjYXNlICd3YWl0aW5nJzpcclxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3dhaXRpbmdKb2JzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3J1bm5pbmcnOlxyXG4gICAgICAgICAgc3RhdHMgPSBfX29iamVjdFZhbHVlcyhfcnVubmluZ0pvYnMpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZG9uZSc6XHJcbiAgICAgICAgICBzdGF0cyA9IF9kb25lSm9icztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBwYXR0ZXJuID0gdjE7XHJcbiAgICAgIH1cclxuXHJcbiAgICBpZiAodjEgaW5zdGFuY2VvZiBSZWdFeHApXHJcbiAgICAgIHBhdHRlcm4gPSB2MTtcclxuXHJcbiAgICBpZiAoIXBhdHRlcm4gJiYgKHR5cGVvZiB2MiA9PT0gJ3N0cmluZycgfHwgdjIgaW5zdGFuY2VvZiBSZWdFeHApKVxyXG4gICAgICBwYXR0ZXJuID0gdjI7XHJcblxyXG4gICAgLy8gRmlsdGVyIGpvYnMgaWYgYSBwYXR0ZXJuIGlzIGdpdmVuOlxyXG4gICAgaWYgKHBhdHRlcm4pIHtcclxuICAgICAgaXNQYXR0ZXJuU3RyaW5nID0gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnO1xyXG5cclxuICAgICAgaWYgKHN0YXRzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBhID0gc3RhdHM7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGEgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChrIGluIHN0YXRzKVxyXG4gICAgICAgICAgYSA9IGEuY29uY2F0KHN0YXRzW2tdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhID0gW107XHJcblxyXG4gICAgICAgIGZvciAoayBpbiBfam9icylcclxuICAgICAgICAgIGEucHVzaChfam9ic1trXSk7XHJcblxyXG4gICAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXHJcbiAgICAgICAgICBhLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcclxuXHJcbiAgICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcclxuICAgICAgICAgIGEucHVzaChfcnVubmluZ0pvYnNba10pO1xyXG5cclxuICAgICAgICBhID0gYS5jb25jYXQoX2RvbmVKb2JzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RhdHMgPSBbXTtcclxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmIChpc1BhdHRlcm5TdHJpbmcgPyBhW2ldLmlkID09PSBwYXR0ZXJuIDogYVtpXS5pZC5tYXRjaChwYXR0ZXJuKSlcclxuICAgICAgICAgIHN0YXRzLnB1c2goYVtpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9fY2xvbmUoc3RhdHMpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRPT0xTIEZVTkNUSU9OUzpcclxuICAgKiAqKioqKioqKioqKioqKioqXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW55IG51bWJlciBvZiBvYmplY3RzIGFzIGFyZ3VtZW50cywgY29waWVzIGZyb20gZWFjaFxyXG4gICAqIG9mIHRoZXNlIG9iamVjdHMgZWFjaCBwYWlyIGtleS92YWx1ZSBpbnRvIGEgbmV3IG9iamVjdCwgYW5kIGZpbmFsbHlcclxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGZyb20gdGhlIGxhc3Qgb25lIHRvIHRoZSBmaXJzdCBvbmUsIHN1Y2ggdGhhdFxyXG4gICAqIHdoZW4gdHdvIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cclxuICAgKlxyXG4gICAqIEV4YW1wbGU6XHJcbiAgICogKioqKioqKipcclxuICAgKiAgPiB2YXIgbzEgPSB7XHJcbiAgICogID4gICAgICAgYTogMSxcclxuICAgKiAgPiAgICAgICBiOiAyLFxyXG4gICAqICA+ICAgICAgIGM6ICczJ1xyXG4gICAqICA+ICAgICB9LFxyXG4gICAqICA+ICAgICBvMiA9IHtcclxuICAgKiAgPiAgICAgICBjOiAnNCcsXHJcbiAgICogID4gICAgICAgZDogWyA1IF1cclxuICAgKiAgPiAgICAgfTtcclxuICAgKiAgPiBfX2V4dGVuZChvMSwgbzIpO1xyXG4gICAqICA+IC8vIFJldHVybnM6IHtcclxuICAgKiAgPiAvLyAgIGE6IDEsXHJcbiAgICogID4gLy8gICBiOiAyLFxyXG4gICAqICA+IC8vICAgYzogJzMnLFxyXG4gICAqICA+IC8vICAgZDogWyA1IF1cclxuICAgKiAgPiAvLyB9O1xyXG4gICAqXHJcbiAgICogQHBhcmFtICB7T2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gIFRoZSBtZXJnZWQgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kKCkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgayxcclxuICAgICAgICByZXMgPSB7fSxcclxuICAgICAgICBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgIGZvciAoayBpbiBhcmd1bWVudHNbaV0pXHJcbiAgICAgICAgcmVzW2tdID0gYXJndW1lbnRzW2ldW2tdO1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGZ1bmN0aW9uIHNpbXBseSBjbG9uZXMgYW4gb2JqZWN0LiBUaGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gb25seVxyXG4gICAqIG9iamVjdHMsIGFycmF5cyBhbmQgaW1tdXRhYmxlIHZhbHVlcy4gU2luY2UgaXQgaXMgbm90IHB1YmxpYywgaXQgZG9lcyBub3RcclxuICAgKiBkZWFsIHdpdGggY3ljbGljIHJlZmVyZW5jZXMsIERPTSBlbGVtZW50cyBhbmQgaW5zdGFudGlhdGVkIG9iamVjdHMgLSBzb1xyXG4gICAqIHVzZSBpdCBjYXJlZnVsbHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFRoZSBvYmplY3QgdG8gY2xvbmUuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX19jbG9uZShpdGVtKSB7XHJcbiAgICB2YXIgcmVzdWx0LCBpLCBrLCBsO1xyXG5cclxuICAgIGlmICghaXRlbSlcclxuICAgICAgcmV0dXJuIGl0ZW07XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcclxuICAgICAgcmVzdWx0ID0gW107XHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICByZXN1bHQucHVzaChfX2Nsb25lKGl0ZW1baV0pKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICBmb3IgKGkgaW4gaXRlbSlcclxuICAgICAgICByZXN1bHRbaV0gPSBfX2Nsb25lKGl0ZW1baV0pO1xyXG4gICAgfSBlbHNlXHJcbiAgICAgIHJlc3VsdCA9IGl0ZW07XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdC5cclxuICAgKiBAcmV0dXJuIHtBcnJheX0gIFRoZSBhcnJheSBvZiB2YWx1ZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX19vYmplY3RWYWx1ZXMobykge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgYSA9IFtdO1xyXG5cclxuICAgIGZvciAoayBpbiBvKVxyXG4gICAgICBhLnB1c2gob1trXSk7XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIHNob3J0IFwiRGF0ZS5ub3coKVwiIHBvbHlmaWxsLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgY3VycmVudCB0aW1lIChpbiBtcykuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX19kYXRlTm93KCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUG9seWZpbGwgZm9yIHRoZSBBcnJheS5pc0FycmF5IGZ1bmN0aW9uOlxyXG4gICAqL1xyXG4gIGlmICghQXJyYXkuaXNBcnJheSlcclxuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbih2KSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRVhQT1JUIFBVQkxJQyBBUEk6XHJcbiAgICogKioqKioqKioqKioqKioqKioqXHJcbiAgICovXHJcbiAgdmFyIGNvbnJhZCA9IHtcclxuICAgIGhhc0pvYjogX2hhc0pvYixcclxuICAgIGFkZEpvYjogX2FkZEpvYixcclxuICAgIGtpbGxKb2I6IF9raWxsSm9iLFxyXG4gICAga2lsbEFsbDogX2tpbGxBbGwsXHJcbiAgICBzZXR0aW5nczogX3NldHRpbmdzLFxyXG4gICAgZ2V0U3RhdHM6IF9nZXRTdGF0cyxcclxuICAgIGlzUnVubmluZzogX2dldElzUnVubmluZyxcclxuICAgIGNsZWFySGlzdG9yeTogX2NsZWFySGlzdG9yeSxcclxuXHJcbiAgICAvLyBFdmVudHMgbWFuYWdlbWVudDpcclxuICAgIGJpbmQ6IF9iaW5kLFxyXG4gICAgdW5iaW5kOiBfdW5iaW5kLFxyXG5cclxuICAgIC8vIFZlcnNpb246XHJcbiAgICB2ZXJzaW9uOiAnMC4xLjAnXHJcbiAgfTtcclxuXHJcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxyXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb25yYWQ7XHJcbiAgICBleHBvcnRzLmNvbnJhZCA9IGNvbnJhZDtcclxuICB9XHJcbiAgZ2xvYmFsLmNvbnJhZCA9IGNvbnJhZDtcclxufSkodGhpcyk7XHJcblxyXG4vLyBIYXJkY29kZWQgZXhwb3J0IGZvciB0aGUgbm9kZS5qcyB2ZXJzaW9uOlxyXG52YXIgc2lnbWEgPSB0aGlzLnNpZ21hLFxyXG4gICAgY29ucmFkID0gdGhpcy5jb25yYWQ7XHJcblxyXG5zaWdtYS5jb25yYWQgPSBjb25yYWQ7XHJcblxyXG4vLyBEaXJ0eSBwb2x5ZmlsbHMgdG8gcGVybWl0IHNpZ21hIHVzYWdlIGluIG5vZGVcclxuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgSFRNTEVsZW1lbnQgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxyXG4gIHdpbmRvdyA9IHtcclxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cclxuICB9O1xyXG5cclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcclxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHNpZ21hO1xyXG4gIGV4cG9ydHMuc2lnbWEgPSBzaWdtYTtcclxufVxyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIHZhciBfcm9vdCA9IHRoaXM7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMgPSBzaWdtYS51dGlscyB8fCB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogTUlTQyBVVElMUzpcclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFNpZ21hTWFwIHdyYXBzIGFuIEVTNiBPYmplY3QuIE1ldGhvZHMgc2V0LCBnZXQsIGhhcywgZm9yRWFjaCwgZGVsZXRlLCBhbmQgY2xlYXJcclxuICAgKiBoYXZlIHRoZSBzYW1lIHNpZ25hdHVyZSB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIE1hcCBtZXRob2RzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFNpZ21hTWFwKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIF9zdG9yZTtcclxuXHJcbiAgICBpZiAoIXNpZ21hLmZvcmNlRVM1ICYmXHJcbiAgICAgIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgIE1hcC5wcm90b3R5cGUua2V5cyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICYmIEFycmF5LmZyb20gIT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgX3N0b3JlID0gbmV3IE1hcCgpO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaXplJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBfc3RvcmUuc2l6ZTsgfSxcclxuICAgICAgICBzZXQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7IF9zdG9yZS5zZXQoJycgKyBrZXksIHZhbHVlKTsgfTtcclxuICAgICAgdGhpcy5nZXQgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIF9zdG9yZS5nZXQoJycgKyBrZXkpOyB9O1xyXG4gICAgICB0aGlzLmhhcyA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gX3N0b3JlLmhhcygnJyArIGtleSk7IH07XHJcbiAgICAgIHRoaXMuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1bmMpIHsgcmV0dXJuIF9zdG9yZS5mb3JFYWNoKGZ1bmMpOyB9O1xyXG4gICAgICB0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gX3N0b3JlLmRlbGV0ZSgnJyArIGtleSk7IH07XHJcbiAgICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHsgX3N0b3JlLmNsZWFyKCk7IH07XHJcblxyXG4gICAgICB0aGlzLmtleUxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oX3N0b3JlLmtleXMoKSk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLnZhbHVlTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgX3N0b3JlLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgX3N0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgdGhpcy5zaXplID0gMDtcclxuXHJcbiAgICAgIHRoaXMua2V5TGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoX3N0b3JlKS5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICByZXR1cm4gX3N0b3JlW2tleV0gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMudmFsdWVMaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX3N0b3JlKTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIHZhbCA9IF9zdG9yZVtrZXlzW2ldXTtcclxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChfc3RvcmVba2V5XSA9PT0gdW5kZWZpbmVkKSBzZWxmLnNpemUrKztcclxuXHJcbiAgICAgICAgX3N0b3JlW2tleV0gPSB2YWx1ZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBfc3RvcmVba2V5XTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBfc3RvcmVba2V5XSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5mb3JFYWNoID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKF9zdG9yZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSxcclxuICAgICAgICAgICAgICBvYmogPSBfc3RvcmVba2V5XTtcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgZnVuYyhvYmosIGtleSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gX3N0b3JlW2tleV07XHJcbiAgICAgICAgX3N0b3JlW2tleV0gPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSBzZWxmLnNpemUtLTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBrIGluIF9zdG9yZSlcclxuICAgICAgICAgIGlmICghKCdoYXNPd25Qcm9wZXJ0eScgaW4gX3N0b3JlKSB8fCBfc3RvcmUuaGFzT3duUHJvcGVydHkoaykpXHJcbiAgICAgICAgICAgIGRlbGV0ZSBfc3RvcmVba107XHJcblxyXG4gICAgICAgIF9zdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgc2VsZi5zaXplID0gMDtcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNpZ21hLnV0aWxzLm1hcCA9IFNpZ21hTWFwO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXHJcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxyXG4gICAqIHJldHVybnMgdGhpcyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XHJcbiAgICogd2hlbiBzZXZlcmFsIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cclxuICAgKlxyXG4gICAqIEV4YW1wbGU6XHJcbiAgICogKioqKioqKipcclxuICAgKiAgPiB2YXIgbzEgPSB7XHJcbiAgICogID4gICAgICAgYTogMSxcclxuICAgKiAgPiAgICAgICBiOiAyLFxyXG4gICAqICA+ICAgICAgIGM6ICczJ1xyXG4gICAqICA+ICAgICB9LFxyXG4gICAqICA+ICAgICBvMiA9IHtcclxuICAgKiAgPiAgICAgICBjOiAnNCcsXHJcbiAgICogID4gICAgICAgZDogWyA1IF1cclxuICAgKiAgPiAgICAgfTtcclxuICAgKiAgPiBzaWdtYS51dGlscy5leHRlbmQobzEsIG8yKTtcclxuICAgKiAgPiAvLyBSZXR1cm5zOiB7XHJcbiAgICogID4gLy8gICBhOiAxLFxyXG4gICAqICA+IC8vICAgYjogMixcclxuICAgKiAgPiAvLyAgIGM6ICczJyxcclxuICAgKiAgPiAvLyAgIGQ6IFsgNSBdXHJcbiAgICogID4gLy8gfTtcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdCt9IEFueSBudW1iZXIgb2Ygb2JqZWN0cy5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5leHRlbmQgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGssXHJcbiAgICAgICAgcmVzID0ge30sXHJcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChpID0gbCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxyXG4gICAgICAgIHJlc1trXSA9IGFyZ3VtZW50c1tpXVtrXTtcclxuXHJcbiAgICByZXR1cm4gcmVzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5kYXRlTm93ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGFrZXMgYSBwYWNrYWdlIG5hbWUgYXMgcGFyYW1ldGVyIGFuZCBjaGVja3MgYXQgZWFjaCBsZWJlbCBpZiBpdCBleGlzdHMsXHJcbiAgICogYW5kIGlmIGl0IGRvZXMgbm90LCBjcmVhdGVzIGl0LlxyXG4gICAqXHJcbiAgICogRXhhbXBsZTpcclxuICAgKiAqKioqKioqKlxyXG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmMnKTtcclxuICAgKiAgPiBhLmIuYztcclxuICAgKiAgPiAvLyBPYmplY3Qge307XHJcbiAgICogID5cclxuICAgKiAgPiBzaWdtYS51dGlscy5wa2coJ2EuYi5kJyk7XHJcbiAgICogID4gYS5iO1xyXG4gICAqICA+IC8vIE9iamVjdCB7IGM6IHt9LCBkOiB7fSB9O1xyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwa2dOYW1lIFRoZSBuYW1lIG9mIHRoZSBwYWNrYWdlIHRvIGNyZWF0ZS9maW5kLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLnBrZyA9IGZ1bmN0aW9uKHBrZ05hbWUpIHtcclxuICAgIHJldHVybiAocGtnTmFtZSB8fCAnJykuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24oY29udGV4dCwgb2JqTmFtZSkge1xyXG4gICAgICByZXR1cm4gKG9iak5hbWUgaW4gY29udGV4dCkgP1xyXG4gICAgICAgIGNvbnRleHRbb2JqTmFtZV0gOlxyXG4gICAgICAgIChjb250ZXh0W29iak5hbWVdID0ge30pO1xyXG4gICAgfSwgX3Jvb3QpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB1bmlxdWUgaW5jcmVtZW50YWwgbnVtYmVyIElELlxyXG4gICAqXHJcbiAgICogRXhhbXBsZTpcclxuICAgKiAqKioqKioqKlxyXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XHJcbiAgICogID4gLy8gMTtcclxuICAgKiAgPlxyXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XHJcbiAgICogID4gLy8gMjtcclxuICAgKiAgPlxyXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XHJcbiAgICogID4gLy8gMztcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHJlbGF0ZWQgcGFja2FnZS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5pZCA9IChmdW5jdGlvbigpIHtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuICsraTtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBoZXhhIGNvbG9yIChmb3IgaW5zdGFuY2UgXCIjZmZjYzAwXCIgb3IgXCIjZmMwXCIpIG9yIGFcclxuICAgKiByZ2IgLyByZ2JhIGNvbG9yIChsaWtlIFwicmdiKDI1NSwyNTUsMTIpXCIgb3IgXCJyZ2JhKDI1NSwyNTUsMTIsMSlcIikgYW5kXHJcbiAgICogcmV0dXJucyBhbiBpbnRlZ2VyIGVxdWFsIHRvIFwiciAqIDI1NSAqIDI1NSArIGcgKiAyNTUgKyBiXCIsIHRvIGdhaW4gc29tZVxyXG4gICAqIG1lbW9yeSBpbiB0aGUgZGF0YSBnaXZlbiB0byBXZWJHTCBzaGFkZXJzLlxyXG4gICAqXHJcbiAgICogTm90ZSB0aGF0IHRoZSBmdW5jdGlvbiBhY3R1YWxseSBjYWNoZXMgaXRzIHJlc3VsdHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsIFRoZSBoZXhhIG9yIHJnYmEgY29sb3IuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIG51bWJlciB2YWx1ZS5cclxuICAgKi9cclxuICB2YXIgZmxvYXRDb2xvckNhY2hlID0ge307XHJcblxyXG4gIHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IgPSBmdW5jdGlvbih2YWwpIHtcclxuXHJcbiAgICAvLyBJcyB0aGUgY29sb3IgYWxyZWFkeSBjb21wdXRlZD9cclxuICAgIGlmIChmbG9hdENvbG9yQ2FjaGVbdmFsXSlcclxuICAgICAgcmV0dXJuIGZsb2F0Q29sb3JDYWNoZVt2YWxdO1xyXG5cclxuICAgIHZhciBvcmlnaW5hbCA9IHZhbCxcclxuICAgICAgICByID0gMCxcclxuICAgICAgICBnID0gMCxcclxuICAgICAgICBiID0gMDtcclxuXHJcbiAgICBpZiAodmFsWzBdID09PSAnIycpIHtcclxuICAgICAgdmFsID0gdmFsLnNsaWNlKDEpO1xyXG5cclxuICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMCksIDE2KTtcclxuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcclxuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgwKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcclxuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMyksIDE2KTtcclxuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL14gKnJnYmE/ICpcXCgvKSkge1xyXG4gICAgICB2YWwgPSB2YWwubWF0Y2goXHJcbiAgICAgICAgL14gKnJnYmE/ICpcXCggKihbMC05XSopICosICooWzAtOV0qKSAqLCAqKFswLTldKikgKigsLiopP1xcKSAqJC9cclxuICAgICAgKTtcclxuICAgICAgciA9ICt2YWxbMV07XHJcbiAgICAgIGcgPSArdmFsWzJdO1xyXG4gICAgICBiID0gK3ZhbFszXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29sb3IgPSAoXHJcbiAgICAgIHIgKiAyNTYgKiAyNTYgK1xyXG4gICAgICBnICogMjU2ICtcclxuICAgICAgYlxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDYWNoaW5nIHRoZSBjb2xvclxyXG4gICAgZmxvYXRDb2xvckNhY2hlW29yaWdpbmFsXSA9IGNvbG9yO1xyXG5cclxuICAgIHJldHVybiBjb2xvcjtcclxuICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAqIFBlcmZvcm0gYSB6b29tIGludG8gYSBjYW1lcmEsIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24sIHRvIHRoZVxyXG4gICAqIGNvb3JkaW5hdGVzIGluZGljYXRlZCB1c2luZyBhIHNwZWNpZmllZCByYXRpby5cclxuICAgKlxyXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAqIG9iamVjdDpcclxuICAgKlxyXG4gICAqICAgez9udW1iZXJ9IGR1cmF0aW9uICAgICBBbiBhbW91bnQgb2YgdGltZSB0aGF0IG1lYW5zIHRoZSBkdXJhdGlvbiBvZiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLiBJZiB0aGlzIHBhcmFtZXRlciBkb2Vzbid0IGV4aXN0IHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tIHdpbGwgYmUgcGVyZm9ybWVkIHdpdGhvdXQgYW5pbWF0aW9uLlxyXG4gICAqICAgez9mdW5jdGlvbn0gb25Db21wbGV0ZSBBIGZ1bmN0aW9uIHRvIHBlcmZvcm0gaXQgYWZ0ZXIgdGhlIGFuaW1hdGlvbi4gSXRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwZXJmb3JtZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Y2FtZXJhfSAgICAgVGhlIGNhbWVyYSB3aGVyZSBwZXJmb3JtIHRoZSB6b29tLlxyXG4gICAqIEBwYXJhbSB7eH0gICAgICAgICAgVGhlIFggY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXHJcbiAgICogQHBhcmFtIHt5fSAgICAgICAgICBUaGUgWSBjb29yZGlhbnRpb24gd2hlcmUgdGhlIHpvb20gZ29lcy5cclxuICAgKiBAcGFyYW0ge3JhdGlvfSAgICAgIFRoZSByYXRpbyB0byBhcHBseSBpdCB0byB0aGUgY3VycmVudCBjYW1lcmEgcmF0aW8uXHJcbiAgICogQHBhcmFtIHs/YW5pbWF0aW9ufSBBIGRpY3Rpb25hcnkgd2l0aCBvcHRpb25zIGZvciBhIHBvc3NpYmxlIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy56b29tVG8gPSBmdW5jdGlvbihjYW1lcmEsIHgsIHksIHJhdGlvLCBhbmltYXRpb24pIHtcclxuICAgIHZhciBzZXR0aW5ncyA9IGNhbWVyYS5zZXR0aW5ncyxcclxuICAgICAgICBjb3VudCxcclxuICAgICAgICBuZXdSYXRpbyxcclxuICAgICAgICBhbmltYXRpb25TZXR0aW5ncyxcclxuICAgICAgICBjb29yZGluYXRlcztcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIG5ld1JhdGlvIGRlYWxpbmcgd2l0aCBtaW4gLyBtYXg6XHJcbiAgICBuZXdSYXRpbyA9IE1hdGgubWF4KFxyXG4gICAgICBzZXR0aW5ncygnem9vbU1pbicpLFxyXG4gICAgICBNYXRoLm1pbihcclxuICAgICAgICBzZXR0aW5ncygnem9vbU1heCcpLFxyXG4gICAgICAgIGNhbWVyYS5yYXRpbyAqIHJhdGlvXHJcbiAgICAgIClcclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbmV3IHJhdGlvIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbml0aWFsIG9uZTpcclxuICAgIGlmIChuZXdSYXRpbyAhPT0gY2FtZXJhLnJhdGlvKSB7XHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgY29vcmRpbmF0ZXMgdmFyaWFibGU6XHJcbiAgICAgIHJhdGlvID0gbmV3UmF0aW8gLyBjYW1lcmEucmF0aW87XHJcbiAgICAgIGNvb3JkaW5hdGVzID0ge1xyXG4gICAgICAgIHg6IHggKiAoMSAtIHJhdGlvKSArIGNhbWVyYS54LFxyXG4gICAgICAgIHk6IHkgKiAoMSAtIHJhdGlvKSArIGNhbWVyYS55LFxyXG4gICAgICAgIHJhdGlvOiBuZXdSYXRpb1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uZHVyYXRpb24pIHtcclxuICAgICAgICAvLyBDb21wbGV0ZSB0aGUgYW5pbWF0aW9uIHNldGluZ3M6XHJcbiAgICAgICAgY291bnQgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKGNhbWVyYSk7XHJcbiAgICAgICAgYW5pbWF0aW9uID0gc2lnbWEudXRpbHMuZXh0ZW5kKFxyXG4gICAgICAgICAgYW5pbWF0aW9uLFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBlYXNpbmc6IGNvdW50ID8gJ3F1YWRyYXRpY091dCcgOiAncXVhZHJhdGljSW5PdXQnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24uY2FtZXJhKGNhbWVyYSwgY29vcmRpbmF0ZXMsIGFuaW1hdGlvbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2FtZXJhLmdvVG8oY29vcmRpbmF0ZXMpO1xyXG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLm9uQ29tcGxldGUpXHJcbiAgICAgICAgICBhbmltYXRpb24ub25Db21wbGV0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MSAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc3RhcnQgcG9pbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgeTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gIHgyICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgeTIgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cclxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSBjYyAgVGhlIGN1cnZhdHVyZSBjb2VmZmljaWVudHMuXHJcbiAgICogQHJldHVybiB7eCx5fSAgICAgICAgIFRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCBjYykge1xyXG4gICAgY2MgPSB0aGlzLmV4dGVuZChjYywgeyB4OiAyLCB5OiA0IH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogKHgxICsgeDIpIC8gY2MueCArICh5MiAtIHkxKSAvIGNjLnksXHJcbiAgICAgIHk6ICh5MSArIHkyKSAvIGNjLnggKyAoeDEgLSB4MikgLyBjYy55XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgcG9zaXRpb25lZFxyXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cclxuICAgICpcclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHBvaW50IGluIHRoZSBjdXJ2ZSBmcm9tIHRoZSBjb250ZXh0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kaW5nIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhpIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geWkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cclxuICAgICogQHJldHVybiB7b2JqZWN0fSAgICB7eCx5fS5cclxuICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSA9IGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCB4aSwgeWkpIHtcclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU2MzQ1MjhcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6ICgxIC0gdCkgKiAoMSAtIHQpICogeDEgKyAyICogKDEgLSB0KSAqIHQgKiB4aSArIHQgKiB0ICogeDIsXHJcbiAgICAgIHk6ICgxIC0gdCkgKiAoMSAtIHQpICogeTEgKyAyICogKDEgLSB0KSAqIHQgKiB5aSArIHQgKiB0ICogeTJcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXHJcbiAgICAqIGF0IGxlbmd0aCB0IGluIHRoZSBjdWJpYyBiZXppZXIgY3VydmUuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW4gWzAsMV0gdGhlIHN0ZXAgcGVyY2VudGFnZSB0byByZWFjaFxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250ZXh0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5IFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEByZXR1cm4ge29iamVjdH0gICAge3gseX0gVGhlIHBvaW50IGF0IHQuXHJcbiAgKi9cclxuICBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUgPVxyXG4gICAgZnVuY3Rpb24odCwgeDEsIHkxLCB4MiwgeTIsIGN4LCBjeSwgZHgsIGR5KSB7XHJcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTM5NzU5NlxyXG4gICAgLy8gQmxlbmRpbmcgZnVuY3Rpb25zOlxyXG4gICAgdmFyIEIwX3QgPSAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCksXHJcbiAgICAgICAgQjFfdCA9IDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCksXHJcbiAgICAgICAgQjJfdCA9IDMgKiB0ICogdCAqICgxIC0gdCksXHJcbiAgICAgICAgQjNfdCA9IHQgKiB0ICogdDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiAoQjBfdCAqIHgxKSArIChCMV90ICogY3gpICsgKEIyX3QgKiBkeCkgKyAoQjNfdCAqIHgyKSxcclxuICAgICAgeTogKEIwX3QgKiB5MSkgKyAoQjFfdCAqIGN5KSArIChCMl90ICogZHkpICsgKEIzX3QgKiB5MilcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzIGZvciBhIHNlbGYgbG9vcCAoaS5lLlxyXG4gICAqIHdoZXJlIHRoZSBzdGFydCBwb2ludCBpcyBhbHNvIHRoZSBlbmQgcG9pbnQpIGNvbXB1dGVkIGFzIGEgY3ViaWMgYmV6aWVyXHJcbiAgICogY3VydmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHNpemUgVGhlIG5vZGUgc2l6ZS5cclxuICAgKiBAcmV0dXJuIHt4MSx5MSx4Mix5Mn0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY29udHJvbCBwb2ludHMuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oeCAsIHksIHNpemUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHgxOiB4IC0gc2l6ZSAqIDcsXHJcbiAgICAgIHkxOiB5LFxyXG4gICAgICB4MjogeCxcclxuICAgICAgeTI6IHkgKyBzaXplICogN1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMgb2YgYSBwbGFuZVxyXG4gICAqIHdpdGggYW4gb3J0aG9ub3JtYWwgYmFzaXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBldWNsaWRpYW4gZGlzdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSkge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDEgLSB4MCkgKiAoeDEgLSB4MCkgKyAoeTEgLSB5MCkgKiAoeTEgLSB5MCkpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludHMgb2YgdHdvIGNpcmNsZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgwICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgZmlyc3RcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MCAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gcjAgIFRoZSByYWRpdXMgb2YgdGhlIGZpcnN0IGNpcmNsZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTEgIFRoZSBZIGNvb3JkaW5hdGUgb2YgY2VudGVyIGxvY2F0aW9uIG9mIHRoZSBzZWNvbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSByMSAgVGhlIHJhZGl1cyBvZiB0aGUgc2Vjb25kIGNpcmNsZS5cclxuICAgKiBAcmV0dXJuIHt4aSx5aX0gICAgICBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGludGVyc2VjdGlvbiBwb2ludHMuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0Q2lyY2xlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTIyMTk4MDJcclxuICAgIHZhciBhLCBkeCwgZHksIGQsIGgsIHJ4LCByeSwgeDIsIHkyO1xyXG5cclxuICAgIC8vIGR4IGFuZCBkeSBhcmUgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGRpc3RhbmNlcyBiZXR3ZWVuIHRoZSBjaXJjbGVcclxuICAgIC8vIGNlbnRlcnM6XHJcbiAgICBkeCA9IHgxIC0geDA7XHJcbiAgICBkeSA9IHkxIC0geTA7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzdHJhaWdodC1saW5lIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnM6XHJcbiAgICBkID0gTWF0aC5zcXJ0KChkeSAqIGR5KSArIChkeCAqIGR4KSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIHNvbHZhYmlsaXR5OlxyXG4gICAgaWYgKGQgPiAocjAgKyByMSkpIHtcclxuICAgICAgICAvLyBObyBzb2x1dGlvbi4gY2lyY2xlcyBkbyBub3QgaW50ZXJzZWN0LlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChkIDwgTWF0aC5hYnMocjAgLSByMSkpIHtcclxuICAgICAgICAvLyBObyBzb2x1dGlvbi4gb25lIGNpcmNsZSBpcyBjb250YWluZWQgaW4gdGhlIG90aGVyLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLydwb2ludCAyJyBpcyB0aGUgcG9pbnQgd2hlcmUgdGhlIGxpbmUgdGhyb3VnaCB0aGUgY2lyY2xlIGludGVyc2VjdGlvblxyXG4gICAgLy8gcG9pbnRzIGNyb3NzZXMgdGhlIGxpbmUgYmV0d2VlbiB0aGUgY2lyY2xlIGNlbnRlcnMuXHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDAgdG8gcG9pbnQgMjpcclxuICAgIGEgPSAoKHIwICogcjApIC0gKHIxICogcjEpICsgKGQgKiBkKSkgLyAoMi4wICogZCk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBjb29yZGluYXRlcyBvZiBwb2ludCAyOlxyXG4gICAgeDIgPSB4MCArIChkeCAqIGEgLyBkKTtcclxuICAgIHkyID0geTAgKyAoZHkgKiBhIC8gZCk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDIgdG8gZWl0aGVyIG9mIHRoZSBpbnRlcnNlY3Rpb25cclxuICAgIC8vIHBvaW50czpcclxuICAgIGggPSBNYXRoLnNxcnQoKHIwICogcjApIC0gKGEgKiBhKSk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvZmZzZXRzIG9mIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRzIGZyb20gcG9pbnQgMjpcclxuICAgIHJ4ID0gLWR5ICogKGggLyBkKTtcclxuICAgIHJ5ID0gZHggKiAoaCAvIGQpO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0aGUgYWJzb2x1dGUgaW50ZXJzZWN0aW9uIHBvaW50czpcclxuICAgIHZhciB4aSA9IHgyICsgcng7XHJcbiAgICB2YXIgeGlfcHJpbWUgPSB4MiAtIHJ4O1xyXG4gICAgdmFyIHlpID0geTIgKyByeTtcclxuICAgIHZhciB5aV9wcmltZSA9IHkyIC0gcnk7XHJcblxyXG4gICAgcmV0dXJuIHt4aTogeGksIHhpX3ByaW1lOiB4aV9wcmltZSwgeWk6IHlpLCB5aV9wcmltZTogeWlfcHJpbWV9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgbGluZSBzZWdtZW50LlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXHJcbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmIHBvaW50IGlzIFwiY2xvc2UgdG9cIiB0aGUgbGluZVxyXG4gICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICovXHJcbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBlcHNpbG9uKSB7XHJcbiAgICByZXR1cm4gc2lnbWEudXRpbHMuZGlzdGFuY2VQb2ludFRvU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5MikgPCBlcHNpbG9uO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAgKiBDb21wdXRlIHRoZSBkaXN0YW5jZSBvZiBhIHBvaW50IHRvIGEgbGluZSBzZWdtZW50LlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBsaW5lIGVuZCBwb2ludC5cclxuICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgIERpc3RhbmNlIHRvIHRoZSBzZWdtZW50XHJcbiAgKi9cclxuICBzaWdtYS51dGlscy5kaXN0YW5jZVBvaW50VG9TZWdtZW50ID0gZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY4NTM5MjYvMTA3NTE5NVxyXG4gICAgdmFyIEEgPSB4IC0geDEsXHJcbiAgICAgICAgQiA9IHkgLSB5MSxcclxuICAgICAgICBDID0geDIgLSB4MSxcclxuICAgICAgICBEID0geTIgLSB5MSxcclxuICAgICAgICBkb3QgPSBBICogQyArIEIgKiBELFxyXG4gICAgICAgIGxlbl9zcSA9IEMgKiBDICsgRCAqIEQsXHJcbiAgICAgICAgcGFyYW0gPSAtMSxcclxuICAgICAgICB4eCwgeXk7XHJcblxyXG4gICAgaWYgKGxlbl9zcSAhPT0gMCkgLy9pbiBjYXNlIG9mIDAgbGVuZ3RoIGxpbmVcclxuICAgICAgICBwYXJhbSA9IGRvdCAvIGxlbl9zcTtcclxuXHJcbiAgICBpZiAocGFyYW0gPCAwKSB7XHJcbiAgICAgIHh4ID0geDE7XHJcbiAgICAgIHl5ID0geTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJhbSA+IDEpIHtcclxuICAgICAgeHggPSB4MjtcclxuICAgICAgeXkgPSB5MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xyXG4gICAgICB5eSA9IHkxICsgcGFyYW0gKiBEO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkeCA9IHggLSB4eDtcclxuICAgIHZhciBkeSA9IHkgLSB5eTtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgc3RhcnQgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHggICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5ICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cclxuICAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgIFRydWUgaWYgKHgseSkgaXMgb24gdGhlIGN1cnZlIHNlZ21lbnQsXHJcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXHJcbiAgKi9cclxuICBzaWdtYS51dGlscy5pc1BvaW50T25RdWFkcmF0aWNDdXJ2ZSA9XHJcbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHksIGVwc2lsb24pIHtcclxuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxyXG4gICAgLy8gcHJldmVudGluZyBmb3IgbW9yZSBjb3N0bHkgY29tcHV0YXRpb246XHJcbiAgICB2YXIgZFAxUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mik7XHJcbiAgICBpZiAoTWF0aC5hYnMoeCAtIHgxKSA+IGRQMVAyIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFQMikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGRQMSA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHgxLCB5MSksXHJcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcclxuICAgICAgICB0ID0gMC41LFxyXG4gICAgICAgIHIgPSAoZFAxIDwgZFAyKSA/IC0wLjAxIDogMC4wMSxcclxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXHJcbiAgICAgICAgaSA9IDEwMCxcclxuICAgICAgICBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZSh0LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHkpLFxyXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXHJcbiAgICAgICAgb2xkX2R0O1xyXG5cclxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxyXG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXHJcbiAgICAvLyBwb2ludCBvZiB0aGUgY3VydmUsIHN0YXJ0aW5nIGZyb20gdD0wLjUuXHJcbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cclxuICAgIHdoaWxlIChpLS0gPiAwICYmXHJcbiAgICAgIHQgPj0gMCAmJiB0IDw9IDEgJiZcclxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcclxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcclxuICAgICAgb2xkX2R0ID0gZHQ7XHJcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSk7XHJcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XHJcblxyXG4gICAgICBpZiAoZHQgPiBvbGRfZHQpIHtcclxuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcclxuICAgICAgICAvLyBoYWxmc3RlcCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXHJcbiAgICAgICAgciA9IC1yIC8gMjtcclxuICAgICAgICB0ICs9IHI7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAodCArIHIgPCAwIHx8IHQgKyByID4gMSkge1xyXG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcclxuICAgICAgICAvLyByZXZlcnQgd2l0aCBhIGhhbGZzdGVwXHJcbiAgICAgICAgciA9IHIgLyAyO1xyXG4gICAgICAgIGR0ID0gb2xkX2R0O1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHByb2dyZXNzOlxyXG4gICAgICAgIHQgKz0gcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkdCA8IGVwc2lsb247XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIHNlZ21lbnQgd2l0aCBhIHRoaWNrbmVzcy5cclxuICAgICpcclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gY2hlY2suXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweDEgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgMXN0IGN1cnZlIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5MSAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSAxc3QgY3VydmUgY29udHJvbCBwb2ludC5cclxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgyICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxyXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweTIgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgMm5kIGN1cnZlIGNvbnRyb2wgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSAge251bWJlcn0gZXBzaWxvbiBUaGUgcHJlY2lzaW9uIChjb25zaWRlciB0aGUgbGluZSB0aGlja25lc3MpLlxyXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cclxuICAqL1xyXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlID1cclxuICAgIGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBlcHNpbG9uKSB7XHJcbiAgICAvLyBGYWlscyBpZiB0aGUgcG9pbnQgaXMgdG9vIGZhciBmcm9tIHRoZSBleHRyZW1pdGllcyBvZiB0aGUgc2VnbWVudCxcclxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxyXG4gICAgdmFyIGRQMUNQMSA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgxLCB5MSwgY3B4MSwgY3B5MSk7XHJcbiAgICBpZiAoTWF0aC5hYnMoeCAtIHgxKSA+IGRQMUNQMSB8fCBNYXRoLmFicyh5IC0geTEpID4gZFAxQ1AxKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcclxuICAgICAgICBkUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCB4MiwgeTIpLFxyXG4gICAgICAgIHQgPSAwLjUsXHJcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxyXG4gICAgICAgIHJUaHJlc2hvbGQgPSAwLjAwMSxcclxuICAgICAgICBpID0gMTAwLFxyXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxyXG4gICAgICAgICAgdCwgeDEsIHkxLCB4MiwgeTIsIGNweDEsIGNweTEsIGNweDIsIGNweTIpLFxyXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXHJcbiAgICAgICAgb2xkX2R0O1xyXG5cclxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxyXG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXHJcbiAgICAvLyBwb2ludCBvZiB0aGUgY3VydmUsIHN0YXJ0aW5nIGZyb20gdD0wLjUuXHJcbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cclxuICAgIHdoaWxlIChpLS0gPiAwICYmXHJcbiAgICAgIHQgPj0gMCAmJiB0IDw9IDEgJiZcclxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcclxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcclxuICAgICAgb2xkX2R0ID0gZHQ7XHJcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxyXG4gICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKTtcclxuICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KTtcclxuXHJcbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xyXG4gICAgICAgIC8vIG5vdCB0aGUgcmlnaHQgZGlyZWN0aW9uOlxyXG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cclxuICAgICAgICByID0gLXIgLyAyO1xyXG4gICAgICAgIHQgKz0gcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XHJcbiAgICAgICAgLy8gb29wcywgd2UndmUgZ29uZSB0b28gZmFyOlxyXG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcclxuICAgICAgICByID0gciAvIDI7XHJcbiAgICAgICAgZHQgPSBvbGRfZHQ7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcHJvZ3Jlc3M6XHJcbiAgICAgICAgdCArPSByO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogKioqKioqKioqKioqXHJcbiAgICogRVZFTlRTIFVUSUxTOlxyXG4gICAqICoqKioqKioqKioqKlxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIEhlcmUgYXJlIHNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB0byB1bmlmeSBleHRyYWN0aW9uIG9mIHRoZSBpbmZvcm1hdGlvbiB3ZVxyXG4gICAqIG5lZWQgd2l0aCBtb3VzZSBldmVudHMgYW5kIHRvdWNoIGV2ZW50cywgZnJvbSBkaWZmZXJlbnQgYnJvd3NlcnM6XHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFggcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBYIHZhbHVlIG9mIHRoZSBtb3VzZS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRYID0gZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgKGUub2Zmc2V0WCAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WCkgfHxcclxuICAgICAgKGUubGF5ZXJYICE9PSB1bmRlZmluZWQgJiYgZS5sYXllclgpIHx8XHJcbiAgICAgIChlLmNsaWVudFggIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFgpXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFkgcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBZIHZhbHVlIG9mIHRoZSBtb3VzZS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRZID0gZnVuY3Rpb24oZSkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgKGUub2Zmc2V0WSAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WSkgfHxcclxuICAgICAgKGUubGF5ZXJZICE9PSB1bmRlZmluZWQgJiYgZS5sYXllclkpIHx8XHJcbiAgICAgIChlLmNsaWVudFkgIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFkpXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgc2NyZWVuLiBUYWtpbmcgem9vbSBpbnRvIGFjY291bnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcmF0aW8gPSAxO1xyXG4gICAgaWYgKHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgIHdpbmRvdy5zY3JlZW4ubG9naWNhbFhEUEkgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgPiB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XHJcbiAgICAgICAgcmF0aW8gPSB3aW5kb3cuc2NyZWVuLnN5c3RlbVhEUEkgLyB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF0aW87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXh0cmFjdCB0aGUgd2lkdGggZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aWR0aCBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0V2lkdGggPSBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgdyA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XHJcbiAgICAgICAgICAgICAgZS50YXJnZXQud2lkdGggOlxyXG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC53aWR0aDtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAodHlwZW9mIHcgPT09ICdudW1iZXInICYmIHcpIHx8XHJcbiAgICAgICh3ICE9PSB1bmRlZmluZWQgJiYgdy5iYXNlVmFsICE9PSB1bmRlZmluZWQgJiYgdy5iYXNlVmFsLnZhbHVlKVxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0IHRoZSBjZW50ZXIgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBjZW50ZXIgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmdldENlbnRlciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIHZhciByYXRpbyA9IGUudGFyZ2V0Lm5hbWVzcGFjZVVSSS5pbmRleE9mKCdzdmcnKSAhPT0gLTEgPyAxIDpcclxuICAgICAgICBzaWdtYS51dGlscy5nZXRQaXhlbFJhdGlvKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBzaWdtYS51dGlscy5nZXRXaWR0aChlKSAvICgyICogcmF0aW8pLFxyXG4gICAgICB5OiBzaWdtYS51dGlscy5nZXRIZWlnaHQoZSkgLyAoMiAqIHJhdGlvKSxcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBtb3VzZSBjb29yZHMgdG8gc2lnbWEgY29vcmRzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeCBjb29yZCB0byBjb252ZXJ0XHJcbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeSBjb29yZCB0byBjb252ZXJ0XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBzdGFuZGFyZGl6ZWQgZXZlbnRcclxuICAgKi9cclxuICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyA9IGZ1bmN0aW9uKGUsIHgsIHkpIHtcclxuICAgIHggPSB4IHx8IHNpZ21hLnV0aWxzLmdldFgoZSk7XHJcbiAgICB5ID0geSB8fCBzaWdtYS51dGlscy5nZXRZKGUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB4OiB4IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXHJcbiAgICAgICAgeTogeSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxyXG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcclxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXHJcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxyXG4gICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcclxuICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxyXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4dHJhY3QgdGhlIGhlaWdodCBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGhlaWdodCBvZiB0aGUgZXZlbnQncyB0YXJnZXQuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIGggPSAoIWUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkgP1xyXG4gICAgICAgICAgICAgIGUudGFyZ2V0LmhlaWdodCA6XHJcbiAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJTVkdFbGVtZW50LmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAodHlwZW9mIGggPT09ICdudW1iZXInICYmIGgpIHx8XHJcbiAgICAgIChoICE9PSB1bmRlZmluZWQgJiYgaC5iYXNlVmFsICE9PSB1bmRlZmluZWQgJiYgaC5iYXNlVmFsLnZhbHVlKVxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0IHRoZSB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIHdoZWVsIGRlbHRhIG9mIHRoZSBtb3VzZS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXREZWx0YSA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIChlLndoZWVsRGVsdGEgIT09IHVuZGVmaW5lZCAmJiBlLndoZWVsRGVsdGEpIHx8XHJcbiAgICAgIChlLmRldGFpbCAhPT0gdW5kZWZpbmVkICYmIC1lLmRldGFpbClcclxuICAgICk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0IG9mIGEgRE9NIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb20gVGhlIGVsZW1lbnQgdG8gcmV0cmlldmUgdGhlIHBvc2l0aW9uLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgb2Zmc2V0IG9mIHRoZSBET00gZWxlbWVudCAodG9wLCBsZWZ0KS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5nZXRPZmZzZXQgPSBmdW5jdGlvbihkb20pIHtcclxuICAgIHZhciBsZWZ0ID0gMCxcclxuICAgICAgICB0b3AgPSAwO1xyXG5cclxuICAgIHdoaWxlIChkb20pIHtcclxuICAgICAgdG9wID0gdG9wICsgcGFyc2VJbnQoZG9tLm9mZnNldFRvcCk7XHJcbiAgICAgIGxlZnQgPSBsZWZ0ICsgcGFyc2VJbnQoZG9tLm9mZnNldExlZnQpO1xyXG4gICAgICBkb20gPSBkb20ub2Zmc2V0UGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogdG9wLFxyXG4gICAgICBsZWZ0OiBsZWZ0XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNpbXVsYXRlcyBhIFwiZG91YmxlIGNsaWNrXCIgZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgVGhlIGV2ZW50IHRhcmdldC5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGNsaWNrcyA9IDAsXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaGFuZGxlcnM7XHJcblxyXG4gICAgdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXIgPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fTtcclxuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gfHwgW107XHJcbiAgICBoYW5kbGVycyA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdO1xyXG5cclxuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oZSkge1xyXG4gICAgICBjbGlja3MrKztcclxuXHJcbiAgICAgIGlmIChjbGlja3MgPT09IDIpIHtcclxuICAgICAgICBjbGlja3MgPSAwO1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcclxuICAgICAgfSBlbHNlIGlmIChjbGlja3MgPT09IDEpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgY2xpY2tzID0gMDtcclxuICAgICAgICB9LCBzaWdtYS5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyc1toYW5kbGVycy5sZW5ndGggLSAxXSwgZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVuYmluZCBzaW11bGF0ZWQgXCJkb3VibGUgY2xpY2tcIiBldmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgVGhlIGV2ZW50IHRhcmdldC5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUpIHtcclxuICAgIHZhciBoYW5kbGVyLFxyXG4gICAgICAgIGhhbmRsZXJzID0gKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXSB8fCBbXTtcclxuXHJcbiAgICB3aGlsZSAoKGhhbmRsZXIgPSBoYW5kbGVycy5wb3AoKSkpIHtcclxuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlICh0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fSlbdHlwZV07XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogSGVyZSBhcmUganVzdCBzb21lIG9mIHRoZSBtb3N0IGJhc2ljIGVhc2luZyBmdW5jdGlvbnMsIHVzZWQgZm9yIHRoZVxyXG4gICAqIGFuaW1hdGVkIGNhbWVyYSBcImdvVG9cIiBjYWxscy5cclxuICAgKlxyXG4gICAqIElmIHlvdSBuZWVkIHNvbWUgbW9yZSBlYXNpbmdzIGZ1bmN0aW9ucywgZG9uJ3QgaGVzaXRhdGUgdG8gYWRkIHRoZW0gdG9cclxuICAgKiBzaWdtYS51dGlscy5lYXNpbmdzLiBCdXQgSSB3aWxsIG5vdCBhZGQgc29tZSBtb3JlIGhlcmUgb3IgbWVyZ2UgUFJzXHJcbiAgICogY29udGFpbmluZywgYmVjYXVzZSBJIGRvIG5vdCB3YW50IHNpZ21hIHNvdXJjZXMgZnVsbCBvZiBvdmVya2lsbCBhbmQgbmV2ZXJcclxuICAgKiB1c2VkIHN0dWZmLi4uXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuZWFzaW5ncyA9IHNpZ21hLnV0aWxzLmVhc2luZ3MgfHwge307XHJcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5saW5lYXJOb25lID0gZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIGs7XHJcbiAgfTtcclxuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luID0gZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIGsgKiBrO1xyXG4gIH07XHJcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNPdXQgPSBmdW5jdGlvbihrKSB7XHJcbiAgICByZXR1cm4gayAqICgyIC0gayk7XHJcbiAgfTtcclxuICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luT3V0ID0gZnVuY3Rpb24oaykge1xyXG4gICAgaWYgKChrICo9IDIpIDwgMSlcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xyXG4gICAgcmV0dXJuIC0gMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcclxuICB9O1xyXG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbiA9IGZ1bmN0aW9uKGspIHtcclxuICAgIHJldHVybiBrICogayAqIGs7XHJcbiAgfTtcclxuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljT3V0ID0gZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcclxuICB9O1xyXG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcclxuICAgIGlmICgoayAqPSAyKSA8IDEpXHJcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XHJcbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiAqKioqKioqKioqKipcclxuICAgKiBXRUJHTCBVVElMUzpcclxuICAgKiAqKioqKioqKioqKipcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydCB3ZWJnbFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5pc1dlYkdMU3VwcG9ydGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY2FudmFzLFxyXG4gICAgICAgIHdlYmdsID0gISF3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xyXG4gICAgaWYgKHdlYmdsKSB7XHJcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAhIShcclxuICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8XHJcbiAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJylcclxuICAgICAgICApO1xyXG4gICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIExvYWRzIGEgV2ViR0wgc2hhZGVyIGFuZCByZXR1cm5zIGl0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7V2ViR0xDb250ZXh0fSAgICAgICAgICAgZ2wgICAgICAgICAgIFRoZSBXZWJHTENvbnRleHQgdG8gdXNlLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgIHNoYWRlclNvdXJjZSBUaGUgc2hhZGVyIHNvdXJjZS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICBzaGFkZXJUeXBlICAgVGhlIHR5cGUgb2Ygc2hhZGVyLlxyXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxyXG4gICAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBzaGFkZXIuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMubG9hZFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUsIGVycm9yKSB7XHJcbiAgICB2YXIgY29tcGlsZWQsXHJcbiAgICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xyXG5cclxuICAgIC8vIExvYWQgdGhlIHNoYWRlciBzb3VyY2VcclxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XHJcblxyXG4gICAgLy8gQ29tcGlsZSB0aGUgc2hhZGVyXHJcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlIGNvbXBpbGUgc3RhdHVzXHJcbiAgICBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcclxuXHJcbiAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZzpcclxuICAgIGlmICghY29tcGlsZWQpIHtcclxuICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgZXJyb3IoXHJcbiAgICAgICAgICAnRXJyb3IgY29tcGlsaW5nIHNoYWRlciBcIicgKyBzaGFkZXIgKyAnXCI6JyArXHJcbiAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNoYWRlcjtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgcHJvZ3JhbSwgYXR0YWNoZXMgc2hhZGVycywgYmluZHMgYXR0cmliIGxvY2F0aW9ucywgbGlua3MgdGhlXHJcbiAgICogcHJvZ3JhbSBhbmQgY2FsbHMgdXNlUHJvZ3JhbS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0FycmF5LjxXZWJHTFNoYWRlcj59ICAgIHNoYWRlcnMgICBUaGUgc2hhZGVycyB0byBhdHRhY2guXHJcbiAgICogQHBhcmFtICB7QXJyYXkuPHN0cmluZz59ICAgICAgICAgYXR0cmlicyAgIFRoZSBhdHRyaWJzIG5hbWVzLlxyXG4gICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSAgICAgICAgIGxvY2F0aW9ucyBUaGUgbG9jYXRpb25zIGZvciB0aGUgYXR0cmlicy5cclxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBlcnJvciAgICAgQ2FsbGJhY2sgZm9yIGVycm9ycy5cclxuICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19ICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgcHJvZ3JhbS5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJzLCBhdHRyaWJzLCBsb2MsIGVycm9yKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsaW5rZWQsXHJcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2hhZGVycy5sZW5ndGg7ICsraSlcclxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xyXG5cclxuICAgIGlmIChhdHRyaWJzKVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7ICsraSlcclxuICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oXHJcbiAgICAgICAgICBwcm9ncmFtLFxyXG4gICAgICAgICAgbG9jYXRpb25zID8gbG9jYXRpb25zW2ldIDogaSxcclxuICAgICAgICAgIG9wdF9hdHRyaWJzW2ldXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuXHJcbiAgICAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcclxuICAgIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgaWYgKCFsaW5rZWQpIHtcclxuICAgICAgaWYgKGVycm9yKVxyXG4gICAgICAgIGVycm9yKCdFcnJvciBpbiBwcm9ncmFtIGxpbmtpbmc6ICcgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcblxyXG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJvZ3JhbTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAqKioqKioqKipcclxuICAgKiBNQVRSSUNFUzpcclxuICAgKiAqKioqKioqKipcclxuICAgKiBUaGUgZm9sbG93aW5nIHV0aWxzIGFyZSBqdXN0IGhlcmUgdG8gaGVscCBnZW5lcmF0aW5nIHRoZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAqIG1hdHJpY2VzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXJzLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEudXRpbHMubWF0cmljZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJldHVybnMgYSAzeDMgdHJhbnNsYXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCB0cmFuc2xhdGlvbi5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR5IFRoZSBZIHRyYW5zbGF0aW9uLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnRyYW5zbGF0aW9uID0gZnVuY3Rpb24oZHgsIGR5KSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAxLCAwLCAwLFxyXG4gICAgICAwLCAxLCAwLFxyXG4gICAgICBkeCwgZHksIDFcclxuICAgIF07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIHJvdGF0aW9uIG1hdHJpeC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gIGFuZ2xlIFRoZSByb3RhdGlvbiBhbmdsZS5cclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBtMiAgICBJZiB0cnVlLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSAyeDIgbWF0cml4LlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbiA9IGZ1bmN0aW9uKGFuZ2xlLCBtMikge1xyXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcclxuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgcmV0dXJuIG0yID8gW1xyXG4gICAgICBjb3MsIC1zaW4sXHJcbiAgICAgIHNpbiwgY29zXHJcbiAgICBdIDogW1xyXG4gICAgICBjb3MsIC1zaW4sIDAsXHJcbiAgICAgIHNpbiwgY29zLCAwLFxyXG4gICAgICAwLCAwLCAxXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIG9yIDJ4MiBob21vdGhldGljIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gIHJhdGlvIFRoZSBzY2FsaW5nIHJhdGlvLlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlID0gZnVuY3Rpb24ocmF0aW8sIG0yKSB7XHJcbiAgICByZXR1cm4gbTIgPyBbXHJcbiAgICAgIHJhdGlvLCAwLFxyXG4gICAgICAwLCByYXRpb1xyXG4gICAgXSA6IFtcclxuICAgICAgcmF0aW8sIDAsIDAsXHJcbiAgICAgIDAsIHJhdGlvLCAwLFxyXG4gICAgICAwLCAwLCAxXHJcbiAgICBdO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSByZXR1cm5zIGEgM3gzIG9yIDJ4MiBob21vdGhldGljIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIGEgIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAgICogQHBhcmFtICB7YXJyYXl9ICAgYiAgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgYXNzdW1lIGJvdGggbWF0cmljZXMgYXJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgMngyLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseSA9IGZ1bmN0aW9uKGEsIGIsIG0yKSB7XHJcbiAgICB2YXIgbCA9IG0yID8gMiA6IDMsXHJcbiAgICAgICAgYTAwID0gYVswICogbCArIDBdLFxyXG4gICAgICAgIGEwMSA9IGFbMCAqIGwgKyAxXSxcclxuICAgICAgICBhMDIgPSBhWzAgKiBsICsgMl0sXHJcbiAgICAgICAgYTEwID0gYVsxICogbCArIDBdLFxyXG4gICAgICAgIGExMSA9IGFbMSAqIGwgKyAxXSxcclxuICAgICAgICBhMTIgPSBhWzEgKiBsICsgMl0sXHJcbiAgICAgICAgYTIwID0gYVsyICogbCArIDBdLFxyXG4gICAgICAgIGEyMSA9IGFbMiAqIGwgKyAxXSxcclxuICAgICAgICBhMjIgPSBhWzIgKiBsICsgMl0sXHJcbiAgICAgICAgYjAwID0gYlswICogbCArIDBdLFxyXG4gICAgICAgIGIwMSA9IGJbMCAqIGwgKyAxXSxcclxuICAgICAgICBiMDIgPSBiWzAgKiBsICsgMl0sXHJcbiAgICAgICAgYjEwID0gYlsxICogbCArIDBdLFxyXG4gICAgICAgIGIxMSA9IGJbMSAqIGwgKyAxXSxcclxuICAgICAgICBiMTIgPSBiWzEgKiBsICsgMl0sXHJcbiAgICAgICAgYjIwID0gYlsyICogbCArIDBdLFxyXG4gICAgICAgIGIyMSA9IGJbMiAqIGwgKyAxXSxcclxuICAgICAgICBiMjIgPSBiWzIgKiBsICsgMl07XHJcblxyXG4gICAgcmV0dXJuIG0yID8gW1xyXG4gICAgICBhMDAgKiBiMDAgKyBhMDEgKiBiMTAsXHJcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSxcclxuICAgICAgYTEwICogYjAwICsgYTExICogYjEwLFxyXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTFcclxuICAgIF0gOiBbXHJcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCArIGEwMiAqIGIyMCxcclxuICAgICAgYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxLFxyXG4gICAgICBhMDAgKiBiMDIgKyBhMDEgKiBiMTIgKyBhMDIgKiBiMjIsXHJcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCArIGExMiAqIGIyMCxcclxuICAgICAgYTEwICogYjAxICsgYTExICogYjExICsgYTEyICogYjIxLFxyXG4gICAgICBhMTAgKiBiMDIgKyBhMTEgKiBiMTIgKyBhMTIgKiBiMjIsXHJcbiAgICAgIGEyMCAqIGIwMCArIGEyMSAqIGIxMCArIGEyMiAqIGIyMCxcclxuICAgICAgYTIwICogYjAxICsgYTIxICogYjExICsgYTIyICogYjIxLFxyXG4gICAgICBhMjAgKiBiMDIgKyBhMjEgKiBiMTIgKyBhMjIgKiBiMjJcclxuICAgIF07XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqICoqKioqKioqKioqKlxyXG4gICAqIENBTlZBUyBVVElMUzpcclxuICAgKiAqKioqKioqKioqKipcclxuICAgKi9cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0IGVpdGhlciBhcHByb3hpbWF0ZWQgdmlhIHRoZSBmb250IHNpemUgb3JcclxuICAgKiB2aWEgdGhlIG1vcmUgZXhwZW5zaXZlIGJ1dCBhY2N1cmF0ZSBjb250ZXh0Lm1lYXN1cmVUZXh0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgIGFwcHJveGltYXRlICAgQXBwcm94aW1hdGUgb3Igbm90LlxyXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICAgICBmb250U2l6ZSAgICAgIEZvbnQgc2l6ZSBvZiB0aGUgdGV4dC5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdGV4dCAgICAgICAgICBUaGUgdGV4dCB0byB1c2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtmbG9hdH0gICAgICAgUmV0dXJucyB0aGUgd2lkdGguXHJcbiAgICovXHJcbiAgIHNpZ21hLnV0aWxzLmNhbnZhcyA9IHt9O1xyXG4gICBzaWdtYS51dGlscy5jYW52YXMuZ2V0VGV4dFdpZHRoID1cclxuICAgICAgICBmdW5jdGlvbihjb250ZXh0LCBhcHByb3hpbWF0ZSwgZm9udFNpemUsIHRleHQpIHtcclxuXHJcbiAgICBpZiAoIXRleHQpIHJldHVybiAwO1xyXG5cclxuICAgIHJldHVybiBhcHByb3hpbWF0ZSA/IDAuNiAqIHRleHQubGVuZ3RoICogZm9udFNpemUgOlxyXG4gICAgICBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2hhZG93IHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGNvbnRleHQgYWNjb3JkaW5nIHRvIHRoZSBsZXZlbFxyXG4gICAqIHRvIGNyZWF0ZSB2aXN1YWwgZGVwdGguXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICBsZXZlbCAgICAgVGhlIGxldmVsIChmcm9tIDEgdG8gNSkuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuY2FudmFzLnNldExldmVsID0gZnVuY3Rpb24obGV2ZWwsIGNvbnRleHQpIHtcclxuICAgIGlmIChsZXZlbCkge1xyXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAvLyBpbnNwaXJlZCBieSBNYXRlcmlhbCBEZXNpZ24gc2hhZG93cywgbGV2ZWwgZnJvbSAxIHRvIDU6XHJcbiAgICAgIHN3aXRjaChsZXZlbCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDEuNTtcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDQ7XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMC4zNiknO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMztcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDEyO1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMzkpJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDY7XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAxMjtcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwLjQyKSc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAxMDtcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDIwO1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDAuNDcpJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDE1O1xyXG4gICAgICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gMjQ7XHJcbiAgICAgICAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMC41MiknO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgc2hhZG93IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLmNhbnZhcy5yZXNldExldmVsID0gZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcclxuICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XHJcbiAgICBjb250ZXh0LnNoYWRvd0NvbG9yID0gJyMwMDAwMDAnO1xyXG4gIH07XHJcblxyXG4gIC8vIGluY3JlbWVudGFsbHkgc2NhbGVkLCBub3QgYXV0b21hdGljYWxseSByZXNpemVkIGZvciBub3dcclxuICAvLyAoaWUuIHBvc3NpYmxlIG1lbW9yeSBsZWFrIGlmIHRoZXJlIGFyZSBtYW55IGdyYXBoIGxvYWQgLyB1bmxvYWQpXHJcbiAgdmFyIGltZ0NhY2hlID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIERyYXcgYW4gaW1hZ2UgaW5zaWRlIHRoZSBzcGVjaWZpZWQgbm9kZSBvbiB0aGUgY2FudmFzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICB4ICAgICAgICBUaGUgbm9kZSB4IGNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICB5ICAgICAgICBUaGUgbm9kZSB5IGNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICBzaXplICAgICBUaGUgbm9kZSBzaXplLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAgICAgaW1nQ3Jvc3NPcmlnaW4gQ3Jvc3Mtb3JpZ2luIFVSTCBvciAnKicuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCBEaXNwbGF5IGlmIG5vZGUgc2l6ZSBpcyBsYXJnZXJcclxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgICAgICAgICAgICAgIGNsaXBGbiAgICBUaGUgY2xpcHBpbmcgc2hhcGUgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuY2FudmFzLmRyYXdJbWFnZSA9XHJcbiAgICBmdW5jdGlvbihub2RlLCB4LCB5LCBzaXplLCBjb250ZXh0LCBpbWdDcm9zc09yaWdpbiwgdGhyZXNob2xkLCBjbGlwRm4pIHtcclxuXHJcbiAgICBpZighbm9kZS5pbWFnZSB8fCAhbm9kZS5pbWFnZS51cmwgfHwgc2l6ZSA8IHRocmVzaG9sZCkgcmV0dXJuO1xyXG5cclxuICAgIHZhciB1cmwgPSBub2RlLmltYWdlLnVybDtcclxuICAgIHZhciBpaCA9IG5vZGUuaW1hZ2UuaCB8fCAxOyAvLyAxIGlzIGFyYml0cmFyeSwgYW55d2F5IG9ubHkgdGhlIHJhdGlvIGNvdW50c1xyXG4gICAgdmFyIGl3ID0gbm9kZS5pbWFnZS53IHx8IDE7XHJcbiAgICB2YXIgc2NhbGUgPSBub2RlLmltYWdlLnNjYWxlIHx8IDE7XHJcbiAgICB2YXIgY2xpcCA9IG5vZGUuaW1hZ2UuY2xpcCB8fCAxO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBuZXcgSU1HIG9yIGdldCBmcm9tIGltZ0NhY2hlXHJcbiAgICB2YXIgaW1hZ2UgPSBpbWdDYWNoZVt1cmxdO1xyXG4gICAgaWYoIWltYWdlKSB7XHJcbiAgICAgIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU1HJyk7XHJcbiAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnY3Jvc3NPcmlnaW4nLCBpbWdDcm9zc09yaWdpbik7XHJcbiAgICAgIGltYWdlLnNyYyA9IHVybDtcclxuICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZXNpemUnKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGltZ0NhY2hlW3VybF0gPSBpbWFnZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb24gYW5kIGRyYXdcclxuICAgIHZhciB4cmF0aW8gPSAoaXcgPCBpaCkgPyAoaXcgLyBpaCkgOiAxO1xyXG4gICAgdmFyIHlyYXRpbyA9IChpaCA8IGl3KSA/IChpaCAvIGl3KSA6IDE7XHJcbiAgICB2YXIgciA9IHNpemUgKiBzY2FsZTtcclxuXHJcbiAgICBjb250ZXh0LnNhdmUoKTsgLy8gZW50ZXIgY2xpcHBpbmcgbW9kZVxyXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgaWYgKHR5cGVvZiBjbGlwRm4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgY2xpcEZuKG5vZGUsIHgsIHksIHNpemUsIGNvbnRleHQsIGNsaXApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIERyYXcgdGhlIGNsaXBwaW5nIGRpc2M6XHJcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIHNpemUgKiBjbGlwLCAwLCBNYXRoLiBQSSAqIDIsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGNvbnRleHQuY2xpcCgpO1xyXG5cclxuICAgIC8vIERyYXcgdGhlIGFjdHVhbCBpbWFnZVxyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgIGltYWdlLFxyXG4gICAgICB4ICsgTWF0aC5zaW4oLTMuMTQyIC8gNCkgKiByICogeHJhdGlvLFxyXG4gICAgICB5IC0gTWF0aC5jb3MoLTMuMTQyIC8gNCkgKiByICogeXJhdGlvLFxyXG4gICAgICByICogeHJhdGlvICogMiAqIE1hdGguc2luKC0zLjE0MiAvIDQpICogKC0xKSxcclxuICAgICAgciAqIHlyYXRpbyAqIDIgKiBNYXRoLmNvcygtMy4xNDIgLyA0KVxyXG4gICAgKTtcclxuICAgIGNvbnRleHQucmVzdG9yZSgpOyAvLyBleGl0IGNsaXBwaW5nIG1vZGVcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEcmF3IGFuIGljb24gaW5zaWRlIHRoZSBzcGVjaWZpZWQgbm9kZSBvbiB0aGUgY2FudmFzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICB4ICAgICAgICBUaGUgbm9kZSB4IGNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICB5ICAgICAgICBUaGUgbm9kZSB5IGNvb3JkaW5hdGUuXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgICAgICAgICAgICAgICAgICBzaXplICAgICBUaGUgbm9kZSBzaXplLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgRGlzcGxheSBpZiBub2RlIHNpemUgaXMgbGFyZ2VyXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMuY2FudmFzLmRyYXdJY29uID0gZnVuY3Rpb24obm9kZSwgeCwgeSwgc2l6ZSwgY29udGV4dCwgdGhyZXNob2xkKXtcclxuICAgIGlmKCFub2RlLmljb24gfHwgc2l6ZSA8IHRocmVzaG9sZCkgcmV0dXJuO1xyXG5cclxuICAgIHZhciBmb250ID0gbm9kZS5pY29uLmZvbnQgfHwgJ0FyaWFsJyxcclxuICAgICAgICBmZ0NvbG9yID0gbm9kZS5pY29uLmNvbG9yIHx8ICcjRjAwJyxcclxuICAgICAgICB0ZXh0ID0gbm9kZS5pY29uLmNvbnRlbnQgfHwgJz8nLFxyXG4gICAgICAgIHB4ID0gbm9kZS5pY29uLnggfHwgMC41LFxyXG4gICAgICAgIHB5ID0gbm9kZS5pY29uLnkgfHwgMC41LFxyXG4gICAgICAgIGhlaWdodCA9IHNpemUsXHJcbiAgICAgICAgd2lkdGggPSBzaXplO1xyXG5cclxuICAgIHZhciBmb250U2l6ZVJhdGlvID0gMC43MDtcclxuICAgIGlmICh0eXBlb2Ygbm9kZS5pY29uLnNjYWxlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIGZvbnRTaXplUmF0aW8gPSBNYXRoLmFicyhNYXRoLm1heCgwLjAxLCBub2RlLmljb24uc2NhbGUpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm9udFNpemUgPSBNYXRoLnJvdW5kKGZvbnRTaXplUmF0aW8gKiBoZWlnaHQpO1xyXG5cclxuICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBmZ0NvbG9yO1xyXG5cclxuICAgIGNvbnRleHQuZm9udCA9ICcnICsgZm9udFNpemUgKyAncHggJyArIGZvbnQ7XHJcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcclxuICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XHJcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcclxuICB9O1xyXG5cclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24oZ2xvYmFsKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKipcclxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG4gICAqIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcclxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLlxyXG4gICAqIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcclxuICAgKiBNSVQgbGljZW5zZVxyXG4gICAqL1xyXG4gIHZhciB4LFxyXG4gICAgICBsYXN0VGltZSA9IDAsXHJcbiAgICAgIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xyXG5cclxuICBmb3IgKHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIWdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7IHgrKykge1xyXG4gICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgZ2xvYmFsW3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fFxyXG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICB9XHJcblxyXG4gIGlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSlcclxuICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xyXG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcclxuICAgICAgICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSksXHJcbiAgICAgICAgICBpZCA9IGdsb2JhbC5zZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aW1lVG9DYWxsXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcbiAgICAgIHJldHVybiBpZDtcclxuICAgIH07XHJcblxyXG4gIGlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxyXG4gICAgZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHBvbHlmaWxsIGZvdW5kIG9uIE1ETi5cclxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kI0NvbXBhdGliaWxpdHlcclxuICAgKiBQdWJsaWMgZG9tYWluXHJcbiAgICovXHJcbiAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZClcclxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24ob1RoaXMpIHtcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIC8vIENsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNSBpbnRlcm5hbCBJc0NhbGxhYmxlXHJcbiAgICAgICAgLy8gZnVuY3Rpb246XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZSdcclxuICAgICAgICApO1xyXG5cclxuICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuICAgICAgICAgIGZUb0JpbmQgPSB0aGlzLFxyXG4gICAgICAgICAgZk5PUCxcclxuICAgICAgICAgIGZCb3VuZDtcclxuXHJcbiAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9O1xyXG4gICAgICBmQm91bmQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseShcclxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID9cclxuICAgICAgICAgICAgdGhpcyA6XHJcbiAgICAgICAgICAgIG9UaGlzLFxyXG4gICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgICAgKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xyXG5cclxuICAgICAgcmV0dXJuIGZCb3VuZDtcclxuICAgIH07XHJcbn0pKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIFBhY2thZ2VzIGluaXRpYWxpemF0aW9uOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc2V0dGluZ3MnKTtcclxuXHJcbiAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHUkFQSCBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKlxyXG4gICAgICovXHJcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBkYXRhIGhhdmUgdG8gYmUgY2xvbmVkIGluIG1ldGhvZHMgdG8gYWRkXHJcbiAgICAvLyAgICAgICAgICAgbm9kZXMgb3IgZWRnZXMuXHJcbiAgICBjbG9uZTogZmFsc2UsXHJcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIG5vZGVzIFwiaWRcIiB2YWx1ZXMgYW5kIGVkZ2VzIFwiaWRcIiwgXCJzb3VyY2VcIiBhbmRcclxuICAgIC8vICAgICAgICAgICBcInRhcmdldFwiIHZhbHVlcyBtdXN0IGJlIHNldCBhcyBpbW11dGFibGUuXHJcbiAgICBpbW11dGFibGU6IHRydWUsXHJcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHNpZ21hIGNhbiBsb2cgaXRzIGVycm9ycyBhbmQgd2FybmluZ3MuXHJcbiAgICB2ZXJib3NlOiBmYWxzZSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSRU5ERVJFUlMgU0VUVElOR1M6XHJcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgKi9cclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBjbGFzc1ByZWZpeDogJ3NpZ21hJyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0Tm9kZVR5cGU6ICdkZWYnLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHRFZGdlVHlwZTogJ2RlZicsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZGVmYXVsdExhYmVsQ29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0RWRnZUNvbG9yOiAnIzAwMCcsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZGVmYXVsdE5vZGVDb2xvcjogJyMwMDAnLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHRMYWJlbFNpemU6IDE0LFxyXG4gICAgLy8ge3N0cmluZ30gTGFiZWwgcG9zaXRpb24gcmVsYXRpdmUgdG8gaXRzIG5vZGUuIEF2YWlsYWJsZSB2YWx1ZXM6XHJcbiAgICAvLyAgICAgICAgICBcInJpZ2h0XCIsIFwibGVmdFwiLCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImNlbnRlclwiLCBcImluc2lkZVwiXHJcbiAgICBsYWJlbEFsaWdubWVudDogJ3JpZ2h0JyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgIC8vICAgICAgICAgIFwic291cmNlXCIsIFwidGFyZ2V0XCIsIFwiZGVmYXVsdFwiXHJcbiAgICBlZGdlQ29sb3I6ICdzb3VyY2UnLFxyXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyB0aGUgbWluaW1hbCBlZGdlJ3MgYXJyb3cgZGlzcGxheSBzaXplLlxyXG4gICAgbWluQXJyb3dTaXplOiAwLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGZvbnQ6ICdhcmlhbCcsXHJcbiAgICAvLyB7c3RyaW5nfSBFeGFtcGxlOiAnYm9sZCdcclxuICAgIGZvbnRTdHlsZTogJycsXHJcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxyXG4gICAgLy8gICAgICAgICAgXCJub2RlXCIsIFwiZGVmYXVsdFwiXHJcbiAgICBsYWJlbENvbG9yOiAnZGVmYXVsdCcsXHJcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIHNpemUuIEF2YWlsYWJsZSB2YWx1ZXM6XHJcbiAgICAvLyAgICAgICAgICBcImZpeGVkXCIsIFwicHJvcG9ydGlvbmFsXCJcclxuICAgIGxhYmVsU2l6ZTogJ2ZpeGVkJyxcclxuICAgIC8vIHtzdHJpbmd9IFRoZSByYXRpbyBiZXR3ZWVuIHRoZSBmb250IHNpemUgb2YgdGhlIGxhYmVsIGFuZCB0aGUgbm9kZSBzaXplLlxyXG4gICAgbGFiZWxTaXplUmF0aW86IDEsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSBzaXplIGEgbm9kZSBtdXN0IGhhdmUgdG8gc2VlIGl0cyBsYWJlbCBkaXNwbGF5ZWQuXHJcbiAgICBsYWJlbFRocmVzaG9sZDogOCxcclxuICAgIC8vIHtudW1iZXJ9IE1heGltdW0gbGVuZ3RoIG9mIGEgbm9kZSdzIGxhYmVsIChpbiBjaGFyYWN0ZXJzKS4gRGlzcGxheXMgdGhlIGxhYmVsIG9uIHNldmVyYWwgbGluZXMuIDAgZGlzYWJsZXMgaXRcclxuICAgIC8vICh0aGUgd2hvbGUgbGFiZWwgaXMgZGlzcGxheWVkIG9uIG9uZSBsaW5lKVxyXG4gICAgbWF4Tm9kZUxhYmVsTGluZUxlbmd0aDogMCxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBvdmVyc2FtcGxpbmcgZmFjdG9yIHVzZWQgaW4gV2ViR0wgcmVuZGVyZXIuXHJcbiAgICB3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvOiAyLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGJvcmRlciBvZiBub2Rlcy5cclxuICAgIG5vZGVCb3JkZXJTaXplOiAwLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIGRlZmF1bHQgbm9kZSBib3JkZXIncyBjb2xvci5cclxuICAgIGRlZmF1bHROb2RlQm9yZGVyQ29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBob3ZlcmVkIG5vZGUncyBsYWJlbCBmb250LiBJZiBub3Qgc3BlY2lmaWVkLCB3aWxsIGhlcml0YXRlXHJcbiAgICAvLyAgICAgICAgICB0aGUgXCJmb250XCIgdmFsdWUuXHJcbiAgICBob3ZlckZvbnQ6ICcnLFxyXG4gICAgLy8ge2Jvb2xlYW59IElmIHRydWUsIHRoZW4gb25seSBvbmUgbm9kZSBjYW4gYmUgaG92ZXJlZCBhdCBhIHRpbWUuXHJcbiAgICBzaW5nbGVIb3ZlcjogdHJ1ZSxcclxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xyXG4gICAgaG92ZXJGb250U3R5bGU6ICcnLFxyXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgc2hhZG93IGNvbG9yLlxyXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXHJcbiAgICBsYWJlbEhvdmVyU2hhZG93OiAnZGVmYXVsdCcsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgbGFiZWxIb3ZlclNoYWRvd0NvbG9yOiAnIzAwMCcsXHJcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBjb2xvci5cclxuICAgIC8vICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwibm9kZVwiLCBcImRlZmF1bHRcIlxyXG4gICAgbm9kZUhvdmVyQ29sb3I6ICdub2RlJyxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0Tm9kZUhvdmVyQ29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGJhY2tncm91bmQgY29sb3IuXHJcbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcclxuICAgIGxhYmVsSG92ZXJCR0NvbG9yOiAnZGVmYXVsdCcsXHJcbiAgICAvLyB7c3RyaW5nfVxyXG4gICAgZGVmYXVsdEhvdmVyTGFiZWxCR0NvbG9yOiAnI2ZmZicsXHJcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBsYWJlbHMgY29sb3IuXHJcbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcclxuICAgIGxhYmVsSG92ZXJDb2xvcjogJ2RlZmF1bHQnLFxyXG4gICAgLy8ge3N0cmluZ31cclxuICAgIGRlZmF1bHRMYWJlbEhvdmVyQ29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBob3ZlciBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgIC8vICAgICAgICAgIFwiZWRnZVwiLCBcImRlZmF1bHRcIlxyXG4gICAgZWRnZUhvdmVyQ29sb3I6ICdlZGdlJyxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBzaXplIG11bHRpcGxpY2F0b3Igb2YgaG92ZXJlZCBlZGdlcy5cclxuICAgIGVkZ2VIb3ZlclNpemVSYXRpbzogMSxcclxuICAgIC8vIHtzdHJpbmd9XHJcbiAgICBkZWZhdWx0RWRnZUhvdmVyQ29sb3I6ICcjMDAwJyxcclxuICAgIC8vIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgdGhlIGVkZ2UgZXh0cmVtaXRpZXMgbXVzdCBiZSBob3ZlcmVkIHdoZW4gdGhlXHJcbiAgICAvLyAgICAgICAgICAgZWRnZSBpcyBob3ZlcmVkLlxyXG4gICAgZWRnZUhvdmVyRXh0cmVtaXRpZXM6IGZhbHNlLFxyXG4gICAgLy8ge2Jvb2xlYW5zfSBUaGUgZGlmZmVyZW50IGRyYXdpbmcgbW9kZXM6XHJcbiAgICAvLyAgICAgICAgICAgZmFsc2U6IExheWVyZWQgbm90IGRpc3BsYXllZC5cclxuICAgIC8vICAgICAgICAgICB0cnVlOiBMYXllcmVkIGRpc3BsYXllZC5cclxuICAgIGRyYXdFZGdlczogdHJ1ZSxcclxuICAgIGRyYXdOb2RlczogdHJ1ZSxcclxuICAgIGRyYXdMYWJlbHM6IHRydWUsXHJcbiAgICBkcmF3RWRnZUxhYmVsczogZmFsc2UsXHJcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGRyYXduIGluIHNldmVyYWwgZnJhbWVzIG9yIGluXHJcbiAgICAvLyAgICAgICAgICAgb25lIGZyYW1lLCBhcyB0aGUgbm9kZXMgYW5kIGxhYmVscyBhcmUgZHJhd24uXHJcbiAgICBiYXRjaEVkZ2VzRHJhd2luZzogZmFsc2UsXHJcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGhpZGRlbiBkdXJpbmcgZHJhZ2dpbmcgYW5kXHJcbiAgICAvLyAgICAgICAgICAgYW5pbWF0aW9ucy5cclxuICAgIGhpZGVFZGdlc09uTW92ZTogZmFsc2UsXHJcbiAgICAvLyB7bnVtYmVyc30gVGhlIGRpZmZlcmVudCBiYXRjaCBzaXplcywgd2hlbiBlbGVtZW50cyBhcmUgZGlzcGxheWVkIGluXHJcbiAgICAvLyAgICAgICAgICAgc2V2ZXJhbCBmcmFtZXMuXHJcbiAgICBjYW52YXNFZGdlc0JhdGNoU2l6ZTogNTAwLFxyXG4gICAgd2ViZ2xFZGdlc0JhdGNoU2l6ZTogMTAwMCxcclxuICAgIC8vIHtib29sZWFufSBBcHByb3hpbWF0ZSBsYWJlbHMgd2lkdGggaW5zdGVhZCBvZiB1c2luZyBjYW52YXMubWVhc3VyZVRleHRcclxuICAgIGFwcHJveGltYXRlTGFiZWxXaWR0aDogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufSBIaWRlIGVkZ2VzIGZyb20gbm9kZXMgdG9vIGZhciBhd2F5XHJcbiAgICBlZGdlc0NsaXBwaW5nV2l0aE5vZGVzOiB0cnVlLFxyXG4gICAgLy8ge251bWJlcn0gaWYgc2lnbWEuY2FudmFzLmVkZ2VzLmF1dG9DdXJ2ZSBpcyBjYWxsZWQsIHNldCByZWxhdGl2ZVxyXG4gICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjdXJ2ZWQgcGFyYWxsZWwgZWRnZXMgKGkuZS4gZWRnZXMgd2l0aCBzYW1lXHJcbiAgICAvLyBleHRyZW1pdGllcykuIFNtYWxsZXIgdmFsdWUgaW5jcmVhc2VzIGRpc3RhbmNlcy5cclxuICAgIGF1dG9DdXJ2ZVJhdGlvOiAxLFxyXG4gICAgLy8ge2Jvb2xlYW59IGlmIHNpZ21hLmNhbnZhcy5lZGdlcy5hdXRvQ3VydmUgaXMgY2FsbGVkLCBzb3J0IGVkZ2VzIGJ5XHJcbiAgICAvLyBkaXJlY3Rpb24uXHJcbiAgICBhdXRvQ3VydmVTb3J0QnlEaXJlY3Rpb246IHRydWUsXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUkVTQ0FMRSBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKioqXHJcbiAgICAgKi9cclxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBvZiB0byBzY2FsZSB0aGUgZ3JhcGggcmVsYXRpdmVseSB0byBpdHMgY29udGFpbmVyLlxyXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJpbnNpZGVcIiwgXCJvdXRzaWRlXCJcclxuICAgIHNjYWxpbmdNb2RlOiAnaW5zaWRlJyxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXJnaW4gdG8ga2VlcCBhcm91bmQgdGhlIGdyYXBoLlxyXG4gICAgc2lkZU1hcmdpbjogMCxcclxuICAgIC8vIHtudW1iZXJ9IERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgc21hbGxlc3QgYW5kIHRoZSBiaWdnZXN0IG5vZGUgLyBlZGdlc1xyXG4gICAgLy8gICAgICAgICAgb24gdGhlIHNjcmVlbi4gVGhpcyBtYXBwaW5nIG1ha2VzIGVhc2llciB0byBkaXNwbGF5IHRoZSBncmFwaCxcclxuICAgIC8vICAgICAgICAgIGF2b2lkaW5nIHRvbyBiaWcgbm9kZXMgdGhhdCB0YWtlIGhhbGYgb2YgdGhlIHNjcmVlbiwgb3IgdG9vXHJcbiAgICAvLyAgICAgICAgICBzbWFsbCBvbmVzIHRoYXQgYXJlIG5vdCByZWFkYWJsZS4gSWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZVxyXG4gICAgLy8gICAgICAgICAgZXF1YWxzLCB0aGVuIHRoZSBtaW5pbWFsIGRpc3BsYXkgc2l6ZSB3aWxsIGJlIDAuIEFuZCBpZiB0aGV5XHJcbiAgICAvLyAgICAgICAgICBhcmUgYm90aCBlcXVhbCB0byAwLCB0aGVuIHRoZXJlIGlzIG5vIG1hcHBpbmcsIGFuZCB0aGUgcmFkaXVzXHJcbiAgICAvLyAgICAgICAgICBvZiB0aGUgbm9kZXMgd2lsbCBiZSB0aGVpciBzaXplLlxyXG4gICAgbWluRWRnZVNpemU6IDAuNSxcclxuICAgIG1heEVkZ2VTaXplOiAxLFxyXG4gICAgbWluTm9kZVNpemU6IDEsXHJcbiAgICBtYXhOb2RlU2l6ZTogOCxcclxuXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENBUFRPUlMgU0VUVElOR1M6XHJcbiAgICAgKiAqKioqKioqKioqKioqKioqKlxyXG4gICAgICovXHJcbiAgICAvLyB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHVzZXIgd2lsbCBuZWVkIHRvIGNsaWNrIG9uIHRoZSB2aXN1YWxpemF0aW9uIGVsZW1lbnRcclxuICAgIC8vIGluIG9yZGVyIHRvIGZvY3VzIGl0XHJcbiAgICBjbGlja1RvRm9jdXM6IGZhbHNlLFxyXG4gICAgLy8ge2Jvb2xlYW59XHJcbiAgICB0b3VjaEVuYWJsZWQ6IHRydWUsXHJcbiAgICAvLyB7Ym9vbGVhbn1cclxuICAgIG1vdXNlRW5hYmxlZDogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufVxyXG4gICAgbW91c2VXaGVlbEVuYWJsZWQ6IHRydWUsXHJcbiAgICAvLyB7Ym9vbGVhbn1cclxuICAgIGRvdWJsZUNsaWNrRW5hYmxlZDogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufSBEZWZpbmVzIHdoZXRoZXIgdGhlIGN1c3RvbSBldmVudHMgc3VjaCBhcyBcImNsaWNrTm9kZVwiIGNhbiBiZVxyXG4gICAgLy8gICAgICAgICAgIHVzZWQuXHJcbiAgICBldmVudHNFbmFibGVkOiB0cnVlLFxyXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyBieSBob3cgbXVjaCBtdWx0aXBsaWNhdGluZyB0aGUgem9vbWluZyBsZXZlbCB3aGVuIHRoZVxyXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyB3aXRoIHRoZSBtb3VzZS13aGVlbC5cclxuICAgIHpvb21pbmdSYXRpbzogMS43LFxyXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyBieSBob3cgbXVjaCBtdWx0aXBsaWNhdGluZyB0aGUgem9vbWluZyBsZXZlbCB3aGVuIHRoZVxyXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyBieSBkb3VibGUgY2xpY2tpbmcuXHJcbiAgICBkb3VibGVDbGlja1pvb21pbmdSYXRpbzogMi4yLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbWluZyBsZXZlbC5cclxuICAgIHpvb21NaW46IDAuMDYyNSxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHpvb21pbmcgbGV2ZWwuXHJcbiAgICB6b29tTWF4OiAyLFxyXG4gICAgLy8ge2Jvb2xlYW59IERlZmluZXMgd2hldGhlciB0aGUgem9vbSBmb2N1c2VzIG9uIHRoZSBtb3VzZSBsb2NhdGlvbi5cclxuICAgIHpvb21PbkxvY2F0aW9uOiB0cnVlLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2Ugc2Nyb2xsaW5nLlxyXG4gICAgbW91c2Vab29tRHVyYXRpb246IDIwMCxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBkdXJhdGlvbiBvZiBhbmltYXRpb25zIGZvbGxvd2luZyBhIG1vdXNlIGRvdWJsZSBjbGljay5cclxuICAgIGRvdWJsZUNsaWNrWm9vbUR1cmF0aW9uOiAyMDAsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSBtb3VzZSBkcm9wcGluZy5cclxuICAgIG1vdXNlSW5lcnRpYUR1cmF0aW9uOiAyMDAsXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAobW91c2UgY2FwdG9yKS5cclxuICAgIG1vdXNlSW5lcnRpYVJhdGlvOiAzLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgdG91Y2ggZHJvcHBpbmcuXHJcbiAgICB0b3VjaEluZXJ0aWFEdXJhdGlvbjogMjAwLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIGluZXJ0aWEgcG93ZXIgKHRvdWNoIGNhcHRvcikuXHJcbiAgICB0b3VjaEluZXJ0aWFSYXRpbzogMyxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gY2xpY2tzIHRvIG1ha2UgaXQgYSBkb3VibGUgY2xpY2suXHJcbiAgICBkb3VibGVDbGlja1RpbWVvdXQ6IDMwMCxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gdGFwcyB0byBtYWtlIGl0IGEgZG91YmxlIHRhcC5cclxuICAgIGRvdWJsZVRhcFRpbWVvdXQ6IDMwMCxcclxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgb2YgZHJhZ2dpbmcgdG8gdHJpZ2dlciBpbnRlcnRpYS5cclxuICAgIGRyYWdUaW1lb3V0OiAyMDAsXHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHTE9CQUwgU0VUVElOR1M6XHJcbiAgICAgKiAqKioqKioqKioqKioqKioqXHJcbiAgICAgKi9cclxuICAgIC8vIHtib29sZWFufSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIFwicmVzY2FsZVwiIG1pZGRsZXdhcmUgaGFzIHRvIGJlIGNhbGxlZFxyXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgZm9yIGVhY2ggY2FtZXJhIG9uIHJlZnJlc2guXHJcbiAgICBhdXRvUmVzY2FsZTogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gZmFsc2UsIHRoZSBjYW1lcmEgbWV0aG9kIFwiZ29Ub1wiIHdpbGwgYmFzaWNhbGx5IGRvXHJcbiAgICAvLyAgICAgICAgICAgbm90aGluZy5cclxuICAgIGVuYWJsZUNhbWVyYTogdHJ1ZSxcclxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gZmFsc2UsIHRoZSBub2RlcyBjYW5ub3QgYmUgaG92ZXJlZC5cclxuICAgIGVuYWJsZUhvdmVyaW5nOiB0cnVlLFxyXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgZWRnZXMgY2FuIGJlIGhvdmVyZWQuXHJcbiAgICBlbmFibGVFZGdlSG92ZXJpbmc6IGZhbHNlLFxyXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGFyZWEgYXJvdW5kIHRoZSBlZGdlcyB0byBhY3RpdmF0ZSBob3ZlcmluZy5cclxuICAgIGVkZ2VIb3ZlclByZWNpc2lvbjogNSxcclxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHJlc2NhbGUgbWlkZGxld2FyZSB3aWxsIGlnbm9yZSBub2RlIHNpemVzXHJcbiAgICAvLyAgICAgICAgICAgdG8gZGV0ZXJtaW5lIHRoZSBncmFwaHMgYm91bmRpbmdzLlxyXG4gICAgcmVzY2FsZUlnbm9yZVNpemU6IGZhbHNlLFxyXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgaWYgdGhlIGNvcmUgaGFzIHRvIHRyeSB0byBjYXRjaCBlcnJvcnMgb25cclxuICAgIC8vICAgICAgICAgICByZW5kZXJpbmcuXHJcbiAgICBza2lwRXJyb3JzOiBmYWxzZSxcclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1BBVElBTCBJTkRFWElORyBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKipcclxuICAgICAqL1xyXG4gICAgLy8ge251bWJlcn0gTWF4IGhlaWdodCBvZiB0aGUgbm9kZSBxdWFkIHRyZWUuXHJcbiAgICBub2RlUXVhZHRyZWVNYXhMZXZlbDogNCxcclxuICAgIC8vIHtudW1iZXJ9IE1heCBoZWlnaHQgb2YgdGhlIGVkZ2UgcXVhZCB0cmVlLlxyXG4gICAgZWRnZVF1YWR0cmVlTWF4TGV2ZWw6IDQsXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENBTUVSQSBTRVRUSU5HUzpcclxuICAgICAqICoqKioqKioqKioqKioqKipcclxuICAgICAqL1xyXG4gICAgLy8ge251bWJlcn0gVGhlIHBvd2VyIGRlZ3JlZXMgYXBwbGllZCB0byB0aGUgbm9kZXMvZWRnZXMgc2l6ZSByZWxhdGl2ZWx5IHRvXHJcbiAgICAvLyAgICAgICAgICB0aGUgem9vbWluZyBsZXZlbC4gQmFzaWNhbGx5OlxyXG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5SID0gTWF0aC5wb3coem9vbSwgbm9kZXNQb3dSYXRpbykgKiBSXHJcbiAgICAvLyAgICAgICAgICAgPiBvblNjcmVlblQgPSBNYXRoLnBvdyh6b29tLCBlZGdlc1Bvd1JhdGlvKSAqIFRcclxuICAgIG5vZGVzUG93UmF0aW86IDAuNSxcclxuICAgIGVkZ2VzUG93UmF0aW86IDAuNSxcclxuXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFOSU1BVElPTlMgU0VUVElOR1M6XHJcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICovXHJcbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBhbmltYXRpb24gdGltZS5cclxuICAgIGFuaW1hdGlvbnNUaW1lOiAyMDBcclxuICB9O1xyXG5cclxuICAvLyBFeHBvcnQgdGhlIHByZXZpb3VzbHkgZGVzaWduZWQgc2V0dGluZ3M6XHJcbiAgc2lnbWEuc2V0dGluZ3MgPSBzaWdtYS51dGlscy5leHRlbmQoc2lnbWEuc2V0dGluZ3MgfHwge30sIHNldHRpbmdzKTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaGVyIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gVGhlIG5ldyBkaXNwYXRjaGVyIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHZhciBkaXNwYXRjaGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19oYW5kbGVycycsIHtcclxuICAgICAgdmFsdWU6IHt9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBXaWxsIGV4ZWN1dGUgdGhlIGhhbmRsZXIgZXZlcnl0aW1lIHRoYXQgdGhlIGluZGljYXRlZCBldmVudCAob3IgdGhlXHJcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxyXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZUFycmF5O1xyXG5cclxuICAgIGlmIChcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0J1xyXG4gICAgKVxyXG4gICAgICBmb3IgKGV2ZW50cyBpbiBhcmd1bWVudHNbMF0pXHJcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50cywgYXJndW1lbnRzWzBdW2V2ZW50c10pO1xyXG4gICAgZWxzZSBpZiAoXHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiZcclxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgKSB7XHJcbiAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gbDsgaSArPSAxKSB7XHJcbiAgICAgICAgZXZlbnQgPSBlQXJyYXlbaV07XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgZXZlbnQgaXMgbm90ICcnOlxyXG4gICAgICAgIGlmICghZXZlbnQpXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyc1tldmVudF0pXHJcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBbXTtcclxuXHJcbiAgICAgICAgLy8gVXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgZGlyZWN0bHkgdGhlIGhhbmRsZXIgd2lsbCBtYWtlIHBvc3NpYmxlXHJcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXHJcbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnRdLnB1c2goe1xyXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2VcclxuICAgICAgdGhyb3cgJ2JpbmQ6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgICAgICAgZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gYWxsIGhhbmRsZXJzIGFyZSByZW1vdmVkLlxyXG4gICAqIEBwYXJhbSAgez9mdW5jdGlvbihvYmplY3QpfSBoYW5kbGVyIFRoZSBoYW5kbGVyIHRvIHVuYmluZC4gSWYgdW5kZWZpbmVkLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgZGlzcGF0Y2hlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBuLFxyXG4gICAgICAgIGosXHJcbiAgICAgICAgbSxcclxuICAgICAgICBrLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcclxuXHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgZm9yIChrIGluIHRoaXMuX2hhbmRsZXJzKVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1trXTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xyXG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xyXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF0pIHtcclxuICAgICAgICAgIGEgPSBbXTtcclxuICAgICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBtOyBqICs9IDEpXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudF1bal0uaGFuZGxlciAhPT0gaGFuZGxlcilcclxuICAgICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdKTtcclxuXHJcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLl9oYW5kbGVyc1tldmVudF0ubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlXHJcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpXHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2VBcnJheVtpXV07XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZXMgZWFjaCBoYW5kbGVyIGJvdW5kIHRvIHRoZSBldmVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgc3BhY2VzKS5cclxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSAgICBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXHJcbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRzLCBkYXRhKSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBuLFxyXG4gICAgICAgIGosXHJcbiAgICAgICAgbSxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGV2ZW50LFxyXG4gICAgICAgIGV2ZW50TmFtZSxcclxuICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICBlQXJyYXkgPSB0eXBlb2YgZXZlbnRzID09PSAnc3RyaW5nJyA/IGV2ZW50cy5zcGxpdCgnICcpIDogZXZlbnRzO1xyXG5cclxuICAgIGRhdGEgPSBkYXRhID09PSB1bmRlZmluZWQgPyB7fSA6IGRhdGE7XHJcblxyXG4gICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xyXG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XHJcblxyXG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICAgIGV2ZW50ID0gc2VsZi5nZXRFdmVudChldmVudE5hbWUsIGRhdGEpO1xyXG4gICAgICAgIGEgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChqID0gMCwgbSA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBtOyBqICs9IDEpIHtcclxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0uaGFuZGxlcihldmVudCk7XHJcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0ub25lKVxyXG4gICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gYTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbiBldmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudHMgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmdldEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IGV2ZW50LFxyXG4gICAgICBkYXRhOiBkYXRhIHx8IHt9LFxyXG4gICAgICB0YXJnZXQ6IHRoaXNcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB1c2VmdWwgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGluaGVyaXRhbmNlLiBJdCB3aWxsIG1ha2UgdGhlIHRhcmdldFxyXG4gICAqIGluaGVyaXQgdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3MgZGlzcGF0Y2hlciBhcyB3ZWxsIGFzIGl0cyBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldC5cclxuICAgKi9cclxuICBkaXNwYXRjaGVyLmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCwgYXJncykge1xyXG4gICAgdmFyIGs7XHJcblxyXG4gICAgZm9yIChrIGluIGRpc3BhdGNoZXIucHJvdG90eXBlKVxyXG4gICAgICBpZiAoZGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaykpXHJcbiAgICAgICAgdGFyZ2V0W2tdID0gZGlzcGF0Y2hlci5wcm90b3R5cGVba107XHJcblxyXG4gICAgZGlzcGF0Y2hlci5hcHBseSh0YXJnZXQsIGFyZ3MpO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEVYUE9SVDpcclxuICAgKiAqKioqKioqXHJcbiAgICovXHJcbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xyXG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoZXI7XHJcbiAgICBleHBvcnRzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xyXG4gIH0gZWxzZVxyXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIHV0aWxzIGFpbXMgdG8gZmFjaWxpdGF0ZSB0aGUgbWFuaXB1bGF0aW9uIG9mIGVhY2ggaW5zdGFuY2Ugc2V0dGluZy5cclxuICAgKiBVc2luZyBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgYW4gb2JqZWN0IGJyaW5ncyB0d28gbWFpbiBhZHZhbnRhZ2VzOiBGaXJzdCxcclxuICAgKiBpdCB3aWxsIGJlIGVhc2llciBpbiB0aGUgZnV0dXJlIHRvIGNhdGNoIHNldHRpbmdzIHVwZGF0ZXMgdGhyb3VnaCBhXHJcbiAgICogZnVuY3Rpb24gdGhhbiBhbiBvYmplY3QuIFNlY29uZCwgZ2l2aW5nIGl0IGEgZnVsbCBvYmplY3Qgd2lsbCBcIm1lcmdlXCIgaXRcclxuICAgKiB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHByb3Blcmx5LCBrZWVwaW5nIHVzIHRvIGhhdmUgdG8gYWx3YXlzIGFkZCBhIGxvb3AuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtjb25maWd1cmFibGV9IFRoZSBcInNldHRpbmdzXCIgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgdmFyIGNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBkYXRhID0ge30sXHJcbiAgICAgICAgZGF0YXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1ldGhvZCB0byB1c2UgdG8gc2V0IG9yIGdldCBhbnkgcHJvcGVydHkgb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSAgICBhMSBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXMgdW5kZWZpbmVkLFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbiBpdCB3aWxsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuIElmIGl0IGlzIGEgc3RyaW5nIGFuZCBpZiBhMiBpc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0LCB0aGVuIGl0IHdpbGwgc2V0IGEyIGFzIHRoZSBwcm9wZXJ0eVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZGluZyB0byBhMSwgYW5kIHJldHVybiB0aGlzLiBJZlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQgaXMgYW4gb2JqZWN0LCB0aGVuIGVhY2ggcGFpciBzdHJpbmcgK1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0KG9yIGFueSBvdGhlciB0eXBlKSB3aWxsIGJlIHNldCBhcyBhXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSAgeyo/fSAgICAgICAgICAgICAgIGEyIFRoZSBuZXcgcHJvcGVydHkgY29ycmVzcG9uZGluZyB0byBhMSBpZiBhMVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJuIHsqfGNvbmZpZ3VyYWJsZX0gICAgICBSZXR1cm5zIGl0c2VsZiBvciB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogUG9seW1vcnBoaXNtOlxyXG4gICAgICogKioqKioqKioqKioqKlxyXG4gICAgICogSGVyZSBhcmUgc29tZSBiYXNpYyB1c2UgZXhhbXBsZXM6XHJcbiAgICAgKlxyXG4gICAgICogID4gc2V0dGluZ3MgPSBuZXcgY29uZmlndXJhYmxlKCk7XHJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgNDIpO1xyXG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycpOyAvLyBMb2dzOiA0MlxyXG4gICAgICogID4gc2V0dGluZ3MoJ215U2V0dGluZycsIDEyMyk7XHJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDEyM1xyXG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogNDU2fSk7XHJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDQ1NlxyXG4gICAgICpcclxuICAgICAqIEFsc28sIGl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGUgZnVuY3Rpb24gYXMgYSBmYWxsYmFjazpcclxuICAgICAqICA+IHNldHRpbmdzKHtteVNldHRpbmc6ICdhYmMnfSwgJ215U2V0dGluZycpOyAgLy8gTG9nczogJ2FiYydcclxuICAgICAqICA+IHNldHRpbmdzKHtoaXNTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XHJcbiAgICAgKi9cclxuICAgIHZhciBzZXR0aW5ncyA9IGZ1bmN0aW9uKGExLCBhMikge1xyXG4gICAgICB2YXIgbyxcclxuICAgICAgICAgIGksXHJcbiAgICAgICAgICBsLFxyXG4gICAgICAgICAgaztcclxuXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhMSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoZGF0YVthMV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgIHJldHVybiBkYXRhW2ExXTtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZGF0YXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgaWYgKGRhdGFzW2ldW2ExXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YXNbaV1bYTFdO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYTIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIChhMSB8fCB7fSlbYTJdICE9PSB1bmRlZmluZWQgPyBhMVthMl0gOiBzZXR0aW5ncyhhMik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGEyID09PSB1bmRlZmluZWQpID8gYTEgOiB7fTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhMSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICBvW2ExXSA9IGEyO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwLCBrID0gT2JqZWN0LmtleXMobyksIGwgPSBrLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgIGRhdGFba1tpXV0gPSBvW2tbaV1dO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgY29uZmlndXJhYmxlIGZ1bmN0aW9uLCB3aXRoIG5ldyBvYmplY3RzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0Kn0gIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB0byBzZWFyY2ggaW4uXHJcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gUmV0dXJucyB0aGUgZnVuY3Rpb24uIENoZWNrIGl0cyBkb2N1bWVudGF0aW9uIHRvIGtub3dcclxuICAgICAqICAgICAgICAgICAgICAgICAgICBtb3JlIGFib3V0IGhvdyBpdCB3b3Jrcy5cclxuICAgICAqL1xyXG4gICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhcmdzID0gZGF0YXMuY29uY2F0KFxyXG4gICAgICAgIGRhdGFcclxuICAgICAgKS5jb25jYXQoXHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyZ3VtZW50cywgMClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJldHVybiBjb25maWd1cmFibGUuYXBwbHkoe30sIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplXHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgc2V0dGluZ3MoYXJndW1lbnRzW2ldKTtcclxuXHJcbiAgICByZXR1cm4gc2V0dGluZ3M7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRVhQT1JUOlxyXG4gICAqICoqKioqKipcclxuICAgKi9cclxuICBpZiAodHlwZW9mIHRoaXMuc2lnbWEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XHJcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ3VyYWJsZTtcclxuICAgIGV4cG9ydHMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xyXG4gIH0gZWxzZVxyXG4gICAgdGhpcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIF9tZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgX2luZGV4ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICBfaW5pdEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgX21ldGhvZEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgX2RlZmF1bHRTZXR0aW5ncyA9IHtcclxuICAgICAgICBpbW11dGFibGU6IHRydWUsXHJcbiAgICAgICAgY2xvbmU6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgX2RlZmF1bHRTZXR0aW5nc0Z1bmN0aW9uID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0U2V0dGluZ3Nba2V5XTtcclxuICAgICAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGdyYXBoIGNvbnN0cnVjdG9yLiBJdCBpbml0aWFsaXplcyB0aGUgZGF0YSBhbmQgdGhlIGluZGV4ZXMsIGFuZCBiaW5kc1xyXG4gICAqIHRoZSBjdXN0b20gaW5kZXhlcyBhbmQgbWV0aG9kcyB0byBpdHMgb3duIHNjb3BlLlxyXG4gICAqXHJcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgc2V0dGluZ3NcclxuICAgKiBvYmplY3Q6XHJcbiAgICpcclxuICAgKiAgIHtib29sZWFufSBjbG9uZSAgICAgSW5kaWNhdGVzIGlmIHRoZSBkYXRhIGhhdmUgdG8gYmUgY2xvbmVkIGluIG1ldGhvZHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgdG8gYWRkIG5vZGVzIG9yIGVkZ2VzLlxyXG4gICAqICAge2Jvb2xlYW59IGltbXV0YWJsZSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBcInNvdXJjZVwiIGFuZCBcInRhcmdldFwiIHZhbHVlcyBtdXN0IGJlIHNldCBhc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICBpbW11dGFibGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBFdmVudHVhbGx5IGEgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7Z3JhcGh9ICAgICAgICAgICAgICAgICAgVGhlIG5ldyBncmFwaCBpbnN0YW5jZS5cclxuICAgKi9cclxuICB2YXIgZ3JhcGggPSBmdW5jdGlvbihzZXR0aW5ncykge1xyXG4gICAgdmFyIGssXHJcbiAgICAgICAgZm4sXHJcbiAgICAgICAgZGF0YTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERBVEE6XHJcbiAgICAgKiAqKioqKlxyXG4gICAgICogRXZlcnkgZGF0YSB0aGF0IGlzIGNhbGxhYmxlIGZyb20gZ3JhcGggbWV0aG9kcyBhcmUgc3RvcmVkIGluIHRoaXMgXCJkYXRhXCJcclxuICAgICAqIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSBzZXJ2ZWQgYXMgY29udGV4dCBmb3IgYWxsIHRoZXNlIG1ldGhvZHMsXHJcbiAgICAgKiBhbmQgaXQgaXMgcG9zc2libGUgdG8gYWRkIG90aGVyIHR5cGUgb2YgZGF0YSBpbiBpdC5cclxuICAgICAqL1xyXG4gICAgZGF0YSA9IHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFNFVFRJTkdTIEZVTkNUSU9OOlxyXG4gICAgICAgKiAqKioqKioqKioqKioqKioqKipcclxuICAgICAgICovXHJcbiAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyB8fCBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogTUFJTiBEQVRBOlxyXG4gICAgICAgKiAqKioqKioqKioqXHJcbiAgICAgICAqL1xyXG4gICAgICBub2Rlc0FycmF5OiBbXSxcclxuICAgICAgZWRnZXNBcnJheTogW10sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogR0xPQkFMIElOREVYRVM6XHJcbiAgICAgICAqICoqKioqKioqKioqKioqKlxyXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIGp1c3QgaW5kZXggZGF0YSBieSBpZHMuXHJcbiAgICAgICAqL1xyXG4gICAgICBub2Rlc0luZGV4OiBuZXcgc2lnbWEudXRpbHMubWFwKCksXHJcbiAgICAgIGVkZ2VzSW5kZXg6IG5ldyBzaWdtYS51dGlscy5tYXAoKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBMT0NBTCBJTkRFWEVTOlxyXG4gICAgICAgKiAqKioqKioqKioqKioqKlxyXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIHJlZmVyIGZyb20gbm9kZSB0byBub2Rlcy4gRWFjaCBrZXkgaXMgYW4gaWQsIGFuZCBlYWNoXHJcbiAgICAgICAqIHZhbHVlIGlzIHRoZSBhcnJheSBvZiB0aGUgaWRzIG9mIHJlbGF0ZWQgbm9kZXMuXHJcbiAgICAgICAqL1xyXG4gICAgICBpbk5laWdoYm9yc0luZGV4OiBuZXcgc2lnbWEudXRpbHMubWFwKCksXHJcbiAgICAgIG91dE5laWdoYm9yc0luZGV4OiBuZXcgc2lnbWEudXRpbHMubWFwKCksXHJcbiAgICAgIGFsbE5laWdoYm9yc0luZGV4OiBuZXcgc2lnbWEudXRpbHMubWFwKClcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXhlY3V0ZSBiaW5kaW5nczpcclxuICAgIGZvciAoayBpbiBfaW5pdEJpbmRpbmdzKVxyXG4gICAgICBfaW5pdEJpbmRpbmdzW2tdLmNhbGwoZGF0YSk7XHJcblxyXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYm90aCB0aGUgc2NvcGUgYW5kIHRoZSBkYXRhIG9iamVjdHM6XHJcbiAgICBmb3IgKGsgaW4gX21ldGhvZHMpIHtcclxuICAgICAgZm4gPSBfX2JpbmRHcmFwaE1ldGhvZChrLCBkYXRhLCBfbWV0aG9kc1trXSk7XHJcbiAgICAgIHRoaXNba10gPSBmbjtcclxuICAgICAgZGF0YVtrXSA9IGZuO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgY3VzdG9tIHRvb2wgdG8gYmluZCBtZXRob2RzIHN1Y2ggdGhhdCBmdW5jdGlvbiB0aGF0IGFyZSBib3VuZCB0byBpdCB3aWxsXHJcbiAgICogYmUgZXhlY3V0ZWQgYW55dGltZSB0aGUgbWV0aG9kIGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gYmluZC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgc2NvcGUgICAgICBUaGUgc2NvcGUgd2hlcmUgdGhlIG1ldGhvZCBtdXN0IGJlIGV4ZWN1dGVkLlxyXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmbiAgICAgICAgIFRoZSBtZXRob2QgaXRzZWxmLlxyXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgICAgIFRoZSBuZXcgbWV0aG9kLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9fYmluZEdyYXBoTWV0aG9kKG1ldGhvZE5hbWUsIHNjb3BlLCBmbikge1xyXG4gICAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgayxcclxuICAgICAgICAgIHJlcztcclxuXHJcbiAgICAgIC8vIEV4ZWN1dGUgXCJiZWZvcmVcIiBib3VuZCBmdW5jdGlvbnM6XHJcbiAgICAgIGZvciAoayBpbiBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0pXHJcbiAgICAgICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdW2tdLmFwcGx5KHNjb3BlLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgLy8gQXBwbHkgdGhlIG1ldGhvZDpcclxuICAgICAgcmVzID0gZm4uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAvLyBFeGVjdXRlIGJvdW5kIGZ1bmN0aW9uczpcclxuICAgICAgZm9yIChrIGluIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSlcclxuICAgICAgICBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gcmVzOlxyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBjdXN0b20gdG9vbCBmdW5jdGlvbiByZW1vdmVzIGV2ZXJ5IHBhaXIga2V5L3ZhbHVlIGZyb20gYW4gaGFzaC4gVGhlXHJcbiAgICogZ29hbCBpcyB0byBhdm9pZCBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2hpbGUgc29tZSBvdGhlciByZWZlcmVuY2VzIGFyZVxyXG4gICAqIHN0aWxsIGhhbmdpbmcgaW4gc29tZSBzY29wZXMuLi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZW1wdHkuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIGVtcHR5IG9iamVjdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfX2VtcHR5T2JqZWN0KG9iaikge1xyXG4gICAgdmFyIGs7XHJcblxyXG4gICAgZm9yIChrIGluIG9iailcclxuICAgICAgaWYgKCEoJ2hhc093blByb3BlcnR5JyBpbiBvYmopIHx8IG9iai5oYXNPd25Qcm9wZXJ0eShrKSlcclxuICAgICAgICBkZWxldGUgb2JqW2tdO1xyXG5cclxuICAgIHJldHVybiBvYmo7XHJcbiAgfVxyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgYWRkcyBhIG1ldGhvZCB0aGF0IHdpbGwgYmUgYm91bmQgdG8gdGhlIGZ1dHVybHkgY3JlYXRlZFxyXG4gICAqIGdyYXBoIGluc3RhbmNlcy5cclxuICAgKlxyXG4gICAqIFNpbmNlIHRoZXNlIG1ldGhvZHMgd2lsbCBiZSBib3VuZCB0byB0aGVpciBzY29wZSB3aGVuIHRoZSBpbnN0YW5jZXMgYXJlXHJcbiAgICogY3JlYXRlZCwgaXQgZG9lcyBub3QgdXNlIHRoZSBwcm90b3R5cGUuIEJlY2F1c2Ugb2YgdGhhdCwgbWV0aG9kcyBoYXZlIHRvXHJcbiAgICogYmUgYWRkZWQgYmVmb3JlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlLlxyXG4gICAqXHJcbiAgICogSGVyZSBpcyBhbiBleGFtcGxlOlxyXG4gICAqXHJcbiAgICogID4gZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XHJcbiAgICogID4gICByZXR1cm4gdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aDtcclxuICAgKiAgPiB9KTtcclxuICAgKiAgPlxyXG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XHJcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBmbikge1xyXG4gICAgaWYgKFxyXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcclxuICAgIClcclxuICAgICAgdGhyb3cgJ2FkZE1ldGhvZDogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKF9tZXRob2RzW21ldGhvZE5hbWVdIHx8IGdyYXBoW21ldGhvZE5hbWVdKVxyXG4gICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcblxyXG4gICAgX21ldGhvZHNbbWV0aG9kTmFtZV0gPSBmbjtcclxuICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIG1ldGhvZCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLCBhbmRcclxuICAgKiBmYWxzZSBlbHNlLlxyXG4gICAqXHJcbiAgICogSGVyZSBhcmUgc29tZSBleGFtcGxlczpcclxuICAgKlxyXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnYWRkTm9kZScpOyAvLyByZXR1cm5zIHRydWVcclxuICAgKiAgPiBncmFwaC5oYXNNZXRob2QoJ2hhc01ldGhvZCcpOyAvLyByZXR1cm5zIHRydWVcclxuICAgKiAgPiBncmFwaC5oYXNNZXRob2QoJ3VuZXhpc3RpbmdNZXRob2QnKTsgLy8gcmV0dXJucyBmYWxzZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kLlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgVGhlIHJlc3VsdC5cclxuICAgKi9cclxuICBncmFwaC5oYXNNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XHJcbiAgICByZXR1cm4gISEoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZHMgYXR0YWNoZXMgYSBmdW5jdGlvbiB0byBhIG1ldGhvZC4gQW55dGltZSB0aGUgc3BlY2lmaWVkXHJcbiAgICogbWV0aG9kIGlzIGNhbGxlZCwgdGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBhZnRlciwgd2l0aCB0aGVcclxuICAgKiBzYW1lIGFyZ3VtZW50cyBhbmQgaW4gdGhlIHNhbWUgc2NvcGUuIFRoZSBhdHRhY2hlZCBmdW5jdGlvbiBpcyBjYWxsZWRcclxuICAgKiByaWdodCBiZWZvcmUgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgdHJ1ZSwgdW5sZXNzIHRoZSBtZXRob2QgaXMgdGhlIGdyYXBoXHJcbiAgICogY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBUbyBhdHRhY2ggYSBmdW5jdGlvbiB0byB0aGUgZ3JhcGggY29uc3RydWN0b3IsIHVzZSAnY29uc3RydWN0b3InIGFzIHRoZVxyXG4gICAqIG1ldGhvZCBuYW1lIChmaXJzdCBhcmd1bWVudCkuXHJcbiAgICpcclxuICAgKiBUaGUgbWFpbiBpZGVhIGlzIHRvIGhhdmUgYSBjbGVhbiB3YXkgdG8ga2VlcCBjdXN0b20gaW5kZXhlcyB1cCB0byBkYXRlLFxyXG4gICAqIGZvciBpbnN0YW5jZTpcclxuICAgKlxyXG4gICAqICA+IHZhciB0aW1lc0FkZE5vZGVDYWxsZWQgPSAwO1xyXG4gICAqICA+IGdyYXBoLmF0dGFjaCgnYWRkTm9kZScsICd0aW1lc0FkZE5vZGVDYWxsZWRJbmMnLCBmdW5jdGlvbigpIHtcclxuICAgKiAgPiAgIHRpbWVzQWRkTm9kZUNhbGxlZCsrO1xyXG4gICAqICA+IH0pO1xyXG4gICAqICA+XHJcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcclxuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDBcclxuICAgKiAgPlxyXG4gICAqICA+IG15R3JhcGguYWRkTm9kZSh7IGlkOiAnMScgfSkuYWRkTm9kZSh7IGlkOiAnMicgfSk7XHJcbiAgICogID4gY29uc29sZS5sb2codGltZXNBZGROb2RlQ2FsbGVkKTsgLy8gb3V0cHV0cyAyXHJcbiAgICpcclxuICAgKiBUaGUgaWRlYSBmb3IgY2FsbGluZyBhIGZ1bmN0aW9uIGJlZm9yZSBpcyB0byBwcm92aWRlIHByZS1wcm9jZXNzb3JzLCBmb3JcclxuICAgKiBpbnN0YW5jZTpcclxuICAgKlxyXG4gICAqICA+IHZhciBjb2xvclBhbGV0dGUgPSB7IFBlcnNvbjogJyNDM0NCRTEnLCBQbGFjZTogJyM5QkRFQkQnIH07XHJcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ2FwcGx5Tm9kZUNvbG9yUGFsZXR0ZScsIGZ1bmN0aW9uKG4pIHtcclxuICAgKiAgPiAgIG4uY29sb3IgPSBjb2xvclBhbGV0dGVbbi5jYXRlZ29yeV07XHJcbiAgICogID4gfSwgdHJ1ZSk7XHJcbiAgICogID5cclxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xyXG4gICAqICA+IG15R3JhcGguYWRkTm9kZSh7IGlkOiAnbjAnLCBjYXRlZ29yeTogJ1BlcnNvbicgfSk7XHJcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5ub2RlcygnbjAnKS5jb2xvcik7IC8vIG91dHB1dHMgJyNDM0NCRTEnXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgcmVsYXRlZCBtZXRob2Qgb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yXCIuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIGtleSAgICAgICAgVGhlIGtleSB0byBpZGVudGlmeSB0aGUgZnVuY3Rpb24gdG8gYXR0YWNoLlxyXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBmbiAgICAgICAgIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICBiZWZvcmUgICAgIElmIHRydWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBiZWZvcmUuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgVGhlIGdsb2JhbCBncmFwaCBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBncmFwaC5hdHRhY2ggPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuLCBiZWZvcmUpIHtcclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIG1ldGhvZE5hbWUgIT09ICdzdHJpbmcnIHx8XHJcbiAgICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XHJcbiAgICAgIHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyB8fFxyXG4gICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMyB8fFxyXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gNFxyXG4gICAgKVxyXG4gICAgICB0aHJvdyAnYXR0YWNoOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICB2YXIgYmluZGluZ3M7XHJcblxyXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjb25zdHJ1Y3RvcicpXHJcbiAgICAgIGJpbmRpbmdzID0gX2luaXRCaW5kaW5ncztcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoYmVmb3JlKSB7XHJcbiAgICAgICAgaWYgKCFfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV0pXHJcbiAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xyXG5cclxuICAgICAgICBiaW5kaW5ncyA9IF9tZXRob2RCZWZvcmVCaW5kaW5nc1ttZXRob2ROYW1lXTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAoIV9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSlcclxuICAgICAgICAgIHRocm93ICdUaGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcclxuXHJcbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmluZGluZ3Nba2V5XSlcclxuICAgICAgdGhyb3cgJ0EgZnVuY3Rpb24gXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgYXR0YWNoZWQgJyArXHJcbiAgICAgICAgICAgICd0byB0aGUgbWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIuJztcclxuXHJcbiAgICBiaW5kaW5nc1trZXldID0gZm47XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWxpYXMgb2YgYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpLlxyXG4gICAqL1xyXG4gIGdyYXBoLmF0dGFjaEJlZm9yZSA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGtleSwgZm4pIHtcclxuICAgIHJldHVybiB0aGlzLmF0dGFjaChtZXRob2ROYW1lLCBrZXksIGZuLCB0cnVlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZHMgaXMganVzdCBhbiBoZWxwZXIgdG8gZGVhbCB3aXRoIGN1c3RvbSBpbmRleGVzLiBJdCB0YWtlcyBhc1xyXG4gICAqIGFyZ3VtZW50cyB0aGUgbmFtZSBvZiB0aGUgaW5kZXggYW5kIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgZGlmZmVyZW50XHJcbiAgICogZnVuY3Rpb25zIHRvIGJpbmQgdG8gdGhlIG1ldGhvZHMuXHJcbiAgICpcclxuICAgKiBIZXJlIGlzIGEgYmFzaWMgZXhhbXBsZSwgdGhhdCBjcmVhdGVzIGFuIGluZGV4IHRvIGtlZXAgdGhlIG51bWJlciBvZiBub2Rlc1xyXG4gICAqIGluIHRoZSBjdXJyZW50IGdyYXBoLiBJdCBhbHNvIGFkZHMgYSBtZXRob2QgdG8gcHJvdmlkZSBhIGdldHRlciBvbiB0aGF0XHJcbiAgICogbmV3IGluZGV4OlxyXG4gICAqXHJcbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRJbmRleCgnbm9kZXNDb3VudCcsIHtcclxuICAgKiAgPiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgKiAgPiAgICAgdGhpcy5ub2Rlc0NvdW50ID0gMDtcclxuICAgKiAgPiAgIH0sXHJcbiAgICogID4gICBhZGROb2RlOiBmdW5jdGlvbigpIHtcclxuICAgKiAgPiAgICAgdGhpcy5ub2Rlc0NvdW50Kys7XHJcbiAgICogID4gICB9LFxyXG4gICAqICA+ICAgZHJvcE5vZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQtLTtcclxuICAgKiAgPiAgIH1cclxuICAgKiAgPiB9KTtcclxuICAgKiAgPlxyXG4gICAqICA+IHNpZ21hLmNsYXNzZXMuZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XHJcbiAgICogID4gICByZXR1cm4gdGhpcy5ub2Rlc0NvdW50O1xyXG4gICAqICA+IH0pO1xyXG4gICAqICA+XHJcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCgpO1xyXG4gICAqICA+IGNvbnNvbGUubG9nKG15R3JhcGguZ2V0Tm9kZXNDb3VudCgpKTsgLy8gb3V0cHV0cyAwXHJcbiAgICogID5cclxuICAgKiAgPiBteUdyYXBoLmFkZE5vZGUoeyBpZDogJzEnIH0pLmFkZE5vZGUoeyBpZDogJzInIH0pO1xyXG4gICAqICA+IGNvbnNvbGUubG9nKG15R3JhcGguZ2V0Tm9kZXNDb3VudCgpKTsgLy8gb3V0cHV0cyAyXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSBpbmRleC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGJpbmRpbmdzIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgZnVuY3Rpb25zIHRvIGJpbmQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZEluZGV4ID0gZnVuY3Rpb24obmFtZSwgYmluZGluZ3MpIHtcclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8XHJcbiAgICAgIE9iamVjdChiaW5kaW5ncykgIT09IGJpbmRpbmdzIHx8XHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcclxuICAgIClcclxuICAgICAgdGhyb3cgJ2FkZEluZGV4OiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAoX2luZGV4ZXNbbmFtZV0pXHJcbiAgICAgIHRocm93ICdUaGUgaW5kZXggXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xyXG5cclxuICAgIHZhciBrO1xyXG5cclxuICAgIC8vIFN0b3JlIHRoZSBiaW5kaW5nczpcclxuICAgIF9pbmRleGVzW25hbWVdID0gYmluZGluZ3M7XHJcblxyXG4gICAgLy8gQXR0YWNoIHRoZSBiaW5kaW5nczpcclxuICAgIGZvciAoayBpbiBiaW5kaW5ncylcclxuICAgICAgaWYgKHR5cGVvZiBiaW5kaW5nc1trXSAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICB0aHJvdyAnVGhlIGJpbmRpbmdzIG11c3QgYmUgZnVuY3Rpb25zLic7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBncmFwaC5hdHRhY2goaywgbmFtZSwgYmluZGluZ3Nba10pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGFkZHMgYSBub2RlIHRvIHRoZSBncmFwaC4gVGhlIG5vZGUgbXVzdCBiZSBhbiBvYmplY3QsIHdpdGggYVxyXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIi4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgYW55XHJcbiAgICogb3RoZXIgYXR0cmlidXRlLCB0aGF0IHdpbGwgYmUgcHJlc2VydmVkIGFsbCBhbG9uZyB0aGUgbWFuaXB1bGF0aW9ucy5cclxuICAgKlxyXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIG5vZGUgd2lsbCBiZSBjbG9uZWRcclxuICAgKiB3aGVuIGFkZGVkIHRvIHRoZSBncmFwaC4gQWxzbywgaWYgdGhlIGdyYXBoIG9wdGlvbiBcImltbXV0YWJsZVwiIGhhcyBhXHJcbiAgICogdHJ1dGh5IHZhbHVlLCBpdHMgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gbm9kZSBUaGUgbm9kZSB0byBhZGQuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ2FkZE5vZGUnLCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBub2RlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxyXG4gICAgaWYgKE9iamVjdChub2RlKSAhPT0gbm9kZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxyXG4gICAgICB0aHJvdyAnYWRkTm9kZTogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBub2RlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygbm9kZS5pZCAhPT0gJ251bWJlcicpXHJcbiAgICAgIHRocm93ICdUaGUgbm9kZSBtdXN0IGhhdmUgYSBzdHJpbmcgb3IgbnVtYmVyIGlkLic7XHJcblxyXG4gICAgaWYgKHRoaXMubm9kZXNJbmRleC5nZXQobm9kZS5pZCkpXHJcbiAgICAgIHRocm93ICdUaGUgbm9kZSBcIicgKyBub2RlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XHJcblxyXG4gICAgdmFyIGssXHJcbiAgICAgICAgaWQgPSBub2RlLmlkLFxyXG4gICAgICAgIHZhbGlkTm9kZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xyXG4gICAgICBmb3IgKGsgaW4gbm9kZSlcclxuICAgICAgICBpZiAoayAhPT0gJ2lkJylcclxuICAgICAgICAgIHZhbGlkTm9kZVtrXSA9IG5vZGVba107XHJcbiAgICB9IGVsc2VcclxuICAgICAgdmFsaWROb2RlID0gbm9kZTtcclxuXHJcbiAgICAvLyBUcnkgdG8gZml4IHRoZSBub2RlIGNvb3JkaW5hdGVzIGFuZCBzaXplXHJcbiAgICBpZiAodmFsaWROb2RlLnggIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsaWROb2RlLnggIT09ICdudW1iZXInKSB7XHJcbiAgICAgIHZhbGlkTm9kZS54ID0gcGFyc2VGbG9hdCh2YWxpZE5vZGUueCk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsaWROb2RlLnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsaWROb2RlLnkgIT09ICdudW1iZXInKSB7XHJcbiAgICAgIHZhbGlkTm9kZS55ID0gcGFyc2VGbG9hdCh2YWxpZE5vZGUueSk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsaWROb2RlLnNpemUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsaWROb2RlLnNpemUgIT09ICdudW1iZXInKSB7XHJcbiAgICAgIHZhbGlkTm9kZS5zaXplID0gcGFyc2VGbG9hdCh2YWxpZE5vZGUuc2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgbm9kZSBzaXplXHJcbiAgICBpZiAoIXZhbGlkTm9kZS5zaXplIHx8IHZhbGlkTm9kZS5zaXplIDw9IDApIHtcclxuICAgICAgdmFsaWROb2RlLnNpemUgPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIHRoZSBcImltbXV0YWJsZVwiIG9wdGlvbjpcclxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSlcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkTm9kZSwgJ2lkJywge1xyXG4gICAgICAgIHZhbHVlOiBpZCxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgZWxzZVxyXG4gICAgICB2YWxpZE5vZGUuaWQgPSBpZDtcclxuXHJcbiAgICAvLyBBZGQgZW1wdHkgY29udGFpbmVycyBmb3IgZWRnZXMgaW5kZXhlczpcclxuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleC5zZXQoaWQsIG5ldyBzaWdtYS51dGlscy5tYXAoKSk7XHJcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LnNldChpZCwgbmV3IHNpZ21hLnV0aWxzLm1hcCgpKTtcclxuICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguc2V0KGlkLCBuZXcgc2lnbWEudXRpbHMubWFwKCkpO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgbm9kZSB0byBpbmRleGVzOlxyXG4gICAgdGhpcy5ub2Rlc0FycmF5LnB1c2godmFsaWROb2RlKTtcclxuICAgIHRoaXMubm9kZXNJbmRleC5zZXQodmFsaWROb2RlLmlkLCB2YWxpZE5vZGUpO1xyXG5cclxuICAgIC8vIFJldHVybiB0aGUgY3VycmVudCBpbnN0YW5jZTpcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGdyYXBoLiBUaGUgZWRnZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXHJcbiAgICogc3RyaW5nIHVuZGVyIHRoZSBrZXkgXCJpZFwiLCBhbmQgc3RyaW5ncyB1bmRlciB0aGUga2V5cyBcInNvdXJjZVwiIGFuZFxyXG4gICAqIFwidGFyZ2V0XCIgdGhhdCBkZXNpZ24gZXhpc3Rpbmcgbm9kZXMuIEV4Y2VwdCBmb3IgdGhpcywgaXQgaXMgcG9zc2libGUgdG9cclxuICAgKiBhZGQgYW55IG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlXHJcbiAgICogbWFuaXB1bGF0aW9ucy5cclxuICAgKlxyXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIGVkZ2Ugd2lsbCBiZSBjbG9uZWRcclxuICAgKiB3aGVuIGFkZGVkIHRvIHRoZSBncmFwaC4gQWxzbywgaWYgdGhlIGdyYXBoIG9wdGlvbiBcImltbXV0YWJsZVwiIGhhcyBhXHJcbiAgICogdHJ1dGh5IHZhbHVlLCBpdHMgaWQsIHNvdXJjZSBhbmQgdGFyZ2V0IHdpbGwgYmUgZGVmaW5lZCBhcyBpbW11dGFibGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVkZ2UgVGhlIGVkZ2UgdG8gYWRkLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICBUaGUgZ3JhcGggaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGRFZGdlJywgZnVuY3Rpb24oZWRnZSkge1xyXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZWRnZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhbiBpZDpcclxuICAgIGlmIChPYmplY3QoZWRnZSkgIT09IGVkZ2UgfHwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcclxuICAgICAgdGhyb3cgJ2FkZEVkZ2U6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZWRnZS5pZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2UuaWQgIT09ICdudW1iZXInKVxyXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xyXG5cclxuICAgIGlmICgodHlwZW9mIGVkZ2Uuc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdudW1iZXInKSB8fFxyXG4gICAgICAgICF0aGlzLm5vZGVzSW5kZXguZ2V0KGVkZ2Uuc291cmNlKSlcclxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIHNvdXJjZSBtdXN0IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBpZC4nO1xyXG5cclxuICAgIGlmICgodHlwZW9mIGVkZ2UudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdudW1iZXInKSB8fFxyXG4gICAgICAgICF0aGlzLm5vZGVzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KSlcclxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIHRhcmdldCBtdXN0IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBpZC4nO1xyXG5cclxuICAgIGlmICh0aGlzLmVkZ2VzSW5kZXguZ2V0KGVkZ2UuaWQpKVxyXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgZWRnZS5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xyXG5cclxuICAgIHZhciBrLFxyXG4gICAgICAgIHZhbGlkRWRnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xyXG4gICAgICBmb3IgKGsgaW4gZWRnZSlcclxuICAgICAgICBpZiAoayAhPT0gJ2lkJyAmJiBrICE9PSAnc291cmNlJyAmJiBrICE9PSAndGFyZ2V0JylcclxuICAgICAgICAgIHZhbGlkRWRnZVtrXSA9IGVkZ2Vba107XHJcbiAgICB9IGVsc2VcclxuICAgICAgdmFsaWRFZGdlID0gZWRnZTtcclxuXHJcbiAgICAvLyBUcnkgdG8gZml4IHRoZSBlZGdlIHNpemVcclxuICAgIGlmICh2YWxpZEVkZ2Uuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWxpZEVkZ2Uuc2l6ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgdmFsaWRFZGdlLnNpemUgPSBwYXJzZUZsb2F0KHZhbGlkRWRnZS5zaXplKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBlZGdlIHNpemVcclxuICAgIGlmICghdmFsaWRFZGdlLnNpemUgfHwgdmFsaWRFZGdlLnNpemUgPD0gMCkge1xyXG4gICAgICB2YWxpZEVkZ2Uuc2l6ZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2ltbXV0YWJsZScpKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICdpZCcsIHtcclxuICAgICAgICB2YWx1ZTogZWRnZS5pZCxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ3NvdXJjZScsIHtcclxuICAgICAgICB2YWx1ZTogZWRnZS5zb3VyY2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICd0YXJnZXQnLCB7XHJcbiAgICAgICAgdmFsdWU6IGVkZ2UudGFyZ2V0LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWxpZEVkZ2UuaWQgPSBlZGdlLmlkO1xyXG4gICAgICB2YWxpZEVkZ2Uuc291cmNlID0gZWRnZS5zb3VyY2U7XHJcbiAgICAgIHZhbGlkRWRnZS50YXJnZXQgPSBlZGdlLnRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIGVkZ2UgdG8gaW5kZXhlczpcclxuICAgIHRoaXMuZWRnZXNBcnJheS5wdXNoKHZhbGlkRWRnZSk7XHJcbiAgICB0aGlzLmVkZ2VzSW5kZXguc2V0KHZhbGlkRWRnZS5pZCwgdmFsaWRFZGdlKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuaW5OZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnRhcmdldCkuZ2V0KHZhbGlkRWRnZS5zb3VyY2UpKVxyXG4gICAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS50YXJnZXQpLnNldCh2YWxpZEVkZ2Uuc291cmNlLFxyXG4gICAgICAgIG5ldyBzaWdtYS51dGlscy5tYXAoKSk7XHJcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS50YXJnZXQpLmdldCh2YWxpZEVkZ2Uuc291cmNlKS5zZXQodmFsaWRFZGdlLmlkLFxyXG4gICAgICB2YWxpZEVkZ2UpO1xyXG5cclxuICAgIGlmICghdGhpcy5vdXROZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnNvdXJjZSkuZ2V0KHZhbGlkRWRnZS50YXJnZXQpKVxyXG4gICAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2Uuc291cmNlKS5zZXQodmFsaWRFZGdlLnRhcmdldCxcclxuICAgICAgICBuZXcgc2lnbWEudXRpbHMubWFwKCkpO1xyXG4gICAgdGhpcy5vdXROZWlnaGJvcnNJbmRleC5nZXQodmFsaWRFZGdlLnNvdXJjZSkuZ2V0KHZhbGlkRWRnZS50YXJnZXQpLnNldCh2YWxpZEVkZ2UuaWQsXHJcbiAgICAgIHZhbGlkRWRnZSk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2Uuc291cmNlKS5nZXQodmFsaWRFZGdlLnRhcmdldCkpXHJcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS5zb3VyY2UpLnNldCh2YWxpZEVkZ2UudGFyZ2V0LFxyXG4gICAgICAgIG5ldyBzaWdtYS51dGlscy5tYXAoKSk7XHJcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2Uuc291cmNlKS5nZXQodmFsaWRFZGdlLnRhcmdldCkuc2V0KHZhbGlkRWRnZS5pZCxcclxuICAgICAgdmFsaWRFZGdlKTtcclxuXHJcbiAgICBpZiAodmFsaWRFZGdlLnRhcmdldCAhPT0gdmFsaWRFZGdlLnNvdXJjZSkge1xyXG4gICAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS50YXJnZXQpLmdldCh2YWxpZEVkZ2Uuc291cmNlKSlcclxuICAgICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldCh2YWxpZEVkZ2UudGFyZ2V0KS5zZXQodmFsaWRFZGdlLnNvdXJjZSxcclxuICAgICAgICAgIG5ldyBzaWdtYS51dGlscy5tYXAoKSk7XHJcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KHZhbGlkRWRnZS50YXJnZXQpLmdldCh2YWxpZEVkZ2Uuc291cmNlKS5zZXQodmFsaWRFZGdlLmlkLFxyXG4gICAgICAgIHZhbGlkRWRnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGRyb3BzIGEgbm9kZSBmcm9tIHRoZSBncmFwaC4gSXQgYWxzbyByZW1vdmVzIGVhY2ggZWRnZSB0aGF0IGlzXHJcbiAgICogYm91bmQgdG8gaXQsIHRocm91Z2ggdGhlIGRyb3BFZGdlIG1ldGhvZC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBub2RlXHJcbiAgICogZG9lcyBub3QgZXhpc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBub2RlIGlkLlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcE5vZGUnLCBmdW5jdGlvbihpZCkge1xyXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcclxuICAgIGlmICgodHlwZW9mIGlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgaWQgIT09ICdudW1iZXInKSB8fFxyXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXHJcbiAgICAgIHRocm93ICdkcm9wTm9kZTogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKCF0aGlzLm5vZGVzSW5kZXguZ2V0KGlkKSlcclxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XHJcblxyXG4gICAgdmFyIGksIGssIGw7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gaW5kZXhlczpcclxuICAgIHRoaXMubm9kZXNJbmRleC5kZWxldGUoaWQpO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMubm9kZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGlmICh0aGlzLm5vZGVzQXJyYXlbaV0uaWQgPT09IGlkKSB7XHJcbiAgICAgICAgdGhpcy5ub2Rlc0FycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2VzOlxyXG4gICAgZm9yIChpID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICBpZiAodGhpcy5lZGdlc0FycmF5W2ldLnNvdXJjZSA9PT0gaWQgfHwgdGhpcy5lZGdlc0FycmF5W2ldLnRhcmdldCA9PT0gaWQpXHJcbiAgICAgICAgdGhpcy5kcm9wRWRnZSh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQpO1xyXG5cclxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2UgaW5kZXhlczpcclxuICAgIHRoaXMuaW5OZWlnaGJvcnNJbmRleC5kZWxldGUoaWQpO1xyXG4gICAgdGhpcy5vdXROZWlnaGJvcnNJbmRleC5kZWxldGUoaWQpO1xyXG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleC5kZWxldGUoaWQpO1xyXG5cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRoaXMubm9kZXNJbmRleC5mb3JFYWNoKGZ1bmN0aW9uKG4sIGspIHtcclxuICAgICAgc2VsZi5pbk5laWdoYm9yc0luZGV4LmdldChrKS5kZWxldGUoaWQpO1xyXG4gICAgICBzZWxmLm91dE5laWdoYm9yc0luZGV4LmdldChrKS5kZWxldGUoaWQpO1xyXG4gICAgICBzZWxmLmFsbE5laWdoYm9yc0luZGV4LmdldChrKS5kZWxldGUoaWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGRyb3BzIGFuIGVkZ2UgZnJvbSB0aGUgZ3JhcGguIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgZWRnZVxyXG4gICAqIGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCBUaGUgZWRnZSBpZC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ2Ryb3BFZGdlJywgZnVuY3Rpb24oaWQpIHtcclxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGFyZ3VtZW50cyBhcmUgdmFsaWQ6XHJcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcclxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxyXG4gICAgICB0aHJvdyAnZHJvcEVkZ2U6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIGlmICghdGhpcy5lZGdlc0luZGV4LmdldChpZCkpXHJcbiAgICAgIHRocm93ICdUaGUgZWRnZSBcIicgKyBpZCArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xyXG5cclxuICAgIHZhciBpLCBsLCBlZGdlO1xyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgZWRnZSBmcm9tIGluZGV4ZXM6XHJcbiAgICBlZGdlID0gdGhpcy5lZGdlc0luZGV4LmdldChpZCk7XHJcbiAgICB0aGlzLmVkZ2VzSW5kZXguZGVsZXRlKGlkKTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBpZiAodGhpcy5lZGdlc0FycmF5W2ldLmlkID09PSBpZCkge1xyXG4gICAgICAgIHRoaXMuZWRnZXNBcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KS5nZXQoZWRnZS5zb3VyY2UpLmRlbGV0ZShlZGdlLmlkKTtcclxuICAgIGlmICh0aGlzLmluTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KS5nZXQoZWRnZS5zb3VyY2UpLnNpemUgPT0gMClcclxuICAgICAgdGhpcy5pbk5laWdoYm9yc0luZGV4LmdldChlZGdlLnRhcmdldCkuZGVsZXRlKGVkZ2Uuc291cmNlKTtcclxuXHJcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LmdldChlZGdlLnNvdXJjZSkuZ2V0KGVkZ2UudGFyZ2V0KS5kZWxldGUoZWRnZS5pZCk7XHJcbiAgICBpZiAodGhpcy5vdXROZWlnaGJvcnNJbmRleC5nZXQoZWRnZS5zb3VyY2UpLmdldChlZGdlLnRhcmdldCkuc2l6ZSA9PSAwKVxyXG4gICAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LmdldChlZGdlLnNvdXJjZSkuZGVsZXRlKGVkZ2UudGFyZ2V0KTtcclxuXHJcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldChlZGdlLnNvdXJjZSkuZ2V0KGVkZ2UudGFyZ2V0KS5kZWxldGUoZWRnZS5pZCk7XHJcbiAgICBpZiAodGhpcy5hbGxOZWlnaGJvcnNJbmRleC5nZXQoZWRnZS5zb3VyY2UpLmdldChlZGdlLnRhcmdldCkuc2l6ZSA9PSAwKVxyXG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldChlZGdlLnNvdXJjZSkuZGVsZXRlKGVkZ2UudGFyZ2V0KTtcclxuXHJcbiAgICBpZiAoZWRnZS50YXJnZXQgIT09IGVkZ2Uuc291cmNlKSB7XHJcbiAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KS5nZXQoZWRnZS5zb3VyY2UpLmRlbGV0ZShlZGdlLmlkKTtcclxuICAgICAgaWYgKHRoaXMuYWxsTmVpZ2hib3JzSW5kZXguZ2V0KGVkZ2UudGFyZ2V0KS5nZXQoZWRnZS5zb3VyY2UpLnNpemUgPT0gMClcclxuICAgICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmdldChlZGdlLnRhcmdldCkuZGVsZXRlKGVkZ2Uuc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgZGVzdHJveXMgdGhlIGN1cnJlbnQgaW5zdGFuY2UuIEl0IGJhc2ljYWxseSBlbXB0aWVzIGVhY2ggaW5kZXhcclxuICAgKiBhbmQgbWV0aG9kcyBhdHRhY2hlZCB0byB0aGUgZ3JhcGguXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkTWV0aG9kKCdraWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBEZWxldGUgYXJyYXlzOlxyXG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmVkZ2VzQXJyYXkubGVuZ3RoID0gMDtcclxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzQXJyYXk7XHJcbiAgICBkZWxldGUgdGhpcy5lZGdlc0FycmF5O1xyXG5cclxuICAgIC8vIERlbGV0ZSBpbmRleGVzOlxyXG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleDtcclxuICAgIGRlbGV0ZSB0aGlzLmVkZ2VzSW5kZXg7XHJcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4O1xyXG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzSW5kZXg7XHJcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleDtcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgZW1wdGllcyB0aGUgbm9kZXMgYW5kIGVkZ2VzIGFycmF5cywgYXMgd2VsbCBhcyB0aGUgZGlmZmVyZW50XHJcbiAgICogaW5kZXhlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIGdyYXBoIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgnY2xlYXInLCBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMubm9kZXNBcnJheS5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XHJcblxyXG4gICAgLy8gRHVlIHRvIEdDIGlzc3VlcywgSSBwcmVmZXIgbm90IHRvIGNyZWF0ZSBuZXcgb2JqZWN0LiBUaGVzZSBvYmplY3RzIGFyZVxyXG4gICAgLy8gb25seSBhdmFpbGFibGUgZnJvbSB0aGUgbWV0aG9kcyBhbmQgYXR0YWNoZWQgZnVuY3Rpb25zLCBidXQgc3RpbGwsIGl0IGlzXHJcbiAgICAvLyBiZXR0ZXIgdG8gcHJldmVudCBnaG9zdCByZWZlcmVuY2VzIHRvIHVucmVsZXZhbnQgZGF0YS4uLlxyXG4gICAgdGhpcy5ub2Rlc0luZGV4LmNsZWFyKCk7XHJcbiAgICB0aGlzLmVkZ2VzSW5kZXguY2xlYXIoKTtcclxuICAgIHRoaXMubm9kZXNJbmRleC5jbGVhcigpO1xyXG4gICAgdGhpcy5pbk5laWdoYm9yc0luZGV4LmNsZWFyKCk7XHJcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4LmNsZWFyKCk7XHJcbiAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4LmNsZWFyKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHJlYWRzIGFuIG9iamVjdCBhbmQgYWRkcyB0aGUgbm9kZXMgYW5kIGVkZ2VzLCB0aHJvdWdoIHRoZVxyXG4gICAqIHByb3BlciBtZXRob2RzIFwiYWRkTm9kZVwiIGFuZCBcImFkZEVkZ2VcIi5cclxuICAgKlxyXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcclxuICAgKlxyXG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IGdyYXBoKCk7XHJcbiAgICogID4gbXlHcmFwaC5yZWFkKHtcclxuICAgKiAgPiAgIG5vZGVzOiBbXHJcbiAgICogID4gICAgIHsgaWQ6ICduMCcgfSxcclxuICAgKiAgPiAgICAgeyBpZDogJ24xJyB9XHJcbiAgICogID4gICBdLFxyXG4gICAqICA+ICAgZWRnZXM6IFtcclxuICAgKiAgPiAgICAge1xyXG4gICAqICA+ICAgICAgIGlkOiAnZTAnLFxyXG4gICAqICA+ICAgICAgIHNvdXJjZTogJ24wJyxcclxuICAgKiAgPiAgICAgICB0YXJnZXQ6ICduMSdcclxuICAgKiAgPiAgICAgfVxyXG4gICAqICA+ICAgXVxyXG4gICAqICA+IH0pO1xyXG4gICAqICA+XHJcbiAgICogID4gY29uc29sZS5sb2coXHJcbiAgICogID4gICBteUdyYXBoLm5vZGVzKCkubGVuZ3RoLFxyXG4gICAqICA+ICAgbXlHcmFwaC5lZGdlcygpLmxlbmd0aFxyXG4gICAqICA+ICk7IC8vIG91dHB1dHMgMiAxXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGcgVGhlIGdyYXBoIG9iamVjdC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGdyYXBoIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGdyYXBoLmFkZE1ldGhvZCgncmVhZCcsIGZ1bmN0aW9uKGcpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgbDtcclxuXHJcbiAgICBhID0gZy5ub2RlcyB8fCBbXTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgdGhpcy5hZGROb2RlKGFbaV0pO1xyXG5cclxuICAgIGEgPSBnLmVkZ2VzIHx8IFtdO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICB0aGlzLmFkZEVkZ2UoYVtpXSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2Ygbm9kZXMsIGNhbGwgXCJub2Rlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXHJcbiAgICogc3BlY2lmaWMgbm9kZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgbm9kZS4gVGhlIGdldCBtdWx0aXBsZSBub2RlLFxyXG4gICAqIGNhbGwgaXQgd2l0aCBhbiBhcnJheSBvZiBpZHMsIGFuZCBpdCB3aWxsIHJldHVybiB0aGUgYXJyYXkgb2Ygbm9kZXMsIGluXHJcbiAgICogdGhlIHNhbWUgb3JkZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xhcnJheSl9IHYgRXZlbnR1YWxseSBvbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgbm9kZSBvciBhcnJheSBvZiBub2Rlcy5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ25vZGVzJywgZnVuY3Rpb24odikge1xyXG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIG5vZGVzIGFuZCByZXR1cm4gaXQ6XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkuc2xpY2UoMCk7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNJbmRleC5nZXQodik7XHJcblxyXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIG5vZGU6XHJcbiAgICBpZiAoXHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nXHJcbiAgICApIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgICBsLFxyXG4gICAgICAgICAgYSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgYS5wdXNoKHRoaXMubm9kZXNJbmRleC5nZXQodltpXSkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93ICdub2RlczogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyB0aGUgZGVncmVlIG9mIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93XHJcbiAgICogaXQgaXMgY2FsbGVkLiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGdldCBpbmNvbWluZyBvciBvdXRjb21pbmcgZGVncmVlc1xyXG4gICAqIGluc3RlYWQgYnkgc3BlY2lmeWluZyAnaW4nIG9yICdvdXQnIGFzIGEgc2Vjb25kIGFyZ3VtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fSB2ICAgICBPbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cclxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgIHdoaWNoIFdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZC4gVmFsdWVzIGFyZSAnaW4nLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ291dCcsIGFuZCBieSBkZWZhdWx0IHRoZSBub3JtYWwgZGVncmVlLlxyXG4gICAqIEByZXR1cm4ge251bWJlcnxhcnJheX0gICAgICAgVGhlIHJlbGF0ZWQgZGVncmVlIG9yIGFycmF5IG9mIGRlZ3JlZXMuXHJcbiAgICovXHJcbiAgZ3JhcGguYWRkTWV0aG9kKCdkZWdyZWUnLCBmdW5jdGlvbih2LCB3aGljaCkge1xyXG4gICAgLy8gQ2hlY2sgd2hpY2ggZGVncmVlIGlzIHJlcXVpcmVkOlxyXG4gICAgd2hpY2ggPSB7XHJcbiAgICAgICdpbic6IHRoaXMuaW5OZWlnaGJvcnNJbmRleCxcclxuICAgICAgJ291dCc6IHRoaXMub3V0TmVpZ2hib3JzSW5kZXhcclxuICAgIH1bd2hpY2ggfHwgJyddIHx8IHRoaXMuYWxsTmVpZ2hib3JzSW5kZXg7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XHJcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcclxuICAgICAgcmV0dXJuIHdoaWNoLmdldCh2KS5zaXplO1xyXG5cclxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG4gICAgICB2YXIgaSxcclxuICAgICAgICAgIGwsXHJcbiAgICAgICAgICBhID0gW107XHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICBhLnB1c2god2hpY2guZ2V0KHZbaV0pLnNpemUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93ICdkZWdyZWU6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIGVkZ2VzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2YgZWRnZXMsIGNhbGwgXCJlZGdlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXHJcbiAgICogc3BlY2lmaWMgZWRnZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgZWRnZS4gVGhlIGdldCBtdWx0aXBsZSBlZGdlLFxyXG4gICAqIGNhbGwgaXQgd2l0aCBhbiBhcnJheSBvZiBpZHMsIGFuZCBpdCB3aWxsIHJldHVybiB0aGUgYXJyYXkgb2YgZWRnZXMsIGluXHJcbiAgICogdGhlIHNhbWUgb3JkZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xhcnJheSl9IHYgRXZlbnR1YWxseSBvbmUgaWQsIGFuIGFycmF5IG9mIGlkcy5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgZWRnZSBvciBhcnJheSBvZiBlZGdlcy5cclxuICAgKi9cclxuICBncmFwaC5hZGRNZXRob2QoJ2VkZ2VzJywgZnVuY3Rpb24odikge1xyXG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm4gaXQ6XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzQXJyYXkuc2xpY2UoMCk7XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIGVkZ2U6XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcclxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNJbmRleC5nZXQodik7XHJcblxyXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSByZWxhdGVkIGVkZ2U6XHJcbiAgICBpZiAoXHJcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBBcnJheV0nXHJcbiAgICApIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgICBsLFxyXG4gICAgICAgICAgYSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IHYubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgYS5wdXNoKHRoaXMuZWRnZXNJbmRleC5nZXQodltpXSkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93ICdlZGdlczogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyAnZWRnZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG4gIH0pO1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRVhQT1JUOlxyXG4gICAqICoqKioqKipcclxuICAgKi9cclxuICBpZiAodHlwZW9mIHNpZ21hICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgc2lnbWEuY2xhc3NlcyA9IHNpZ21hLmNsYXNzZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHNpZ21hLmNsYXNzZXMuZ3JhcGggPSBncmFwaDtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxyXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBncmFwaDtcclxuICAgIGV4cG9ydHMuZ3JhcGggPSBncmFwaDtcclxuICB9IGVsc2VcclxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNsYXNzZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGNhbWVyYSBjb25zdHJ1Y3Rvci4gSXQganVzdCBpbml0aWFsaXplcyBpdHMgYXR0cmlidXRlcyBhbmQgbWV0aG9kcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgaWQgICAgICAgVGhlIGlkLlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICBncmFwaCAgICBUaGUgZ3JhcGguXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICBvcHRpb25zICBFdmVudHVhbGx5IHNvbWUgb3ZlcnJpZGluZyBvcHRpb25zLlxyXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgZnJlc2ggbmV3IGNhbWVyYSBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5jbGFzc2VzLmNhbWVyYSA9IGZ1bmN0aW9uKGlkLCBncmFwaCwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcclxuICAgICAgdmFsdWU6IGdyYXBoXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWQnLCB7XHJcbiAgICAgIHZhbHVlOiBpZFxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWRQcmVmaXgnLCB7XHJcbiAgICAgIHZhbHVlOiAncmVhZF9jYW0nICsgaWQgKyAnOidcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmVmaXgnLCB7XHJcbiAgICAgIHZhbHVlOiAnY2FtJyArIGlkICsgJzonXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnggPSAwO1xyXG4gICAgdGhpcy55ID0gMDtcclxuICAgIHRoaXMucmF0aW8gPSAxO1xyXG4gICAgdGhpcy5hbmdsZSA9IDA7XHJcbiAgICB0aGlzLmlzQW5pbWF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMpID9cclxuICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3Qob3B0aW9ucykgOlxyXG4gICAgICBzZXR0aW5ncztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBjYW1lcmEgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvb3JkaW5hdGVzIFRoZSBuZXcgY29vcmRpbmF0ZXMgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge2NhbWVyYX0gICAgICAgICAgICAgUmV0dXJucyB0aGUgY2FtZXJhLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcclxuICAgIGlmICghdGhpcy5zZXR0aW5ncygnZW5hYmxlQ2FtZXJhJykpXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYyA9IGNvb3JkaW5hdGVzIHx8IHt9LFxyXG4gICAgICAgIGtleXMgPSAoJ3JhdGlvJyBpbiBjb29yZGluYXRlcyAmJiAhdGhpcy5zZXR0aW5ncygnem9vbU9uTG9jYXRpb24nKSlcclxuICAgICAgICAgID8gWydyYXRpbycsICdhbmdsZSddIDogWyd4JywgJ3knLCAncmF0aW8nLCAnYW5nbGUnXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGlmIChjW2tleXNbaV1dICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNba2V5c1tpXV0gPT09ICdudW1iZXInICYmICFpc05hTihjW2tleXNbaV1dKSlcclxuICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBjW2tleXNbaV1dO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93ICdWYWx1ZSBmb3IgXCInICsga2V5c1tpXSArICdcIiBpcyBub3QgYSBudW1iZXIuJztcclxuICAgICAgfVxyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnY29vcmRpbmF0ZXNVcGRhdGVkJyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGdyYXBoIGFuZCBjb21wdXRlcyBmb3IgZWFjaCBub2RlIGFuZCBlZGdlcyBpdHNcclxuICAgKiBjb29yZGluYXRlcyByZWxhdGl2ZWx5IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNhbWVyYS4gQmFzaWNhbGx5LCBpdCB3aWxsXHJcbiAgICogY29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIGdyYXBoaWMgcmVuZGVyZXJzLlxyXG4gICAqXHJcbiAgICogU2luY2UgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBkaWZmZXJlbnQgY2FtZXJhcyBhbmQgZGlmZmVyZW50XHJcbiAgICogcmVuZGVyZXJzLCBpdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcHJlZml4IHRvIHB1dCBiZWZvcmUgdGhlIG5ld1xyXG4gICAqIGNvb3JkaW5hdGVzICh0byBnZXQgc29tZXRoaW5nIGxpa2UgXCJub2RlLmNhbWVyYTFfeFwiKVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P3N0cmluZ30gcmVhZCAgICBUaGUgcHJlZml4IG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFkLlxyXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHdyaXRlICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gd3JpdGUuXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLiBUaG9zZSBjYW4gYmU6XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgcmVzdHJpY3RlZCBub2RlcyBhcnJheS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIGVkZ2VzIGFycmF5LlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIHdpZHRoLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBBIGhlaWdodC5cclxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXHJcbiAgICovXHJcbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmFwcGx5VmlldyA9IGZ1bmN0aW9uKHJlYWQsIHdyaXRlLCBvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHdyaXRlID0gd3JpdGUgIT09IHVuZGVmaW5lZCA/IHdyaXRlIDogdGhpcy5wcmVmaXg7XHJcbiAgICByZWFkID0gcmVhZCAhPT0gdW5kZWZpbmVkID8gcmVhZCA6IHRoaXMucmVhZFByZWZpeDtcclxuXHJcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLm5vZGVzIHx8IHRoaXMuZ3JhcGgubm9kZXMoKSxcclxuICAgICAgICBlZGdlcyA9IG9wdGlvbnMuZWRnZXMgfHwgdGhpcy5ncmFwaC5lZGdlcygpO1xyXG5cclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgbm9kZSxcclxuICAgICAgICByZWxDb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXHJcbiAgICAgICAgcmVsU2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSkgLyB0aGlzLnJhdGlvLFxyXG4gICAgICAgIG5vZGVSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSksXHJcbiAgICAgICAgZWRnZVJhdGlvID0gTWF0aC5wb3codGhpcy5yYXRpbywgdGhpcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKSxcclxuICAgICAgICB4T2Zmc2V0ID0gKG9wdGlvbnMud2lkdGggfHwgMCkgLyAyIC0gdGhpcy54ICogcmVsQ29zIC0gdGhpcy55ICogcmVsU2luLFxyXG4gICAgICAgIHlPZmZzZXQgPSAob3B0aW9ucy5oZWlnaHQgfHwgMCkgLyAyIC0gdGhpcy55ICogcmVsQ29zICsgdGhpcy54ICogcmVsU2luO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICBub2RlW3dyaXRlICsgJ3gnXSA9XHJcbiAgICAgICAgKG5vZGVbcmVhZCArICd4J10gfHwgMCkgKiByZWxDb3MgK1xyXG4gICAgICAgIChub2RlW3JlYWQgKyAneSddIHx8IDApICogcmVsU2luICtcclxuICAgICAgICB4T2Zmc2V0O1xyXG4gICAgICBub2RlW3dyaXRlICsgJ3knXSA9XHJcbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxDb3MgLVxyXG4gICAgICAgIChub2RlW3JlYWQgKyAneCddIHx8IDApICogcmVsU2luICtcclxuICAgICAgICB5T2Zmc2V0O1xyXG4gICAgICBub2RlW3dyaXRlICsgJ3NpemUnXSA9XHJcbiAgICAgICAgKG5vZGVbcmVhZCArICdzaXplJ10gfHwgMCkgL1xyXG4gICAgICAgIG5vZGVSYXRpbztcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGVkZ2VzW2ldW3dyaXRlICsgJ3NpemUnXSA9XHJcbiAgICAgICAgKGVkZ2VzW2ldW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cclxuICAgICAgICBlZGdlUmF0aW87XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcclxuICAgKiBjYW1lcmEgdG8gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgIGNhbWVyYS5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBwb2ludCBjb29yZGluYXRlcyBpbiB0aGUgZnJhbWUgb2YgdGhlIGdyYXBoLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5ncmFwaFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XHJcbiAgICB2YXIgWCA9IDAsXHJcbiAgICAgICAgWSA9IDAsXHJcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXHJcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XHJcblxyXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcclxuICAgIGlmICghdmVjdG9yKSB7XHJcbiAgICAgIFggPSAtICh0aGlzLnggKiBjb3MgKyB0aGlzLnkgKiBzaW4pIC8gdGhpcy5yYXRpbztcclxuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6ICh4ICogY29zICsgeSAqIHNpbikgLyB0aGlzLnJhdGlvICsgWCxcclxuICAgICAgeTogKHkgKiBjb3MgLSB4ICogc2luKSAvIHRoaXMucmF0aW8gKyBZXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gY29udmVydHMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWUgb2YgdGhlXHJcbiAgICogZ3JhcGggdG8gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICBncmFwaC5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICBncmFwaC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIHBvaW50IGNvb3JkaW5hdGVzIGluIHRoZSBmcmFtZSBvZiB0aGUgY2FtZXJhLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5jYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHZlY3Rvcikge1xyXG4gICAgdmFyIFggPSAwLFxyXG4gICAgICAgIFkgPSAwLFxyXG4gICAgICAgIGNvcyA9IE1hdGguY29zKHRoaXMuYW5nbGUpLFxyXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xyXG5cclxuICAgIC8vIFJldmVydCB0aGUgb3JpZ2luIGRpZmZlcmVudGlhbCB2ZWN0b3I6XHJcbiAgICBpZiAoIXZlY3Rvcikge1xyXG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XHJcbiAgICAgIFkgPSAtICh0aGlzLnkgKiBjb3MgLSB0aGlzLnggKiBzaW4pIC8gdGhpcy5yYXRpbztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiAoKHggLSBYKSAqIGNvcyAtICh5IC0gWSkgKiBzaW4pICogdGhpcy5yYXRpbyxcclxuICAgICAgeTogKCh5IC0gWSkgKiBjb3MgKyAoeCAtIFgpICogc2luKSAqIHRoaXMucmF0aW9cclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBjYW1lcmEuIFRoaXMgaXNcclxuICAgKiBlc3BlY2lhbGx5IHVzZWZ1bCB0byBhcHBseSB0aGUgY2FtZXJhIHZpZXcgZGlyZWN0bHkgaW4gc2hhZGVycywgaW4gY2FzZSBvZlxyXG4gICAqIFdlYkdMIHJlbmRlcmluZy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxyXG4gICAqL1xyXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzY2FsZSA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlKDEgLyB0aGlzLnJhdGlvKSxcclxuICAgICAgICByb3RhdGlvbiA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKHRoaXMuYW5nbGUpLFxyXG4gICAgICAgIHRyYW5zbGF0aW9uID0gc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24oLXRoaXMueCwgLXRoaXMueSksXHJcbiAgICAgICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXHJcbiAgICAgICAgICB0cmFuc2xhdGlvbixcclxuICAgICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxyXG4gICAgICAgICAgICByb3RhdGlvbixcclxuICAgICAgICAgICAgc2NhbGVcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG5cclxuICAgIHJldHVybiBtYXRyaXg7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGFraW5nIGEgd2lkdGggYW5kIGEgaGVpZ2h0IGFzIHBhcmFtZXRlcnMsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlXHJcbiAgICogY29vcmRpbmF0ZXMgb2YgdGhlIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhlIGNhbWVyYSBvbiBzY3JlZW4sIGluIHRoZVxyXG4gICAqIGdyYXBoJ3MgcmVmZXJlbnRpZWwuXHJcbiAgICpcclxuICAgKiBUbyBrZWVwIGRpc3BsYXlpbmcgbGFiZWxzIG9mIG5vZGVzIGdvaW5nIG91dCBvZiB0aGUgc2NyZWVuLCB0aGUgbWV0aG9kXHJcbiAgICoga2VlcHMgYSBtYXJnaW4gYXJvdW5kIHRoZSBzY3JlZW4gaW4gdGhlIHJldHVybmVkIHJlY3RhbmdsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGggIFRoZSB3aWR0aCBvZiB0aGUgc2NyZWVuLlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNjcmVlbi5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgcmVjdGFuZ2xlIGFzIHgxLCB5MSwgeDIgYW5kIHkyLCByZXByZXNlbnRpbmdcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0d28gb3Bwb3NpdGUgcG9pbnRzLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRSZWN0YW5nbGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgd2lkdGhWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCwgMCwgdHJ1ZSksXHJcbiAgICAgICAgaGVpZ2h0VmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24oMCwgaGVpZ2h0LCB0cnVlKSxcclxuICAgICAgICBjZW50ZXJWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHRydWUpLFxyXG4gICAgICAgIG1hcmdpblggPSB0aGlzLmNhbWVyYVBvc2l0aW9uKHdpZHRoIC8gNCwgMCwgdHJ1ZSkueCxcclxuICAgICAgICBtYXJnaW5ZID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQgLyA0LCB0cnVlKS55O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHgxOiB0aGlzLnggLSBjZW50ZXJWZWN0LnggLSBtYXJnaW5YLFxyXG4gICAgICB5MTogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSxcclxuICAgICAgeDI6IHRoaXMueCAtIGNlbnRlclZlY3QueCArIG1hcmdpblggKyB3aWR0aFZlY3QueCxcclxuICAgICAgeTI6IHRoaXMueSAtIGNlbnRlclZlY3QueSAtIG1hcmdpblkgKyB3aWR0aFZlY3QueSxcclxuICAgICAgaGVpZ2h0OiBNYXRoLnNxcnQoXHJcbiAgICAgICAgTWF0aC5wb3coaGVpZ2h0VmVjdC54LCAyKSArXHJcbiAgICAgICAgTWF0aC5wb3coaGVpZ2h0VmVjdC55ICsgMiAqIG1hcmdpblksIDIpXHJcbiAgICAgIClcclxuICAgIH07XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKipcclxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGVcclxuICAgKiA9PT09PT09PT09PT09PT09PT09PT1cclxuICAgKlxyXG4gICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbCksIFPDqWJhc3RpZW4gSGV5bWFubiwgRGFtaWVuIE1hcmnDqVxyXG4gICAqL1xyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFF1YWQgR2VvbWV0cmljIE9wZXJhdGlvbnNcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICpcclxuICAgKiBBIHVzZWZ1bCBiYXRjaCBvZiBnZW9tZXRyaWMgb3BlcmF0aW9ucyB1c2VkIGJ5IHRoZSBxdWFkdHJlZS5cclxuICAgKi9cclxuXHJcbiAgdmFyIF9nZW9tID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIG5vZGUgd2l0aCB4LCB5IGFuZCBzaXplIGludG8gYW5cclxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGdyYXBoIG5vZGUgd2l0aCBhdCBsZWFzdCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgcG9pbnRUb1NxdWFyZTogZnVuY3Rpb24obikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHgxOiBuLnggLSBuLnNpemUsXHJcbiAgICAgICAgeTE6IG4ueSAtIG4uc2l6ZSxcclxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxyXG4gICAgICAgIHkyOiBuLnkgLSBuLnNpemUsXHJcbiAgICAgICAgaGVpZ2h0OiBuLnNpemUgKiAyXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIHdpdGggeDEsIHkxLCB4MiwgeTIgYW5kIHNpemUgaW50byBhblxyXG4gICAgICogYXhpcy1hbGlnbmVkIHNxdWFyZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcclxuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBhIHNpemUuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBsaW5lVG9TcXVhcmU6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgaWYgKGUueTEgPCBlLnkyKSB7XHJcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHRvcFxyXG4gICAgICAgIGlmIChlLngxIDwgZS54Mikge1xyXG4gICAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcclxuICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHgxOiBlLngxIC0gZS5zaXplLFxyXG4gICAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcclxuICAgICAgICAgICAgeDI6IGUueDIgKyBlLnNpemUsXHJcbiAgICAgICAgICAgIHkyOiBlLnkxIC0gZS5zaXplLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHJpZ2h0XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHgxOiBlLngyIC0gZS5zaXplLFxyXG4gICAgICAgICAgeTE6IGUueTEgLSBlLnNpemUsXHJcbiAgICAgICAgICB4MjogZS54MSArIGUuc2l6ZSxcclxuICAgICAgICAgIHkyOiBlLnkxIC0gZS5zaXplLFxyXG4gICAgICAgICAgaGVpZ2h0OiBlLnkyIC0gZS55MSArIGUuc2l6ZSAqIDJcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gdG9wXHJcbiAgICAgIGlmIChlLngxIDwgZS54Mikge1xyXG4gICAgICAgIC8vIChlLngxLCBlLnkxKSBvbiBsZWZ0XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHgxOiBlLngxIC0gZS5zaXplLFxyXG4gICAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXHJcbiAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcclxuICAgICAgICAgIHkyOiBlLnkyIC0gZS5zaXplLFxyXG4gICAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIC8vIChlLngyLCBlLnkyKSBvbiByaWdodFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHgxOiBlLngyIC0gZS5zaXplLFxyXG4gICAgICAgIHkxOiBlLnkyIC0gZS5zaXplLFxyXG4gICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxyXG4gICAgICAgIHkyOiBlLnkyIC0gZS5zaXplLFxyXG4gICAgICAgIGhlaWdodDogZS55MSAtIGUueTIgKyBlLnNpemUgKiAyXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyBhIGdyYXBoIGVkZ2Ugb2YgdHlwZSAnY3VydmUnIHdpdGggeDEsIHkxLCB4MiwgeTIsXHJcbiAgICAgKiBjb250cm9sIHBvaW50IGFuZCBzaXplIGludG8gYW4gYXhpcy1hbGlnbmVkIHNxdWFyZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgIEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBhIHNpemUuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGNwIEEgY29udHJvbCBwb2ludCAoeCx5KS5cclxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICAgKi9cclxuICAgIHF1YWRyYXRpY0N1cnZlVG9TcXVhcmU6IGZ1bmN0aW9uKGUsIGNwKSB7XHJcbiAgICAgIHZhciBwdCA9IHNpZ21hLnV0aWxzLmdldFBvaW50T25RdWFkcmF0aWNDdXJ2ZShcclxuICAgICAgICAwLjUsXHJcbiAgICAgICAgZS54MSxcclxuICAgICAgICBlLnkxLFxyXG4gICAgICAgIGUueDIsXHJcbiAgICAgICAgZS55MixcclxuICAgICAgICBjcC54LFxyXG4gICAgICAgIGNwLnlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIEJvdW5kaW5nIGJveCBvZiB0aGUgdHdvIHBvaW50cyBhbmQgdGhlIHBvaW50IGF0IHRoZSBtaWRkbGUgb2YgdGhlXHJcbiAgICAgIC8vIGN1cnZlOlxyXG4gICAgICB2YXIgbWluWCA9IE1hdGgubWluKGUueDEsIGUueDIsIHB0LngpLFxyXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KGUueDEsIGUueDIsIHB0LngpLFxyXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGUueTEsIGUueTIsIHB0LnkpLFxyXG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KGUueTEsIGUueTIsIHB0LnkpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4MTogbWluWCAtIGUuc2l6ZSxcclxuICAgICAgICB5MTogbWluWSAtIGUuc2l6ZSxcclxuICAgICAgICB4MjogbWF4WCArIGUuc2l6ZSxcclxuICAgICAgICB5MjogbWluWSAtIGUuc2l6ZSxcclxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgZS5zaXplICogMlxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBzZWxmIGxvb3AgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbiBBIGdyYXBoIG5vZGUgd2l0aCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBzZWxmTG9vcFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XHJcbiAgICAgIC8vIEZpdHRpbmcgdG8gdGhlIGN1cnZlIGlzIHRvbyBjb3N0bHksIHdlIGNvbXB1dGUgYSBsYXJnZXIgYm91bmRpbmcgYm94XHJcbiAgICAgIC8vIHVzaW5nIHRoZSBjb250cm9sIHBvaW50czpcclxuICAgICAgdmFyIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKG4ueCwgbi55LCBuLnNpemUpO1xyXG5cclxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSBwb2ludCBhbmQgdGhlIHR3byBjb250cm9sIHBvaW50czpcclxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihuLngsIGNwLngxLCBjcC54MiksXHJcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobi54LCBjcC54MSwgY3AueDIpLFxyXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKG4ueSwgY3AueTEsIGNwLnkyKSxcclxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChuLnksIGNwLnkxLCBjcC55Mik7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHgxOiBtaW5YIC0gbi5zaXplLFxyXG4gICAgICAgIHkxOiBtaW5ZIC0gbi5zaXplLFxyXG4gICAgICAgIHgyOiBtYXhYICsgbi5zaXplLFxyXG4gICAgICAgIHkyOiBtaW5ZIC0gbi5zaXplLFxyXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBuLnNpemUgKiAyXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cclxuICAgICAqL1xyXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xyXG4gICAgICByZXR1cm4gci54MSA9PT0gci54MiB8fCByLnkxID09PSByLnkyO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdG9wIHBvaW50cyBvZiBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlLiBUaGlzIGlzIHVzZWZ1bCBpblxyXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXHJcbiAgICAgKiBsYXRlciBvcGVyYXRpb25zIG5lZWQgdG8ga25vdyB0aGUgdG9wIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJlY3RhbmdsZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cclxuICAgICAqL1xyXG4gICAgYXhpc0FsaWduZWRUb3BQb2ludHM6IGZ1bmN0aW9uKHIpIHtcclxuXHJcbiAgICAgIC8vIEJhc2ljXHJcbiAgICAgIGlmIChyLnkxID09PSByLnkyICYmIHIueDEgPCByLngyKVxyXG4gICAgICAgIHJldHVybiByO1xyXG5cclxuICAgICAgLy8gUm90YXRlZCB0byByaWdodFxyXG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyID4gci55MSlcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDE6IHIueDEgLSByLmhlaWdodCwgeTE6IHIueTEsXHJcbiAgICAgICAgICB4Mjogci54MSwgeTI6IHIueTEsXHJcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxyXG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyIDwgci55MSlcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxyXG4gICAgICAgICAgeDI6IHIueDIgKyByLmhlaWdodCwgeTI6IHIueTIsXHJcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEJvdHRvbSdzIHVwXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgeDE6IHIueDIsIHkxOiByLnkxIC0gci5oZWlnaHQsXHJcbiAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxIC0gci5oZWlnaHQsXHJcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIGxlZnQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cclxuICAgICAqL1xyXG4gICAgbG93ZXJMZWZ0Q29vcjogZnVuY3Rpb24ocikge1xyXG4gICAgICB2YXIgd2lkdGggPSAoXHJcbiAgICAgICAgTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgKHIueDIgLSByLngxKSAqIChyLngyIC0gci54MSkgK1xyXG4gICAgICAgICAgKHIueTIgLSByLnkxKSAqIChyLnkyIC0gci55MSlcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcclxuICAgICAgICB5OiByLnkxICsgKHIueDIgLSByLngxKSAqIHIuaGVpZ2h0IC8gd2lkdGhcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xyXG4gICAgICogYW5kIGl0cyBsb3dlciBsZWZ0IGNvcm5lci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgY29ybmVyJ3MgY29vcmRpbmF0ZXMgKHgsIHkpLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cclxuICAgICAqL1xyXG4gICAgbG93ZXJSaWdodENvb3I6IGZ1bmN0aW9uKHIsIGxsYykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXHJcbiAgICAgICAgeTogbGxjLnkgLSByLnkxICsgci55MlxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cclxuICAgICAqL1xyXG4gICAgcmVjdGFuZ2xlQ29ybmVyczogZnVuY3Rpb24ocikge1xyXG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxyXG4gICAgICAgICAgbHJjID0gdGhpcy5sb3dlclJpZ2h0Q29vcihyLCBsbGMpO1xyXG5cclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICB7eDogci54MSwgeTogci55MX0sXHJcbiAgICAgICAge3g6IHIueDIsIHk6IHIueTJ9LFxyXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxyXG4gICAgICAgIHt4OiBscmMueCwgeTogbHJjLnl9XHJcbiAgICAgIF07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBCb3VuZGFyaWVzIG9mIHRoZSBzcXVhcmUgKHgsIHksIHdpZHRoLCBoZWlnaHQpLlxyXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgIGRlZmluZWQgYnkgYW4gYXJyYXkgb2YgdGhlaXIgZm91ciBjb3JuZXJzICh4LCB5KS5cclxuICAgICAqL1xyXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICBbXHJcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxyXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueX0sXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcclxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0fSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBbXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXHJcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcclxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9LFxyXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxyXG4gICAgICAgIF1cclxuICAgICAgXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXHJcbiAgICAgKiByZWN0YW5nbGUgQi4gVGhpcyBpcyBuZWVkZWQgbGF0ZXIgdG8gY2hlY2sgYW4gZXZlbnR1YWwgY29sbGlzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEIncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxyXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGZvdXIgYXhpcyBkZWZpbmVkIGJ5IHRoZWlyIGNvb3JkaW5hdGVzICh4LHkpLlxyXG4gICAgICovXHJcbiAgICBheGlzOiBmdW5jdGlvbihjMSwgYzIpIHtcclxuICAgICAgcmV0dXJuIFtcclxuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcclxuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzNdLngsIHk6IGMxWzFdLnkgLSBjMVszXS55fSxcclxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzJdLngsIHk6IGMyWzBdLnkgLSBjMlsyXS55fSxcclxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxyXG4gICAgICBdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3QgYSByZWN0YW5nbGUncyBjb3JuZXIgb24gYW4gYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgY29ybmVyICh4LCB5KS5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYW4gYXhpcyAoeCwgeSkuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxyXG4gICAgICovXHJcbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbihjLCBhKSB7XHJcbiAgICAgIHZhciBsID0gKFxyXG4gICAgICAgIChjLnggKiBhLnggKyBjLnkgKiBhLnkpIC9cclxuICAgICAgICAoYS54ICogYS54ICsgYS55ICogYS55KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBsICogYS54LFxyXG4gICAgICAgIHk6IGwgKiBhLnlcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gb25lIHBhcnRpY3VsYXIgYXhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgQW4gYXhpcycgY29vcmRpbmF0ZXMgKHgsIHkpLlxyXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cclxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIHRoZSBheGlzLlxyXG4gICAgICovXHJcbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcclxuICAgICAgdmFyIHNjMSA9IFtdLFxyXG4gICAgICAgICAgc2MyID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgNDsgY2krKykge1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvamVjdGlvbihjMVtjaV0sIGEpLFxyXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xyXG5cclxuICAgICAgICBzYzEucHVzaChwMS54ICogYS54ICsgcDEueSAqIGEueSk7XHJcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxyXG4gICAgICAgICAgbWF4YzIgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzIpLFxyXG4gICAgICAgICAgbWluYzEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzEpLFxyXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xyXG5cclxuICAgICAgcmV0dXJuIChtaW5jMiA8PSBtYXhjMSAmJiBtYXhjMiA+PSBtaW5jMSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcclxuICAgICAqIGFsbCBheGlzIGNvbGxpZGUsIHRoZW4gdGhlIHR3byByZWN0YW5nbGVzIGRvIGNvbGxpZGUgb24gdGhlIHBsYW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXHJcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZS5cclxuICAgICAqL1xyXG4gICAgY29sbGlzaW9uOiBmdW5jdGlvbihjMSwgYzIpIHtcclxuICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMoYzEsIGMyKSxcclxuICAgICAgICAgIGNvbCA9IHRydWU7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcclxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XHJcblxyXG4gICAgICByZXR1cm4gY29sO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBRdWFkIEZ1bmN0aW9uc1xyXG4gICAqIC0tLS0tLS0tLS0tLVxyXG4gICAqXHJcbiAgICogVGhlIFF1YWR0cmVlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxyXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxyXG4gICAqIGluZGV4IG9mIGVhY2ggbm9kZSBpcyB0aGUgZm9sbG93aW5nOlxyXG4gICAqIDA6IHRvcCBsZWZ0XHJcbiAgICogMTogdG9wIHJpZ2h0XHJcbiAgICogMjogYm90dG9tIGxlZnRcclxuICAgKiAzOiBib3R0b20gcmlnaHRcclxuICAgKlxyXG4gICAqIE1vcmVvdmVyLCB0aGUgaGVyZWFmdGVyIHF1YWQncyBwaGlsb3NvcGh5IGlzIHRvIGNvbnNpZGVyIHRoYXQgaWYgYW4gZWxlbWVudFxyXG4gICAqIGNvbGxpZGVzIHdpdGggbW9yZSB0aGFuIG9uZSBub2RlcywgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gZWFjaCBvZiB0aGVcclxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludCBpbiB0aGUgcXVhZFxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWRCb3VuZHMgQm91bmRhcmllcyBvZiB0aGUgcXVhZCAoeCwgeSwgd2lkdGgsIGhlaWd0aCkuXHJcbiAgICogQHJldHVybiB7aW50ZWdlcn0gICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3F1YWRJbmRleChwb2ludCwgcXVhZEJvdW5kcykge1xyXG4gICAgdmFyIHhtcCA9IHF1YWRCb3VuZHMueCArIHF1YWRCb3VuZHMud2lkdGggLyAyLFxyXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcclxuICAgICAgICB0b3AgPSAocG9pbnQueSA8IHltcCksXHJcbiAgICAgICAgbGVmdCA9IChwb2ludC54IDwgeG1wKTtcclxuXHJcbiAgICBpZiAodG9wKSB7XHJcbiAgICAgIGlmIChsZWZ0KVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGxlZnQpXHJcbiAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gMztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIHF1YWRDb3JuZXJzIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VyIGludGVnZXJzLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XHJcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xyXG5cclxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcclxuICAgICAgaWYgKChyZWN0YW5nbGUueDIgPj0gcXVhZENvcm5lcnNbaV1bMF0ueCkgJiZcclxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcclxuICAgICAgICAgIChyZWN0YW5nbGUueTEgKyByZWN0YW5nbGUuaGVpZ2h0ID49IHF1YWRDb3JuZXJzW2ldWzBdLnkpICYmXHJcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxIDw9IHF1YWRDb3JuZXJzW2ldWzJdLnkpKVxyXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcclxuXHJcbiAgICByZXR1cm4gaW5kZXhlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2FycmF5fSAgY29ybmVycyAgICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBjb3JuZXIgb2YgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cclxuICAgKiBAcGFyYW0gIHthcnJheX0gIHF1YWRDb3JuZXJzICBBbiBhcnJheSBvZiB0aGUgcXVhZCBub2RlcycgY29ybmVycy5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfcXVhZENvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVycykge1xyXG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcclxuXHJcbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXHJcbiAgICAgIGlmIChfZ2VvbS5jb2xsaXNpb24oY29ybmVycywgcXVhZENvcm5lcnNbaV0pKVxyXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcclxuXHJcbiAgICByZXR1cm4gaW5kZXhlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YmRpdmlkZSBhIHF1YWQgYnkgY3JlYXRpbmcgYSBub2RlIGF0IGEgcHJlY2lzZSBpbmRleC4gVGhlIGZ1bmN0aW9uIGRvZXNcclxuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNyZWF0ZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgQSBuZXcgcXVhZCByZXByZXNlbnRpbmcgdGhlIG5vZGUgY3JlYXRlZC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xyXG4gICAgdmFyIG5leHQgPSBxdWFkLmxldmVsICsgMSxcclxuICAgICAgICBzdWJ3ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy53aWR0aCAvIDIpLFxyXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxyXG4gICAgICAgIHF4ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy54KSxcclxuICAgICAgICBxeSA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueSksXHJcbiAgICAgICAgeCxcclxuICAgICAgICB5O1xyXG5cclxuICAgIHN3aXRjaCAoaW5kZXgpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIHggPSBxeDtcclxuICAgICAgICB5ID0gcXk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMTpcclxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xyXG4gICAgICAgIHkgPSBxeTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIHggPSBxeDtcclxuICAgICAgICB5ID0gcXkgKyBzdWJoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDM6XHJcbiAgICAgICAgeCA9IHF4ICsgc3VidztcclxuICAgICAgICB5ID0gcXkgKyBzdWJoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfcXVhZFRyZWUoXHJcbiAgICAgIHt4OiB4LCB5OiB5LCB3aWR0aDogc3VidywgaGVpZ2h0OiBzdWJofSxcclxuICAgICAgbmV4dCxcclxuICAgICAgcXVhZC5tYXhFbGVtZW50cyxcclxuICAgICAgcXVhZC5tYXhMZXZlbFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IGluc2VydCBhbiBlbGVtZW50IGludG8gdGhlIHF1YWR0cmVlLiBPbmx5IHBvaW50c1xyXG4gICAqIHdpdGggc2l6ZSwgaS5lLiBheGlzLWFsaWduZWQgc3F1YXJlcywgbWF5IGJlIGluc2VydGVkIHdpdGggdGhpc1xyXG4gICAqIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGVsICAgICAgICAgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBxdWFkdHJlZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgICAgICBUaGUgcXVhZCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXHJcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkKSB7XHJcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcclxuXHJcbiAgICAgIC8vIFNlYXJjaGluZyBhcHByb3ByaWF0ZSBxdWFkc1xyXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xyXG5cclxuICAgICAgLy8gSXRlcmF0aW5nXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHJcbiAgICAgICAgLy8gU3ViZGl2aWRpbmcgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPSBfcXVhZFN1YmRpdmlkZShpbmRleGVzW2ldLCBxdWFkKTtcclxuXHJcbiAgICAgICAgLy8gUmVjdXJzaW9uXHJcbiAgICAgICAgX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcclxuICAgICAgcXVhZC5lbGVtZW50cy5wdXNoKGVsKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcclxuICAgKiBzZWFyY2hlZCBwb2ludC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgVGhlIHNlYXJjaGVkIHF1YWQuXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSByZWxldmFudFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkKSB7XHJcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcclxuICAgICAgdmFyIGluZGV4ID0gX3F1YWRJbmRleChwb2ludCwgcXVhZC5ib3VuZHMpO1xyXG5cclxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxyXG4gICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQubm9kZXNbaW5kZXhdKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYW4gcmVjdGFuZ3VsYXIgYXJlYVxyXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fGFycmF5fSByZWN0RGF0YSAgICAgICBUaGUgc2VhcmNoZWQgYXJlYSBkZWZpbmVkIGVpdGhlciBieVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGNhc2Ugb2YgYSBub24tYXhpcy1hbGlnbmVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgb3IgYW4gb2JqZWN0IHdpdGggdHdvIHRvcFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgcXVhZCAgICAgICAgICAgVGhlIHNlYXJjaGVkIHF1YWQuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICBjb2xsaXNpb25GdW5jICBUaGUgY29sbGlzaW9uIGZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxyXG4gICAqIEBwYXJhbSAge2FycmF5P30gICAgICAgZWxzICAgICAgICAgICAgVGhlIHJldHJpZXZlZCBlbGVtZW50cy5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZUFyZWEocmVjdERhdGEsIHF1YWQsIGNvbGxpc2lvbkZ1bmMsIGVscykge1xyXG4gICAgZWxzID0gZWxzIHx8IHt9O1xyXG5cclxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xyXG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICBfcXVhZFJldHJpZXZlQXJlYShcclxuICAgICAgICAgICAgcmVjdERhdGEsXHJcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkZ1bmMsXHJcbiAgICAgICAgICAgIGVsc1xyXG4gICAgICAgICAgKTtcclxuICAgIH0gZWxzZVxyXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHF1YWQuZWxlbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKVxyXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgIGVsc1txdWFkLmVsZW1lbnRzW2pdLmlkXSA9IHF1YWQuZWxlbWVudHNbal07XHJcblxyXG4gICAgcmV0dXJuIGVscztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIHF1YWR0cmVlIG9iamVjdCBpdHNlbGYuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiAoeCwgeSksIHdpZHRoIGFuZCBoZWlndGguXHJcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGxldmVsICAgICAgICBUaGUgbGV2ZWwgb2YgdGhlIHF1YWQgaW4gdGhlIHRyZWUuXHJcbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxyXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhMZXZlbCAgICAgVGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIF9xdWFkVHJlZShib3VuZHMsIGxldmVsLCBtYXhFbGVtZW50cywgbWF4TGV2ZWwpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxyXG4gICAgICBib3VuZHM6IGJvdW5kcyxcclxuICAgICAgY29ybmVyczogX2dlb20uc3BsaXRTcXVhcmUoYm91bmRzKSxcclxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDIwLFxyXG4gICAgICBtYXhMZXZlbDogbWF4TGV2ZWwgfHwgNCxcclxuICAgICAgZWxlbWVudHM6IFtdLFxyXG4gICAgICBub2RlczogW11cclxuICAgIH07XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKlxyXG4gICAqIFRoZSBxdWFkIEFQSSBhcyBleHBvc2VkIHRvIHNpZ21hLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcXVhZCBjb3JlIHRoYXQgd2lsbCBiZWNvbWUgdGhlIHNpZ21hIGludGVyZmFjZSB3aXRoIHRoZSBxdWFkdHJlZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW4/fSBpbmRleEVkZ2VzIFRlbGwgdG8gaW5kZXggZWRnZXMgb3Igbm9kZXNcclxuICAgKlxyXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF90cmVlICAgICAgIFByb3BlcnR5IGhvbGRpbmcgdGhlIHF1YWR0cmVlIG9iamVjdFxyXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9nZW9tICAgICAgIEV4cG9zaXRpb24gb2YgdGhlIF9nZW9tIG5hbWVzcGFjZSBmb3IgdGVzdGluZ1xyXG4gICAqIHByb3BlcnR5IHtvYmplY3R9IF9jYWNoZSAgICAgIENhY2hlIGZvciB0aGUgYXJlYSBtZXRob2RcclxuICAgKi9cclxuICB2YXIgcXVhZCA9IGZ1bmN0aW9uKGluZGV4RWRnZXMpIHtcclxuICAgIHRoaXMuX2dlb20gPSBfZ2VvbTtcclxuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xyXG4gICAgdGhpcy5fY2FjaGUgPSB7XHJcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcclxuICAgICAgcmVzdWx0OiBmYWxzZVxyXG4gICAgfTtcclxuICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5faW5kZXhFZGdlcyA9IGluZGV4RWRnZXMgfHwgZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5kZXggYSBncmFwaCBieSBpbnNlcnRpbmcgaXRzIGVsZW1lbnRzIGludG8gdGhlIHF1YWR0cmVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YXJyYXl9ICBncmFwaCAgICAgIFRoZSBncmFwaCB0byBpbmRleFxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICAgICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kcy5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cclxuICAgKlxyXG4gICAqIFBhcmFtZXRlcnM6XHJcbiAgICogLS0tLS0tLS0tLVxyXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoIGFuZCBoZWlndGguXHJcbiAgICogcHJlZml4OiAgICAgIHtzdHJpbmc/fSAgYSBwcmVmaXggZm9yIG5vZGUgZ2VvbWV0cmljIGF0dHJpYnV0ZXMuXHJcbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXHJcbiAgICogbWF4TGV2ZWw6ICAgIHtpbnRlZ2VyP30gdGhlIG1heCByZWN1cnNpb24gbGV2ZWwgb2YgdGhlIHRyZWUuXHJcbiAgICovXHJcbiAgcXVhZC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihncmFwaCwgcGFyYW1zKSB7XHJcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcclxuICAgIGlmICghcGFyYW1zLmJvdW5kcylcclxuICAgICAgdGhyb3cgJ3NpZ21hLmNsYXNzZXMucXVhZC5pbmRleDogYm91bmRzIGluZm9ybWF0aW9uIG5vdCBnaXZlbi4nO1xyXG5cclxuICAgIC8vIFByZWZpeFxyXG4gICAgdmFyIHByZWZpeCA9IHBhcmFtcy5wcmVmaXggfHwgJycsXHJcbiAgICAgICAgY3AsXHJcbiAgICAgICAgY2MgPSBwYXJhbXMuY3VydmF0dXJlQ29lZmZpY2llbnRzLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIG4sXHJcbiAgICAgICAgZTtcclxuXHJcbiAgICAvLyBCdWlsZGluZyB0aGUgdHJlZVxyXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcclxuICAgICAgcGFyYW1zLmJvdW5kcyxcclxuICAgICAgMCxcclxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxyXG4gICAgICBwYXJhbXMubWF4TGV2ZWxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9pbmRleEVkZ2VzKSB7XHJcbiAgICAgIHZhciBub2RlcyA9IGdyYXBoLm5vZGVzKCk7XHJcbiAgICAgIC8vIEluc2VydGluZyBncmFwaCBub2RlcyBpbnRvIHRoZSB0cmVlXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0aW5nIG5vZGVcclxuICAgICAgICBfcXVhZEluc2VydChcclxuICAgICAgICAgIG5vZGVzW2ldLFxyXG4gICAgICAgICAgX2dlb20ucG9pbnRUb1NxdWFyZSh7XHJcbiAgICAgICAgICAgIHg6IG5vZGVzW2ldW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgIHk6IG5vZGVzW2ldW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgIHNpemU6IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ11cclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgdGhpcy5fdHJlZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XHJcbiAgICAgIC8vIEluc2VydGluZyBncmFwaCBlZGdlcyBpbnRvIHRoZSB0cmVlXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBzb3VyY2UgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS5zb3VyY2UpO1xyXG4gICAgICAgIHRhcmdldCA9IGdyYXBoLm5vZGVzKGVkZ2VzW2ldLnRhcmdldCk7XHJcbiAgICAgICAgZSA9IHtcclxuICAgICAgICAgIHgxOiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkxOiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIHgyOiB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkyOiB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIHNpemU6IGVkZ2VzW2ldW3ByZWZpeCArICdzaXplJ10gfHwgMFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEluc2VydGluZyBlZGdlXHJcbiAgICAgICAgaWYgKGVkZ2VzW2ldLnR5cGUgPT09ICdjdXJ2ZScgfHwgZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlZEFycm93Jykge1xyXG4gICAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgICAgICAgIG4gPSB7XHJcbiAgICAgICAgICAgICAgeDogc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgeTogc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgc2l6ZTogc291cmNlW3ByZWZpeCArICdzaXplJ10gfHwgMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBfcXVhZEluc2VydChcclxuICAgICAgICAgICAgICBlZGdlc1tpXSxcclxuICAgICAgICAgICAgICBfZ2VvbS5zZWxmTG9vcFRvU3F1YXJlKG4pLFxyXG4gICAgICAgICAgICAgIHRoaXMuX3RyZWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KGUueDEsIGUueTEsIGUueDIsIGUueTIsIGVkZ2VzW2ldLmNjIHx8IGNjKTtcclxuICAgICAgICAgICAgX3F1YWRJbnNlcnQoXHJcbiAgICAgICAgICAgICAgZWRnZXNbaV0sXHJcbiAgICAgICAgICAgICAgX2dlb20ucXVhZHJhdGljQ3VydmVUb1NxdWFyZShlLCBjcCksXHJcbiAgICAgICAgICAgICAgdGhpcy5fdHJlZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgX3F1YWRJbnNlcnQoXHJcbiAgICAgICAgICAgIGVkZ2VzW2ldLFxyXG4gICAgICAgICAgICBfZ2VvbS5saW5lVG9TcXVhcmUoZSksXHJcbiAgICAgICAgICAgIHRoaXMuX3RyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2V0IGNhY2hlOlxyXG4gICAgdGhpcy5fY2FjaGUgPSB7XHJcbiAgICAgIHF1ZXJ5OiBmYWxzZSxcclxuICAgICAgcmVzdWx0OiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyByZW1vdmU/XHJcbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSBldmVyeSBncmFwaCBub2RlcyBoZWxkIGJ5IHRoZSBxdWFkdHJlZSBub2RlIGNvbnRhaW5pbmcgdGhlXHJcbiAgICogc2VhcmNoZWQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHggb2YgdGhlIHBvaW50LlxyXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBvZiB0aGUgcG9pbnQuXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXHJcbiAgICovXHJcbiAgcXVhZC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpXHJcbiAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XHJcbiAgICAgIF9xdWFkUmV0cmlldmVQb2ludCh7eDogeCwgeTogeX0sIHRoaXMuX3RyZWUpIHx8IFtdIDpcclxuICAgICAgW107XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcclxuICAgKiBsYXN0IGFyZWEgcXVlcmllZCBpbiBjYWNoZSBmb3Igb3B0aW1pemF0aW9uIHJlYXNvbiBhbmQgd2lsbCBhY3QgZGlmZmVyZW50bHlcclxuICAgKiBmb3IgdGhlIHNhbWUgcmVhc29uIGlmIHRoZSBhcmVhIGlzIGF4aXMtYWxpZ25lZCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpXHJcbiAgICogICAgICAgICAgICAgICAgICBhbmQgaGVpZ2h0LlxyXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2Ygbm9kZXMgcmV0cmlldmVkLlxyXG4gICAqL1xyXG4gIHF1YWQucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbihyZWN0KSB7XHJcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpXHJcbiAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlY3QpLFxyXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXHJcbiAgICAgICAgcmVjdERhdGE7XHJcblxyXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xyXG4gICAgaWYgKHRoaXMuX2NhY2hlLnF1ZXJ5ID09PSBzZXJpYWxpemVkKVxyXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUucmVzdWx0O1xyXG5cclxuICAgIC8vIEF4aXMgYWxpZ25lZCA/XHJcbiAgICBpZiAoX2dlb20uaXNBeGlzQWxpZ25lZChyZWN0KSkge1xyXG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xyXG4gICAgICByZWN0RGF0YSA9IF9nZW9tLmF4aXNBbGlnbmVkVG9wUG9pbnRzKHJlY3QpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGNvbGxpc2lvbkZ1bmMgPSBfcXVhZENvbGxpc2lvbjtcclxuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5yZWN0YW5nbGVDb3JuZXJzKHJlY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldHJpZXZpbmcgbm9kZXNcclxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX3RyZWUgP1xyXG4gICAgICBfcXVhZFJldHJpZXZlQXJlYShcclxuICAgICAgICByZWN0RGF0YSxcclxuICAgICAgICB0aGlzLl90cmVlLFxyXG4gICAgICAgIGNvbGxpc2lvbkZ1bmNcclxuICAgICAgKSA6XHJcbiAgICAgIFtdO1xyXG5cclxuICAgIC8vIE9iamVjdCB0byBhcnJheVxyXG4gICAgdmFyIGVsZW1lbnRzQXJyID0gW107XHJcbiAgICBmb3IgKHZhciBpIGluIGVsZW1lbnRzKVxyXG4gICAgICBlbGVtZW50c0Fyci5wdXNoKGVsZW1lbnRzW2ldKTtcclxuXHJcbiAgICAvLyBDYWNoaW5nXHJcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XHJcbiAgICB0aGlzLl9jYWNoZS5yZXN1bHQgPSBlbGVtZW50c0FycjtcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudHNBcnI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEVYUE9SVDpcclxuICAgKiAqKioqKioqXHJcbiAgICovXHJcbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzID0gdGhpcy5zaWdtYS5jbGFzc2VzIHx8IHt9O1xyXG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLnF1YWQgPSBxdWFkO1xyXG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmVkZ2VxdWFkID0gcXVhZC5iaW5kKHRoaXMsIHRydWUpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHF1YWQ7XHJcbiAgICBleHBvcnRzLnF1YWQgPSBxdWFkO1xyXG4gIH0gZWxzZVxyXG4gICAgdGhpcy5xdWFkID0gcXVhZDtcclxuXHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXHJcbiAgICogZXZlbnRzIGFuZCB0b3VjaCBldmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kLlxyXG4gICAqIEBwYXJhbSAge2NhbWVyYX0gICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYSByZWxhdGVkIHRvIHRoZSB0YXJnZXQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7c2lnbWEuY2FwdG9yfSAgICAgICAgICBUaGUgZnJlc2ggbmV3IGNhcHRvciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5jYXB0b3JzLm1vdXNlID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxyXG4gICAgICAgIF90YXJnZXQgPSB0YXJnZXQsXHJcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcclxuICAgICAgICBfc2V0dGluZ3MgPSBzZXR0aW5ncyxcclxuXHJcbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XHJcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgLy8gVGhlIGNhbWVyYSBwb3NpdGlvbiB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZzpcclxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxyXG4gICAgICAgIF9zdGFydENhbWVyYVksXHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhQW5nbGUsXHJcblxyXG4gICAgICAgIC8vIFRoZSBsYXRlc3Qgc3RhZ2UgcG9zaXRpb246XHJcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxyXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcclxuICAgICAgICBfbGFzdENhbWVyYUFuZ2xlLFxyXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXHJcblxyXG4gICAgICAgIC8vIE1PVVNFIE1BTkFHRU1FTlQ6XHJcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcclxuICAgICAgICAvLyBUaGUgbW91c2UgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XHJcbiAgICAgICAgX3N0YXJ0TW91c2VYLFxyXG4gICAgICAgIF9zdGFydE1vdXNlWSxcclxuXHJcbiAgICAgICAgX2lzTW91c2VEb3duLFxyXG4gICAgICAgIF9pc01vdmluZyxcclxuICAgICAgICBfaGFzRHJhZ2dlZCxcclxuICAgICAgICBfZG93blN0YXJ0VGltZSxcclxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xyXG5cclxuICAgIHRoaXMuZWx0Rm9jdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJywgX2RvdWJsZUNsaWNrSGFuZGxlcik7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgX3doZWVsSGFuZGxlciwgZmFsc2UpO1xyXG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgX3doZWVsSGFuZGxlciwgZmFsc2UpO1xyXG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Rvd25IYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgX2NsaWNrSGFuZGxlciwgZmFsc2UpO1xyXG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBfZW50ZXJIYW5kbGVyLCBmYWxzZSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3VwSGFuZGxlciwgZmFsc2UpO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgdW5iaW5kcyBldmVyeSBoYW5kbGVycyB0aGF0IG1ha2VzIHRoZSBjYXB0b3Igd29yay5cclxuICAgICAqL1xyXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrKF90YXJnZXQsICdjbGljaycpO1xyXG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgX3doZWVsSGFuZGxlcik7XHJcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIpO1xyXG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9tb3ZlSGFuZGxlcik7XHJcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgX2Rvd25IYW5kbGVyKTtcclxuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIpO1xyXG4gICAgICBfdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgX291dEhhbmRsZXIpO1xyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX3VwSGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIE1PVVNFIEVWRU5UUzpcclxuICAgIC8vICoqKioqKioqKioqKipcclxuXHJcbiAgICBmdW5jdGlvbiBfZW50ZXJIYW5kbGVyKGUpIHtcclxuICAgICAgaWYgKCFfc2V0dGluZ3MoJ2NsaWNrVG9Gb2N1cycpKSB7XHJcbiAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ21vdmUnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5XHJcbiAgICAgKiBkcmFnIHRoZSBncmFwaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9tb3ZlSGFuZGxlcihlKSB7XHJcbiAgICAgIHZhciB4LFxyXG4gICAgICAgICAgeSxcclxuICAgICAgICAgIHBvcztcclxuXHJcbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50OlxyXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XHJcblxyXG4gICAgICAgIGlmIChfaXNNb3VzZURvd24pIHtcclxuICAgICAgICAgIF9pc01vdmluZyA9IHRydWU7XHJcbiAgICAgICAgICBfaGFzRHJhZ2dlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcclxuXHJcbiAgICAgICAgICBfbW92aW5nVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xyXG5cclxuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoX2NhbWVyYSk7XHJcblxyXG4gICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XHJcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gX3N0YXJ0TW91c2VYLFxyXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRZKGUpIC0gX3N0YXJ0TW91c2VZLFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIHggPSBfc3RhcnRDYW1lcmFYIC0gcG9zLng7XHJcbiAgICAgICAgICB5ID0gX3N0YXJ0Q2FtZXJhWSAtIHBvcy55O1xyXG5cclxuICAgICAgICAgIGlmICh4ICE9PSBfY2FtZXJhLnggfHwgeSAhPT0gX2NhbWVyYS55KSB7XHJcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcclxuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcclxuICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgIHk6IHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd1cCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RvcCBkcmFnZ2luZyB0aGVcclxuICAgICAqIGdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3VwSGFuZGxlcihlKSB7XHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9pc01vdXNlRG93bikge1xyXG4gICAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xyXG5cclxuICAgICAgICBfY2FtZXJhLmlzTW92aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciB4ID0gc2lnbWEudXRpbHMuZ2V0WChlKSxcclxuICAgICAgICAgICAgeSA9IHNpZ21hLnV0aWxzLmdldFkoZSk7XHJcblxyXG4gICAgICAgIGlmIChfaXNNb3ZpbmcpIHtcclxuICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwoX2NhbWVyYSk7XHJcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXHJcbiAgICAgICAgICAgIF9jYW1lcmEsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xyXG4gICAgICAgICAgICAgICAgX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFSYXRpbycpICogKF9jYW1lcmEueCAtIF9sYXN0Q2FtZXJhWCksXHJcbiAgICAgICAgICAgICAgeTogX2NhbWVyYS55ICtcclxuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxyXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlSW5lcnRpYUR1cmF0aW9uJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgX3N0YXJ0TW91c2VYICE9PSB4IHx8XHJcbiAgICAgICAgICBfc3RhcnRNb3VzZVkgIT09IHlcclxuICAgICAgICApXHJcbiAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xyXG4gICAgICAgICAgICB4OiBfY2FtZXJhLngsXHJcbiAgICAgICAgICAgIHk6IF9jYW1lcmEueVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNldXAnLFxyXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgX2lzTW92aW5nIGZsYWc6XHJcbiAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ2Rvd24nIG1vdXNlIGV2ZW50LiBJdCB3aWxsIHN0YXJ0IG9ic2VydmluZ1xyXG4gICAgICogdGhlIG1vdXNlIHBvc2l0aW9uIGZvciBkcmFnZ2luZyB0aGUgZ3JhcGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZG93bkhhbmRsZXIoZSkge1xyXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSkge1xyXG4gICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcclxuXHJcbiAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcclxuXHJcbiAgICAgICAgX3N0YXJ0TW91c2VYID0gc2lnbWEudXRpbHMuZ2V0WChlKTtcclxuICAgICAgICBfc3RhcnRNb3VzZVkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xyXG5cclxuICAgICAgICBfaGFzRHJhZ2dlZCA9IGZhbHNlO1xyXG4gICAgICAgIF9kb3duU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIC8vIE1pZGRsZSBtb3VzZSBidXR0b24gcHJlc3NlZFxyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgLy8gUmlnaHQgbW91c2UgYnV0dG9uIHByZXNzZWRcclxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRjbGljaycsXHJcbiAgICAgICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgX3N0YXJ0TW91c2VYLCBfc3RhcnRNb3VzZVkpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAvLyBjYXNlIDE6XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvLyBMZWZ0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXHJcbiAgICAgICAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZWRvd24nLFxyXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdvdXQnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGp1c3QgcmVkaXNwYXRjaFxyXG4gICAgICogdGhlIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX291dEhhbmRsZXIoZSkge1xyXG4gICAgICBfc2VsZi5lbHRGb2N1c2VkID0gZmFsc2U7XHJcbiAgICAgIHRhcmdldC5ibHVyKCk7XHJcblxyXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSlcclxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW91dCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAnY2xpY2snIG1vdXNlIGV2ZW50LiBJdCB3aWxsIHJlZGlzcGF0Y2ggdGhlXHJcbiAgICAgKiBjbGljayBldmVudCwgYnV0IHdpdGggbm9ybWFsaXplZCBYIGFuZCBZIGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NsaWNrSGFuZGxlcihlKSB7XHJcbiAgICAgIF9zZWxmLmVsdEZvY3VzZWQgPSB0cnVlO1xyXG4gICAgICB0YXJnZXQuZm9jdXMoKTtcclxuXHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSk7XHJcbiAgICAgICAgZXZlbnQuaXNEcmFnZ2luZyA9XHJcbiAgICAgICAgICAoKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBfZG93blN0YXJ0VGltZSkgPiAxMDApICYmIF9oYXNEcmFnZ2VkO1xyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZXZlbnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblxyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSBjbGljayBjdXN0b20gZXZlbnQuIEl0IHdpbGxcclxuICAgICAqIGJhc2ljYWxseSB6b29tIGludG8gdGhlIGdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2RvdWJsZUNsaWNrSGFuZGxlcihlKSB7XHJcbiAgICAgIHZhciBwb3MsXHJcbiAgICAgICAgICByYXRpbyxcclxuICAgICAgICAgIGFuaW1hdGlvbjtcclxuXHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xyXG5cclxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XHJcblxyXG4gICAgICAgIGlmIChfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcclxuICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJylcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcclxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd3aGVlbCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgYmFzaWNhbGx5IHpvb21cclxuICAgICAqIGluIG9yIG5vdCBpbnRvIHRoZSBncmFwaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF93aGVlbEhhbmRsZXIoZSkge1xyXG4gICAgICB2YXIgcG9zLFxyXG4gICAgICAgICAgcmF0aW8sXHJcbiAgICAgICAgICBhbmltYXRpb247XHJcblxyXG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSAmJiBfc2V0dGluZ3MoJ21vdXNlV2hlZWxFbmFibGVkJykgJiYgKCFfc2V0dGluZ3MoJ2NsaWNrVG9Gb2N1cycpIHx8IF9zZWxmLmVsdEZvY3VzZWQpKSB7XHJcbiAgICAgICAgcmF0aW8gPSBzaWdtYS51dGlscy5nZXREZWx0YShlKSA+IDAgP1xyXG4gICAgICAgICAgMSAvIF9zZXR0aW5ncygnem9vbWluZ1JhdGlvJykgOlxyXG4gICAgICAgICAgX3NldHRpbmdzKCd6b29taW5nUmF0aW8nKTtcclxuXHJcbiAgICAgICAgcG9zID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcclxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFgoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcclxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcclxuICAgICAgICAgIHRydWVcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdtb3VzZVpvb21EdXJhdGlvbicpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgc2lnbWEudXRpbHMuem9vbVRvKF9jYW1lcmEsIHBvcy54LCBwb3MueSwgcmF0aW8sIGFuaW1hdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYXB0b3JzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB1c2VyIGlucHV0cyBkZWZhdWx0IGNhcHRvci4gSXQgZGVhbHMgd2l0aCBtb3VzZSBldmVudHMsIGtleWJvYXJkc1xyXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICB0YXJnZXQgICBUaGUgRE9NIGVsZW1lbnQgd2hlcmUgdGhlIGxpc3RlbmVycyB3aWxsIGJlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cclxuICAgKiBAcGFyYW0gIHtjYW1lcmF9ICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEgcmVsYXRlZCB0byB0aGUgdGFyZ2V0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEuY2FwdG9ycy50b3VjaCA9IGZ1bmN0aW9uKHRhcmdldCwgY2FtZXJhLCBzZXR0aW5ncykge1xyXG4gICAgdmFyIF9zZWxmID0gdGhpcyxcclxuICAgICAgICBfdGFyZ2V0ID0gdGFyZ2V0LFxyXG4gICAgICAgIF9jYW1lcmEgPSBjYW1lcmEsXHJcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXHJcblxyXG4gICAgICAgIC8vIENBTUVSQSBNQU5BR0VNRU5UOlxyXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIC8vIFRoZSBjYW1lcmEgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XHJcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCxcclxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxyXG4gICAgICAgIF9zdGFydENhbWVyYUFuZ2xlLFxyXG4gICAgICAgIF9zdGFydENhbWVyYVJhdGlvLFxyXG5cclxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxyXG4gICAgICAgIF9sYXN0Q2FtZXJhWCxcclxuICAgICAgICBfbGFzdENhbWVyYVksXHJcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcclxuICAgICAgICBfbGFzdENhbWVyYVJhdGlvLFxyXG5cclxuICAgICAgICAvLyBUT1VDSCBNQU5BR0VNRU5UOlxyXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgLy8gVG91Y2hlcyB0aGF0IGFyZSBkb3duOlxyXG4gICAgICAgIF9kb3duVG91Y2hlcyA9IFtdLFxyXG5cclxuICAgICAgICBfc3RhcnRUb3VjaFgwLFxyXG4gICAgICAgIF9zdGFydFRvdWNoWTAsXHJcbiAgICAgICAgX3N0YXJ0VG91Y2hYMSxcclxuICAgICAgICBfc3RhcnRUb3VjaFkxLFxyXG4gICAgICAgIF9zdGFydFRvdWNoQW5nbGUsXHJcbiAgICAgICAgX3N0YXJ0VG91Y2hEaXN0YW5jZSxcclxuXHJcbiAgICAgICAgX3RvdWNoTW9kZSxcclxuXHJcbiAgICAgICAgX2lzTW92aW5nLFxyXG4gICAgICAgIF9kb3VibGVUYXAsXHJcbiAgICAgICAgX21vdmluZ1RpbWVvdXRJZDtcclxuXHJcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xyXG5cclxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0JywgX2RvdWJsZVRhcEhhbmRsZXIpO1xyXG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX2hhbmRsZVN0YXJ0LCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XHJcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobGVhdmUnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcclxuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2hhbmRsZU1vdmUsIGZhbHNlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBwb3NpdGlvbihlKSB7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBzaWdtYS51dGlscy5nZXRPZmZzZXQoX3RhcmdldCk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IGUucGFnZVggLSBvZmZzZXQubGVmdCxcclxuICAgICAgICB5OiBlLnBhZ2VZIC0gb2Zmc2V0LnRvcFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgdW5iaW5kcyBldmVyeSBoYW5kbGVycyB0aGF0IG1ha2VzIHRoZSBjYXB0b3Igd29yay5cclxuICAgICAqL1xyXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0Jyk7XHJcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCk7XHJcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUpO1xyXG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlKTtcclxuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlKTtcclxuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPVUNIIEVWRU5UUzpcclxuICAgIC8vICoqKioqKioqKioqKipcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hzdGFydCcgZXZlbnQuIEl0IHdpbGwgc2V0IHRoZSB0b3VjaFxyXG4gICAgICogbW9kZSAoXCJfdG91Y2hNb2RlXCIpIGFuZCBzdGFydCBvYnNlcnZpbmcgdGhlIHVzZXIgdG91Y2ggbW92ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfaGFuZGxlU3RhcnQoZSkge1xyXG4gICAgICBpZiAoX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xyXG4gICAgICAgIHZhciB4MCxcclxuICAgICAgICAgICAgeDEsXHJcbiAgICAgICAgICAgIHkwLFxyXG4gICAgICAgICAgICB5MSxcclxuICAgICAgICAgICAgcG9zMCxcclxuICAgICAgICAgICAgcG9zMTtcclxuXHJcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKF9kb3duVG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAxO1xyXG5cclxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcclxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcclxuXHJcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcclxuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XHJcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDAgPSBwb3MwLng7XHJcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSBwb3MwLnk7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAyO1xyXG5cclxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XHJcbiAgICAgICAgICAgIHBvczEgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMV0pO1xyXG4gICAgICAgICAgICB4MCA9IHBvczAueDtcclxuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XHJcbiAgICAgICAgICAgIHgxID0gcG9zMS54O1xyXG4gICAgICAgICAgICB5MSA9IHBvczEueTtcclxuXHJcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcclxuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICAgICAgX3N0YXJ0Q2FtZXJhQW5nbGUgPSBfY2FtZXJhLmFuZ2xlO1xyXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XHJcblxyXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHgwO1xyXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkwID0geTA7XHJcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWDEgPSB4MTtcclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMSA9IHkxO1xyXG5cclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hBbmdsZSA9IE1hdGguYXRhbjIoXHJcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTAsXHJcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgX3N0YXJ0VG91Y2hEaXN0YW5jZSA9IE1hdGguc3FydChcclxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICpcclxuICAgICAgICAgICAgICAgIChfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCkgK1xyXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgxIC0gX3N0YXJ0VG91Y2hYMCkgKlxyXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcgYW5kICd0b3VjaGxlYXZlJ1xyXG4gICAgICogZXZlbnQuIEl0IHdpbGwgdXBkYXRlIHRoZSB0b3VjaCBtb2RlIGlmIHRoZXJlIGFyZSBzdGlsbCBhdCBsZWFzdCBvbmVcclxuICAgICAqIGZpbmdlciwgYW5kIHN0b3AgZHJhZ2dpbmcgZWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9oYW5kbGVMZWF2ZShlKSB7XHJcbiAgICAgIGlmIChfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xyXG4gICAgICAgIHZhciBpbmVydGlhUmF0aW8gPSBfc2V0dGluZ3MoJ3RvdWNoSW5lcnRpYVJhdGlvJyk7XHJcblxyXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKSB7XHJcbiAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIGNsZWFyVGltZW91dChfbW92aW5nVGltZW91dElkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN3aXRjaCAoX3RvdWNoTW9kZSkge1xyXG4gICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgIF9oYW5kbGVTdGFydChlKTtcclxuXHJcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdzdG9wRHJhZycpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9pc01vdmluZykge1xyXG4gICAgICAgICAgICAgIF9kb3VibGVUYXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXHJcbiAgICAgICAgICAgICAgICBfY2FtZXJhLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xyXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxyXG4gICAgICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xyXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxyXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFEdXJhdGlvbicpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNobW92ZScgZXZlbnQuIEl0IHdpbGwgZWZmZWN0aXZlbHkgZHJhZ1xyXG4gICAgICogdGhlIGdyYXBoLCBhbmQgZXZlbnR1YWxseSB6b29tcyBhbmQgdHVybiBpdCBpZiB0aGUgdXNlciBpcyB1c2luZyB0d29cclxuICAgICAqIGZpbmdlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIHRvdWNoIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfaGFuZGxlTW92ZShlKSB7XHJcbiAgICAgIGlmICghX2RvdWJsZVRhcCAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgdmFyIHgwLFxyXG4gICAgICAgICAgICB4MSxcclxuICAgICAgICAgICAgeTAsXHJcbiAgICAgICAgICAgIHkxLFxyXG4gICAgICAgICAgICBjb3MsXHJcbiAgICAgICAgICAgIHNpbixcclxuICAgICAgICAgICAgZW5kLFxyXG4gICAgICAgICAgICBwb3MwLFxyXG4gICAgICAgICAgICBwb3MxLFxyXG4gICAgICAgICAgICBkaWZmLFxyXG4gICAgICAgICAgICBzdGFydCxcclxuICAgICAgICAgICAgZEFuZ2xlLFxyXG4gICAgICAgICAgICBkUmF0aW8sXHJcbiAgICAgICAgICAgIG5ld1N0YWdlWCxcclxuICAgICAgICAgICAgbmV3U3RhZ2VZLFxyXG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvLFxyXG4gICAgICAgICAgICBuZXdTdGFnZUFuZ2xlO1xyXG5cclxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XHJcbiAgICAgICAgX2lzTW92aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXHJcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX21vdmluZ1RpbWVvdXRJZCk7XHJcblxyXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSwgX3NldHRpbmdzKCdkcmFnVGltZW91dCcpKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XHJcbiAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xyXG4gICAgICAgICAgICB4MCA9IHBvczAueDtcclxuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XHJcblxyXG4gICAgICAgICAgICBkaWZmID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcclxuICAgICAgICAgICAgICB4MCAtIF9zdGFydFRvdWNoWDAsXHJcbiAgICAgICAgICAgICAgeTAgLSBfc3RhcnRUb3VjaFkwLFxyXG4gICAgICAgICAgICAgIHRydWVcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIG5ld1N0YWdlWCA9IF9zdGFydENhbWVyYVggLSBkaWZmLng7XHJcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IF9zdGFydENhbWVyYVkgLSBkaWZmLnk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmV3U3RhZ2VYICE9PSBfY2FtZXJhLnggfHwgbmV3U3RhZ2VZICE9PSBfY2FtZXJhLnkpIHtcclxuICAgICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XHJcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xyXG5cclxuICAgICAgICAgICAgICBfY2FtZXJhLmdvVG8oe1xyXG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxyXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZXHJcbiAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXHJcbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlLCBwb3MwLngsIHBvczAueSkpO1xyXG5cclxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xyXG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcclxuICAgICAgICAgICAgeDAgPSBwb3MwLng7XHJcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xyXG4gICAgICAgICAgICB4MSA9IHBvczEueDtcclxuICAgICAgICAgICAgeTEgPSBwb3MxLnk7XHJcblxyXG4gICAgICAgICAgICBzdGFydCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDAgKyBfc3RhcnRUb3VjaFgxKSAvIDIgLVxyXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLngsXHJcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTAgKyBfc3RhcnRUb3VjaFkxKSAvIDIgLVxyXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXHJcbiAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBlbmQgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgICAgICh4MCArIHgxKSAvIDIgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcclxuICAgICAgICAgICAgICAoeTAgKyB5MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXHJcbiAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZEFuZ2xlID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKSAtIF9zdGFydFRvdWNoQW5nbGU7XHJcbiAgICAgICAgICAgIGRSYXRpbyA9IE1hdGguc3FydChcclxuICAgICAgICAgICAgICAoeTEgLSB5MCkgKiAoeTEgLSB5MCkgKyAoeDEgLSB4MCkgKiAoeDEgLSB4MClcclxuICAgICAgICAgICAgKSAvIF9zdGFydFRvdWNoRGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbjpcclxuICAgICAgICAgICAgeDAgPSBzdGFydC54O1xyXG4gICAgICAgICAgICB5MCA9IHN0YXJ0Lnk7XHJcblxyXG4gICAgICAgICAgICAvLyBIb21vdGhldGljIHRyYW5zZm9ybWF0aW9uOlxyXG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvID0gX3N0YXJ0Q2FtZXJhUmF0aW8gLyBkUmF0aW87XHJcbiAgICAgICAgICAgIHgwID0geDAgKiBkUmF0aW87XHJcbiAgICAgICAgICAgIHkwID0geTAgKiBkUmF0aW87XHJcblxyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbjpcclxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSA9IF9zdGFydENhbWVyYUFuZ2xlIC0gZEFuZ2xlO1xyXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcygtZEFuZ2xlKTtcclxuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oLWRBbmdsZSk7XHJcbiAgICAgICAgICAgIHgxID0geDAgKiBjb3MgKyB5MCAqIHNpbjtcclxuICAgICAgICAgICAgeTEgPSB5MCAqIGNvcyAtIHgwICogc2luO1xyXG4gICAgICAgICAgICB4MCA9IHgxO1xyXG4gICAgICAgICAgICB5MCA9IHkxO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluYWxpemU6XHJcbiAgICAgICAgICAgIG5ld1N0YWdlWCA9IHgwIC0gZW5kLnggKyBfc3RhcnRDYW1lcmFYO1xyXG4gICAgICAgICAgICBuZXdTdGFnZVkgPSB5MCAtIGVuZC55ICsgX3N0YXJ0Q2FtZXJhWTtcclxuXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICBuZXdTdGFnZVJhdGlvICE9PSBfY2FtZXJhLnJhdGlvIHx8XHJcbiAgICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSAhPT0gX2NhbWVyYS5hbmdsZSB8fFxyXG4gICAgICAgICAgICAgIG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8XHJcbiAgICAgICAgICAgICAgbmV3U3RhZ2VZICE9PSBfY2FtZXJhLnlcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xyXG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcclxuICAgICAgICAgICAgICBfbGFzdENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcclxuICAgICAgICAgICAgICBfbGFzdENhbWVyYVJhdGlvID0gX2NhbWVyYS5yYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcclxuICAgICAgICAgICAgICAgIHg6IG5ld1N0YWdlWCxcclxuICAgICAgICAgICAgICAgIHk6IG5ld1N0YWdlWSxcclxuICAgICAgICAgICAgICAgIGFuZ2xlOiBuZXdTdGFnZUFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgcmF0aW86IG5ld1N0YWdlUmF0aW9cclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgZG91YmxlIHRhcCBjdXN0b20gZXZlbnQuIEl0IHdpbGxcclxuICAgICAqIGJhc2ljYWxseSB6b29tIGludG8gdGhlIGdyYXBoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2RvdWJsZVRhcEhhbmRsZXIoZSkge1xyXG4gICAgICB2YXIgcG9zLFxyXG4gICAgICAgICAgcmF0aW8sXHJcbiAgICAgICAgICBhbmltYXRpb247XHJcblxyXG4gICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgJiYgX3NldHRpbmdzKCd0b3VjaEVuYWJsZWQnKSkge1xyXG4gICAgICAgIF9kb3VibGVUYXAgPSB0cnVlO1xyXG5cclxuICAgICAgICByYXRpbyA9IDEgLyBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbWluZ1JhdGlvJyk7XHJcblxyXG4gICAgICAgIHBvcyA9IHBvc2l0aW9uKGUudG91Y2hlc1swXSk7XHJcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlY2xpY2snLFxyXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zLngsIHBvcy55KSk7XHJcblxyXG4gICAgICAgIGlmIChfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrRW5hYmxlZCcpKSB7XHJcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxyXG4gICAgICAgICAgICBwb3MueCAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxyXG4gICAgICAgICAgICBwb3MueSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxyXG4gICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgZHVyYXRpb246IF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29tRHVyYXRpb24nKSxcclxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgaWYgKHR5cGVvZiBjb25yYWQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjYW52YXMgc2lnbWEncyByZW5kZXJlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cclxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXHJcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMuY2FudmFzOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcclxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcclxuXHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgZm4sXHJcbiAgICAgICAgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XHJcbiAgICAgIHZhbHVlOiBzaWdtYS51dGlscy5pZCgpXHJcbiAgICB9KTtcclxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcclxuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgdGhpcy5jb250ZXh0cyA9IHt9O1xyXG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSAoXHJcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xyXG4gICAgICApID9cclxuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxyXG4gICAgICAgIHNldHRpbmdzO1xyXG5cclxuICAgIC8vIE5vZGUgaW5kZXhlczpcclxuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IFtdO1xyXG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XHJcblxyXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcclxuICAgIHRoaXMuam9icyA9IHt9O1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcclxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgdGhpcy5jb25yYWRJZCArICc6JztcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBET00gZWxlbWVudHM6XHJcbiAgICBpZiAoXHJcbiAgICAgICF0aGlzLnNldHRpbmdzKCdiYXRjaEVkZ2VzRHJhd2luZycpXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnKTtcclxuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XHJcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xyXG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdlZGdlcycpO1xyXG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xyXG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcclxuICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ21vdXNlJyk7XHJcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGNhcHRvcnM6XHJcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcclxuICAgIGEgPSB0aGlzLm9wdGlvbnMuY2FwdG9ycyB8fCBbc2lnbWEuY2FwdG9ycy5tb3VzZSwgc2lnbWEuY2FwdG9ycy50b3VjaF07XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xyXG4gICAgICB0aGlzLmNhcHRvcnMucHVzaChcclxuICAgICAgICBuZXcgZm4oXHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxyXG4gICAgICAgICAgdGhpcy5jYW1lcmEsXHJcbiAgICAgICAgICB0aGlzLnNldHRpbmdzXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlYWwgd2l0aCBzaWdtYSBldmVudHM6XHJcbiAgICBzaWdtYS5taXNjLmJpbmRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cclxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIHJlbmRlciBlZGdlcyBvciBub2RlcyB3aXRoIHRoZSBnaXZlbiByZW5kZXJlcnNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgcGFyYW1zICAgICBUaGUgcGFyYW1ldGVycyBwYXNzZWQgaW4gYW4gb2JqZWN0XHJcbiAgICoge1xyXG4gICAqICAgcmVuZGVyZXJzOiB7b2JqZWN0fSAgICAgICAgICAgICAgUmVuZGVyZXJzIGluZGV4ZWQgYnkgdHlwZXNcclxuICAgKiAgIHR5cGU6ICAgICAge3N0cmluZ30gICAgICAgICAgICAgIFwiZWRnZXNcIiBvciBcIm5vZGVzXCJcclxuICAgKiAgIGN0eDogICAgICAge0NvbnRleHQyRH0gICAgICAgICAgIENhbnZhcyBDb250ZXh0IHRvIGRyYXcgb25cclxuICAgKiAgIHNldHRpbmdzOiAge29iamVjdH0gICAgICAgICAgICAgIFNldHRpbmdzIG9iamVjdCB0byB1c2VcclxuICAgKiAgIGVsZW1lbnRzOiAge2FycmF5fSAgICAgICAgICAgICAgIEVsZW1lbnRzIHRvIHJlbmRlclxyXG4gICAqICAgZ3JhcGg/OiAgICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gR3JhcGggb2JqZWN0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25seSBuZWNlc3NhcnkgZm9yIGVkZ2UgcmVuZGVyaW5nKVxyXG4gICAqICAgc3RhcnQ/OiAgICB7aW50ZWdlcn0gICAgICAgICAgICAgU3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnRzIHRvIHJlbmRlclxyXG4gICAqICAgZW5kPzogICAgICB7aW50ZWdlcn0gICAgICAgICAgICAgTGFzdCBpbmRleCBvZiB0aGUgZWxlbWVudHMgdG8gcmVuZGVyXHJcbiAgICogfVxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMuYXBwbHlSZW5kZXJlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIHJlbmRlcmVyLFxyXG4gICAgICAgIHNwZWNpYWxpemVkUmVuZGVyZXIsXHJcbiAgICAgICAgZGVmLFxyXG4gICAgICAgIHJlbmRlcixcclxuICAgICAgICBlbHMgPSBwYXJhbXMuZWxlbWVudHMsXHJcbiAgICAgICAgY3R4X2luZm9zID0ge2ZvbnQ6IHBhcmFtcy5jdHguZm9udH0sXHJcbiAgICAgICAgZWxlbWVudFR5cGUgPSAocGFyYW1zLmVsZW1lbnRzIHx8IHBhcmFtcy50eXBlID09ICdlZGdlcycgP1xyXG4gICAgICAgICAgICAgICdkZWZhdWx0RWRnZVR5cGUnIDogJ2RlZmF1bHROb2RlVHlwZScpO1xyXG5cclxuICAgIHBhcmFtcy5zdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwO1xyXG4gICAgcGFyYW1zLmVuZCA9IHBhcmFtcy5lbmQgfHwgcGFyYW1zLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgIHBhcmFtcy5lbmQgPSBNYXRoLm1pbihwYXJhbXMuZWxlbWVudHMubGVuZ3RoLCBwYXJhbXMuZW5kKTtcclxuXHJcbiAgICBwYXJhbXMuY3R4LnNhdmUoKTtcclxuXHJcbiAgICBmb3IgKGkgPSBwYXJhbXMuc3RhcnQ7IGkgPCBwYXJhbXMuZW5kOyBpKyspIHtcclxuICAgICAgaWYgKCFlbHNbaV0uaGlkZGVuKSB7XHJcbiAgICAgICAgc3BlY2lhbGl6ZWRSZW5kZXJlciA9IHBhcmFtcy5yZW5kZXJlcnNbXHJcbiAgICAgICAgICBlbHNbaV0udHlwZSB8fCBwYXJhbXMuc2V0dGluZ3MoZWxlbWVudFR5cGUpXHJcbiAgICAgICAgXTtcclxuICAgICAgICBkZWYgPSAoc3BlY2lhbGl6ZWRSZW5kZXJlciB8fCBwYXJhbXMucmVuZGVyZXJzLmRlZik7XHJcbiAgICAgICAgaWYgKHBhcmFtcy50eXBlID09ICdlZGdlcycpIHtcclxuICAgICAgICAgIGRlZihcclxuICAgICAgICAgICAgZWxzW2ldLFxyXG4gICAgICAgICAgICBwYXJhbXMuZ3JhcGgubm9kZXMoZWxzW2ldLnNvdXJjZSksXHJcbiAgICAgICAgICAgIHBhcmFtcy5ncmFwaC5ub2RlcyhlbHNbaV0udGFyZ2V0KSxcclxuICAgICAgICAgICAgcGFyYW1zLmN0eCxcclxuICAgICAgICAgICAgcGFyYW1zLnNldHRpbmdzLFxyXG4gICAgICAgICAgICB7Y3R4OiBjdHhfaW5mb3N9XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgIGRlZihcclxuICAgICAgICAgICAgZWxzW2ldLFxyXG4gICAgICAgICAgICBwYXJhbXMuY3R4LFxyXG4gICAgICAgICAgICBwYXJhbXMuc2V0dGluZ3MsXHJcbiAgICAgICAgICAgIHtjdHg6IGN0eF9pbmZvc31cclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcGFyYW1zLmN0eC5yZXN0b3JlKCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciBhIGJhdGNoIG9mIGVkZ2VzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gICAge2ludGVnZXJ9ICAgICAgc3RhcnQgICAgU3RhcnRpbmcgaW5kZXggb2YgdGhlIGVsZW1lbnRzIHRvIHJlbmRlclxyXG4gICAqIEBwYXJhbSAgICB7aW50ZWdlcn0gICAgICBlbmQgICAgICBMYXN0IGluZGV4IG9mIHRoZSBlbGVtZW50cyB0byByZW5kZXJcclxuICAgKiBAcGFyYW0gICAge29iamVjdH0gICAgICAgc2V0dGluZ3MgU2V0dGluZ3MgdG8gdXNlXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVuZGVyRWRnZXMgPVxyXG4gICAgICAgICAgZnVuY3Rpb24oc3RhcnQsIGVuZCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciByZW5kZXJQYXJhbXMgPSB7XHJcbiAgICAgIHJlbmRlcmVyczogc2lnbWEuY2FudmFzLmVkZ2VzLFxyXG4gICAgICB0eXBlOiAnZWRnZXMnLFxyXG4gICAgICBlbGVtZW50czogdGhpcy5lZGdlc09uU2NyZWVuLFxyXG4gICAgICBjdHg6IHRoaXMuY29udGV4dHMuZWRnZXMsXHJcbiAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgZW5kOiBlbmQsXHJcbiAgICAgIGdyYXBoOiB0aGlzLmdyYXBoLFxyXG4gICAgICBzZXR0aW5nczogc2V0dGluZ3NcclxuICAgIH07XHJcbiAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHJlbmRlclBhcmFtcyk7XHJcbiAgICBpZiAoc2V0dGluZ3MoJ2RyYXdFZGdlTGFiZWxzJykpIHtcclxuICAgICAgcmVuZGVyUGFyYW1zLnJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XHJcbiAgICAgIHJlbmRlclBhcmFtcy5jdHggPSB0aGlzLmNvbnRleHRzLmxhYmVscztcclxuICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5hcHBseVJlbmRlcmVycyhyZW5kZXJQYXJhbXMpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBjYW52YXNlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2JlZm9yZVJlbmRlcicpO1xyXG5cclxuICAgIHZhciBhLFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgayxcclxuICAgICAgICBsLFxyXG4gICAgICAgIG8sXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgZW5kLFxyXG4gICAgICAgIGpvYixcclxuICAgICAgICBzdGFydCxcclxuICAgICAgICBlZGdlcyxcclxuICAgICAgICBiYXRjaFNpemUsXHJcbiAgICAgICAgdGVtcEdDTyxcclxuICAgICAgICBpbmRleCA9IHt9LFxyXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcclxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMsXHJcbiAgICAgICAgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeCB8fCAnJyxcclxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcclxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKSxcclxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxyXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XHJcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXhcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XHJcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XHJcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXHJcbiAgICAgIGlmICh0aGlzLmNhbWVyYS5pc0FuaW1hdGVkIHx8IHRoaXMuY2FtZXJhLmlzTW92aW5nKVxyXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEFwcGx5IHRoZSBjYW1lcmEncyB2aWV3OlxyXG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxyXG4gICAgICB1bmRlZmluZWQsXHJcbiAgICAgIHRoaXMub3B0aW9ucy5wcmVmaXgsXHJcbiAgICAgIHtcclxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XHJcbiAgICB0aGlzLmNsZWFyKCk7XHJcblxyXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5qb2JzKVxyXG4gICAgICBpZiAoY29ucmFkLmhhc0pvYihrKSlcclxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcclxuXHJcbiAgICAvLyBGaW5kIHdoaWNoIG5vZGVzIGFyZSBvbiBzY3JlZW46XHJcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxyXG4gICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXHJcbiAgICApO1xyXG5cclxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgaW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xyXG5cclxuICAgIC8vIERyYXcgZWRnZXM6XHJcbiAgICAvLyAtIElmIHNldHRpbmdzKCdiYXRjaEVkZ2VzRHJhd2luZycpIGlzIHRydWUsIHRoZSBlZGdlcyBhcmUgZGlzcGxheWVkIHBlclxyXG4gICAgLy8gICBiYXRjaGVzLiBJZiBub3QsIHRoZXkgYXJlIGRyYXduIGluIG9uZSBmcmFtZS5cclxuICAgIGlmIChkcmF3RWRnZXMpIHtcclxuICAgICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XHJcbiAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlc0NsaXBwaW5nV2l0aE5vZGVzJykpIHtcclxuICAgICAgICAvLyBJZGVudGlmeSB3aGljaCBlZGdlcyB0byBkcmF3IGJ5IGtlZXBpbmcgZXZlcnkgZWRnZXMgdGhhdCBoYXZlIGF0XHJcbiAgICAgICAgLy8gbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvIHRoZSBxdWFkdHJlZSBhbmQgdGhlXHJcbiAgICAgICAgLy8gXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuIGVkZ2VzLlxyXG4gICAgICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgIG8gPSBhW2ldO1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcclxuICAgICAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcclxuICAgICAgICAgIClcclxuICAgICAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuZWRnZXNPblNjcmVlbiA9IHRoaXMuY2FtZXJhLmVkZ2VxdWFkdHJlZS5hcmVhKFxyXG4gICAgICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHRoZSBcImJhdGNoRWRnZXNEcmF3aW5nXCIgc2V0dGluZ3MgaXMgdHJ1ZSwgZWRnZXMgYXJlIGJhdGNoZWQ6XHJcbiAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XHJcbiAgICAgICAgaWQgPSAnZWRnZXNfJyArIHRoaXMuY29ucmFkSWQ7XHJcbiAgICAgICAgYmF0Y2hTaXplID0gZW1iZWRTZXR0aW5ncygnY2FudmFzRWRnZXNCYXRjaFNpemUnKTtcclxuXHJcbiAgICAgICAgZWRnZXMgPSB0aGlzLmVkZ2VzT25TY3JlZW47XHJcbiAgICAgICAgbCA9IGVkZ2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgIGVuZCA9IE1hdGgubWluKGVkZ2VzLmxlbmd0aCwgc3RhcnQgKyBiYXRjaFNpemUpO1xyXG5cclxuICAgICAgICBqb2IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHRlbXBHQ08gPSB0aGlzLmNvbnRleHRzLmVkZ2VzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcclxuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xyXG5cclxuICAgICAgICAgIHRoaXMucmVuZGVyRWRnZXMoc3RhcnQsIGVuZCwgZW1iZWRTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246XHJcbiAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRlbXBHQ087XHJcblxyXG4gICAgICAgICAgLy8gQ2F0Y2ggam9iJ3MgZW5kOlxyXG4gICAgICAgICAgaWYgKGVuZCA9PT0gZWRnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RhcnQgPSBlbmQgKyAxO1xyXG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xyXG4gICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgIC8vIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lOlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRWRnZXMoMCwgdGhpcy5lZGdlc09uU2NyZWVuLmxlbmd0aCwgZW1iZWRTZXR0aW5ncyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEcmF3IG5vZGVzOlxyXG4gICAgLy8gLSBObyBiYXRjaGluZ1xyXG4gICAgaWYgKGRyYXdOb2Rlcykge1xyXG4gICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHtcclxuICAgICAgICByZW5kZXJlcnM6IHNpZ21hLmNhbnZhcy5ub2RlcyxcclxuICAgICAgICB0eXBlOiAnbm9kZXMnLFxyXG4gICAgICAgIGN0eDogdGhpcy5jb250ZXh0cy5ub2RlcyxcclxuICAgICAgICBlbGVtZW50czogdGhpcy5ub2Rlc09uU2NyZWVuLFxyXG4gICAgICAgIHNldHRpbmdzOiBlbWJlZFNldHRpbmdzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERyYXcgbGFiZWxzOlxyXG4gICAgLy8gLSBObyBiYXRjaGluZ1xyXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcclxuICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5hcHBseVJlbmRlcmVycyh7XHJcbiAgICAgICAgcmVuZGVyZXJzOiBzaWdtYS5jYW52YXMubGFiZWxzLFxyXG4gICAgICAgIHR5cGU6ICdub2RlcycsXHJcbiAgICAgICAgY3R4OiB0aGlzLmNvbnRleHRzLmxhYmVscyxcclxuICAgICAgICBlbGVtZW50czogdGhpcy5ub2Rlc09uU2NyZWVuLFxyXG4gICAgICAgIHNldHRpbmdzOiBlbWJlZFNldHRpbmdzXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXHJcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxyXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGhlIGxhYmVsIHRhZy5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZywgaWQpIHtcclxuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XHJcblxyXG4gICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XHJcblxyXG4gICAgdGhpcy5kb21FbGVtZW50c1tpZF0gPSBkb207XHJcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xyXG5cclxuICAgIGlmICh0YWcudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpXHJcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQoJzJkJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xyXG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICAgIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcclxuICAgICAgICBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCxcclxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xyXG5cclxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB3O1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgdyA9IHRoaXMud2lkdGg7XHJcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xyXG4gICAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xyXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcclxuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSArICdweCcpO1xyXG5cclxuICAgICAgICAgIGlmIChwaXhlbFJhdGlvICE9PSAxKVxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGNsZWFycyBlYWNoIGNhbnZhcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgZm9yICh2YXIgayBpbiB0aGlzLmNvbnRleHRzKSB7XHJcbiAgICAgIHRoaXMuY29udGV4dHNba10uY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgayxcclxuICAgICAgICBjYXB0b3I7XHJcblxyXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxyXG4gICAgd2hpbGUgKChjYXB0b3IgPSB0aGlzLmNhcHRvcnMucG9wKCkpKVxyXG4gICAgICBjYXB0b3Iua2lsbCgpO1xyXG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcclxuXHJcbiAgICAvLyBLaWxsIGNvbnRleHRzOlxyXG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcclxuICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tRWxlbWVudHNba10pO1xyXG4gICAgICBkZWxldGUgdGhpcy5kb21FbGVtZW50c1trXTtcclxuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XHJcbiAgICB9XHJcbiAgICBkZWxldGUgdGhpcy5kb21FbGVtZW50cztcclxuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xyXG4gIH07XHJcblxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBsYWJlbHMsIG5vZGVzIGFuZCBlZGdlcyByZW5kZXJlcnMgYXJlIHN0b3JlZCBpbiB0aGUgdGhyZWUgZm9sbG93aW5nXHJcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcclxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXHJcbiAgICogZGVmYXVsdCByZW5kZXJlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgKlxyXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vY2FudmFzXCIgZm9sZGVyLlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLm5vZGVzJyk7XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjYW52YXMgc2lnbWEncyByZW5kZXJlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cclxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcclxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy53ZWJnbDogV3JvbmcgYXJndW1lbnRzLic7XHJcblxyXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXHJcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XHJcblxyXG4gICAgdmFyIGssXHJcbiAgICAgICAgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgZm4sXHJcbiAgICAgICAgX3NlbGYgPSB0aGlzO1xyXG5cclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcclxuICAgIHRoaXMuam9icyA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XHJcbiAgICAgIHZhbHVlOiBzaWdtYS51dGlscy5pZCgpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcclxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcclxuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgdGhpcy5jb250ZXh0cyA9IHt9O1xyXG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSAoXHJcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xyXG4gICAgICApID9cclxuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxyXG4gICAgICAgIHNldHRpbmdzO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcclxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSB0aGlzLmNhbWVyYS5yZWFkUHJlZml4O1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgcHJvZ3JhbXMgaGFzaFxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub2RlUHJvZ3JhbXMnLCB7XHJcbiAgICAgIHZhbHVlOiB7fVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VQcm9ncmFtcycsIHtcclxuICAgICAgdmFsdWU6IHt9XHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZUZsb2F0QXJyYXlzJywge1xyXG4gICAgICB2YWx1ZToge31cclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlRmxvYXRBcnJheXMnLCB7XHJcbiAgICAgIHZhbHVlOiB7fVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VkZ2VJbmRpY2VzQXJyYXlzJywge1xyXG4gICAgICB2YWx1ZToge31cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcclxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XHJcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJywgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ25vZGVzJywgdHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScsIHRydWUpO1xyXG4gICAgICB0aGlzLmNvbnRleHRzLm5vZGVzID0gdGhpcy5jb250ZXh0cy5zY2VuZTtcclxuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbGFiZWxzJyk7XHJcbiAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdtb3VzZScpO1xyXG4gICAgdGhpcy5jb250ZXh0cy5ob3ZlciA9IHRoaXMuY29udGV4dHMubW91c2U7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBjYXB0b3JzOlxyXG4gICAgdGhpcy5jYXB0b3JzID0gW107XHJcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xyXG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGZuID0gdHlwZW9mIGFbaV0gPT09ICdmdW5jdGlvbicgPyBhW2ldIDogc2lnbWEuY2FwdG9yc1thW2ldXTtcclxuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXHJcbiAgICAgICAgbmV3IGZuKFxyXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5tb3VzZSxcclxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxyXG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1xyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxyXG4gICAgc2lnbWEubWlzYy5iaW5kRXZlbnRzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcclxuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMuY2FtZXJhLnByZWZpeCk7XHJcblxyXG4gICAgdGhpcy5yZXNpemUoKTtcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGdlbmVyYXRlIHRoZSBub2RlcyBhbmQgZWRnZXMgZmxvYXQgYXJyYXlzLiBUaGlzIHN0ZXAgaXNcclxuICAgKiBzZXBhcmF0ZWQgZnJvbSB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJlY2F1c2UgdG8ga2VlcCBXZWJHTCBlZmZpY2llbnQsIHNpbmNlXHJcbiAgICogYWxsIHRoZSBjYW1lcmEgYW5kIG1pZGRsZXdhcmVzIGFyZSBtb2RlbGlzZWQgYXMgbWF0cmljZXMgYW5kIHRoZXkgZG8gbm90XHJcbiAgICogcmVxdWlyZSB0aGUgZmxvYXQgYXJyYXlzIHRvIGJlIHJlZ2VuZXJhdGVkLlxyXG4gICAqXHJcbiAgICogQmFzaWNhbGx5LCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBjYW1lcmEgb3IgYXBwbGllcyBzb21lIHNwZWNpZmljIGxpbmVhclxyXG4gICAqIHRyYW5zZm9ybWF0aW9ucywgdGhpcyBwcm9jZXNzIHN0ZXAgd2lsbCBiZSBza2lwcGVkLCBhbmQgdGhlIFwicmVuZGVyXCJcclxuICAgKiBtZXRob2Qgd2lsbCBlZmZpY2llbnRseSByZWZyZXNoIHRoZSByZW5kZXJpbmcuXHJcbiAgICpcclxuICAgKiBBbmQgd2hlbiB0aGUgdXNlciBtb2RpZmllcyB0aGUgZ3JhcGggY29sb3JzIG9yIHBvc2l0aW9ucyAoYXBwbHlpbmcgYSBuZXdcclxuICAgKiBsYXlvdXQgb3IgZmlsdGVyaW5nIHRoZSBjb2xvcnMsIGZvciBpbnN0YW5jZSksIHRoaXMgXCJwcm9jZXNzXCIgc3RlcCB3aWxsIGJlXHJcbiAgICogcmVxdWlyZWQgdG8gcmVnZW5lcmF0ZSB0aGUgZmxvYXQgYXJyYXlzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYSxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgayxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHJlbmRlcmVyLFxyXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcclxuICAgICAgICBvcHRpb25zID0gc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMsIHRoaXMub3B0aW9ucyksXHJcbiAgICAgICAgZGVmYXVsdEVkZ2VUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJyksXHJcbiAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJyk7XHJcblxyXG4gICAgLy8gRW1wdHkgZmxvYXQgYXJyYXlzOlxyXG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKVxyXG4gICAgICBkZWxldGUgdGhpcy5ub2RlRmxvYXRBcnJheXNba107XHJcblxyXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKVxyXG4gICAgICBkZWxldGUgdGhpcy5lZGdlRmxvYXRBcnJheXNba107XHJcblxyXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUluZGljZXNBcnJheXMpXHJcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2tdO1xyXG5cclxuICAgIC8vIFNvcnQgZWRnZXMgYW5kIG5vZGVzIHBlciB0eXBlczpcclxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdHlwZSA9IGFbaV0udHlwZSB8fCBkZWZhdWx0RWRnZVR5cGU7XHJcbiAgICAgIGsgPSAodHlwZSAmJiBzaWdtYS53ZWJnbC5lZGdlc1t0eXBlXSkgPyB0eXBlIDogJ2RlZic7XHJcblxyXG4gICAgICBpZiAoIXRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdKVxyXG4gICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdID0ge1xyXG4gICAgICAgICAgZWRnZXM6IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmVkZ2VzLnB1c2goYVtpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChhID0gZ3JhcGgubm9kZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHROb2RlVHlwZTtcclxuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLm5vZGVzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcclxuXHJcbiAgICAgIGlmICghdGhpcy5ub2RlRmxvYXRBcnJheXNba10pXHJcbiAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10gPSB7XHJcbiAgICAgICAgICBub2RlczogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10ubm9kZXMucHVzaChhW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdXNoIGVkZ2VzOlxyXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKSB7XHJcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XHJcbiAgICAgIGEgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcztcclxuXHJcbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXHJcbiAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cclxuICAgICAgICAvLyBKdXN0IGNoZWNrIHRoYXQgdGhlIGVkZ2UgYW5kIGJvdGggaXRzIGV4dHJlbWl0aWVzIGFyZSB2aXNpYmxlOlxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFhW2ldLmhpZGRlbiAmJlxyXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0uc291cmNlKS5oaWRkZW4gJiZcclxuICAgICAgICAgICFncmFwaC5ub2RlcyhhW2ldLnRhcmdldCkuaGlkZGVuXHJcbiAgICAgICAgKVxyXG4gICAgICAgICAgcmVuZGVyZXIuYWRkRWRnZShcclxuICAgICAgICAgICAgYVtpXSxcclxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxyXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXHJcbiAgICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxyXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcclxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NcclxuICAgICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuY29tcHV0ZUluZGljZXMgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXSA9IHJlbmRlcmVyLmNvbXB1dGVJbmRpY2VzKFxyXG4gICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1c2ggbm9kZXM6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcclxuICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcclxuICAgICAgYSA9IHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzO1xyXG5cclxuICAgICAgLy8gQ3JlYXRpbmcgdGhlIG5lY2Vzc2FyeSBhcnJheXNcclxuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxyXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xyXG4gICAgICApO1xyXG5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSlcclxuICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcclxuICAgICAgICAgICAgYS5sZW5ndGggKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBKdXN0IGNoZWNrIHRoYXQgdGhlIGVkZ2UgYW5kIGJvdGggaXRzIGV4dHJlbWl0aWVzIGFyZSB2aXNpYmxlOlxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFhW2ldLmhpZGRlblxyXG4gICAgICAgIClcclxuICAgICAgICAgIHJlbmRlcmVyLmFkZE5vZGUoXHJcbiAgICAgICAgICAgIGFbaV0sXHJcbiAgICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxyXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcclxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NcclxuICAgICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaC4gSXQgYmFzaWNhbGx5IGNhbGxzIGVhY2ggcHJvZ3JhbSAoYW5kXHJcbiAgICogZ2VuZXJhdGUgdGhlbSBpZiB0aGV5IGRvIG5vdCBleGlzdCB5ZXQpIHRvIHJlbmRlciBub2RlcyBhbmQgZWRnZXMsIGJhdGNoZWRcclxuICAgKiBwZXIgcmVuZGVyZXIuXHJcbiAgICpcclxuICAgKiBBcyBpbiB0aGUgY2FudmFzIHJlbmRlcmVyLCBpdCBpcyBwb3NzaWJsZSB0byBkaXNwbGF5IGVkZ2VzLCBub2RlcyBhbmQgLyBvclxyXG4gICAqIGxhYmVscyBpbiBiYXRjaGVzLCB0byBtYWtlIHRoZSB3aG9sZSB0aGluZyB3YXkgbW9yZSBzY2FsYWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgcGFyYW1zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IG9mIG9wdGlvbnMuXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICB2YXIgYSxcclxuICAgICAgICBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgayxcclxuICAgICAgICBvLFxyXG4gICAgICAgIHByb2dyYW0sXHJcbiAgICAgICAgcmVuZGVyZXIsXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxyXG4gICAgICAgIG5vZGVzR2wgPSB0aGlzLmNvbnRleHRzLm5vZGVzLFxyXG4gICAgICAgIGVkZ2VzR2wgPSB0aGlzLmNvbnRleHRzLmVkZ2VzLFxyXG4gICAgICAgIG1hdHJpeCA9IHRoaXMuY2FtZXJhLmdldE1hdHJpeCgpLFxyXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMpLFxyXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXHJcbiAgICAgICAgZHJhd0VkZ2VzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VzJyksXHJcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyk7XHJcblxyXG4gICAgLy8gQ2FsbCB0aGUgcmVzaXplIGZ1bmN0aW9uOlxyXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xyXG5cclxuICAgIC8vIENoZWNrIHRoZSAnaGlkZUVkZ2VzT25Nb3ZlJyBzZXR0aW5nOlxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxyXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcclxuICAgICAgICBkcmF3RWRnZXMgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBDbGVhciBjYW52YXNlczpcclxuICAgIHRoaXMuY2xlYXIoKTtcclxuXHJcbiAgICAvLyBUcmFuc2xhdGUgbWF0cml4IHRvIFt3aWR0aC8yLCBoZWlnaHQvMl06XHJcbiAgICBtYXRyaXggPSBzaWdtYS51dGlscy5tYXRyaWNlcy5tdWx0aXBseShcclxuICAgICAgbWF0cml4LFxyXG4gICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbih0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBLaWxsIHJ1bm5pbmcgam9iczpcclxuICAgIGZvciAoayBpbiB0aGlzLmpvYnMpXHJcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxyXG4gICAgICAgIGNvbnJhZC5raWxsSm9iKGspO1xyXG5cclxuICAgIGlmIChkcmF3RWRnZXMpIHtcclxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2JhdGNoRWRnZXNEcmF3aW5nJykpXHJcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgdmFyIGEsXHJcbiAgICAgICAgICAgICAgayxcclxuICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgIGpvYixcclxuICAgICAgICAgICAgICBhcnIsXHJcbiAgICAgICAgICAgICAgZW5kLFxyXG4gICAgICAgICAgICAgIHN0YXJ0LFxyXG4gICAgICAgICAgICAgIGluZGljZXMsXHJcbiAgICAgICAgICAgICAgcmVuZGVyZXIsXHJcbiAgICAgICAgICAgICAgYmF0Y2hTaXplLFxyXG4gICAgICAgICAgICAgIGN1cnJlbnRQcm9ncmFtO1xyXG5cclxuICAgICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xyXG4gICAgICAgICAgYmF0Y2hTaXplID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnd2ViZ2xFZGdlc0JhdGNoU2l6ZScpO1xyXG4gICAgICAgICAgYSA9IE9iamVjdC5rZXlzKHRoaXMuZWRnZUZsb2F0QXJyYXlzKTtcclxuXHJcbiAgICAgICAgICBpZiAoIWEubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNbYVtpXV07XHJcbiAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcclxuICAgICAgICAgIGluZGljZXMgPSB0aGlzLmVkZ2VJbmRpY2VzQXJyYXlzW2FbaV1dO1xyXG4gICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxyXG4gICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBqb2IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSlcclxuICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSA9IHJlbmRlcmVyLmluaXRQcm9ncmFtKGVkZ2VzR2wpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dKTtcclxuICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXHJcbiAgICAgICAgICAgICAgICBlZGdlc0dsLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0sXHJcbiAgICAgICAgICAgICAgICBhcnIsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxyXG4gICAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcclxuICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcclxuICAgICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nXHJcbiAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgY291bnQ6IGVuZCAtIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICBpbmRpY2VzRGF0YTogaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIGVuZCA+PSBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFUyAmJlxyXG4gICAgICAgICAgICAgIGkgPT09IGEubGVuZ3RoIC0gMVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5qb2JzW2lkXTtcclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMpIHtcclxuICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgYXJyID0gdGhpcy5lZGdlRmxvYXRBcnJheXNbYVtpXV0uYXJyYXk7XHJcbiAgICAgICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcclxuICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcclxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcclxuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxyXG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVNcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgdGhpcy5qb2JzW2lkXSA9IGpvYjtcclxuICAgICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcclxuICAgICAgICB9KS5jYWxsKHRoaXMpO1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcclxuICAgICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcclxuICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNba10pXHJcbiAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XHJcblxyXG4gICAgICAgICAgLy8gUmVuZGVyXHJcbiAgICAgICAgICBpZiAodGhpcy5lZGdlRmxvYXRBcnJheXNba10pIHtcclxuICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2tdKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxyXG4gICAgICAgICAgICAgIGVkZ2VzR2wsXHJcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10sXHJcbiAgICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcclxuICAgICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpLFxyXG4gICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IHRoaXMuZWRnZUluZGljZXNBcnJheXNba11cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRyYXdOb2Rlcykge1xyXG4gICAgICAvLyBFbmFibGUgYmxlbmRpbmc6XHJcbiAgICAgIG5vZGVzR2wuYmxlbmRGdW5jKG5vZGVzR2wuU1JDX0FMUEhBLCBub2Rlc0dsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICBub2Rlc0dsLmVuYWJsZShub2Rlc0dsLkJMRU5EKTtcclxuXHJcbiAgICAgIGZvciAoayBpbiB0aGlzLm5vZGVGbG9hdEFycmF5cykge1xyXG4gICAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wubm9kZXNba107XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHByb2dyYW06XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vZGVQcm9ncmFtc1trXSlcclxuICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0obm9kZXNHbCk7XHJcblxyXG4gICAgICAgIC8vIFJlbmRlclxyXG4gICAgICAgIGlmICh0aGlzLm5vZGVGbG9hdEFycmF5c1trXSkge1xyXG4gICAgICAgICAgbm9kZXNHbC51c2VQcm9ncmFtKHRoaXMubm9kZVByb2dyYW1zW2tdKTtcclxuICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcclxuICAgICAgICAgICAgbm9kZXNHbCxcclxuICAgICAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba10sXHJcbiAgICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXHJcbiAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXHJcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXHJcbiAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZHJhd0xhYmVscykge1xyXG4gICAgICBhID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcclxuICAgICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBBcHBseSBjYW1lcmEgdmlldyB0byB0aGVzZSBub2RlczpcclxuICAgICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgbm9kZXM6IGEsXHJcbiAgICAgICAgICBlZGdlczogW10sXHJcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcblxyXG4gICAgICBvID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuc2V0dGluZ3Moe1xyXG4gICAgICAgICAgcHJlZml4OiBzZWxmLmNhbWVyYS5wcmVmaXhcclxuICAgICAgICB9LCBrZXkpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXHJcbiAgICAgICAgICAoXHJcbiAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5sYWJlbHNbXHJcbiAgICAgICAgICAgICAgYVtpXS50eXBlIHx8XHJcbiAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcclxuICAgICAgICAgICAgXSB8fCBzaWdtYS5jYW52YXMubGFiZWxzLmRlZlxyXG4gICAgICAgICAgKShhW2ldLCB0aGlzLmNvbnRleHRzLmxhYmVscywgbyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcclxuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXHJcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgdGFnICAgVGhlIGxhYmVsIHRhZy5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWQgICAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBcImRvbUVsZW1lbnRzXCIpLlxyXG4gICAqIEBwYXJhbSAgez9ib29sZWFufSB3ZWJnbCBXaWxsIGluaXQgdGhlIFdlYkdMIGNvbnRleHQgaWYgdHJ1ZS5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmluaXRET00gPSBmdW5jdGlvbih0YWcsIGlkLCB3ZWJnbCkge1xyXG4gICAgdmFyIGdsLFxyXG4gICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKSxcclxuICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2lnbWEtJyArIGlkKTtcclxuXHJcbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcclxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XHJcblxyXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xyXG4gICAgICB0aGlzLmNvbnRleHRzW2lkXSA9IGRvbS5nZXRDb250ZXh0KHdlYmdsID8gJ2V4cGVyaW1lbnRhbC13ZWJnbCcgOiAnMmQnLCB7XHJcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQWRkaW5nIHdlYmdsIGNvbnRleHQgbG9zcyBsaXN0ZW5lcnNcclxuICAgICAgaWYgKHdlYmdsKSB7XHJcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSwgZmFsc2UpO1xyXG5cclxuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBzZWxmLnJlbmRlcigpO1xyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcclxuICAgKiBkaW1lbnNpb25zLiBUaGVuLCBpdCByZW5kZXJzIHRoZSBncmFwaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICAgIG9sZFdpZHRoID0gdGhpcy53aWR0aCxcclxuICAgICAgICBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodCxcclxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xyXG5cclxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB3O1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgICAgdyA9IHRoaXMud2lkdGg7XHJcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2xkV2lkdGggIT09IHRoaXMud2lkdGggfHwgb2xkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCkge1xyXG4gICAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xyXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcclxuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XHJcbiAgICAgICAgICAvLyBJZiBzaW1wbGUgMkQgY2FudmFzOlxyXG4gICAgICAgICAgaWYgKHRoaXMuY29udGV4dHNba10gJiYgdGhpcy5jb250ZXh0c1trXS5zY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XHJcblxyXG4gICAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcclxuICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgICAgJ3dpZHRoJyxcclxuICAgICAgICAgICAgICAodyAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKSkgKyAncHgnXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKFxyXG4gICAgICAgICAgICAgICdoZWlnaHQnLFxyXG4gICAgICAgICAgICAgIChoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTY2FsZTpcclxuICAgIGZvciAoayBpbiB0aGlzLmNvbnRleHRzKVxyXG4gICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KVxyXG4gICAgICAgIHRoaXMuY29udGV4dHNba10udmlld3BvcnQoXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgMCxcclxuICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnNldHRpbmdzKCd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXHJcbiAgICAgICAgICB0aGlzLmhlaWdodCAqIHRoaXMuc2V0dGluZ3MoJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICovXHJcbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb250ZXh0cy5sYWJlbHMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIHRoaXMuY29udGV4dHMubm9kZXMuY2xlYXIodGhpcy5jb250ZXh0cy5ub2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgIHRoaXMuY29udGV4dHMuZWRnZXMuY2xlYXIodGhpcy5jb250ZXh0cy5lZGdlcy5DT0xPUl9CVUZGRVJfQklUKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICAgIGNhcHRvcjtcclxuXHJcbiAgICAvLyBLaWxsIGNhcHRvcnM6XHJcbiAgICB3aGlsZSAoKGNhcHRvciA9IHRoaXMuY2FwdG9ycy5wb3AoKSkpXHJcbiAgICAgIGNhcHRvci5raWxsKCk7XHJcbiAgICBkZWxldGUgdGhpcy5jYXB0b3JzO1xyXG5cclxuICAgIC8vIEtpbGwgY29udGV4dHM6XHJcbiAgICBmb3IgKGsgaW4gdGhpcy5kb21FbGVtZW50cykge1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1trXSk7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xyXG4gICAgICBkZWxldGUgdGhpcy5jb250ZXh0c1trXTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xyXG4gICAgZGVsZXRlIHRoaXMuY29udGV4dHM7XHJcbiAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLndlYmdsLm5vZGVzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudCBXZWJHTCBub2RlXHJcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBub2RlcyBhcyBkaXNjcy4gSGVyZSBhcmUgdGhlIGF0dHJpYnV0ZXNcclxuICAgKiBhbnkgbm9kZSByZW5kZXJlciBtdXN0IGhhdmU6XHJcbiAgICpcclxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYSBub2RlLlxyXG4gICAqIHtudW1iZXJ9ICAgQVRUUklCVVRFUyAgVGhlIG51bWJlciBvZiBhdHRyaWJ1dGVzIG5lZWRlZCB0byBkcmF3IG9uZSBwb2ludC5cclxuICAgKiB7ZnVuY3Rpb259IGFkZE5vZGUgICAgIEEgZnVuY3Rpb24gdGhhdCBhZGRzIGEgbm9kZSB0byB0aGUgZGF0YSBzdGFjayB0aGF0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgbm9kZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7bnVtYmVyfSAgICAgICBpbmRleCAgIFRoZSBub2RlIGluZGV4IGluIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzIGFycmF5LlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjay5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgb3B0aW9ucyBTb21lIG9wdGlvbnMuXHJcbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgbm9kZXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGludG8gdGhlIGJ1ZmZlci5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7RmxvYXQzMkFycmF5fSBkYXRhICAgIFRoZSBzdGFjayB0byBnaXZlIHRvIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucywgbGlrZSB3aWR0aCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQsIHRoZSBjYW1lcmEgcmF0aW8uXHJcbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgcmVsZXZhbnQgc2hhZGVycyBhbmQgcGFyYW1ldGVycy4gSXQgbXVzdCByZXR1cm5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBuZXdseSBjcmVhdGVkIHByb2dyYW0uXHJcbiAgICpcclxuICAgKiBDaGVjayBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgb3Igc2lnbWEud2ViZ2wubm9kZXMuZmFzdCB0byBzZWUgaG93IGl0XHJcbiAgICogd29ya3MgbW9yZSBwcmVjaXNlbHkuXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5ub2RlcycpO1xyXG5cclxuXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wuZWRnZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIGVkZ2VcclxuICAgKiByZW5kZXJlcnMuIFRoZSBkZWZhdWx0IG9uZSBkcmF3IGVkZ2VzIGFzIGRpcmVjdCBsaW5lcy4gSGVyZSBhcmUgdGhlXHJcbiAgICogYXR0cmlidXRlcyBhbnkgZWRnZSByZW5kZXJlciBtdXN0IGhhdmU6XHJcbiAgICpcclxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYW4gZWRnZS5cclxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXHJcbiAgICoge2Z1bmN0aW9ufSBhZGRFZGdlICAgICBBIGZ1bmN0aW9uIHRoYXQgYWRkcyBhbiBlZGdlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGJ1ZmZlci4gSGVyZSBpcyB0aGUgYXJndW1lbnRzOlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBlZGdlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHNvdXJjZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICB0YXJnZXRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG9wdGlvbnMgU29tZSBvcHRpb25zLlxyXG4gICAqIHtmdW5jdGlvbn0gcmVuZGVyICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBlZmZlY3RpdmVseSByZW5kZXIgdGhlIGVkZ2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtXZWJHTFByb2dyYW19ICAgICAgICAgIHByb2dyYW1cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHBhcmFtcyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc29tZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LCB0aGUgY2FtZXJhIHJhdGlvLlxyXG4gICAqIHtmdW5jdGlvbn0gaW5pdFByb2dyYW0gVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBpbml0aWF0ZSB0aGUgcHJvZ3JhbSwgd2l0aFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0aGUgbmV3bHkgY3JlYXRlZCBwcm9ncmFtLlxyXG4gICAqXHJcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wuZWRnZXMuZGVmIG9yIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgdG8gc2VlIGhvdyBpdFxyXG4gICAqIHdvcmtzIG1vcmUgcHJlY2lzZWx5LlxyXG4gICAqL1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcclxuXHJcblxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLmNhbnZhcy5sYWJlbHNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50XHJcbiAgICogbGFiZWwgcmVuZGVyZXJzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXIuIFNpbmNlIGRpc3BsYXlpbmcgdGV4dHMgaW4gV2ViR0wgaXNcclxuICAgKiBkZWZpbml0ZWx5IHBhaW5mdWwgYW5kIHNpbmNlIHRoZXJlIGEgd2F5IGxlc3MgbGFiZWxzIHRvIGRpc3BsYXkgdGhhbiBub2Rlc1xyXG4gICAqIG9yIGVkZ2VzLCB0aGUgZGVmYXVsdCByZW5kZXJlciBzaW1wbHkgcmVuZGVycyB0aGVtIGluIGEgY2FudmFzLlxyXG4gICAqXHJcbiAgICogQSBsYWJlbHMgcmVuZGVyZXIgaXMgYSBzaW1wbGUgZnVuY3Rpb24sIHRha2luZyBhcyBhcmd1bWVudHMgdGhlIHJlbGF0ZWRcclxuICAgKiBub2RlLCB0aGUgcmVuZGVyZXIgYW5kIGEgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgaWYgKHR5cGVvZiBjb25yYWQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzdmcgc2lnbWEncyByZW5kZXJlci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuZ3JhcGh9ICAgICAgICAgICAgZ3JhcGggICAgVGhlIGdyYXBoIHRvIHJlbmRlci5cclxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuc3ZnID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXHJcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMuc3ZnOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcclxuICAgICAgdGhyb3cgJ0NvbnRhaW5lciBub3QgZm91bmQuJztcclxuXHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGEsXHJcbiAgICAgICAgZm4sXHJcbiAgICAgICAgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcclxuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcclxuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHtcclxuICAgICAgZ3JhcGg6IG51bGwsXHJcbiAgICAgIGdyb3Vwczoge30sXHJcbiAgICAgIG5vZGVzOiB7fSxcclxuICAgICAgZWRnZXM6IHt9LFxyXG4gICAgICBsYWJlbHM6IHt9LFxyXG4gICAgICBlZGdlbGFiZWxzOiB7fSxcclxuICAgICAgaG92ZXJzOiB7fVxyXG4gICAgfTtcclxuICAgIHRoaXMubWVhc3VyZW1lbnRDYW52YXMgPSBudWxsO1xyXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcclxuICAgIHRoaXMuc2V0dGluZ3MgPSAoXHJcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xyXG4gICAgICApID9cclxuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxyXG4gICAgICAgIHNldHRpbmdzO1xyXG5cclxuICAgIC8vIElzIHRoZSByZW5kZXJlciBtZWFudCB0byBiZSBmcmVlc3R5bGU/XHJcbiAgICB0aGlzLnNldHRpbmdzKCdmcmVlU3R5bGUnLCAhIXRoaXMub3B0aW9ucy5mcmVlU3R5bGUpO1xyXG5cclxuICAgIC8vIFNWRyB4bWxuc1xyXG4gICAgdGhpcy5zZXR0aW5ncygneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcclxuXHJcbiAgICAvLyBJbmRleGVzOlxyXG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XHJcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XHJcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gJ3JlbmRlcmVyJyArIHNpZ21hLnV0aWxzLmlkKCkgKyAnOic7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzXHJcbiAgICB0aGlzLmluaXRET00oJ3N2ZycpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcclxuICAgIHRoaXMuY2FwdG9ycyA9IFtdO1xyXG4gICAgYSA9IHRoaXMub3B0aW9ucy5jYXB0b3JzIHx8IFtzaWdtYS5jYXB0b3JzLm1vdXNlLCBzaWdtYS5jYXB0b3JzLnRvdWNoXTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBmbiA9IHR5cGVvZiBhW2ldID09PSAnZnVuY3Rpb24nID8gYVtpXSA6IHNpZ21hLmNhcHRvcnNbYVtpXV07XHJcbiAgICAgIHRoaXMuY2FwdG9ycy5wdXNoKFxyXG4gICAgICAgIG5ldyBmbihcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGgsXHJcbiAgICAgICAgICB0aGlzLmNhbWVyYSxcclxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmluZCByZXNpemU6XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNlbGYucmVzaXplKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxyXG4gICAgLy8gVE9ETzoga2VlcCBhbiBvcHRpb24gdG8gb3ZlcnJpZGUgdGhlIERPTSBldmVudHM/XHJcbiAgICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMuY2FsbCh0aGlzLCB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoKTtcclxuICAgIHRoaXMuYmluZEhvdmVycyh0aGlzLm9wdGlvbnMucHJlZml4KTtcclxuXHJcbiAgICAvLyBSZXNpemVcclxuICAgIHRoaXMucmVzaXplKGZhbHNlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaCBvbiB0aGUgc3ZnIHNjZW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICAgb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCBvZiBvcHRpb25zLlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5zdmd9ICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnYmVmb3JlUmVuZGVyJyk7XHJcblxyXG4gICAgdmFyIGEsXHJcbiAgICAgICAgaSxcclxuICAgICAgICBrLFxyXG4gICAgICAgIGUsXHJcbiAgICAgICAgbCxcclxuICAgICAgICBvLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgZWRnZXMsXHJcbiAgICAgICAgcmVuZGVyZXJzLFxyXG4gICAgICAgIHN1YnJlbmRlcmVycyxcclxuICAgICAgICBpbmRleCA9IHt9LFxyXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcclxuICAgICAgICBub2RlcyA9IHRoaXMuZ3JhcGgubm9kZXMsXHJcbiAgICAgICAgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeCB8fCAnJyxcclxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcclxuICAgICAgICBkcmF3Tm9kZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3Tm9kZXMnKSxcclxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxyXG4gICAgICAgIGRyYXdFZGdlTGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VMYWJlbHMnKSxcclxuICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKSxcclxuICAgICAgICBlbWJlZFNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucywge1xyXG4gICAgICAgICAgcHJlZml4OiB0aGlzLm9wdGlvbnMucHJlZml4LFxyXG4gICAgICAgICAgZm9yY2VMYWJlbHM6IHRoaXMub3B0aW9ucy5mb3JjZUxhYmVsc1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vIENoZWNrIHRoZSAnaGlkZUVkZ2VzT25Nb3ZlJyBzZXR0aW5nOlxyXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxyXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcclxuICAgICAgICBkcmF3RWRnZXMgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcclxuICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxyXG4gICAgICB7XHJcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIEhpZGluZyBldmVyeXRoaW5nXHJcbiAgICAvLyBUT0RPOiBmaW5kIGEgbW9yZSBzZW5zaWJsZSB3YXkgdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvblxyXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5ub2Rlcyk7XHJcbiAgICB0aGlzLmhpZGVET01FbGVtZW50cyh0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzKTtcclxuICAgIHRoaXMuaGlkZURPTUVsZW1lbnRzKHRoaXMuZG9tRWxlbWVudHMubGFiZWxzKTtcclxuICAgIHRoaXMuaGlkZURPTUVsZW1lbnRzKHRoaXMuZG9tRWxlbWVudHMuZWRnZWxhYmVscyk7XHJcblxyXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuXHJcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcclxuICAgIHRoaXMubm9kZXNPblNjcmVlbiA9IHRoaXMuY2FtZXJhLnF1YWR0cmVlLmFyZWEoXHJcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcclxuICAgICk7XHJcblxyXG4gICAgLy8gTm9kZSBpbmRleFxyXG4gICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XHJcblxyXG4gICAgLy8gRmluZCB3aGljaCBlZGdlcyBhcmUgb24gc2NyZWVuXHJcbiAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIG8gPSBhW2ldO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKGluZGV4W28uc291cmNlXSB8fCBpbmRleFtvLnRhcmdldF0pICYmXHJcbiAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcclxuICAgICAgKVxyXG4gICAgICAgIHRoaXMuZWRnZXNPblNjcmVlbi5wdXNoKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXkgbm9kZXNcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tXHJcbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcubm9kZXM7XHJcbiAgICBzdWJyZW5kZXJlcnMgPSBzaWdtYS5zdmcubGFiZWxzO1xyXG5cclxuICAgIC8vLS0gRmlyc3Qgd2UgY3JlYXRlIHRoZSBub2RlcyB3aGljaCBhcmUgbm90IGFscmVhZHkgY3JlYXRlZFxyXG4gICAgaWYgKGRyYXdOb2RlcylcclxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFhW2ldLmhpZGRlbiAmJiAhdGhpcy5kb21FbGVtZW50cy5ub2Rlc1thW2ldLmlkXSkge1xyXG5cclxuICAgICAgICAgIC8vIE5vZGVcclxuICAgICAgICAgIGUgPSAocmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgcmVuZGVyZXJzLmRlZikuY3JlYXRlKFxyXG4gICAgICAgICAgICBhW2ldLFxyXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0gPSBlO1xyXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoZSk7XHJcblxyXG4gICAgICAgICAgLy8gTGFiZWxcclxuICAgICAgICAgIGlmIChkcmF3TGFiZWxzKSB7XHJcbiAgICAgICAgICAgIGUgPSAoc3VicmVuZGVyZXJzW2FbaV0udHlwZV0gfHwgc3VicmVuZGVyZXJzLmRlZikuY3JlYXRlKFxyXG4gICAgICAgICAgICAgIGFbaV0sXHJcbiAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5sYWJlbHNbYVtpXS5pZF0gPSBlO1xyXG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5sYWJlbHMuYXBwZW5kQ2hpbGQoZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBub2Rlc1xyXG4gICAgaWYgKGRyYXdOb2RlcylcclxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblxyXG4gICAgICAgIGlmIChhW2ldLmhpZGRlbilcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAvLyBOb2RlXHJcbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcclxuICAgICAgICAgIGFbaV0sXHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm5vZGVzW2FbaV0uaWRdLFxyXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIExhYmVsXHJcbiAgICAgICAgaWYgKGRyYXdMYWJlbHMpIHtcclxuICAgICAgICAgIChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS51cGRhdGUoXHJcbiAgICAgICAgICAgIGFbaV0sXHJcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdLFxyXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIC8vIERpc3BsYXkgZWRnZXNcclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tXHJcbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcuZWRnZXM7XHJcbiAgICBzdWJyZW5kZXJlcnMgPSBzaWdtYS5zdmcuZWRnZXMubGFiZWxzO1xyXG5cclxuICAgIC8vLS0gRmlyc3Qgd2UgY3JlYXRlIHRoZSBlZGdlcyB3aGljaCBhcmUgbm90IGFscmVhZHkgY3JlYXRlZFxyXG4gICAgaWYgKGRyYXdFZGdlcylcclxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvbUVsZW1lbnRzLmVkZ2VzW2FbaV0uaWRdKSB7XHJcbiAgICAgICAgICBzb3VyY2UgPSBub2RlcyhhW2ldLnNvdXJjZSk7XHJcbiAgICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XHJcblxyXG4gICAgICAgICAgZSA9IChyZW5kZXJlcnNbYVtpXS50eXBlXSB8fFxyXG4gICAgICAgICAgICByZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxyXG4gICAgICAgICAgICByZW5kZXJlcnMuZGVmXHJcbiAgICAgICAgICApLmNyZWF0ZShcclxuICAgICAgICAgICAgYVtpXSxcclxuICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSA9IGU7XHJcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5lZGdlcy5hcHBlbmRDaGlsZChlKTtcclxuXHJcbiAgICAgICAgICAvLyBMYWJlbFxyXG4gICAgICAgICAgaWYgKGRyYXdFZGdlTGFiZWxzKSB7XHJcblxyXG4gICAgICAgICAgICBlID0gKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8XHJcbiAgICAgICAgICAgICAgc3VicmVuZGVyZXJzW2RlZmF1bHRFZGdlVHlwZV0gIHx8XHJcbiAgICAgICAgICAgICAgc3VicmVuZGVyZXJzLmRlZlxyXG4gICAgICAgICAgICApLmNyZWF0ZShcclxuICAgICAgICAgICAgICBhW2ldLFxyXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5lZGdlbGFiZWxzW2FbaV0uaWRdID0gZTtcclxuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHMuZWRnZWxhYmVscy5hcHBlbmRDaGlsZChlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBlZGdlc1xyXG4gICAgaWYgKGRyYXdFZGdlcylcclxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xyXG4gICAgICAgIHRhcmdldCA9IG5vZGVzKGFbaV0udGFyZ2V0KTtcclxuXHJcbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8XHJcbiAgICAgICAgICByZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxyXG4gICAgICAgICAgcmVuZGVyZXJzLmRlZlxyXG4gICAgICAgICkudXBkYXRlKFxyXG4gICAgICAgICAgYVtpXSxcclxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0sXHJcbiAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gTGFiZWxcclxuICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcclxuICAgICAgICAgIChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fFxyXG4gICAgICAgICAgICBzdWJyZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxyXG4gICAgICAgICAgICBzdWJyZW5kZXJlcnMuZGVmXHJcbiAgICAgICAgICApLnVwZGF0ZShcclxuICAgICAgICAgICAgYVtpXSxcclxuICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZWxhYmVsc1thW2ldLmlkXSxcclxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICB9XHJcblxyXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcclxuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXHJcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgIFRoZSBpZCBvZiB0aGUgZWxlbWVudCAodG8gc3RvcmUgaXQgaW4gXCJkb21FbGVtZW50c1wiKS5cclxuICAgKi9cclxuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnKSB7XHJcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMuc2V0dGluZ3MoJ3htbG5zJyksIHRhZyksXHJcbiAgICAgICAgYyA9IHRoaXMuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JyksXHJcbiAgICAgICAgZyxcclxuICAgICAgICBsLFxyXG4gICAgICAgIGk7XHJcblxyXG4gICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctc3ZnJyk7XHJcblxyXG4gICAgLy8gU2V0dGluZyBTVkcgbmFtZXNwYWNlXHJcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxucycsIHRoaXMuc2V0dGluZ3MoJ3htbG5zJykpO1xyXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xyXG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsICcxLjEnKTtcclxuXHJcbiAgICAvLyBDcmVhdGluZyB0aGUgbWVhc3VyZW1lbnQgY2FudmFzXHJcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGMgKyAnLW1lYXN1cmVtZW50LWNhbnZhcycpO1xyXG5cclxuICAgIC8vIEFwcGVuZGluZyBlbGVtZW50c1xyXG4gICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCA9IHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XHJcblxyXG4gICAgLy8gQ3JlYXRpbmcgZ3JvdXBzXHJcbiAgICB2YXIgZ3JvdXBzID0gWydlZGdlcycsICdub2RlcycsICdlZGdlbGFiZWxzJywgJ2xhYmVscycsICdob3ZlcnMnXTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgJ2cnKTtcclxuXHJcbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2lkJywgYyArICctZ3JvdXAtJyArIGdyb3Vwc1tpXSk7XHJcbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgYyArICctZ3JvdXAnKTtcclxuXHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzW2dyb3Vwc1tpXV0gPVxyXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguYXBwZW5kQ2hpbGQoZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXBwZW5kaW5nIG1lYXN1cmVtZW50IGNhbnZhc1xyXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcclxuICAgIHRoaXMubWVhc3VyZW1lbnRDYW52YXMgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBoaWRlcyBhIGJhdGNoIG9mIFNWRyBET00gZWxlbWVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHthcnJheX0gICAgICAgICAgICAgICAgICBlbGVtZW50cyAgQW4gYXJyYXkgb2YgZWxlbWVudHMgdG8gaGlkZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICByZW5kZXJlciAgVGhlIHJlbmRlcmVyIHRvIHVzZS5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmhpZGVET01FbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XHJcbiAgICB2YXIgbyxcclxuICAgICAgICBpO1xyXG5cclxuICAgIGZvciAoaSBpbiBlbGVtZW50cykge1xyXG4gICAgICBvID0gZWxlbWVudHNbaV07XHJcbiAgICAgIHNpZ21hLnN2Zy51dGlscy5oaWRlKG8pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGJpbmRzIHRoZSBob3ZlciBldmVudHMgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcmVmaXggVGhlIHJlbmRlcmVyIHByZWZpeC5cclxuICAgKi9cclxuICAvLyBUT0RPOiBhZGQgb3B0aW9uIGFib3V0IHdoZXRoZXIgdG8gZGlzcGxheSBob3ZlcnMgb3Igbm90XHJcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuYmluZEhvdmVycyA9IGZ1bmN0aW9uKHByZWZpeCkge1xyXG4gICAgdmFyIHJlbmRlcmVycyA9IHNpZ21hLnN2Zy5ob3ZlcnMsXHJcbiAgICAgICAgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaG92ZXJlZE5vZGU7XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlSG92ZXJzKGUpIHtcclxuICAgICAgdmFyIG5vZGUsXHJcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xyXG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKGUuZGF0YS5lbnRlci5ub2Rlcy5sZW5ndGggPiAwKSB7IC8vIG92ZXJcclxuICAgICAgICBub2RlID0gZS5kYXRhLmVudGVyLm5vZGVzWzBdO1xyXG4gICAgICAgIHZhciBob3ZlciA9IChyZW5kZXJlcnNbbm9kZS50eXBlXSB8fCByZW5kZXJlcnMuZGVmKS5jcmVhdGUoXHJcbiAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXSxcclxuICAgICAgICAgIHNlbGYubWVhc3VyZW1lbnRDYW52YXMsXHJcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF0gPSBob3ZlcjtcclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXHJcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLmFwcGVuZENoaWxkKGhvdmVyKTtcclxuICAgICAgICBob3ZlcmVkTm9kZSA9IG5vZGU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmxlYXZlLm5vZGVzLmxlbmd0aCA+IDApIHsgLy8gb3V0XHJcbiAgICAgICAgbm9kZSA9IGUuZGF0YS5sZWF2ZS5ub2Rlc1swXTtcclxuXHJcbiAgICAgICAgLy8gRGVsZXRpbmcgZWxlbWVudFxyXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcclxuICAgICAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW25vZGUuaWRdXHJcbiAgICAgICAgKTtcclxuICAgICAgICBob3ZlcmVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgZGVsZXRlIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW25vZGUuaWRdO1xyXG5cclxuICAgICAgICAvLyBSZWluc3RhdGVcclxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ub2Rlcy5hcHBlbmRDaGlsZChcclxuICAgICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbbm9kZS5pZF1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT1BUSU1JWkU6IHBlcmZvcm0gYSByZWFsIHVwZGF0ZSByYXRoZXIgdGhhbiBhIGRlbGV0aW9uXHJcbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcbiAgICAgIGlmICghaG92ZXJlZE5vZGUpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XHJcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnQgYmVmb3JlIHVwZGF0ZVxyXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMucmVtb3ZlQ2hpbGQoXHJcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdXHJcbiAgICAgICk7XHJcbiAgICAgIGRlbGV0ZSBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF07XHJcblxyXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW2hvdmVyZWROb2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcclxuICAgICAgICBob3ZlcmVkTm9kZSxcclxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLm5vZGVzW2hvdmVyZWROb2RlLmlkXSxcclxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxyXG4gICAgICAgIGVtYmVkU2V0dGluZ3NcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuaG92ZXJzW2hvdmVyZWROb2RlLmlkXSA9IGhvdmVyO1xyXG5cclxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXHJcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5hcHBlbmRDaGlsZChob3Zlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmluZGluZyBldmVudHNcclxuICAgIHRoaXMuYmluZCgnaG92ZXJzJywgdXBkYXRlSG92ZXJzKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgb24gcmVuZGVyXHJcbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIHVwZGF0ZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmVzaXplcyBlYWNoIERPTSBlbGVtZW50cyBpbiB0aGUgY29udGFpbmVyIGFuZCBzdG9yZXMgdGhlIG5ld1xyXG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7P251bWJlcn0gICAgICAgICAgICAgICAgd2lkdGggIFRoZSBuZXcgd2lkdGggb2YgdGhlIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgICBoZWlnaHQgVGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lci5cclxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAqL1xyXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcclxuICAgIHZhciBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXHJcbiAgICAgICAgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy53aWR0aCA9IHc7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcclxuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcclxuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xyXG4gICAqIG9iamVjdHMuIFdoZW4gYW4gZWxlbWVudCBpcyBkcmF3biwgaXRzIHR5cGUgd2lsbCBiZSBjaGVja2VkIGFuZCBpZiBhXHJcbiAgICogcmVuZGVyZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkLiBJZiBub3QgZm91bmQsIHRoZVxyXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICpcclxuICAgKiBUaGV5IGFyZSBzdG9yZWQgaW4gZGlmZmVyZW50IGZpbGVzLCBpbiB0aGUgXCIuL3N2Z1wiIGZvbGRlci5cclxuICAgKi9cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5ub2RlcycpO1xyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubGFiZWxzJyk7XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZWxhYmVscycpO1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbihnbG9iYWwpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcclxuXHJcbiAgLy8gQ29weSB0aGUgZ29vZCByZW5kZXJlcjpcclxuICBzaWdtYS5yZW5kZXJlcnMuZGVmID0gc2lnbWEudXRpbHMuaXNXZWJHTFN1cHBvcnRlZCgpID9cclxuICAgIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA6XHJcbiAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzO1xyXG59KSh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgYXMgZGlzY3MsIHNoYXBlZCBpbiB0cmlhbmdsZXMgd2l0aFxyXG4gICAqIHRoZSBnbC5UUklBTkdMRVMgZGlzcGxheSBtb2RlLiBTbywgdG8gYmUgbW9yZSBwcmVjaXNlLCB0byBkcmF3IG9uZSBub2RlLFxyXG4gICAqIGl0IHdpbGwgc3RvcmUgdGhyZWUgdGltZXMgdGhlIGNlbnRlciBvZiBub2RlLCB3aXRoIHRoZSBjb2xvciBhbmQgdGhlIHNpemUsXHJcbiAgICogYW5kIGFuIGFuZ2xlIGluZGljYXRpbmcgd2hpY2ggXCJjb3JuZXJcIiBvZiB0aGUgdHJpYW5nbGUgdG8gZHJhdy5cclxuICAgKlxyXG4gICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZG9lcyBub3QgZGVhbCB3aXRoIGFudGktYWxpYXNpbmcsIHNvIG1ha2Ugc3VyZSB0aGF0XHJcbiAgICogeW91IGRlYWwgd2l0aCBpdCBzb21ld2hlcmUgZWxzZSBpbiB0aGUgY29kZSAoYnkgZGVmYXVsdCwgdGhlIFdlYkdMXHJcbiAgICogcmVuZGVyZXIgd2lsbCBvdmVyc2FtcGxlIHRoZSByZW5kZXJpbmcgdGhyb3VnaCB0aGUgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpb1xyXG4gICAqIHZhbHVlKS5cclxuICAgKi9cclxuICBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgPSB7XHJcbiAgICBQT0lOVFM6IDMsXHJcbiAgICBBVFRSSUJVVEVTOiA1LFxyXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgY29sb3IgPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKFxyXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDA7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuICAgICAgZGF0YVtpKytdID0gMiAqIE1hdGguUEkgLyAzO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAneCddO1xyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDQgKiBNYXRoLlBJIC8gMztcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgdmFyIGJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxyXG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyksXHJcbiAgICAgICAgICBzaXplTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXHJcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcclxuICAgICAgICAgIGFuZ2xlTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9hbmdsZScpLFxyXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcclxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxyXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxyXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xyXG5cclxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcclxuXHJcbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihcclxuICAgICAgICByYXRpb0xvY2F0aW9uLFxyXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxyXG4gICAgICApO1xyXG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcclxuXHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYW5nbGVMb2NhdGlvbik7XHJcblxyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICAgIHBvc2l0aW9uTG9jYXRpb24sXHJcbiAgICAgICAgMixcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICAgIHNpemVMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICA4XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgY29sb3JMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAxMlxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxyXG4gICAgICAgIGFuZ2xlTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMTZcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGdsLmRyYXdBcnJheXMoXHJcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxyXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxyXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XHJcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcclxuICAgICAgICAgIHByb2dyYW07XHJcblxyXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2NvbG9yOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7JyxcclxuXHJcbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgY2VudGVyOycsXHJcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxyXG4gICAgICAgICAgICAncmFkaXVzID0gYV9zaXplICogdV9yYXRpbzsnLFxyXG5cclxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcclxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eTsnLFxyXG4gICAgICAgICAgICAvLyAnY2VudGVyID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXHJcbiAgICAgICAgICAgICdjZW50ZXIgPSBwb3NpdGlvbiAqIHVfc2NhbGU7JyxcclxuICAgICAgICAgICAgJ2NlbnRlciA9IHZlYzIoY2VudGVyLngsIHVfc2NhbGUgKiB1X3Jlc29sdXRpb24ueSAtIGNlbnRlci55KTsnLFxyXG5cclxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gcG9zaXRpb24gKycsXHJcbiAgICAgICAgICAgICAgJzIuMCAqIHJhZGl1cyAqIHZlYzIoY29zKGFfYW5nbGUpLCBzaW4oYV9hbmdsZSkpOycsXHJcbiAgICAgICAgICAgICdwb3NpdGlvbiA9IChwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKTsnLFxyXG5cclxuICAgICAgICAgICAgJ3JhZGl1cyA9IHJhZGl1cyAqIHVfc2NhbGU7JyxcclxuXHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpOycsXHJcblxyXG4gICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb2xvcjpcclxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXHJcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmcgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxyXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxyXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxyXG4gICAgICAgICAgJ30nXHJcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcclxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXHJcbiAgICAgICAgZ2wsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcblxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcclxuICAgICAgICAgICd2YXJ5aW5nIGZsb2F0IHJhZGl1czsnLFxyXG5cclxuICAgICAgICAgICd2b2lkIG1haW4odm9pZCkgeycsXHJcbiAgICAgICAgICAgICd2ZWM0IGNvbG9yMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX0ZyYWdDb29yZC54eSAtIGNlbnRlcjsnLFxyXG4gICAgICAgICAgICAnZmxvYXQgZGlmZiA9IHJhZGl1cyAtIHNxcnQobS54ICogbS54ICsgbS55ICogbS55KTsnLFxyXG5cclxuICAgICAgICAgICAgLy8gSGVyZSBpcyBob3cgd2UgZHJhdyBhIGRpc2MgaW5zdGVhZCBvZiBhIHNxdWFyZTpcclxuICAgICAgICAgICAgJ2lmIChkaWZmID4gMC4wKScsXHJcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXHJcbiAgICAgICAgICAgICdlbHNlJyxcclxuICAgICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IwOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xyXG5cclxuICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgaW4gdGhlIGZhc3Rlc3Qgd2F5OiBOb2RlcyBhcmUgYmFzaWNcclxuICAgKiBzcXVhcmVzLCBkcmF3biB0aHJvdWdoIHRoZSBnbC5QT0lOVFMgZHJhd2luZyBtZXRob2QuIFRoZSBzaXplIG9mIHRoZSBub2Rlc1xyXG4gICAqIGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBcImdsX1BvaW50U2l6ZVwiIHZhbHVlIGluIHRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAqXHJcbiAgICogSXQgaXMgdGhlIGZhc3Rlc3Qgbm9kZSByZW5kZXJlciBoZXJlIHNpbmNlIHRoZSBidWZmZXIganVzdCB0YWtlcyBvbmUgbGluZVxyXG4gICAqIHRvIGRyYXcgZWFjaCBub2RlICh3aXRoIGF0dHJpYnV0ZXMgXCJ4XCIsIFwieVwiLCBcInNpemVcIiBhbmQgXCJjb2xvclwiKS5cclxuICAgKlxyXG4gICAqIE5ldmVydGhlbGVzcywgdGhpcyBtZXRob2QgaGFzIHNvbWUgcHJvYmxlbXMsIGVzcGVjaWFsbHkgZHVlIHRvIHNvbWUgaXNzdWVzXHJcbiAgICogd2l0aCB0aGUgZ2wuUE9JTlRTOlxyXG4gICAqICAtIEZpcnN0LCBpZiB0aGUgY2VudGVyIG9mIGEgbm9kZSBpcyBvdXRzaWRlIHRoZSBzY2VuZSwgdGhlIHBvaW50IHdpbGwgbm90XHJcbiAgICogICAgYmUgZHJhd24sIGV2ZW4gaWYgaXQgc2hvdWxkIGJlIHBhcnRseSBvbiBzY3JlZW4uXHJcbiAgICogIC0gSSB0cmllZCBhcHBseWluZyBhIGZyYWdtZW50IHNoYWRlciBzaW1pbGFyIHRvIHRoZSBvbmUgaW4gdGhlIGRlZmF1bHRcclxuICAgKiAgICBub2RlIHJlbmRlcmVyIHRvIGRpc3BsYXkgdGhlbSBhcyBkaXNjcywgYnV0IGl0IGRpZCBub3Qgd29yayBmaW5lIG9uXHJcbiAgICogICAgc29tZSBjb21wdXRlcnMgc2V0dGluZ3MsIGZpbGxpbmcgdGhlIGRpc2NzIHdpdGggd2VpcmQgZ3JhZGllbnRzIG5vdFxyXG4gICAqICAgIGRlcGVuZGluZyBvbiB0aGUgYWN0dWFsIGNvbG9yLlxyXG4gICAqL1xyXG4gIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgPSB7XHJcbiAgICBQT0lOVFM6IDEsXHJcbiAgICBBVFRSSUJVVEVTOiA0LFxyXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xyXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XHJcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcclxuICAgICAgZGF0YVtpKytdID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddO1xyXG4gICAgICBkYXRhW2krK10gPSBzaWdtYS51dGlscy5mbG9hdENvbG9yKFxyXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxyXG4gICAgICApO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xyXG4gICAgICB2YXIgYnVmZmVyO1xyXG5cclxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XHJcbiAgICAgIHZhciBwb3NpdGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcclxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3NpemUnKSxcclxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxyXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcclxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxyXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxyXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xyXG5cclxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcclxuXHJcbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihcclxuICAgICAgICByYXRpb0xvY2F0aW9uLFxyXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxyXG4gICAgICApO1xyXG4gICAgICBnbC51bmlmb3JtMWYoc2NhbGVMb2NhdGlvbiwgcGFyYW1zLnNjYWxpbmdSYXRpbyk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcclxuXHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcclxuXHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcclxuICAgICAgICAyLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAwXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoXHJcbiAgICAgICAgc2l6ZUxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDhcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcclxuICAgICAgICBjb2xvckxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDEyXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBnbC5kcmF3QXJyYXlzKFxyXG4gICAgICAgIGdsLlBPSU5UUyxcclxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcclxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxyXG4gICAgICApO1xyXG4gICAgfSxcclxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xyXG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxyXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXHJcbiAgICAgICAgICBwcm9ncmFtO1xyXG5cclxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcclxuICAgICAgICBnbCxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXHJcblxyXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcclxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxyXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHkgLycsXHJcbiAgICAgICAgICAgICAgICAndV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpLCcsXHJcbiAgICAgICAgICAgICAgJzAsJyxcclxuICAgICAgICAgICAgICAnMScsXHJcbiAgICAgICAgICAgICcpOycsXHJcblxyXG4gICAgICAgICAgICAvLyBNdWx0aXBseSB0aGUgcG9pbnQgc2l6ZSB0d2ljZTpcclxuICAgICAgICAgICAgLy8gIC0geCBTQ0FMSU5HX1JBVElPIHRvIGNvcnJlY3QgdGhlIGNhbnZhcyBzY2FsaW5nXHJcbiAgICAgICAgICAgIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxyXG4gICAgICAgICAgICAnZ2xfUG9pbnRTaXplID0gYV9zaXplICogdV9yYXRpbyAqIHVfc2NhbGUgKiAyLjA7JyxcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxyXG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxyXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXHJcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcclxuICAgICAgICBnbCxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcclxuICAgICAgICAgICAgJ2Zsb2F0IGJvcmRlciA9IDAuMDE7JyxcclxuICAgICAgICAgICAgJ2Zsb2F0IHJhZGl1cyA9IDAuNTsnLFxyXG5cclxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXHJcbiAgICAgICAgICAgICd2ZWMyIG0gPSBnbF9Qb2ludENvb3JkIC0gdmVjMigwLjUsIDAuNSk7JyxcclxuICAgICAgICAgICAgJ2Zsb2F0IGRpc3QgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcclxuXHJcbiAgICAgICAgICAgICdmbG9hdCB0ID0gMC4wOycsXHJcbiAgICAgICAgICAgICdpZiAoZGlzdCA+IGJvcmRlciknLFxyXG4gICAgICAgICAgICAgICd0ID0gMS4wOycsXHJcbiAgICAgICAgICAgICdlbHNlIGlmIChkaXN0ID4gMC4wKScsXHJcbiAgICAgICAgICAgICAgJ3QgPSBkaXN0IC8gYm9yZGVyOycsXHJcblxyXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yMCwgY29sb3IsIHQpOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xyXG5cclxuICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcclxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcclxuICAgKiB0d28gdHJpYW5nbGVzIGZvcm1pbmcgcmVjdGFuZ2xlcywgd2l0aCB0aGUgZ2wuVFJJQU5HTEVTIGRyYXdpbmcgbW9kZS5cclxuICAgKlxyXG4gICAqIEl0IGlzIGV4cGVuc2l2ZSwgc2luY2UgZHJhd2luZyBhIHNpbmdsZSBlZGdlIHJlcXVpcmVzIDYgcG9pbnRzLCBlYWNoXHJcbiAgICogaGF2aW5nIDcgYXR0cmlidXRlcyAoc291cmNlIHBvc2l0aW9uLCB0YXJnZXQgcG9zaXRpb24sIHRoaWNrbmVzcywgY29sb3JcclxuICAgKiBhbmQgYSBmbGFnIGluZGljYXRpbmcgd2hpY2ggdmVydGljZSBvZiB0aGUgcmVjdGFuZ2xlIGl0IGlzKS5cclxuICAgKi9cclxuICBzaWdtYS53ZWJnbC5lZGdlcy5kZWYgPSB7XHJcbiAgICBQT0lOVFM6IDYsXHJcbiAgICBBVFRSSUJVVEVTOiA3LFxyXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcclxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XHJcblxyXG4gICAgICBpZiAoIWNvbG9yKVxyXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XHJcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XHJcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZGF0YSwgcGFyYW1zKSB7XHJcbiAgICAgIHZhciBidWZmZXI7XHJcblxyXG4gICAgICAvLyBEZWZpbmUgYXR0cmlidXRlczpcclxuICAgICAgdmFyIGNvbG9yTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxyXG4gICAgICAgICAgcG9zaXRpb25Mb2NhdGlvbjEgPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjEnKSxcclxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24yID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24yJyksXHJcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RoaWNrbmVzcycpLFxyXG4gICAgICAgICAgbWludXNMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX21pbnVzJyksXHJcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxyXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXHJcbiAgICAgICAgICBtYXRyaXhIYWxmUGlMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGknKSxcclxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4SGFsZlBpTWludXMnKSxcclxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcclxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcclxuXHJcbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihcclxuICAgICAgICByYXRpb0xvY2F0aW9uLFxyXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcclxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xyXG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxyXG4gICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uLFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uKE1hdGguUEkgLyAyLCB0cnVlKVxyXG4gICAgICApO1xyXG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxyXG4gICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24sXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24xKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KG1pbnVzTG9jYXRpb24pO1xyXG5cclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcclxuICAgICAgICAyLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAwXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjIsXHJcbiAgICAgICAgMixcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgOFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaWNrbmVzc0xvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDE2XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAyMFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMjRcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGdsLmRyYXdBcnJheXMoXHJcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxyXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxyXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XHJcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcclxuICAgICAgICAgIHByb2dyYW07XHJcblxyXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uMTsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24yOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdGhpY2tuZXNzOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfbWludXM7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXHJcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcclxuXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBnb29kIHBvaW50OlxyXG4gICAgICAgICAgICAndmVjMiBwb3NpdGlvbiA9IGFfdGhpY2tuZXNzICogdV9yYXRpbyAqJyxcclxuICAgICAgICAgICAgICAnbm9ybWFsaXplKGFfcG9zaXRpb24yIC0gYV9wb3NpdGlvbjEpOycsXHJcblxyXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSBhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcclxuICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGk7JyxcclxuXHJcbiAgICAgICAgICAgICdwb3NpdGlvbiA9IG1hdHJpeCAqIHBvc2l0aW9uICsgYV9wb3NpdGlvbjE7JyxcclxuXHJcbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcclxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEpKS54eSAvJyxcclxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcclxuICAgICAgICAgICAgICAnMCwnLFxyXG4gICAgICAgICAgICAgICcxJyxcclxuICAgICAgICAgICAgJyk7JyxcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxyXG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxyXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXHJcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcclxuICAgICAgICBnbCxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcclxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xyXG5cclxuICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgd2l0aCB0aGUgZ2wuTElORVMgZGlzcGxheVxyXG4gICAqIG1vZGUuIFNpbmNlIHRoaXMgbW9kZSBkb2VzIG5vdCBzdXBwb3J0IHdlbGwgdGhpY2tuZXNzLCBlZGdlcyBhcmUgYWxsIGRyYXduXHJcbiAgICogd2l0aCB0aGUgc2FtZSB0aGlja25lc3MgKDNweCksIGluZGVwZW5kYW50bHkgb2YgdGhlIGVkZ2UgYXR0cmlidXRlcyBvciB0aGVcclxuICAgKiB6b29taW5nIHJhdGlvLlxyXG4gICAqL1xyXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgPSB7XHJcbiAgICBQT0lOVFM6IDIsXHJcbiAgICBBVFRSSUJVVEVTOiAzLFxyXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcclxuICAgICAgICAgIHgxID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHkyID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XHJcblxyXG4gICAgICBpZiAoIWNvbG9yKVxyXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XHJcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XHJcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgdmFyIGJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxyXG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2NvbG9yJyksXHJcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcclxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXHJcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKTtcclxuXHJcbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XHJcblxyXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xyXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XHJcblxyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XHJcblxyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sXHJcbiAgICAgICAgMixcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgOFxyXG4gICAgICApO1xyXG5cclxuICAgICAgZ2wubGluZVdpZHRoKDMpO1xyXG4gICAgICBnbC5kcmF3QXJyYXlzKFxyXG4gICAgICAgIGdsLkxJTkVTLFxyXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxyXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XHJcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXHJcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcclxuICAgICAgICAgIHByb2dyYW07XHJcblxyXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XHJcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcclxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxyXG4gICAgICAgICAgICAgICAgJ3VfcmVzb2x1dGlvbiAqIDIuMCAtIDEuMCkgKiB2ZWMyKDEsIC0xKSwnLFxyXG4gICAgICAgICAgICAgICcwLCcsXHJcbiAgICAgICAgICAgICAgJzEnLFxyXG4gICAgICAgICAgICAnKTsnLFxyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XHJcbiAgICAgICAgICAgICdmbG9hdCBjID0gYV9jb2xvcjsnLFxyXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLnIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsgY29sb3IgLz0gMjU1LjA7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxyXG4gICAgICAgIGdsLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxyXG4gICAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7JyxcclxuICAgICAgICAgICd9J1xyXG4gICAgICAgIF0uam9pbignXFxuJyksXHJcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XHJcblxyXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBhcnJvd3MgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcclxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcclxuICAgKiB0aHJlZSB0cmlhbmdsZXM6IHR3byBmb3JtaW5nIHJlY3RhbmdsZXMsIHdpdGggdGhlIGdsLlRSSUFOR0xFUyBkcmF3aW5nXHJcbiAgICogbW9kZS5cclxuICAgKlxyXG4gICAqIEl0IGlzIGV4cGVuc2l2ZSwgc2luY2UgZHJhd2luZyBhIHNpbmdsZSBlZGdlIHJlcXVpcmVzIDkgcG9pbnRzLCBlYWNoXHJcbiAgICogaGF2aW5nIGEgbG90IG9mIGF0dHJpYnV0ZXMuXHJcbiAgICovXHJcbiAgc2lnbWEud2ViZ2wuZWRnZXMuYXJyb3cgPSB7XHJcbiAgICBQT0lOVFM6IDksXHJcbiAgICBBVFRSSUJVVEVTOiAxMSxcclxuICAgIGFkZEVkZ2U6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBpLCBwcmVmaXgsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXHJcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgeTEgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgdGFyZ2V0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgICAgY29sb3IgPSBlZGdlLmNvbG9yO1xyXG5cclxuICAgICAgaWYgKCFjb2xvcilcclxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzKCdlZGdlQ29sb3InKSkge1xyXG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gTm9ybWFsaXplIGNvbG9yOlxyXG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0geDE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xyXG4gICAgICBkYXRhW2krK10gPSB5MjtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuXHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB3O1xyXG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgLy8gQXJyb3cgaGVhZDpcclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IC0xLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xyXG5cclxuICAgICAgZGF0YVtpKytdID0geDI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xyXG4gICAgICBkYXRhW2krK10gPSB4MTtcclxuICAgICAgZGF0YVtpKytdID0geTE7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHc7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMC4wO1xyXG4gICAgICBkYXRhW2krK10gPSAxLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcclxuICAgICAgZGF0YVtpKytdID0gY29sb3I7XHJcblxyXG4gICAgICBkYXRhW2krK10gPSB4MjtcclxuICAgICAgZGF0YVtpKytdID0geTI7XHJcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xyXG4gICAgICBkYXRhW2krK10gPSB5MTtcclxuICAgICAgZGF0YVtpKytdID0gdztcclxuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSAwLjA7XHJcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcclxuICAgICAgZGF0YVtpKytdID0gMS4wO1xyXG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcclxuICAgICAgdmFyIGJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxyXG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbjEgPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3MxJyksXHJcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczInKSxcclxuICAgICAgICAgIHRoaWNrbmVzc0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXHJcbiAgICAgICAgICB0YXJnZXRTaXplTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90U2l6ZScpLFxyXG4gICAgICAgICAgZGVsYXlMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2RlbGF5JyksXHJcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcclxuICAgICAgICAgIGhlYWRMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2hlYWQnKSxcclxuICAgICAgICAgIGhlYWRQb3NpdGlvbkxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZFBvc2l0aW9uJyksXHJcbiAgICAgICAgICBjb2xvckxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcclxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXHJcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcclxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cclxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxyXG4gICAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxyXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxyXG4gICAgICAgICAgbm9kZVJhdGlvTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfbm9kZVJhdGlvJyksXHJcbiAgICAgICAgICBhcnJvd0hlYWRMb2NhdGlvbiA9XHJcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9hcnJvd0hlYWQnKSxcclxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxyXG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcclxuXHJcbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihcclxuICAgICAgICByYXRpb0xvY2F0aW9uLFxyXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihcclxuICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbixcclxuICAgICAgICBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKSAvXHJcbiAgICAgICAgcGFyYW1zLnJhdGlvXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm0xZihhcnJvd0hlYWRMb2NhdGlvbiwgNS4wKTtcclxuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xyXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KG1hdHJpeExvY2F0aW9uLCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXHJcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oTWF0aC5QSSAvIDIsIHRydWUpXHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYoXHJcbiAgICAgICAgbWF0cml4SGFsZlBpTWludXNMb2NhdGlvbixcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbigtTWF0aC5QSSAvIDIsIHRydWUpXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24yKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpY2tuZXNzTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0YXJnZXRTaXplTG9jYXRpb24pO1xyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShkZWxheUxvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGhlYWRMb2NhdGlvbik7XHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGhlYWRQb3NpdGlvbkxvY2F0aW9uKTtcclxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XHJcblxyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24xLFxyXG4gICAgICAgIDIsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDBcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcclxuICAgICAgICAyLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICA4XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMTZcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0YXJnZXRTaXplTG9jYXRpb24sXHJcbiAgICAgICAgMSxcclxuICAgICAgICBnbC5GTE9BVCxcclxuICAgICAgICBmYWxzZSxcclxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXHJcbiAgICAgICAgMjBcclxuICAgICAgKTtcclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihkZWxheUxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDI0XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAyOFxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICAzMlxyXG4gICAgICApO1xyXG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRQb3NpdGlvbkxvY2F0aW9uLFxyXG4gICAgICAgIDEsXHJcbiAgICAgICAgZ2wuRkxPQVQsXHJcbiAgICAgICAgZmFsc2UsXHJcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG4gICAgICAgIDM2XHJcbiAgICAgICk7XHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcclxuICAgICAgICAxLFxyXG4gICAgICAgIGdsLkZMT0FULFxyXG4gICAgICAgIGZhbHNlLFxyXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuICAgICAgICA0MFxyXG4gICAgICApO1xyXG5cclxuICAgICAgZ2wuZHJhd0FycmF5cyhcclxuICAgICAgICBnbC5UUklBTkdMRVMsXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXHJcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcclxuICAgICAgKTtcclxuICAgIH0sXHJcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcclxuICAgICAgdmFyIHZlcnRleFNoYWRlcixcclxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxyXG4gICAgICAgICAgcHJvZ3JhbTtcclxuXHJcbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXHJcbiAgICAgICAgZ2wsXHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMTsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMjsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RTaXplOycsXHJcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfZGVsYXk7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxyXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX2hlYWQ7JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkUG9zaXRpb247JyxcclxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxyXG5cclxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXHJcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X25vZGVSYXRpbzsnLFxyXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9hcnJvd0hlYWQ7JyxcclxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcclxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGlNaW51czsnLFxyXG5cclxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcclxuXHJcbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XHJcbiAgICAgICAgICAgICd2ZWMyIHBvcyA9IG5vcm1hbGl6ZShhX3BvczIgLSBhX3BvczEpOycsXHJcblxyXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSAoMS4wIC0gYV9oZWFkKSAqJyxcclxuICAgICAgICAgICAgICAnKCcsXHJcbiAgICAgICAgICAgICAgICAnYV9taW51cyAqIHVfbWF0cml4SGFsZlBpTWludXMgKycsXHJcbiAgICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGknLFxyXG4gICAgICAgICAgICAgICcpICsgYV9oZWFkICogKCcsXHJcbiAgICAgICAgICAgICAgICAnYV9oZWFkUG9zaXRpb24gKiB1X21hdHJpeEhhbGZQaU1pbnVzICogMC42ICsnLFxyXG4gICAgICAgICAgICAgICAgJyhhX2hlYWRQb3NpdGlvbiAqIGFfaGVhZFBvc2l0aW9uIC0gMS4wKSAqIG1hdDIoMS4wKScsXHJcbiAgICAgICAgICAgICAgJyk7JyxcclxuXHJcbiAgICAgICAgICAgICdwb3MgPSBhX3BvczEgKyAoJyxcclxuICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggYm9keTpcclxuICAgICAgICAgICAgICAnKDEuMCAtIGFfaGVhZCkgKiBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKiBtYXRyaXggKiBwb3MgKycsXHJcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGhlYWQ6XHJcbiAgICAgICAgICAgICAgJ2FfaGVhZCAqIHVfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvICogbWF0cml4ICogcG9zICsnLFxyXG4gICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBkZWxheTpcclxuICAgICAgICAgICAgICAnYV9kZWxheSAqIHBvcyAqICgnLFxyXG4gICAgICAgICAgICAgICAgJ2FfdFNpemUgLyB1X25vZGVSYXRpbyArJyxcclxuICAgICAgICAgICAgICAgICd1X2Fycm93SGVhZCAqIGFfdGhpY2tuZXNzICogdV9yYXRpbycsXHJcbiAgICAgICAgICAgICAgJyknLFxyXG4gICAgICAgICAgICAnKTsnLFxyXG5cclxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxyXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3MsIDEpKS54eSAvJyxcclxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcclxuICAgICAgICAgICAgICAnMCwnLFxyXG4gICAgICAgICAgICAgICcxJyxcclxuICAgICAgICAgICAgJyk7JyxcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxyXG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcclxuICAgICAgICAgICAgJ2NvbG9yLmIgPSBtb2QoYywgMjU2LjApOyBjID0gZmxvb3IoYyAvIDI1Ni4wKTsnLFxyXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXHJcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXHJcbiAgICAgICAgICAgICdjb2xvci5hID0gMS4wOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLlZFUlRFWF9TSEFERVJcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGZyYWdtZW50U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcclxuICAgICAgICBnbCxcclxuICAgICAgICBbXHJcbiAgICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuXHJcbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXHJcblxyXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcclxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXHJcbiAgICAgICAgICAnfSdcclxuICAgICAgICBdLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxyXG4gICAgICApO1xyXG5cclxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xyXG5cclxuICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmxhYmVscycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGxhYmVsIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgbGFiZWwgb2YgdGhlIG5vZGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSAge29iamVjdD99ICAgICAgICAgICAgICAgICAgaW5mb3MgICAgVGhlIGJhdGNoIGluZm9zLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MsIGluZm9zKSB7XHJcbiAgICB2YXIgZm9udFNpemUsXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcclxuICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnZm9udFN0eWxlJyksXHJcbiAgICAgICAgYm9yZGVyU2l6ZSA9IHNldHRpbmdzKCdub2RlQm9yZGVyU2l6ZScpLFxyXG4gICAgICAgIGxhYmVsV2lkdGgsXHJcbiAgICAgICAgbGFiZWxPZmZzZXRYLFxyXG4gICAgICAgIGxhYmVsT2Zmc2V0WSxcclxuICAgICAgICBhbGlnbm1lbnQgPSBzZXR0aW5ncygnbGFiZWxBbGlnbm1lbnQnKSxcclxuICAgICAgICBtYXhMaW5lTGVuZ3RoID0gc2V0dGluZ3MoJ21heE5vZGVMYWJlbExpbmVMZW5ndGgnKSB8fCAwO1xyXG5cclxuICAgIGlmIChzaXplIDw9IHNldHRpbmdzKCdsYWJlbFRocmVzaG9sZCcpKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgaWYgKCFub2RlLmxhYmVsIHx8IHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcclxuICAgICAgcmV0dXJuO1xyXG5cclxuICAgIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xyXG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcclxuICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xyXG5cclxuICAgIHZhciBuZXdfZm9udCA9IChmb250U3R5bGUgPyBmb250U3R5bGUgKyAnICcgOiAnJykgK1xyXG4gICAgICBmb250U2l6ZSArICdweCAnICtcclxuICAgICAgKG5vZGUuYWN0aXZlID9cclxuICAgICAgICBzZXR0aW5ncygnYWN0aXZlRm9udCcpIHx8IHNldHRpbmdzKCdmb250JykgOlxyXG4gICAgICAgIHNldHRpbmdzKCdmb250JykpO1xyXG5cclxuICAgIGlmIChpbmZvcyAmJiBpbmZvcy5jdHguZm9udCAhPSBuZXdfZm9udCkgeyAvL3VzZSBmb250IHZhbHVlIGNhY2hpbmdcclxuICAgICAgY29udGV4dC5mb250ID0gbmV3X2ZvbnQ7XHJcbiAgICAgIGluZm9zLmN0eC5mb250ID0gbmV3X2ZvbnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LmZvbnQgPSBuZXdfZm9udDtcclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9XHJcbiAgICAgICAgKHNldHRpbmdzKCdsYWJlbENvbG9yJykgPT09ICdub2RlJykgP1xyXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XHJcblxyXG4gICAgbGFiZWxPZmZzZXRYID0gMDtcclxuICAgIGxhYmVsT2Zmc2V0WSA9IGZvbnRTaXplIC8gMztcclxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcblxyXG4gICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcclxuICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICBsYWJlbE9mZnNldFkgPSArIHNpemUgKyA0ICogZm9udFNpemUgLyAzO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XHJcbiAgICAgICAgbGFiZWxPZmZzZXRYID0gLSBzaXplIC0gYm9yZGVyU2l6ZSAtIDM7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgbGFiZWxPZmZzZXRZID0gLSBzaXplIC0gMiAqIGZvbnRTaXplIC8gMztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnaW5zaWRlJzpcclxuICAgICAgICBsYWJlbFdpZHRoID0gc2lnbWEudXRpbHMuY2FudmFzLmdldFRleHRXaWR0aChjb250ZXh0LCBzZXR0aW5ncygnYXBwcm94aW1hdGVMYWJlbFdpZHRoJyksIGZvbnRTaXplLCBub2RlLmxhYmVsKTtcclxuICAgICAgICBpZiAobGFiZWxXaWR0aCA8PSAoc2l6ZSArIGZvbnRTaXplIC8gMykgKiAyKSB7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIC8qIGZhbGxzIHRocm91Z2gqL1xyXG4gICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgIC8qIGZhbGxzIHRocm91Z2gqL1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGxhYmVsT2Zmc2V0WCA9IHNpemUgKyBib3JkZXJTaXplICsgMztcclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyhub2RlLmxhYmVsLCBtYXhMaW5lTGVuZ3RoKSxcclxuICAgICAgICBiYXNlWCA9IG5vZGVbcHJlZml4ICsgJ3gnXSArIGxhYmVsT2Zmc2V0WCxcclxuICAgICAgICBiYXNlWSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgbGFiZWxPZmZzZXRZKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbaV0sIGJhc2VYLCBiYXNlWSArIGkgKiAoZm9udFNpemUgKyAxKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU3BsaXQgYSB0ZXh0IGludG8gc2V2ZXJhbCBsaW5lcy4gRWFjaCBsaW5lIHdvbid0IGJlIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgbWF4aW11bSBsZW5ndGguXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICB0ZXh0ICAgICAgICAgICAgVGV4dCB0byBzcGxpdFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbWF4TGluZUxlbmd0aCAgIE1heGltdW0gbGVuZ3RoIG9mIGEgbGluZS4gQSB2YWx1ZSA8PSAxIHdpbGwgYmUgdHJlYXRlZCBhcyBcImluZmluaXR5XCIuXHJcbiAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59ICAgICAgICAgTGlzdCBvZiBsaW5lc1xyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldExpbmVzKHRleHQsIG1heExpbmVMZW5ndGgpIHtcclxuICAgIGlmIChtYXhMaW5lTGVuZ3RoIDw9IDEpIHtcclxuICAgICAgcmV0dXJuIFt0ZXh0XTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd29yZHMgPSB0ZXh0LnNwbGl0KCcgJyksXHJcbiAgICAgICAgbGluZXMgPSBbXSxcclxuICAgICAgICBsaW5lTGVuZ3RoID0gMCxcclxuICAgICAgICBsaW5lSW5kZXggPSAtMSxcclxuICAgICAgICBsaW5lTGlzdCA9IFtdLFxyXG4gICAgICAgIGxpbmVGdWxsID0gdHJ1ZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGlmIChsaW5lRnVsbCkge1xyXG4gICAgICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggPiBtYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgICB2YXIgcGFydHMgPSBzcGxpdFdvcmQod29yZHNbaV0sIG1heExpbmVMZW5ndGgpO1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFtwYXJ0c1tqXV0pO1xyXG4gICAgICAgICAgICArK2xpbmVJbmRleDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxpbmVMZW5ndGggPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxpbmVzLnB1c2goW3dvcmRzW2ldXHJcbiAgICAgICAgICBdKTtcclxuICAgICAgICAgICsrbGluZUluZGV4O1xyXG4gICAgICAgICAgbGluZUxlbmd0aCA9IHdvcmRzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmVGdWxsID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSBpZiAobGluZUxlbmd0aCArIHdvcmRzW2ldLmxlbmd0aCA8PSBtYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgbGluZXNbbGluZUluZGV4XS5wdXNoKHdvcmRzW2ldKTtcclxuICAgICAgICBsaW5lTGVuZ3RoICs9IHdvcmRzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGluZUZ1bGwgPSB0cnVlO1xyXG4gICAgICAgIC0taTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICBsaW5lTGlzdC5wdXNoKGxpbmVzW2ldLmpvaW4oJyAnKSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGluZUxpc3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTcGxpdCBhIHdvcmQgaW50byBzZXZlcmFsIGxpbmVzICh3aXRoIGEgJy0nIGF0IHRoZSBlbmQgb2YgZWFjaCBsaW5lIGJ1dCB0aGUgbGFzdCkuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdvcmQgICAgICAgV29yZCB0byBzcGxpdFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGggIE1heGltdW0gbGVuZ3RoIG9mIGEgbGluZVxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSAgIExpc3Qgb2YgbGluZXNcclxuICAgKi9cclxuICBmdW5jdGlvbiBzcGxpdFdvcmQod29yZCwgbWF4TGVuZ3RoKSB7XHJcbiAgICB2YXIgcGFydHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmQubGVuZ3RoOyBpICs9IG1heExlbmd0aCAtIDEpIHtcclxuICAgICAgcGFydHMucHVzaCh3b3JkLnN1YnN0cihpLCBtYXhMZW5ndGggLSAxKSArICctJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxhc3RQYXJ0TGVuID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0ubGVuZ3RoO1xyXG4gICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5zdWJzdHIoMCwgbGFzdFBhcnRMZW4gLSAxKSArICcgJztcclxuXHJcbiAgICByZXR1cm4gcGFydHM7XHJcbiAgfVxyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuaG92ZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBiYXNpY2FsbHkgZGlzcGxheSB0aGUgbGFiZWwgd2l0aCBhIGJhY2tncm91bmQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgeCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIHcsXHJcbiAgICAgICAgaCxcclxuICAgICAgICBlLFxyXG4gICAgICAgIGxhYmVsWCxcclxuICAgICAgICBsYWJlbFksXHJcbiAgICAgICAgbGluZXMsXHJcbiAgICAgICAgYmFzZVgsXHJcbiAgICAgICAgYmFzZVksXHJcbiAgICAgICAgYm9yZGVyU2l6ZSA9IHNldHRpbmdzKCdub2RlQm9yZGVyU2l6ZScpLFxyXG4gICAgICAgIGFsaWdubWVudCA9IHNldHRpbmdzKCdsYWJlbEFsaWdubWVudCcpLFxyXG4gICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICBtYXhMaW5lTGVuZ3RoID0gc2V0dGluZ3MoJ21heE5vZGVMYWJlbExpbmVMZW5ndGgnKSB8fCAwLFxyXG4gICAgICAgIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xyXG4gICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XHJcbiAgICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XHJcblxyXG5cclxuICAgIC8vIExhYmVsIGJhY2tncm91bmQ6XHJcbiAgICBjb250ZXh0LmZvbnQgPSAoZm9udFN0eWxlID8gZm9udFN0eWxlICsgJyAnIDogJycpICtcclxuICAgICAgZm9udFNpemUgKyAncHggJyArIChzZXR0aW5ncygnaG92ZXJGb250JykgfHwgc2V0dGluZ3MoJ2ZvbnQnKSk7XHJcblxyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MoJ2xhYmVsSG92ZXJCR0NvbG9yJykgPT09ICdub2RlJyA/XHJcbiAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcclxuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcicpO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncygnbGFiZWxIb3ZlclNoYWRvdycpKSB7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDg7XHJcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBzZXR0aW5ncygnbGFiZWxIb3ZlclNoYWRvd0NvbG9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGluZXMgPSBnZXRMaW5lcyhub2RlLmxhYmVsLCBtYXhMaW5lTGVuZ3RoKTtcclxuICAgIGRyYXdIb3ZlckJvcmRlcihhbGlnbm1lbnQsIGNvbnRleHQsIGZvbnRTaXplLCBub2RlLCBsaW5lcywgbWF4TGluZUxlbmd0aCk7XHJcblxyXG4gICAgLy8gTm9kZSBib3JkZXI6XHJcbiAgICBpZiAoYm9yZGVyU2l6ZSA+IDApIHtcclxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUJvcmRlckNvbG9yJykgPT09ICdub2RlJyA/XHJcbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxyXG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0Tm9kZUJvcmRlckNvbG9yJyk7XHJcbiAgICAgIGNvbnRleHQuYXJjKFxyXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBub2RlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgc2l6ZSArIGJvcmRlclNpemUsXHJcbiAgICAgICAgMCxcclxuICAgICAgICBNYXRoLlBJICogMixcclxuICAgICAgICB0cnVlXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vZGU6XHJcbiAgICB2YXIgbm9kZVJlbmRlcmVyID0gc2lnbWEuY2FudmFzLm5vZGVzW25vZGUudHlwZV0gfHwgc2lnbWEuY2FudmFzLm5vZGVzLmRlZjtcclxuICAgIG5vZGVSZW5kZXJlcihub2RlLCBjb250ZXh0LCBzZXR0aW5ncyk7XHJcblxyXG4gICAgLy8gRGlzcGxheSB0aGUgbGFiZWw6XHJcbiAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cclxuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbEhvdmVyQ29sb3InKTtcclxuICAgICAgdmFyIGxhYmVsV2lkdGggPSBzaWdtYS51dGlscy5jYW52YXMuZ2V0VGV4dFdpZHRoKGNvbnRleHQsXHJcbiAgICAgICAgICAgIHNldHRpbmdzKCdhcHByb3hpbWF0ZUxhYmVsV2lkdGgnKSwgZm9udFNpemUsIG5vZGUubGFiZWwpLFxyXG4gICAgICAgICAgbGFiZWxPZmZzZXRYID0gLSBsYWJlbFdpZHRoIC8gMixcclxuICAgICAgICAgIGxhYmVsT2Zmc2V0WSA9IGZvbnRTaXplIC8gMztcclxuXHJcbiAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XHJcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgIGxhYmVsT2Zmc2V0WSA9ICsgc2l6ZSArIDQgKiBmb250U2l6ZSAvIDM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICBsYWJlbE9mZnNldFggPSAtIHNpemUgLSBib3JkZXJTaXplIC0gMyAtIGxhYmVsV2lkdGg7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgbGFiZWxPZmZzZXRZID0gLSBzaXplIC0gMiAqIGZvbnRTaXplIC8gMztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2luc2lkZSc6XHJcbiAgICAgICAgICBpZiAobGFiZWxXaWR0aCA8PSAoc2l6ZSArIGZvbnRTaXplIC8gMykgKiAyKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2gqL1xyXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoKi9cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgbGFiZWxPZmZzZXRYID0gc2l6ZSArIGJvcmRlclNpemUgKyAzO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGJhc2VYID0gbm9kZVtwcmVmaXggKyAneCddICsgbGFiZWxPZmZzZXRYO1xyXG4gICAgICBiYXNlWSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgbGFiZWxPZmZzZXRZKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2ldLCBiYXNlWCwgYmFzZVkgKyBpICogKGZvbnRTaXplICsgMSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0hvdmVyQm9yZGVyKGFsaWdubWVudCwgY29udGV4dCwgZm9udFNpemUsIG5vZGUsIGxpbmVzLCBtYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgIHZhciBsYWJlbFdpZHRoID1cclxuICAgICAgICAobWF4TGluZUxlbmd0aCA+IDEgJiYgbGluZXMubGVuZ3RoID4gMSkgP1xyXG4gICAgICAgIDAuNiAqIG1heExpbmVMZW5ndGggKiBmb250U2l6ZSA6XHJcbiAgICAgICAgc2lnbWEudXRpbHMuY2FudmFzLmdldFRleHRXaWR0aChcclxuICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgICBzZXR0aW5ncygnYXBwcm94aW1hdGVMYWJlbFdpZHRoJyksXHJcbiAgICAgICAgICBmb250U2l6ZSxcclxuICAgICAgICAgIGxpbmVzWzBdXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgIHZhciB4ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10pLFxyXG4gICAgICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddKSxcclxuICAgICAgICAgIGggPSAoKGZvbnRTaXplICsgMSkgKiBsaW5lcy5sZW5ndGgpICsgNCxcclxuICAgICAgICAgIGUgPSBNYXRoLnJvdW5kKHNpemUgKyBmb250U2l6ZSAvIDQpLFxyXG4gICAgICAgICAgdyA9IE1hdGgucm91bmQobGFiZWxXaWR0aCArIHNpemUgKyAxLjUgKyBmb250U2l6ZSAvIDMpO1xyXG5cclxuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgdHlwZW9mIG5vZGUubGFiZWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gZHJhdyBhIHJlY3RhbmdsZSBmb3IgdGhlIGxhYmVsXHJcbiAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcclxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIGZvbnRTaXplIC8gMiArIDIpO1xyXG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkgKyBlKTtcclxuICAgICAgICAgICAgY29udGV4dC5hcmNUbyh4LCB5LCB4IC0gZSwgeSwgZSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggLSB3IC0gYm9yZGVyU2l6ZSAtIGUsIHkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4IC0gdyAtIGJvcmRlclNpemUgLSBlLCB5ICsgaCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHggLSBlLCB5ICsgaCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSArIGgsIHgsIHkgKyBoIC0gZSwgZSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyBlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoeCAtIHcgLyAyLCB5IC0gZSAtIGgsIHcsIGgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIGNvbnRleHQucmVjdCh4IC0gdyAvIDIsIHkgKyBlLCB3LCBoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBjYXNlICdpbnNpZGUnOlxyXG4gICAgICAgICAgICBpZiAobGFiZWxXaWR0aCA8PSBlICogMikge1xyXG4gICAgICAgICAgICAgIC8vIGRvbid0IGRyYXcgYW55dGhpbmdcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB1c2UgZGVmYXVsdCBzZXR0aW5nLCBmYWxsaW5nIHRocm91Z2hcclxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2gqL1xyXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCovXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gLSBmb250U2l6ZSAvIDIgLSAyKTtcclxuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XHJcblxyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgZSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYXJjVG8oeCwgeSwgeCArIGUsIHksIGUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgdyArIGJvcmRlclNpemUgKyBlLCB5KTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCArIHcgKyBib3JkZXJTaXplICsgZSwgeSArIGgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgZSwgeSArIGgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIGUsIGUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5ICsgZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgY29udGV4dC5maWxsKCk7XHJcblxyXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3BsaXQgYSB0ZXh0IGludG8gc2V2ZXJhbCBsaW5lcy4gRWFjaCBsaW5lIHdvbid0IGJlIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgbWF4aW11bSBsZW5ndGguXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgICAgICAgICAgICBUZXh0IHRvIHNwbGl0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIG1heExpbmVMZW5ndGggICBNYXhpbXVtIGxlbmd0aCBvZiBhIGxpbmUuIEEgdmFsdWUgPD0gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgXCJpbmZpbml0eVwiLlxyXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59ICAgICAgICAgTGlzdCBvZiBsaW5lc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRMaW5lcyh0ZXh0LCBtYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgIGlmIChtYXhMaW5lTGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICByZXR1cm4gW3RleHRdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgd29yZHMgPSB0ZXh0LnNwbGl0KCcgJyksXHJcbiAgICAgICAgbGluZXMgPSBbXSxcclxuICAgICAgICBsaW5lTGVuZ3RoID0gMCxcclxuICAgICAgICBsaW5lSW5kZXggPSAtMSxcclxuICAgICAgICBsaW5lTGlzdCA9IFtdLFxyXG4gICAgICAgIGxpbmVGdWxsID0gdHJ1ZTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAobGluZUZ1bGwpIHtcclxuICAgICAgICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggPiBtYXhMaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0V29yZCh3b3Jkc1tpXSwgbWF4TGluZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICBsaW5lcy5wdXNoKFtwYXJ0c1tqXV0pO1xyXG4gICAgICAgICAgICAgICsrbGluZUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpbmVMZW5ndGggPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKFt3b3Jkc1tpXVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgKytsaW5lSW5kZXg7XHJcbiAgICAgICAgICAgIGxpbmVMZW5ndGggPSB3b3Jkc1tpXS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGluZUZ1bGwgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVMZW5ndGggKyB3b3Jkc1tpXS5sZW5ndGggPD0gbWF4TGluZUxlbmd0aCkge1xyXG4gICAgICAgICAgbGluZXNbbGluZUluZGV4XS5wdXNoKHdvcmRzW2ldKTtcclxuICAgICAgICAgIGxpbmVMZW5ndGggKz0gd29yZHNbaV0ubGVuZ3RoICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbGluZUZ1bGwgPSB0cnVlO1xyXG4gICAgICAgICAgLS1pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgbGluZUxpc3QucHVzaChsaW5lc1tpXS5qb2luKCcgJykpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBsaW5lTGlzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNwbGl0IGEgd29yZCBpbnRvIHNldmVyYWwgbGluZXMgKHdpdGggYSAnLScgYXQgdGhlIGVuZCBvZiBlYWNoIGxpbmUgYnV0IHRoZSBsYXN0KS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkICAgICAgIFdvcmQgdG8gc3BsaXRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGggIE1heGltdW0gbGVuZ3RoIG9mIGEgbGluZVxyXG4gICAgICogQHJldHVybnMge0FycmF5PHN0cmluZz59ICAgTGlzdCBvZiBsaW5lc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzcGxpdFdvcmQod29yZCwgbWF4TGVuZ3RoKSB7XHJcbiAgICAgIHZhciBwYXJ0cyA9IFtdO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkLmxlbmd0aDsgaSArPSBtYXhMZW5ndGggLSAxKSB7XHJcbiAgICAgICAgcGFydHMucHVzaCh3b3JkLnN1YnN0cihpLCBtYXhMZW5ndGggLSAxKSArICctJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBsYXN0UGFydExlbiA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxlbmd0aDtcclxuICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5zdWJzdHIoMCwgbGFzdFBhcnRMZW4gLSAxKSArICcgJztcclxuXHJcbiAgICAgIHJldHVybiBwYXJ0cztcclxuICAgIH1cclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLm5vZGVzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkZWZhdWx0IG5vZGUgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgZGlzYy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0LmFyYyhcclxuICAgICAgbm9kZVtwcmVmaXggKyAneCddLFxyXG4gICAgICBub2RlW3ByZWZpeCArICd5J10sXHJcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgMCxcclxuICAgICAgTWF0aC5QSSAqIDIsXHJcbiAgICAgIHRydWVcclxuICAgICk7XHJcblxyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgZWRnZSBhcyBhIHNpbXBsZSBsaW5lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmRlZiA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oXHJcbiAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxyXG4gICAgKTtcclxuICAgIGNvbnRleHQubGluZVRvKFxyXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J11cclxuICAgICk7XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBjdXJ2ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZXMuY3VydmUgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcclxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXHJcbiAgICAgICAgY3AgPSB7fSxcclxuICAgICAgICBzU2l6ZSA9IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XHJcblxyXG4gICAgY3AgPSAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpID9cclxuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpIDpcclxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZLCBlZGdlLmNjKTtcclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcclxuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3AueDEsIGNwLnkxLCBjcC54MiwgY3AueTIsIHRYLCB0WSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgdFgsIHRZKTtcclxuICAgIH1cclxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmFycm93ID0gZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXHJcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICBhU2l6ZSA9IE1hdGgubWF4KHNpemUgKiAyLjUsIHNldHRpbmdzKCdtaW5BcnJvd1NpemUnKSksXHJcbiAgICAgICAgZCA9IE1hdGguc3FydCgodFggLSBzWCkgKiAodFggLSBzWCkgKyAodFkgLSBzWSkgKiAodFkgLSBzWSkpLFxyXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcclxuICAgICAgICBhWSA9IHNZICsgKHRZIC0gc1kpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXHJcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXHJcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XHJcblxyXG4gICAgaWYgKCFjb2xvcilcclxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhcclxuICAgICAgYVgsXHJcbiAgICAgIGFZXHJcbiAgICApO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlZGdlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBlZGdlcyBhcyBjdXJ2ZXMgd2l0aCBhcnJvdyBoZWFkaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmVkZ2VzLmN1cnZlZEFycm93ID1cclxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxyXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxyXG4gICAgICAgIGNwID0ge30sXHJcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICBhU2l6ZSA9IE1hdGgubWF4KHNpemUgKiAyLjUsIHNldHRpbmdzKCdtaW5BcnJvd1NpemUnKSksXHJcbiAgICAgICAgZCxcclxuICAgICAgICBhWCxcclxuICAgICAgICBhWSxcclxuICAgICAgICB2WCxcclxuICAgICAgICB2WTtcclxuXHJcbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xyXG4gICAgICBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCB0U2l6ZSkgOlxyXG4gICAgICBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFksIGVkZ2UuY2MpO1xyXG5cclxuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICBkID0gTWF0aC5zcXJ0KCh0WCAtIGNwLngxKSAqICh0WCAtIGNwLngxKSArICh0WSAtIGNwLnkxKSAqICh0WSAtIGNwLnkxKSk7XHJcbiAgICAgIGFYID0gY3AueDEgKyAodFggLSBjcC54MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgYVkgPSBjcC55MSArICh0WSAtIGNwLnkxKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkO1xyXG4gICAgICB2WCA9ICh0WCAtIGNwLngxKSAqIGFTaXplIC8gZDtcclxuICAgICAgdlkgPSAodFkgLSBjcC55MSkgKiBhU2l6ZSAvIGQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZCA9IE1hdGguc3FydCgodFggLSBjcC54KSAqICh0WCAtIGNwLngpICsgKHRZIC0gY3AueSkgKiAodFkgLSBjcC55KSk7XHJcbiAgICAgIGFYID0gY3AueCArICh0WCAtIGNwLngpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XHJcbiAgICAgIGFZID0gY3AueSArICh0WSAtIGNwLnkpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XHJcbiAgICAgIHZYID0gKHRYIC0gY3AueCkgKiBhU2l6ZSAvIGQ7XHJcbiAgICAgIHZZID0gKHRZIC0gY3AueSkgKiBhU2l6ZSAvIGQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb2xvcilcclxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XHJcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNwLngyLCBjcC55MiwgY3AueDEsIGNwLnkxLCBhWCwgYVkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIGFYLCBhWSk7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG5cclxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYIC0gdlkgKiAwLjYsIGFZICsgdlggKiAwLjYpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XHJcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcbjsoZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXHJcbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmRlZiA9XHJcbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcclxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xyXG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xyXG4gICAgfVxyXG4gICAgc2l6ZSAqPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJyk7XHJcblxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKFxyXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgc291cmNlW3ByZWZpeCArICd5J11cclxuICAgICk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhcclxuICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXHJcbiAgICApO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuY3VydmUgPVxyXG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBzaXplID0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSxcclxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXHJcbiAgICAgICAgY3AgPSB7fSxcclxuICAgICAgICBzU2l6ZSA9IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XHJcblxyXG4gICAgY3AgPSAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpID9cclxuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpIDpcclxuICAgICAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZLCBlZGdlLmNjKTtcclxuXHJcbiAgICBpZiAoIWNvbG9yKVxyXG4gICAgICBzd2l0Y2ggKGVkZ2VDb2xvcikge1xyXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3MoJ2VkZ2VIb3ZlckNvbG9yJykgPT09ICdlZGdlJykge1xyXG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHRFZGdlSG92ZXJDb2xvcicpIHx8IGNvbG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xyXG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MSwgY3AueTEsIGNwLngyLCBjcC55MiwgdFgsIHRZKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjcC54LCBjcC55LCB0WCwgdFkpO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cclxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuYXJyb3cgPVxyXG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXHJcbiAgICAgICAgc2l6ZSA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxLFxyXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXTtcclxuXHJcbiAgICBzaXplID0gKGVkZ2UuaG92ZXIpID9cclxuICAgICAgc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogc2l6ZSA6IHNpemU7XHJcbiAgICB2YXIgYVNpemUgPSBNYXRoLm1heChzaXplICogMi41LCBzZXR0aW5ncygnbWluQXJyb3dTaXplJykpLFxyXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoKHRYIC0gc1gpICogKHRYIC0gc1gpICsgKHRZIC0gc1kpICogKHRZIC0gc1kpKSxcclxuICAgICAgICBhWCA9IHNYICsgKHRYIC0gc1gpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXHJcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxyXG4gICAgICAgIHZYID0gKHRYIC0gc1gpICogYVNpemUgLyBkLFxyXG4gICAgICAgIHZZID0gKHRZIC0gc1kpICogYVNpemUgLyBkO1xyXG5cclxuICAgIGlmICghY29sb3IpXHJcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XHJcbiAgICAgICAgY2FzZSAnc291cmNlJzpcclxuICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd0YXJnZXQnOlxyXG4gICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XHJcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKHNYLCBzWSk7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhcclxuICAgICAgYVgsXHJcbiAgICAgIGFZXHJcbiAgICApO1xyXG4gICAgY29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQubW92ZVRvKGFYICsgdlgsIGFZICsgdlkpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlgsIGFZICsgdlkpO1xyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZWRBcnJvdyA9XHJcbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcclxuICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKSxcclxuICAgICAgICBjcCA9IHt9LFxyXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxyXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICBkLFxyXG4gICAgICAgIGFTaXplLFxyXG4gICAgICAgIGFYLFxyXG4gICAgICAgIGFZLFxyXG4gICAgICAgIHZYLFxyXG4gICAgICAgIHZZO1xyXG5cclxuICAgIGNwID0gKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSA/XHJcbiAgICAgIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhzWCwgc1ksIHRTaXplKSA6XHJcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSwgZWRnZS5jYyk7XHJcblxyXG4gICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgIGQgPSBNYXRoLnNxcnQoKHRYIC0gY3AueDEpICogKHRYIC0gY3AueDEpICsgKHRZIC0gY3AueTEpICogKHRZIC0gY3AueTEpKTtcclxuICAgICAgYVNpemUgPSBNYXRoLm1heChzaXplICogMi41LCBzZXR0aW5ncygnbWluQXJyb3dTaXplJykpO1xyXG4gICAgICBhWCA9IGNwLngxICsgKHRYIC0gY3AueDEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XHJcbiAgICAgIGFZID0gY3AueTEgKyAodFkgLSBjcC55MSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcclxuICAgICAgdlggPSAodFggLSBjcC54MSkgKiBhU2l6ZSAvIGQ7XHJcbiAgICAgIHZZID0gKHRZIC0gY3AueTEpICogYVNpemUgLyBkO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGQgPSBNYXRoLnNxcnQoKHRYIC0gY3AueCkgKiAodFggLSBjcC54KSArICh0WSAtIGNwLnkpICogKHRZIC0gY3AueSkpO1xyXG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XHJcbiAgICAgIGFYID0gY3AueCArICh0WCAtIGNwLngpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XHJcbiAgICAgIGFZID0gY3AueSArICh0WSAtIGNwLnkpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XHJcbiAgICAgIHZYID0gKHRYIC0gY3AueCkgKiBhU2l6ZSAvIGQ7XHJcbiAgICAgIHZZID0gKHRZIC0gY3AueSkgKiBhU2l6ZSAvIGQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb2xvcilcclxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcclxuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IGNvbG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XHJcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcclxuICAgIGlmIChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY3AueDIsIGNwLnkyLCBjcC54MSwgY3AueTEsIGFYLCBhWSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY3AueCwgY3AueSwgYVgsIGFZKTtcclxuICAgIH1cclxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcclxuICAgIGNvbnRleHQubGluZVRvKGFYICsgdlkgKiAwLjYsIGFZIC0gdlggKiAwLjYpO1xyXG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XHJcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcclxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICBjb250ZXh0LmZpbGwoKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZXh0cmVtaXRpZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgcmVuZGVyZXIgZm9yIGhvdmVyZWQgZWRnZSBleHRyZW1pdGllcy4gSXQgcmVuZGVycyB0aGUgZWRnZVxyXG4gICAqIGV4dHJlbWl0aWVzIGFzIGhvdmVyZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXHJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgKi9cclxuICBzaWdtYS5jYW52YXMuZXh0cmVtaXRpZXMuZGVmID1cclxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xyXG4gICAgLy8gU291cmNlIE5vZGU6XHJcbiAgICAoXHJcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbc291cmNlLnR5cGVdIHx8XHJcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnMuZGVmXHJcbiAgICApIChcclxuICAgICAgc291cmNlLCBjb250ZXh0LCBzZXR0aW5nc1xyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUYXJnZXQgTm9kZTpcclxuICAgIChcclxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVyc1t0YXJnZXQudHlwZV0gfHxcclxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcclxuICAgICkgKFxyXG4gICAgICB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzXHJcbiAgICApO1xyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcudXRpbHMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogU29tZSB1c2VmdWwgZnVuY3Rpb25zIHVzZWQgYnkgc2lnbWEncyBTVkcgcmVuZGVyZXIuXHJcbiAgICovXHJcbiAgc2lnbWEuc3ZnLnV0aWxzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgc2hvdy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gc2hvdy5cclxuICAgICAqL1xyXG4gICAgc2hvdzogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgaGlkZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gaGlkZS5cclxuICAgICAqL1xyXG4gICAgaGlkZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxyXG4gICAqL1xyXG4gIHNpZ21hLnN2Zy5ub2Rlcy5kZWYgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKTtcclxuXHJcbiAgICAgIC8vIERlZmluaW5nIHRoZSBub2RlJ3MgY2lyY2xlXHJcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XHJcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctbm9kZScpO1xyXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXHJcbiAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuaW5nIHRoZSBET00gRWxlbWVudFxyXG4gICAgICByZXR1cm4gY2lyY2xlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgY2lyY2xlICAgVGhlIG5vZGUgRE9NIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbihub2RlLCBjaXJjbGUsIHNldHRpbmdzKSB7XHJcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJyc7XHJcblxyXG4gICAgICAvLyBBcHBseWluZyBjaGFuZ2VzXHJcbiAgICAgIC8vIFRPRE86IG9wdGltaXplIC0gY2hlY2sgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xyXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N5Jywgbm9kZVtwcmVmaXggKyAneSddKTtcclxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgbm9kZVtwcmVmaXggKyAnc2l6ZSddKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0aW5nIG9ubHkgaWYgbm90IGZyZWVzdHlsZVxyXG4gICAgICBpZiAoIXNldHRpbmdzKCdmcmVlU3R5bGUnKSlcclxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXHJcbiAgICAgICAgICBudWxsLCAnZmlsbCcsIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSk7XHJcblxyXG4gICAgICAvLyBTaG93aW5nXHJcbiAgICAgIGNpcmNsZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkZWZhdWx0IGVkZ2UgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgbGluZS5cclxuICAgKi9cclxuICBzaWdtYS5zdmcuZWRnZXMuZGVmID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcclxuXHJcbiAgICAgIGlmICghY29sb3IpXHJcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIHZhciBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnbGluZScpO1xyXG5cclxuICAgICAgLy8gQXR0cmlidXRlc1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcclxuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XHJcblxyXG4gICAgICByZXR1cm4gbGluZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVkZ2UsIGxpbmUsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xyXG5cclxuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlLXdpZHRoJywgZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpO1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MScsIHNvdXJjZVtwcmVmaXggKyAneCddKTtcclxuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneTEnLCBzb3VyY2VbcHJlZml4ICsgJ3knXSk7XHJcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gyJywgdGFyZ2V0W3ByZWZpeCArICd4J10pO1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHRhcmdldFtwcmVmaXggKyAneSddKTtcclxuXHJcbiAgICAgIC8vIFNob3dpbmdcclxuICAgICAgbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBjdXJ2ZSBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBlZGdlIGFzIGEgYmV6aWVyIGN1cnZlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnN2Zy5lZGdlcy5jdXJ2ZSA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcclxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcclxuICAgICAgICAgIGRlZmF1bHROb2RlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpLFxyXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XHJcblxyXG4gICAgICBpZiAoIWNvbG9yKVxyXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XHJcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxyXG4gICAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3BhdGgnKTtcclxuXHJcbiAgICAgIC8vIEF0dHJpYnV0ZXNcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWVkZ2UnKTtcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlJywgY29sb3IpO1xyXG5cclxuICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgdXBkYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICBUaGUgZWRnZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIHBhdGggICAgICAgVGhlIHBhdGggRE9NIEVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0ICAgICBUaGUgdGFyZ2V0IG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbihlZGdlLCBwYXRoLCBzb3VyY2UsIHRhcmdldCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXHJcbiAgICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgY3AsXHJcbiAgICAgICAgICBwO1xyXG5cclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnc3Ryb2tlLXdpZHRoJywgZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpO1xyXG5cclxuICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoc1gsIHNZLCBzU2l6ZSk7XHJcbiAgICAgICAgLy8gUGF0aFxyXG4gICAgICAgIHAgPSAnTScgKyBzWCArICcsJyArIHNZICsgJyAnICtcclxuICAgICAgICAgICAgJ0MnICsgY3AueDEgKyAnLCcgKyBjcC55MSArICcgJyArXHJcbiAgICAgICAgICAgIGNwLngyICsgJywnICsgY3AueTIgKyAnICcgK1xyXG4gICAgICAgICAgICB0WCArICcsJyArIHRZO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KHNYLCBzWSwgdFgsIHRZLCBlZGdlLmNjKTtcclxuICAgICAgICAvLyBQYXRoXHJcbiAgICAgICAgcCA9ICdNJyArIHNYICsgJywnICsgc1kgKyAnICcgK1xyXG4gICAgICAgICAgICAnUScgKyBjcC54ICsgJywnICsgY3AueSArICcgJyArXHJcbiAgICAgICAgICAgIHRYICsgJywnICsgdFk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0aW5nIGF0dHJpYnV0ZXNcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHApO1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcclxuXHJcbiAgICAgIC8vIFNob3dpbmdcclxuICAgICAgcGF0aC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9O1xyXG59KSgpO1xyXG5cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE8gYWRkIGFycm93XHJcbiAgICovXHJcbiAgc2lnbWEuc3ZnLmVkZ2VzLmN1cnZlZEFycm93ID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxyXG4gICAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxyXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgICBkZWZhdWx0RWRnZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcclxuXHJcbiAgICAgIGlmICghY29sb3IpXHJcbiAgICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcclxuICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XHJcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndGFyZ2V0JzpcclxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAncGF0aCcpO1xyXG5cclxuICAgICAgLy8gQXR0cmlidXRlc1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWVkZ2UtaWQnLCBlZGdlLmlkKTtcclxuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XHJcblxyXG4gICAgICByZXR1cm4gcGF0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgcGF0aCAgICAgICBUaGUgcGF0aCBET00gRWxlbWVudC5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlICAgICBUaGUgc291cmNlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgICAgIFRoZSB0YXJnZXQgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGVkZ2UsIHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgc1NpemUgPSBzb3VyY2VbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICBjcCxcclxuICAgICAgICAgIHA7XHJcblxyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XHJcblxyXG4gICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgICBjcCA9IHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyhzWCwgc1ksIHNTaXplKTtcclxuICAgICAgICAvLyBQYXRoXHJcbiAgICAgICAgcCA9ICdNJyArIHNYICsgJywnICsgc1kgKyAnICcgK1xyXG4gICAgICAgICAgICAnQycgKyBjcC54MSArICcsJyArIGNwLnkxICsgJyAnICtcclxuICAgICAgICAgICAgY3AueDIgKyAnLCcgKyBjcC55MiArICcgJyArXHJcbiAgICAgICAgICAgIHRYICsgJywnICsgdFk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoc1gsIHNZLCB0WCwgdFksIGVkZ2UuY2MpO1xyXG4gICAgICAgIC8vIFBhdGhcclxuICAgICAgICBwID0gJ00nICsgc1ggKyAnLCcgKyBzWSArICcgJyArXHJcbiAgICAgICAgICAgICdRJyArIGNwLnggKyAnLCcgKyBjcC55ICsgJyAnICtcclxuICAgICAgICAgICAgdFggKyAnLCcgKyB0WTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRpbmcgYXR0cmlidXRlc1xyXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcCk7XHJcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnbm9uZScpO1xyXG5cclxuICAgICAgLy8gU2hvd2luZ1xyXG4gICAgICBwYXRoLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGRlZmF1bHQgbGFiZWwgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGxhYmVsIGFzIGEgc2ltcGxlIHRleHQuXHJcbiAgICovXHJcbiAgc2lnbWEuc3ZnLmxhYmVscy5kZWYgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgRWxlbWVudCBjcmVhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xyXG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcclxuICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICd0ZXh0Jyk7XHJcblxyXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XHJcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xyXG5cclxuICAgICAgdmFyIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxDb2xvcicpID09PSAnbm9kZScpID9cclxuICAgICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XHJcblxyXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdkYXRhLWxhYmVsLXRhcmdldCcsIG5vZGUuaWQpO1xyXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1sYWJlbCcpO1xyXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xyXG5cclxuICAgICAgdGV4dC5pbm5lckhUTUwgPSBub2RlLmxhYmVsO1xyXG4gICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcclxuXHJcbiAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgdGV4dCAgICAgVGhlIGxhYmVsIERPTSBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgdGV4dCwgc2V0dGluZ3MpIHtcclxuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcclxuICAgICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ107XHJcblxyXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XHJcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XHJcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xyXG5cclxuICAgICAgLy8gQ2FzZSB3aGVuIHdlIGRvbid0IHdhbnQgdG8gZGlzcGxheSB0aGUgbGFiZWxcclxuICAgICAgaWYgKCFzZXR0aW5ncygnZm9yY2VMYWJlbHMnKSAmJiBzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAvLyBVcGRhdGluZ1xyXG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcclxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XHJcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxyXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XHJcblxyXG4gICAgICAvLyBTaG93aW5nXHJcbiAgICAgIHRleHQuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmhvdmVycycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZGVmYXVsdCBob3ZlciByZW5kZXJlci5cclxuICAgKi9cclxuICBzaWdtYS5zdmcuaG92ZXJzLmRlZiA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgIG5vZGUgICAgICAgICAgICAgICBUaGUgbm9kZSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNFbGVtZW50fSAgICBtZWFzdXJlbWVudENhbnZhcyAgQSBmYWtlIGNhbnZhcyBoYW5kbGVkIGJ5XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3ZnIHRvIHBlcmZvcm0gc29tZSBtZWFzdXJlbWVudHMgYW5kXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWQgYnkgdGhlIHJlbmRlcmVyLlxyXG4gICAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gICAgICAgbm9kZUNpcmNsZSAgICAgICAgIFRoZSBub2RlIERPTSBFbGVtZW50LlxyXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgc2V0dGluZ3MgICAgICAgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBub2RlQ2lyY2xlLCBtZWFzdXJlbWVudENhbnZhcywgc2V0dGluZ3MpIHtcclxuXHJcbiAgICAgIC8vIERlZmluaW5nIHZpc3VhbCBwcm9wZXJ0aWVzXHJcbiAgICAgIHZhciB4LFxyXG4gICAgICAgICAgeSxcclxuICAgICAgICAgIHcsXHJcbiAgICAgICAgICBoLFxyXG4gICAgICAgICAgZSxcclxuICAgICAgICAgIGQsXHJcbiAgICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnaG92ZXJGb250U3R5bGUnKSB8fCBzZXR0aW5ncygnZm9udFN0eWxlJyksXHJcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXHJcbiAgICAgICAgICBzaXplID0gbm9kZVtwcmVmaXggKyAnc2l6ZSddLFxyXG4gICAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XHJcbiAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxyXG4gICAgICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemUsXHJcbiAgICAgICAgICBmb250Q29sb3IgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xyXG5cclxuICAgICAgLy8gQ3JlYXRpbmcgZWxlbWVudHNcclxuICAgICAgdmFyIGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnZycpLFxyXG4gICAgICAgICAgcmVjdGFuZ2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAncmVjdCcpLFxyXG4gICAgICAgICAgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnY2lyY2xlJyksXHJcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xyXG5cclxuICAgICAgLy8gRGVmaW5pbmcgcHJvcGVydGllc1xyXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY2xhc3MnLCBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcclxuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbm9kZS1pZCcsIG5vZGUuaWQpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xyXG5cclxuICAgICAgICAvLyBUZXh0XHJcbiAgICAgICAgdGV4dC5pbm5lckhUTUwgPSBub2RlLmxhYmVsO1xyXG4gICAgICAgIHRleHQudGV4dENvbnRlbnQgPSBub2RlLmxhYmVsO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMoXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgICdjbGFzcycsXHJcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1sYWJlbCcpO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcclxuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LWZhbWlseScsIHNldHRpbmdzKCdmb250JykpO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3gnLFxyXG4gICAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMykpO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxyXG4gICAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpKTtcclxuXHJcbiAgICAgICAgLy8gTWVhc3VyZXNcclxuICAgICAgICAvLyBPUFRJTUlaRTogRmluZCBhIGJldHRlciB3YXkgdGhhbiBhIG1lYXN1cmVtZW50IGNhbnZhc1xyXG4gICAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xyXG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xyXG4gICAgICAgIHcgPSBNYXRoLnJvdW5kKFxyXG4gICAgICAgICAgbWVhc3VyZW1lbnRDYW52YXMubWVhc3VyZVRleHQobm9kZS5sYWJlbCkud2lkdGggK1xyXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIgKyBzaXplICsgOVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaCA9IE1hdGgucm91bmQoZm9udFNpemUgKyA0KTtcclxuICAgICAgICBlID0gTWF0aC5yb3VuZChmb250U2l6ZSAvIDIgKyAyKTtcclxuXHJcbiAgICAgICAgLy8gQ2lyY2xlXHJcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICAnY2xhc3MnLFxyXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xyXG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XHJcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeCcsIG5vZGVbcHJlZml4ICsgJ3gnXSk7XHJcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XHJcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdyJywgZSk7XHJcblxyXG4gICAgICAgIC8vIFJlY3RhbmdsZVxyXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICAgICAgJ2NsYXNzJyxcclxuICAgICAgICAgICAgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyLWFyZWEnKTtcclxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnI2ZmZicpO1xyXG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIG5vZGVbcHJlZml4ICsgJ3gnXSArIGUgLyA0KTtcclxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLCBub2RlW3ByZWZpeCArICd5J10gLSBlKTtcclxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3dpZHRoJywgdyk7XHJcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXBwZW5kaW5nIGNoaWxkc1xyXG4gICAgICBncm91cC5hcHBlbmRDaGlsZChjaXJjbGUpO1xyXG4gICAgICBncm91cC5hcHBlbmRDaGlsZChyZWN0YW5nbGUpO1xyXG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQobm9kZUNpcmNsZSk7XHJcblxyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9XHJcbiAgfTtcclxufSkuY2FsbCh0aGlzKTtcclxuXHJcbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnV0aWxzJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWlkZGxld2FyZSB3aWxsIHJlc2NhbGUgdGhlIGdyYXBoIHN1Y2ggdGhhdCBpdCB0YWtlcyBhbiBvcHRpbWFsIHNwYWNlXHJcbiAgICogb24gdGhlIHJlbmRlcmVyLlxyXG4gICAqXHJcbiAgICogQXMgZWFjaCBtaWRkbGV3YXJlLCB0aGlzIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBzY29wZSBvZiB0aGUgc2lnbWFcclxuICAgKiBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxyXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gd3JpdGVQcmVmaXggVGhlIHdyaXRlIHByZWZpeC5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgIFRoZSBwYXJhbWV0ZXJzLlxyXG4gICAqL1xyXG4gIHNpZ21hLm1pZGRsZXdhcmVzLnJlc2NhbGUgPSBmdW5jdGlvbihyZWFkUHJlZml4LCB3cml0ZVByZWZpeCwgb3B0aW9ucykge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBhLFxyXG4gICAgICAgIGIsXHJcbiAgICAgICAgYyxcclxuICAgICAgICBkLFxyXG4gICAgICAgIHNjYWxlLFxyXG4gICAgICAgIG1hcmdpbixcclxuICAgICAgICBuID0gdGhpcy5ncmFwaC5ub2RlcygpLFxyXG4gICAgICAgIGUgPSB0aGlzLmdyYXBoLmVkZ2VzKCksXHJcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zIHx8IHt9KSxcclxuICAgICAgICBib3VuZHMgPSBzZXR0aW5ncygnYm91bmRzJykgfHwgc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyhcclxuICAgICAgICAgIHRoaXMuZ3JhcGgsXHJcbiAgICAgICAgICByZWFkUHJlZml4LFxyXG4gICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICksXHJcbiAgICAgICAgbWluWCA9IGJvdW5kcy5taW5YLFxyXG4gICAgICAgIG1pblkgPSBib3VuZHMubWluWSxcclxuICAgICAgICBtYXhYID0gYm91bmRzLm1heFgsXHJcbiAgICAgICAgbWF4WSA9IGJvdW5kcy5tYXhZLFxyXG4gICAgICAgIHNpemVNYXggPSBib3VuZHMuc2l6ZU1heCxcclxuICAgICAgICB3ZWlnaHRNYXggPSBib3VuZHMud2VpZ2h0TWF4LFxyXG4gICAgICAgIHcgPSBzZXR0aW5ncygnd2lkdGgnKSB8fCAxLFxyXG4gICAgICAgIGggPSBzZXR0aW5ncygnaGVpZ2h0JykgfHwgMSxcclxuICAgICAgICByZXNjYWxlU2V0dGluZ3MgPSBzZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSxcclxuICAgICAgICB2YWxpZFNldHRpbmdzID0ge1xyXG4gICAgICAgICAgbm9kZVBvc2l0aW9uOiAxLFxyXG4gICAgICAgICAgbm9kZVNpemU6IDEsXHJcbiAgICAgICAgICBlZGdlU2l6ZTogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGF0IGVsZW1lbnRzIHNob3VsZCB3ZSByZXNjYWxlP1xyXG4gICAgICovXHJcbiAgICBpZiAoIShyZXNjYWxlU2V0dGluZ3MgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgIHJlc2NhbGVTZXR0aW5ncyA9IFsnbm9kZVBvc2l0aW9uJywgJ25vZGVTaXplJywgJ2VkZ2VTaXplJ107XHJcblxyXG4gICAgZm9yIChpID0gMCwgbCA9IHJlc2NhbGVTZXR0aW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGlmICghdmFsaWRTZXR0aW5nc1tyZXNjYWxlU2V0dGluZ3NbaV1dKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICdUaGUgcmVzY2FsZSBzZXR0aW5nIFwiJyArIHJlc2NhbGVTZXR0aW5nc1tpXSArICdcIiBpcyBub3QgcmVjb2duaXplZC4nXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB2YXIgbnAgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVQb3NpdGlvbicpLFxyXG4gICAgICAgIG5zID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdub2RlU2l6ZScpLFxyXG4gICAgICAgIGVzID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdlZGdlU2l6ZScpO1xyXG5cclxuICAgIGlmIChucCkge1xyXG4gICAgICAvKipcclxuICAgICAgICogRmlyc3QsIHdlIGNvbXB1dGUgdGhlIHNjYWxpbmcgcmF0aW8sIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIHNpemVzXHJcbiAgICAgICAqIG9mIHRoZSBub2RlcyA6IEVhY2ggbm9kZSB3aWxsIGhhdmUgaXRzIGNlbnRlciBpbiB0aGUgY2FudmFzLCBidXQgbWlnaHRcclxuICAgICAgICogYmUgcGFydGlhbGx5IG91dCBvZiBpdC5cclxuICAgICAgICovXHJcbiAgICAgIHNjYWxlID0gc2V0dGluZ3MoJ3NjYWxpbmdNb2RlJykgPT09ICdvdXRzaWRlJyA/XHJcbiAgICAgICAgTWF0aC5tYXgoXHJcbiAgICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxyXG4gICAgICAgICAgaCAvIE1hdGgubWF4KG1heFkgLSBtaW5ZLCAxKVxyXG4gICAgICAgICkgOlxyXG4gICAgICAgIE1hdGgubWluKFxyXG4gICAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcclxuICAgICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZW4sIHdlIGNvcnJlY3QgdGhhdCBzY2FsaW5nIHJhdGlvIGNvbnNpZGVyaW5nIGEgbWFyZ2luLCB3aGljaCBpc1xyXG4gICAgICAgKiBiYXNpY2FsbHkgdGhlIHNpemUgb2YgdGhlIGJpZ2dlc3Qgbm9kZS5cclxuICAgICAgICogVGhpcyBoYXMgdG8gYmUgZG9uZSBhcyBhIGNvcnJlY3Rpb24gc2luY2UgdG8gY29tcGFyZSB0aGUgc2l6ZSBvZiB0aGVcclxuICAgICAgICogYmlnZ2VzdCBub2RlIHRvIHRoZSBYIGFuZCBZIHZhbHVlcywgd2UgaGF2ZSB0byBmaXJzdCBnZXQgYW5cclxuICAgICAgICogYXBwcm94aW1hdGlvbiBvZiB0aGUgc2NhbGluZyByYXRpby5cclxuICAgICAgICoqL1xyXG4gICAgICBtYXJnaW4gPVxyXG4gICAgICAgIChcclxuICAgICAgICAgIHNldHRpbmdzKCdyZXNjYWxlSWdub3JlU2l6ZScpID9cclxuICAgICAgICAgICAgMCA6XHJcbiAgICAgICAgICAgIChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSB8fCBzaXplTWF4KSAvIHNjYWxlXHJcbiAgICAgICAgKSArXHJcbiAgICAgICAgKHNldHRpbmdzKCdzaWRlTWFyZ2luJykgfHwgMCk7XHJcbiAgICAgIG1heFggKz0gbWFyZ2luO1xyXG4gICAgICBtaW5YIC09IG1hcmdpbjtcclxuICAgICAgbWF4WSArPSBtYXJnaW47XHJcbiAgICAgIG1pblkgLT0gbWFyZ2luO1xyXG5cclxuICAgICAgLy8gRml4IHRoZSBzY2FsaW5nIHdpdGggdGhlIG5ldyBleHRyZW1hOlxyXG4gICAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xyXG4gICAgICAgIE1hdGgubWF4KFxyXG4gICAgICAgICAgdyAvIE1hdGgubWF4KG1heFggLSBtaW5YLCAxKSxcclxuICAgICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcclxuICAgICAgICApIDpcclxuICAgICAgICBNYXRoLm1pbihcclxuICAgICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXHJcbiAgICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaXplIGhvbW90aGV0aWMgcGFyYW1ldGVyczpcclxuICAgIGlmICghc2V0dGluZ3MoJ21heE5vZGVTaXplJykgJiYgIXNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XHJcbiAgICAgIGEgPSAxO1xyXG4gICAgICBiID0gMDtcclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgPT09IHNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSB7XHJcbiAgICAgIGEgPSAwO1xyXG4gICAgICBiID0gK3NldHRpbmdzKCdtYXhOb2RlU2l6ZScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYSA9IChzZXR0aW5ncygnbWF4Tm9kZVNpemUnKSAtIHNldHRpbmdzKCdtaW5Ob2RlU2l6ZScpKSAvIHNpemVNYXg7XHJcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21pbk5vZGVTaXplJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcclxuICAgICAgYyA9IDE7XHJcbiAgICAgIGQgPSAwO1xyXG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcclxuICAgICAgYyA9IDA7XHJcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjID0gKHNldHRpbmdzKCdtYXhFZGdlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIC8gd2VpZ2h0TWF4O1xyXG4gICAgICBkID0gK3NldHRpbmdzKCdtaW5FZGdlU2l6ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc2NhbGUgdGhlIG5vZGVzIGFuZCBlZGdlczpcclxuICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgZVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxyXG4gICAgICAgIGVbaV1bcmVhZFByZWZpeCArICdzaXplJ10gKiAoZXMgPyBjIDogMSkgKyAoZXMgPyBkIDogMCk7XHJcblxyXG4gICAgZm9yIChpID0gMCwgbCA9IG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID1cclxuICAgICAgICBuW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKG5zID8gYSA6IDEpICsgKG5zID8gYiA6IDApO1xyXG5cclxuICAgICAgaWYgKG5wKSB7XHJcbiAgICAgICAgbltpXVt3cml0ZVByZWZpeCArICd4J10gPVxyXG4gICAgICAgICAgKG5baV1bcmVhZFByZWZpeCArICd4J10gLSAobWF4WCArIG1pblgpIC8gMikgKiBzY2FsZTtcclxuICAgICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9XHJcbiAgICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3knXSAtIChtYXhZICsgbWluWSkgLyAyKSAqIHNjYWxlO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIG5baV1bd3JpdGVQcmVmaXggKyAneCddID0gbltpXVtyZWFkUHJlZml4ICsgJ3gnXTtcclxuICAgICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9IG5baV1bcmVhZFByZWZpeCArICd5J107XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzID0gZnVuY3Rpb24oZ3JhcGgsIHByZWZpeCwgZG9FZGdlcykge1xyXG4gICAgdmFyIGksXHJcbiAgICAgICAgbCxcclxuICAgICAgICBlID0gZ3JhcGguZWRnZXMoKSxcclxuICAgICAgICBuID0gZ3JhcGgubm9kZXMoKSxcclxuICAgICAgICB3ZWlnaHRNYXggPSAtSW5maW5pdHksXHJcbiAgICAgICAgc2l6ZU1heCA9IC1JbmZpbml0eSxcclxuICAgICAgICBtaW5YID0gSW5maW5pdHksXHJcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxyXG4gICAgICAgIG1heFggPSAtSW5maW5pdHksXHJcbiAgICAgICAgbWF4WSA9IC1JbmZpbml0eTtcclxuXHJcbiAgICBpZiAoZG9FZGdlcylcclxuICAgICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgIHdlaWdodE1heCA9IE1hdGgubWF4KGVbaV1bcHJlZml4ICsgJ3NpemUnXSwgd2VpZ2h0TWF4KTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsID0gbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgc2l6ZU1heCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3NpemUnXSwgc2l6ZU1heCk7XHJcbiAgICAgIG1heFggPSBNYXRoLm1heChuW2ldW3ByZWZpeCArICd4J10sIG1heFgpO1xyXG4gICAgICBtaW5YID0gTWF0aC5taW4obltpXVtwcmVmaXggKyAneCddLCBtaW5YKTtcclxuICAgICAgbWF4WSA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3knXSwgbWF4WSk7XHJcbiAgICAgIG1pblkgPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd5J10sIG1pblkpO1xyXG4gICAgfVxyXG5cclxuICAgIHdlaWdodE1heCA9IHdlaWdodE1heCB8fCAxO1xyXG4gICAgc2l6ZU1heCA9IHNpemVNYXggfHwgMTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3ZWlnaHRNYXg6IHdlaWdodE1heCxcclxuICAgICAgc2l6ZU1heDogc2l6ZU1heCxcclxuICAgICAgbWluWDogbWluWCxcclxuICAgICAgbWluWTogbWluWSxcclxuICAgICAgbWF4WDogbWF4WCxcclxuICAgICAgbWF4WTogbWF4WVxyXG4gICAgfTtcclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taWRkbGV3YXJlcycpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCBqdXN0IGNvcHkgdGhlIGdyYXBoaWMgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxyXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gd3JpdGVQcmVmaXggVGhlIHdyaXRlIHByZWZpeC5cclxuICAgKi9cclxuICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5ID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgpIHtcclxuICAgIHZhciBpLFxyXG4gICAgICAgIGwsXHJcbiAgICAgICAgYTtcclxuXHJcbiAgICBpZiAod3JpdGVQcmVmaXggKyAnJyA9PT0gcmVhZFByZWZpeCArICcnKVxyXG4gICAgICByZXR1cm47XHJcblxyXG4gICAgYSA9IHRoaXMuZ3JhcGgubm9kZXMoKTtcclxuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBhW2ldW3dyaXRlUHJlZml4ICsgJ3gnXSA9IGFbaV1bcmVhZFByZWZpeCArICd4J107XHJcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAneSddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3knXTtcclxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xyXG4gICAgfVxyXG5cclxuICAgIGEgPSB0aGlzLmdyYXBoLmVkZ2VzKCk7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgIGFbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID0gYVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXTtcclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRCBmb3IgdGhlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmV3IElELlxyXG4gICAqL1xyXG4gIHZhciBfZ2V0SUQgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaWQgPSAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gJycgKyAoKytpZCk7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gYW5pbWF0ZXMgYSBjYW1lcmEuIEl0IGhhcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgY2FtZXJhIHRvXHJcbiAgICogYW5pbWF0ZSwgdGhlIHZhbHVlcyBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gcmVhY2ggYW5kIGV2ZW50dWFsbHkgc29tZVxyXG4gICAqIG9wdGlvbnMuIEl0IHJldHVybnMgYSBudW1iZXIgaWQsIHRoYXQgeW91IGNhbiB1c2UgdG8ga2lsbCB0aGUgYW5pbWF0aW9uLFxyXG4gICAqIHdpdGggdGhlIG1ldGhvZCBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsKGlkKS5cclxuICAgKlxyXG4gICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XHJcbiAgICpcclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbk5ld0ZyYW1lIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgYSBuZXcgZnJhbWUuXHJcbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbkNvbXBsZXRlIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgY29tcGxldGVkIG9yIGtpbGxlZC5cclxuICAgKiAgIHs/KHN0cmluZ3xmdW5jdGlvbil9IGVhc2luZyAgICAgVGhlIG5hbWUgb2YgYSBmdW5jdGlvbiBmcm9tIHRoZSBwYWNrYWdlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MsIG9yIGEgY3VzdG9tIGVhc2luZ1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2NhbWVyYX0gIGNhbWVyYSAgVGhlIGNhbWVyYSB0byBhbmltYXRlLlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldCAgVGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoLlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3QgdG8gc3BlY2lmeSBzb21lIG9wdGlvbnMgdG9cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBmdW5jdGlvbi4gVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGVkIGluIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24uXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICBUaGUgYW5pbWF0aW9uIGlkLCB0byBtYWtlIGl0IGVhc3kgdG8ga2lsbFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3VnaCB0aGUgbWV0aG9kIFwic2lnbWEubWlzYy5hbmltYXRpb24ua2lsbFwiLlxyXG4gICAqL1xyXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgdmFsLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgICEoY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEpIHx8XHJcbiAgICAgIHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICF2YWxcclxuICAgIClcclxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5jYW1lcmE6IFdyb25nIGFyZ3VtZW50cy4nO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIHZhbC54ICE9PSAnbnVtYmVyJyAmJlxyXG4gICAgICB0eXBlb2YgdmFsLnkgIT09ICdudW1iZXInICYmXHJcbiAgICAgIHR5cGVvZiB2YWwucmF0aW8gIT09ICdudW1iZXInICYmXHJcbiAgICAgIHR5cGVvZiB2YWwuYW5nbGUgIT09ICdudW1iZXInXHJcbiAgICApXHJcbiAgICAgIHRocm93ICdUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSB2YWxpZCBjb29yZGluYXRlIGluIHRoZSBnaXZlbiB2YWwuJztcclxuXHJcbiAgICB2YXIgZm4sXHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgYW5pbSxcclxuICAgICAgICBlYXNpbmcsXHJcbiAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgaW5pdGlhbFZhbCxcclxuICAgICAgICBvID0gb3B0aW9ucyB8fCB7fSxcclxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKTtcclxuXHJcbiAgICAvLyBTdG9yZSBpbml0aWFsIHZhbHVlczpcclxuICAgIGluaXRpYWxWYWwgPSB7XHJcbiAgICAgIHg6IGNhbWVyYS54LFxyXG4gICAgICB5OiBjYW1lcmEueSxcclxuICAgICAgcmF0aW86IGNhbWVyYS5yYXRpbyxcclxuICAgICAgYW5nbGU6IGNhbWVyYS5hbmdsZVxyXG4gICAgfTtcclxuXHJcbiAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb247XHJcbiAgICBlYXNpbmcgPSB0eXBlb2Ygby5lYXNpbmcgIT09ICdmdW5jdGlvbicgP1xyXG4gICAgICBzaWdtYS51dGlscy5lYXNpbmdzW28uZWFzaW5nIHx8ICdxdWFkcmF0aWNJbk91dCddIDpcclxuICAgICAgby5lYXNpbmc7XHJcblxyXG4gICAgZm4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGNvZWYsXHJcbiAgICAgICAgICB0ID0gby5kdXJhdGlvbiA/IChzaWdtYS51dGlscy5kYXRlTm93KCkgLSBzdGFydCkgLyBvLmR1cmF0aW9uIDogMTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBhbmltYXRpb24gaXMgb3ZlcjpcclxuICAgICAgaWYgKHQgPj0gMSkge1xyXG4gICAgICAgIGNhbWVyYS5pc0FuaW1hdGVkID0gZmFsc2U7XHJcbiAgICAgICAgY2FtZXJhLmdvVG8oe1xyXG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/IHZhbC54IDogaW5pdGlhbFZhbC54LFxyXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/IHZhbC55IDogaW5pdGlhbFZhbC55LFxyXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID8gdmFsLnJhdGlvIDogaW5pdGlhbFZhbC5yYXRpbyxcclxuICAgICAgICAgIGFuZ2xlOiB2YWwuYW5nbGUgIT09IHVuZGVmaW5lZCA/IHZhbC5hbmdsZSA6IGluaXRpYWxWYWwuYW5nbGVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xyXG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxyXG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgby5vbkNvbXBsZXRlKCk7XHJcblxyXG4gICAgICAvLyBFbHNlLCBsZXQncyBrZWVwIGdvaW5nOlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvZWYgPSBlYXNpbmcodCk7XHJcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGNhbWVyYS5nb1RvKHtcclxuICAgICAgICAgIHg6IHZhbC54ICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICBpbml0aWFsVmFsLnggKyAodmFsLnggLSBpbml0aWFsVmFsLngpICogY29lZiA6XHJcbiAgICAgICAgICAgIGluaXRpYWxWYWwueCxcclxuICAgICAgICAgIHk6IHZhbC55ICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICBpbml0aWFsVmFsLnkgKyAodmFsLnkgLSBpbml0aWFsVmFsLnkpICogY29lZiA6XHJcbiAgICAgICAgICAgIGluaXRpYWxWYWwueSxcclxuICAgICAgICAgIHJhdGlvOiB2YWwucmF0aW8gIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8gKyAodmFsLnJhdGlvIC0gaW5pdGlhbFZhbC5yYXRpbykgKiBjb2VmIDpcclxuICAgICAgICAgICAgaW5pdGlhbFZhbC5yYXRpbyxcclxuICAgICAgICAgIGFuZ2xlOiB2YWwuYW5nbGUgIT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGUgKyAodmFsLmFuZ2xlIC0gaW5pdGlhbFZhbC5hbmdsZSkgKiBjb2VmIDpcclxuICAgICAgICAgICAgaW5pdGlhbFZhbC5hbmdsZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uTmV3RnJhbWUgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICBvLm9uTmV3RnJhbWUoKTtcclxuXHJcbiAgICAgICAgYW5pbS5mcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZCA9IF9nZXRJRCgpO1xyXG4gICAgYW5pbSA9IHtcclxuICAgICAgZnJhbWVJZDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSxcclxuICAgICAgdGFyZ2V0OiBjYW1lcmEsXHJcbiAgICAgIHR5cGU6ICdjYW1lcmEnLFxyXG4gICAgICBvcHRpb25zOiBvLFxyXG4gICAgICBmbjogZm5cclxuICAgIH07XHJcbiAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXSA9IGFuaW07XHJcblxyXG4gICAgcmV0dXJuIGlkO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEtpbGxzIGEgcnVubmluZyBhbmltYXRpb24uIEl0IHRyaWdnZXJzIHRoZSBldmVudHVhbCBvbkNvbXBsZXRlIGNhbGxiYWNrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZCAgVGhlIGlkIG9mIHRoZSBhbmltYXRpb24gdG8ga2lsbC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBSZXR1cm5zIHRoZSBzaWdtYS5taXNjLmFuaW1hdGlvbiBwYWNrYWdlLlxyXG4gICAqL1xyXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGwgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEgfHwgdHlwZW9mIGlkICE9PSAnbnVtYmVyJylcclxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5raWxsOiBXcm9uZyBhcmd1bWVudHMuJztcclxuXHJcbiAgICB2YXIgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xyXG5cclxuICAgIGlmIChvKSB7XHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcclxuICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbby5mcmFtZUlkXTtcclxuXHJcbiAgICAgIGlmIChvLnR5cGUgPT09ICdjYW1lcmEnKVxyXG4gICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcclxuICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogS2lsbHMgZXZlcnkgcnVubmluZyBhbmltYXRpb25zLCBvciBvbmx5IHRoZSBvbmUgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUsXHJcbiAgICogaWYgYSBzdHJpbmcgcGFyYW1ldGVyIGlzIGdpdmVuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8b2JqZWN0KX0gZmlsdGVyIEEgc3RyaW5nIHRvIGZpbHRlciB0aGUgYW5pbWF0aW9ucyB0byBraWxsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGFuaW1hdGlvbnMga2lsbGVkXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgd2F5LlxyXG4gICAqL1xyXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmtpbGxBbGwgPSBmdW5jdGlvbihmaWx0ZXIpIHtcclxuICAgIHZhciBvLFxyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGNvdW50ID0gMCxcclxuICAgICAgICB0eXBlID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgPyBmaWx0ZXIgOiBudWxsLFxyXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcclxuICAgICAgICBydW5uaW5nID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZztcclxuXHJcbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXHJcbiAgICAgIGlmIChcclxuICAgICAgICAoIXR5cGUgfHwgcnVubmluZ1tpZF0udHlwZSA9PT0gdHlwZSkgJiZcclxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcclxuICAgICAgKSB7XHJcbiAgICAgICAgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKG8uZnJhbWVJZCk7XHJcbiAgICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xyXG5cclxuICAgICAgICBpZiAoby50eXBlID09PSAnY2FtZXJhJylcclxuICAgICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXI6XHJcbiAgICAgICAgY291bnQrKztcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxyXG4gICAgICAgIGlmICh0eXBlb2YgKG8ub3B0aW9ucyB8fCB7fSkub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICByZXR1cm4gY291bnQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBcInRydWVcIiBpZiBhbnkgYW5pbWF0aW9uIHRoYXQgaXMgY3VycmVudGx5IHN0aWxsIHJ1bm5pbmcgbWF0Y2hlc1xyXG4gICAqIHRoZSBmaWx0ZXIgZ2l2ZW4gdG8gdGhlIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfG9iamVjdH0gZmlsdGVyIEEgc3RyaW5nIHRvIGZpbHRlciB0aGUgYW5pbWF0aW9ucyB0byBraWxsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgICAgUmV0dXJucyB0cnVlIGlmIGFueSBydW5uaW5nIGFuaW1hdGlvblxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLlxyXG4gICAqL1xyXG4gIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmhhcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xyXG4gICAgdmFyIGlkLFxyXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0ID0gdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyBmaWx0ZXIgOiBudWxsLFxyXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xyXG5cclxuICAgIGZvciAoaWQgaW4gcnVubmluZylcclxuICAgICAgaWYgKFxyXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxyXG4gICAgICAgICghdGFyZ2V0IHx8IHJ1bm5pbmdbaWRdLnRhcmdldCA9PT0gdGFyZ2V0KVxyXG4gICAgICApXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBoZWxwZXIgd2lsbCBiaW5kIGFueSBuby1ET00gcmVuZGVyZXIgKGZvciBpbnN0YW5jZSBjYW52YXMgb3IgV2ViR0wpXHJcbiAgICogdG8gaXRzIGNhcHRvcnMsIHRvIHByb3Blcmx5IGRpc3BhdGNoIHRoZSBnb29kIGV2ZW50cyB0byB0aGUgc2lnbWEgaW5zdGFuY2VcclxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxyXG4gICAqXHJcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5iaW5kRXZlbnRzID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICB2YXIgaSxcclxuICAgICAgICBsLFxyXG4gICAgICAgIG1YLFxyXG4gICAgICAgIG1ZLFxyXG4gICAgICAgIGNhcHRvcixcclxuICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICBmdW5jdGlvbiBnZXROb2RlcyhlKSB7XHJcbiAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgbVggPSAneCcgaW4gZS5kYXRhID8gZS5kYXRhLnggOiBtWDtcclxuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgaSxcclxuICAgICAgICAgIGosXHJcbiAgICAgICAgICBsLFxyXG4gICAgICAgICAgbixcclxuICAgICAgICAgIHgsXHJcbiAgICAgICAgICB5LFxyXG4gICAgICAgICAgcyxcclxuICAgICAgICAgIGluc2VydGVkLFxyXG4gICAgICAgICAgc2VsZWN0ZWQgPSBbXSxcclxuICAgICAgICAgIG1vZGlmaWVkWCA9IG1YICsgc2VsZi53aWR0aCAvIDIsXHJcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcclxuICAgICAgICAgIHBvaW50ID0gc2VsZi5jYW1lcmEuY2FtZXJhUG9zaXRpb24oXHJcbiAgICAgICAgICAgIG1YLFxyXG4gICAgICAgICAgICBtWVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICAgIG5vZGVzID0gc2VsZi5jYW1lcmEucXVhZHRyZWUucG9pbnQoXHJcbiAgICAgICAgICAgIHBvaW50LngsXHJcbiAgICAgICAgICAgIHBvaW50LnlcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICBpZiAobm9kZXMubGVuZ3RoKVxyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgIG4gPSBub2Rlc1tpXTtcclxuICAgICAgICAgIHggPSBuW3ByZWZpeCArICd4J107XHJcbiAgICAgICAgICB5ID0gbltwcmVmaXggKyAneSddO1xyXG4gICAgICAgICAgcyA9IG5bcHJlZml4ICsgJ3NpemUnXTtcclxuXHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICFuLmhpZGRlbiAmJlxyXG4gICAgICAgICAgICBtb2RpZmllZFggPiB4IC0gcyAmJlxyXG4gICAgICAgICAgICBtb2RpZmllZFggPCB4ICsgcyAmJlxyXG4gICAgICAgICAgICBtb2RpZmllZFkgPiB5IC0gcyAmJlxyXG4gICAgICAgICAgICBtb2RpZmllZFkgPCB5ICsgcyAmJlxyXG4gICAgICAgICAgICBNYXRoLnNxcnQoXHJcbiAgICAgICAgICAgICAgKG1vZGlmaWVkWCAtIHgpICogKG1vZGlmaWVkWCAtIHgpICtcclxuICAgICAgICAgICAgICAobW9kaWZpZWRZIC0geSkgKiAobW9kaWZpZWRZIC0geSlcclxuICAgICAgICAgICAgKSA8IHNcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGU6XHJcbiAgICAgICAgICAgIGluc2VydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXHJcbiAgICAgICAgICAgICAgaWYgKG4uc2l6ZSA+IHNlbGVjdGVkW2pdLnNpemUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShqLCAwLCBuKTtcclxuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaW5zZXJ0ZWQpXHJcbiAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChuKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEVkZ2VzKGUpIHtcclxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSkge1xyXG4gICAgICAgIC8vIE5vIGV2ZW50IGlmIHRoZSBzZXR0aW5nIGlzIG9mZjpcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpc0NhbnZhcyA9IChcclxuICAgICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzICYmIHNlbGYgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMuY2FudmFzKTtcclxuXHJcbiAgICAgIGlmICghaXNDYW52YXMpIHtcclxuICAgICAgICAvLyBBIHF1aWNrIGhhcmRjb2RlZCBydWxlIHRvIHByZXZlbnQgcGVvcGxlIGZyb20gdXNpbmcgdGhpcyBmZWF0dXJlXHJcbiAgICAgICAgLy8gd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXIgKHdoaWNoIGlzIG5vdCBnb29kIGVub3VnaCBhdCB0aGUgbW9tZW50KTpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAnVGhlIGVkZ2UgZXZlbnRzIGZlYXR1cmUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXInXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGUpIHtcclxuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xyXG4gICAgICAgIG1ZID0gJ3knIGluIGUuZGF0YSA/IGUuZGF0YS55IDogbVk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpLFxyXG4gICAgICAgICAgaixcclxuICAgICAgICAgIGwsXHJcbiAgICAgICAgICBhLFxyXG4gICAgICAgICAgZWRnZSxcclxuICAgICAgICAgIHMsXHJcbiAgICAgICAgICBtYXhFcHNpbG9uID0gc2VsZi5zZXR0aW5ncygnZWRnZUhvdmVyUHJlY2lzaW9uJyksXHJcbiAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICBjcCxcclxuICAgICAgICAgIG5vZGVJbmRleCA9IHt9LFxyXG4gICAgICAgICAgaW5zZXJ0ZWQsXHJcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxyXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcclxuICAgICAgICAgIG1vZGlmaWVkWSA9IG1ZICsgc2VsZi5oZWlnaHQgLyAyLFxyXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcclxuICAgICAgICAgICAgbVgsXHJcbiAgICAgICAgICAgIG1ZXHJcbiAgICAgICAgICApLFxyXG4gICAgICAgICAgZWRnZXMgPSBbXTtcclxuXHJcbiAgICAgIGlmIChpc0NhbnZhcykge1xyXG4gICAgICAgIHZhciBub2Rlc09uU2NyZWVuID0gc2VsZi5jYW1lcmEucXVhZHRyZWUuYXJlYShcclxuICAgICAgICAgIHNlbGYuY2FtZXJhLmdldFJlY3RhbmdsZShzZWxmLndpZHRoLCBzZWxmLmhlaWdodClcclxuICAgICAgICApO1xyXG4gICAgICAgIGZvciAoYSA9IG5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICBub2RlSW5kZXhbYVtpXS5pZF0gPSBhW2ldO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBlZGdlcyA9IHNlbGYuY2FtZXJhLmVkZ2VxdWFkdHJlZS5wb2ludChcclxuICAgICAgICAgIHBvaW50LngsXHJcbiAgICAgICAgICBwb2ludC55XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSkge1xyXG4gICAgICAgIGluc2VydGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBzZWxlY3RlZC5sZW5ndGg7IGorKylcclxuICAgICAgICAgIGlmIChlZGdlLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkLnNwbGljZShqLCAwLCBlZGdlKTtcclxuICAgICAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcclxuICAgICAgICAgIHNlbGVjdGVkLnB1c2goZWRnZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChlZGdlcy5sZW5ndGgpXHJcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgICAgc291cmNlID0gc2VsZi5ncmFwaC5ub2RlcyhlZGdlLnNvdXJjZSk7XHJcbiAgICAgICAgICB0YXJnZXQgPSBzZWxmLmdyYXBoLm5vZGVzKGVkZ2UudGFyZ2V0KTtcclxuICAgICAgICAgIC8vIChIQUNLKSB3ZSBjYW4ndCBnZXQgZWRnZVtwcmVmaXggKyAnc2l6ZSddIG9uIFdlYkdMIHJlbmRlcmVyOlxyXG4gICAgICAgICAgcyA9IGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fFxyXG4gICAgICAgICAgICAgIGVkZ2VbJ3JlYWRfJyArIHByZWZpeCArICdzaXplJ107XHJcblxyXG4gICAgICAgICAgLy8gRmlyc3QsIGxldCdzIGlkZW50aWZ5IHdoaWNoIGVkZ2VzIGFyZSBkcmF3bi4gVG8gZG8gdGhpcywgd2Uga2VlcFxyXG4gICAgICAgICAgLy8gZXZlcnkgZWRnZXMgdGhhdCBoYXZlIGF0IGxlYXN0IG9uZSBleHRyZW1pdHkgZGlzcGxheWVkIGFjY29yZGluZyB0b1xyXG4gICAgICAgICAgLy8gdGhlIHF1YWR0cmVlIGFuZCB0aGUgXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuXHJcbiAgICAgICAgICAvLyBlZGdlcy5cclxuICAgICAgICAgIC8vIFRoZW4sIGxldCdzIGNoZWNrIGlmIHRoZSBtb3VzZSBpcyBvbiB0aGUgZWRnZSAod2Ugc3VwcG9zZSB0aGF0IGl0XHJcbiAgICAgICAgICAvLyBpcyBhIGxpbmUgc2VnbWVudCkuXHJcblxyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAhZWRnZS5oaWRkZW4gJiZcclxuICAgICAgICAgICAgIXNvdXJjZS5oaWRkZW4gJiYgIXRhcmdldC5oaWRkZW4gJiZcclxuICAgICAgICAgICAgKCFpc0NhbnZhcyB8fFxyXG4gICAgICAgICAgICAgIChub2RlSW5kZXhbZWRnZS5zb3VyY2VdIHx8IG5vZGVJbmRleFtlZGdlLnRhcmdldF0pKSAmJlxyXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXREaXN0YW5jZShcclxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICBtb2RpZmllZFgsXHJcbiAgICAgICAgICAgICAgbW9kaWZpZWRZKSA+IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddICYmXHJcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxyXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcclxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gdGFyZ2V0W3ByZWZpeCArICdzaXplJ11cclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBpZiAoZWRnZS50eXBlID09ICdjdXJ2ZScgfHwgZWRnZS50eXBlID09ICdjdXJ2ZWRBcnJvdycpIHtcclxuICAgICAgICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5pc1BvaW50T25CZXppZXJDdXJ2ZShcclxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxyXG4gICAgICAgICAgICAgICAgICBtb2RpZmllZFksXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgICBjcC54MSxcclxuICAgICAgICAgICAgICAgICAgY3AueTEsXHJcbiAgICAgICAgICAgICAgICAgIGNwLngyLFxyXG4gICAgICAgICAgICAgICAgICBjcC55MixcclxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcclxuICAgICAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoXHJcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd4J10sXHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgICBlZGdlLmNjKTtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uUXVhZHJhdGljQ3VydmUoXHJcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkWCxcclxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxyXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcclxuICAgICAgICAgICAgICAgICAgY3AueCxcclxuICAgICAgICAgICAgICAgICAgY3AueSxcclxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcclxuICAgICAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudChcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWCxcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcclxuICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcclxuICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneSddLFxyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgocywgbWF4RXBzaWxvbilcclxuICAgICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGJpbmRDYXB0b3IoY2FwdG9yKSB7XHJcbiAgICAgIHZhciBub2RlcyxcclxuICAgICAgICAgIGVkZ2VzLFxyXG4gICAgICAgICAgb3Zlck5vZGVzID0ge30sXHJcbiAgICAgICAgICBvdmVyRWRnZXMgPSB7fTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xyXG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZS5kYXRhKTtcclxuXHJcbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcclxuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xyXG5cclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrTm9kZScsIHtcclxuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlcycsIHtcclxuICAgICAgICAgICAgbm9kZTogbm9kZXMsXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja0VkZ2UnLCB7XHJcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxyXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZXMnLCB7XHJcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzLFxyXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnLCB7Y2FwdG9yOiBlLmRhdGF9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gb25Eb3VibGVDbGljayhlKSB7XHJcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlLmRhdGEpO1xyXG5cclxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xyXG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XHJcblxyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xyXG4gICAgICAgICAgICBub2RlOiBub2Rlc1swXSxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGVzJywge1xyXG4gICAgICAgICAgICBub2RlOiBub2RlcyxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWRnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZScsIHtcclxuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tFZGdlcycsIHtcclxuICAgICAgICAgICAgZWRnZTogZWRnZXMsXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2soZSkge1xyXG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2snLCBlLmRhdGEpO1xyXG5cclxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xyXG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XHJcblxyXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGUnLCB7XHJcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzWzBdLFxyXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tOb2RlcycsIHtcclxuICAgICAgICAgICAgbm9kZTogbm9kZXMsXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZScsIHtcclxuICAgICAgICAgICAgZWRnZTogZWRnZXNbMF0sXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja0VkZ2VzJywge1xyXG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcclxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrU3RhZ2UnLCB7Y2FwdG9yOiBlLmRhdGF9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gb25PdXQoZSkge1xyXG4gICAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgayxcclxuICAgICAgICAgICAgZXZlbnQgPSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudDogeyBub2RlczogW10sIGVkZ2VzOiBbXSwgfSxcclxuICAgICAgICAgICAgICBlbnRlcjogeyBub2RlczogW10sIGVkZ2VzOiBbXSwgfSxcclxuICAgICAgICAgICAgICBsZWF2ZTogeyBub2RlczogW10sIGVkZ2VzOiBbXSwgfSxcclxuICAgICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWF2ZSA9IGV2ZW50LmxlYXZlO1xyXG5cclxuICAgICAgICBmb3IgKGsgaW4gb3Zlck5vZGVzKVxyXG4gICAgICAgICAgbGVhdmUubm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xyXG5cclxuICAgICAgICBmb3IgKGsgaW4gb3ZlckVkZ2VzKVxyXG4gICAgICAgICAgbGVhdmUuZWRnZXMucHVzaChvdmVyRWRnZXNba10pO1xyXG5cclxuICAgICAgICBvdmVyTm9kZXMgPSB7fTtcclxuICAgICAgICBvdmVyRWRnZXMgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKGxlYXZlLm5vZGVzLmxlbmd0aCB8fCBsZWF2ZS5lZGdlcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnaG92ZXJzJywgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gb25Nb3ZlKGUpIHtcclxuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcclxuICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgbm9kZXMgPSBnZXROb2RlcyhlKTtcclxuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xyXG5cclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgayxcclxuICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgZWRnZSxcclxuICAgICAgICAgICAgbmV3T3V0Tm9kZXMgPSBbXSxcclxuICAgICAgICAgICAgbmV3T3Zlck5vZGVzID0gW10sXHJcbiAgICAgICAgICAgIGN1cnJlbnRPdmVyTm9kZXMgPSB7fSxcclxuICAgICAgICAgICAgbmV3T3V0RWRnZXMgPSBbXSxcclxuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzID0gW10sXHJcbiAgICAgICAgICAgIGN1cnJlbnRPdmVyRWRnZXMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBub2RlczpcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgIGN1cnJlbnRPdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xyXG4gICAgICAgICAgaWYgKCFvdmVyTm9kZXNbbm9kZS5pZF0pIHtcclxuICAgICAgICAgICAgbmV3T3Zlck5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIG92ZXJOb2Rlc1tub2RlLmlkXSA9IG5vZGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBubyBtb3JlIG92ZXJyZWQgbm9kZXM6XHJcbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcclxuICAgICAgICAgIGlmICghY3VycmVudE92ZXJOb2Rlc1trXSkge1xyXG4gICAgICAgICAgICBuZXdPdXROb2Rlcy5wdXNoKG92ZXJOb2Rlc1trXSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyTm9kZXNba107XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIG5ld2x5IG92ZXJyZWQgZWRnZXM6XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBlZGdlID0gZWRnZXNbaV07XHJcbiAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcclxuICAgICAgICAgIGlmICghb3ZlckVkZ2VzW2VkZ2UuaWRdKSB7XHJcbiAgICAgICAgICAgIG5ld092ZXJFZGdlcy5wdXNoKGVkZ2UpO1xyXG4gICAgICAgICAgICBvdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgbm8gbW9yZSBvdmVycmVkIGVkZ2VzOlxyXG4gICAgICAgIGZvciAoayBpbiBvdmVyRWRnZXMpXHJcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyRWRnZXNba10pIHtcclxuICAgICAgICAgICAgbmV3T3V0RWRnZXMucHVzaChvdmVyRWRnZXNba10pO1xyXG4gICAgICAgICAgICBkZWxldGUgb3ZlckVkZ2VzW2tdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV3T3V0RWRnZXMubGVuZ3RoIHx8IG5ld092ZXJFZGdlcy5sZW5ndGggfHxcclxuICAgICAgICAgICAgIG5ld091dE5vZGVzLmxlbmd0aCB8fCBuZXdPdmVyTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2hvdmVycycsIHtcclxuICAgICAgICAgICAgY3VycmVudDoge1xyXG4gICAgICAgICAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgICAgICAgICBlZGdlczogZWRnZXMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudGVyOiB7XHJcbiAgICAgICAgICAgICAgbm9kZXM6IG5ld092ZXJOb2RlcyxcclxuICAgICAgICAgICAgICBlZGdlczogbmV3T3ZlckVkZ2VzLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWF2ZToge1xyXG4gICAgICAgICAgICAgIG5vZGVzOiBuZXdPdXROb2RlcyxcclxuICAgICAgICAgICAgICBlZGdlczogbmV3T3V0RWRnZXMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEJpbmQgZXZlbnRzOlxyXG4gICAgICBjYXB0b3IuYmluZCgnY2xpY2snLCBvbkNsaWNrKTtcclxuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlZG93bicsIG9uTW92ZSk7XHJcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZXVwJywgb25Nb3ZlKTtcclxuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlbW92ZScsIG9uTW92ZSk7XHJcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZW91dCcsIG9uT3V0KTtcclxuICAgICAgY2FwdG9yLmJpbmQoJ2RvdWJsZWNsaWNrJywgb25Eb3VibGVDbGljayk7XHJcbiAgICAgIGNhcHRvci5iaW5kKCdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jYXB0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgYmluZENhcHRvcih0aGlzLmNhcHRvcnNbaV0pO1xyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcblxyXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBoZWxwZXIgd2lsbCBiaW5kIGFueSBET00gcmVuZGVyZXIgKGZvciBpbnN0YW5jZSBzdmcpXHJcbiAgICogdG8gaXRzIGNhcHRvcnMsIHRvIHByb3Blcmx5IGRpc3BhdGNoIHRoZSBnb29kIGV2ZW50cyB0byB0aGUgc2lnbWEgaW5zdGFuY2VcclxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxyXG4gICAqXHJcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5iaW5kRE9NRXZlbnRzID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoLFxyXG4gICAgICAgIGhvdmVyZWQgPSB7bm9kZXM6IFtdLCBlZGdlczogW119O1xyXG5cclxuICAgIC8vIERPTUVsZW1lbnQgYWJzdHJhY3Rpb25cclxuICAgIGZ1bmN0aW9uIEVsZW1lbnQoZG9tRWxlbWVudCkge1xyXG5cclxuICAgICAgLy8gSGVscGVyc1xyXG4gICAgICB0aGlzLmF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZU5TKG51bGwsIGF0dHJOYW1lKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFByb3BlcnRpZXNcclxuICAgICAgdGhpcy50YWcgPSBkb21FbGVtZW50LnRhZ05hbWU7XHJcbiAgICAgIHRoaXMuY2xhc3MgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XHJcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmF0dHIoJ2lkJyk7XHJcblxyXG4gICAgICAvLyBNZXRob2RzXHJcbiAgICAgIHRoaXMuaXNOb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ub2RlJyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmlzRWRnZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5pc0hvdmVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICEhfnRoaXMuY2xhc3MuaW5kZXhPZihzZWxmLnNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3ZlcicpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENsaWNrXHJcbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XHJcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEdlbmVyaWMgZXZlbnRcclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGljaycsIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpKTtcclxuXHJcbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XHJcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnQoZS50YXJnZXQpO1xyXG5cclxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXHJcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja05vZGUnLCB7XHJcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbGVtZW50LmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdjbGlja1N0YWdlJyk7XHJcblxyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG91YmxlIGNsaWNrXHJcbiAgICBmdW5jdGlvbiBkb3VibGVDbGljayhlKSB7XHJcbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEdlbmVyaWMgZXZlbnRcclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGljaycsIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpKTtcclxuXHJcbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XHJcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IEVsZW1lbnQoZS50YXJnZXQpO1xyXG5cclxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXHJcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja05vZGUnLCB7XHJcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbGVtZW50LmF0dHIoJ2RhdGEtbm9kZS1pZCcpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVDbGlja1N0YWdlJyk7XHJcblxyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT24gb3ZlclxyXG4gICAgZnVuY3Rpb24gb25PdmVyKGUpIHtcclxuICAgICAgdmFyIHRhcmdldCA9IGUudG9FbGVtZW50IHx8IGUudGFyZ2V0O1xyXG5cclxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykgfHwgIXRhcmdldClcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICB2YXIgZWxfc3ZnID0gbmV3IEVsZW1lbnQodGFyZ2V0KSxcclxuICAgICAgICBldmVudCA9IHtcclxuICAgICAgICAgIGxlYXZlOiB7bm9kZXM6IFtdLCBlZGdlczogW119LFxyXG4gICAgICAgICAgZW50ZXI6IHtub2RlczogW10sIGVkZ2VzOiBbXX0sXHJcbiAgICAgICAgICBjYXB0b3I6IHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZWw7XHJcblxyXG4gICAgICBpZiAoZWxfc3ZnLmlzTm9kZSgpKSB7XHJcbiAgICAgICAgZWwgPSBncmFwaC5ub2RlcyhlbF9zdmcuYXR0cignZGF0YS1ub2RlLWlkJykpO1xyXG4gICAgICAgIGV2ZW50LmVudGVyLm5vZGVzID0gW2VsXTtcclxuICAgICAgICBob3ZlcmVkLm5vZGVzLnB1c2goZWwpO1xyXG4gICAgICB9IGVsc2UgaWYgKGVsX3N2Zy5pc0VkZ2UoKSkge1xyXG4gICAgICAgIGVsID0gZ3JhcGguZWRnZXMoZWxfc3ZnLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcclxuICAgICAgICBldmVudC5lbnRlci5lZGdlcyA9IFtlbF07XHJcbiAgICAgICAgaG92ZXJlZC5lZGdlcy5wdXNoKGVsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZXZlbnQuY3VycmVudCA9IGhvdmVyZWQ7XHJcbiAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnaG92ZXJzJywgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9uIG91dFxyXG4gICAgZnVuY3Rpb24gb25PdXQoZSkge1xyXG4gICAgICB2YXIgdGFyZ2V0ID0gZS5mcm9tRWxlbWVudCB8fCBlLm9yaWdpbmFsVGFyZ2V0O1xyXG5cclxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIGVsX3N2ZyA9IG5ldyBFbGVtZW50KHRhcmdldCksXHJcbiAgICAgICAgZXZlbnQgPSB7XHJcbiAgICAgICAgICBsZWF2ZToge25vZGVzOiBbXSwgZWRnZXM6IFtdfSxcclxuICAgICAgICAgIGVudGVyOiB7bm9kZXM6IFtdLCBlZGdlczogW119LFxyXG4gICAgICAgICAgY2FwdG9yOiBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVsO1xyXG5cclxuICAgICAgaWYgKGVsX3N2Zy5pc05vZGUoKSkge1xyXG4gICAgICAgIGVsID0gZ3JhcGgubm9kZXMoZWxfc3ZnLmF0dHIoJ2RhdGEtbm9kZS1pZCcpKTtcclxuICAgICAgICBldmVudC5sZWF2ZS5ub2RlcyA9IFtlbF07XHJcbiAgICAgICAgaG92ZXJlZC5ub2Rlcy5wdXNoKGVsKTtcclxuICAgICAgfSBlbHNlIGlmIChlbF9zdmcuaXNFZGdlKCkpIHtcclxuICAgICAgICBlbCA9IGdyYXBoLmVkZ2VzKGVsX3N2Zy5hdHRyKCdkYXRhLWVkZ2UtaWQnKSk7XHJcbiAgICAgICAgZXZlbnQubGVhdmUuZWRnZXMgPSBbZWxdO1xyXG4gICAgICAgIGhvdmVyZWQuZWRnZXMucHVzaChlbCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBldmVudC5jdXJyZW50ID0gaG92ZXJlZDtcclxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdob3ZlcnMnLCBldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVnaXN0ZXJpbmcgRXZlbnRzOlxyXG5cclxuICAgIC8vIENsaWNrXHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGljaywgZmFsc2UpO1xyXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soY29udGFpbmVyLCAnY2xpY2snLCBkb3VibGVDbGljayk7XHJcblxyXG4gICAgLy8gVG91Y2ggY291bnRlcnBhcnRzXHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNsaWNrLCBmYWxzZSk7XHJcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICd0b3VjaHN0YXJ0JywgZG91YmxlQ2xpY2spO1xyXG5cclxuICAgIC8vIE1vdXNlb3ZlclxyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uT3ZlciwgdHJ1ZSk7XHJcblxyXG4gICAgLy8gTW91c2VvdXRcclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uT3V0LCB0cnVlKTtcclxuICB9O1xyXG59KS5jYWxsKHRoaXMpO1xyXG5cclxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIGxpc3RlbnMgdG8gXCJob3ZlcnNcIiBldmVudHMgZnJvbSBhIHJlbmRlcmVyIGFuZCByZW5kZXJzXHJcbiAgICogdGhlIG5vZGVzIGRpZmZlcmVudGx5IG9uIHRoZSB0b3AgbGF5ZXIuXHJcbiAgICogVGhlIGdvYWwgaXMgdG8gbWFrZSBhbnkgbm9kZSBsYWJlbCByZWFkYWJsZSB3aXRoIHRoZSBtb3VzZSwgYW5kIHRvXHJcbiAgICogaGlnaGxpZ2h0IGhvdmVyZWQgbm9kZXMgYW5kIGVkZ2VzLlxyXG4gICAqXHJcbiAgICogSXQgaGFzIHRvIGJlIGNhbGxlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHJlbGF0ZWQgcmVuZGVyZXIuXHJcbiAgICovXHJcbiAgc2lnbWEubWlzYy5kcmF3SG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgY3VycmVudCA9IHtub2RlczogW10sIGVkZ2VzOiBbXX07XHJcblxyXG4gICAgdGhpcy5iaW5kKCdob3ZlcnMnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICBjdXJyZW50ID0gZXZlbnQuZGF0YS5jdXJyZW50O1xyXG4gICAgICBkcmF3KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIGRyYXcoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XHJcbiAgICAgIHZhciBjID0gc2VsZi5jb250ZXh0cy5ob3Zlci5jYW52YXMsXHJcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xyXG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgICBlbmQgPSBlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpID8gMSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgIHJlbmRlclBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZWxlbWVudHM6IGN1cnJlbnQubm9kZXMsXHJcbiAgICAgICAgICAgIHJlbmRlcmVyczogc2lnbWEuY2FudmFzLmhvdmVycyxcclxuICAgICAgICAgICAgdHlwZTogJ25vZGVzJyxcclxuICAgICAgICAgICAgY3R4OiBzZWxmLmNvbnRleHRzLmhvdmVyLFxyXG4gICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgZ3JhcGg6IHNlbGYuZ3JhcGgsXHJcbiAgICAgICAgICAgIHNldHRpbmdzOiBlbWJlZFNldHRpbmdzLFxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIuY2xlYXJSZWN0KDAsIDAsIGMud2lkdGgsIGMuaGVpZ2h0KTtcclxuXHJcbiAgICAgIC8vIE5vZGUgcmVuZGVyXHJcbiAgICAgIGlmIChjdXJyZW50Lm5vZGVzLmxlbmd0aCA+IDAgJiYgZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSkge1xyXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMuYXBwbHlSZW5kZXJlcnMocmVuZGVyUGFyYW1zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRWRnZSByZW5kZXJcclxuICAgICAgaWYgKGN1cnJlbnQuZWRnZXMubGVuZ3RoID4gMCAmJiBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSkge1xyXG4gICAgICAgIHJlbmRlclBhcmFtcy5yZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZWhvdmVycztcclxuICAgICAgICByZW5kZXJQYXJhbXMuZWxlbWVudHMgPSBjdXJyZW50LmVkZ2VzO1xyXG4gICAgICAgIHJlbmRlclBhcmFtcy50eXBlID0gJ2VkZ2VzJztcclxuICAgICAgICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLmFwcGx5UmVuZGVyZXJzKHJlbmRlclBhcmFtcyk7XHJcblxyXG4gICAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlSG92ZXJFeHRyZW1pdGllcycpKSB7XHJcbiAgICAgICAgICByZW5kZXJQYXJhbXMucmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmV4dHJlbWl0aWVzO1xyXG4gICAgICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5hcHBseVJlbmRlcmVycyhyZW5kZXJQYXJhbXMpO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vZHJhdyBub2RlcyBvdmVyIGVkZ2VzXHJcbiAgICAgICAgICByZW5kZXJQYXJhbXMuY3R4ID0gc2VsZi5jb250ZXh0cy5ub2RlcztcclxuICAgICAgICAgIHJlbmRlclBhcmFtcy50eXBlID0gJ25vZGVzJztcclxuICAgICAgICAgIHJlbmRlclBhcmFtcy5yZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMubm9kZXM7XHJcbiAgICAgICAgICByZW5kZXJQYXJhbXMuZWxlbWVudHMgPSBjdXJyZW50Lm5vZGVzO1xyXG4gICAgICAgICAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5hcHBseVJlbmRlcmVycyhyZW5kZXJQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn0pLmNhbGwodGhpcyk7XHJcbiIsIjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93IG5ldyBFcnJvcignc2lnbWEgaXMgbm90IGRlY2xhcmVkJyk7XHJcblxyXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZTpcclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmxheW91dHMubm92ZXJsYXAnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogTm92ZXJsYXAgTGF5b3V0XHJcbiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAqXHJcbiAgICogQXV0aG9yOiBAYXBpdHRzIC8gQW5kcmV3IFBpdHRzXHJcbiAgICogQWxnb3JpdGhtOiBAamFjb215bWEgLyBNYXRoaWV1IEphY29teSAob3JpZ2luYWxseSBjb250cmlidXRlZCB0byBHZXBoaSBhbmQgcG9ydGVkIHRvIHNpZ21hLmpzIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBieSBAYW5kcGl0dHMgd2l0aCBwZXJtaXNzaW9uKVxyXG4gICAqIEFja25vd2xlZGdlbWVudDogQHNoZXltYW4gLyBTw6liYXN0aWVuIEhleW1hbm4gKHNvbWUgaW5zcGlyYXRpb24gaGFzIGJlZW4gdGFrZW4gZnJvbSBvdGhlciBNSVQgbGljZW5zZWQgbGF5b3V0IGFsZ29yaXRobXMgYXV0aG9yZWQgYnkgQHNoZXltYW4pXHJcbiAgICogVmVyc2lvbjogMC4xXHJcbiAgICovXHJcblxyXG4gIHZhciBzZXR0aW5ncyA9IHtcclxuICAgIHNwZWVkOiAzLFxyXG4gICAgc2NhbGVOb2RlczogMS4yLFxyXG4gICAgbm9kZU1hcmdpbjogNS4wLFxyXG4gICAgZ3JpZFNpemU6IDIwLFxyXG4gICAgcGVybWl0dGVkRXhwYW5zaW9uOiAxLjEsXHJcbiAgICByZW5kZXJlckluZGV4OiAwLFxyXG4gICAgbWF4SXRlcmF0aW9uczogNTAwXHJcbiAgfTtcclxuXHJcbiAgdmFyIF9pbnN0YW5jZSA9IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBFdmVudCBlbWl0dGVyIE9iamVjdFxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIHZhciBfZXZlbnRFbWl0dGVyID0ge307XHJcblxyXG4gICAvKipcclxuICAgKiBOb3ZlcmxhcCBPYmplY3RcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuICBmdW5jdGlvbiBOb3ZlcmxhcCgpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoc2lnSW5zdCwgb3B0aW9ucykge1xyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgIC8vIFByb3BlcnRpZXNcclxuICAgICAgdGhpcy5zaWdJbnN0ID0gc2lnSW5zdDtcclxuICAgICAgdGhpcy5jb25maWcgPSBzaWdtYS51dGlscy5leHRlbmQob3B0aW9ucywgc2V0dGluZ3MpO1xyXG4gICAgICB0aGlzLmVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xyXG4gICAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLm5vZGVzKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IG9wdGlvbnMubm9kZXM7XHJcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMubm9kZXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghc2lnbWEucGx1Z2lucyB8fCB0eXBlb2Ygc2lnbWEucGx1Z2lucy5hbmltYXRlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbWEucGx1Z2lucy5hbmltYXRlIGlzIG5vdCBkZWNsYXJlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdGF0ZVxyXG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW5nbGUgbGF5b3V0IGl0ZXJhdGlvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy5hdG9taWNHbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcgfHwgdGhpcy5pdGVyQ291bnQgPCAxKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzIHx8IHRoaXMuc2lnSW5zdC5ncmFwaC5ub2RlcygpLFxyXG4gICAgICAgICAgbm9kZXNDb3VudCA9IG5vZGVzLmxlbmd0aCxcclxuICAgICAgICAgIGksXHJcbiAgICAgICAgICBuLFxyXG4gICAgICAgICAgbjEsXHJcbiAgICAgICAgICBuMixcclxuICAgICAgICAgIHhtaW4gPSBJbmZpbml0eSxcclxuICAgICAgICAgIHhtYXggPSAtSW5maW5pdHksXHJcbiAgICAgICAgICB5bWluID0gSW5maW5pdHksXHJcbiAgICAgICAgICB5bWF4ID0gLUluZmluaXR5LFxyXG4gICAgICAgICAgeHdpZHRoLFxyXG4gICAgICAgICAgeWhlaWdodCxcclxuICAgICAgICAgIHhjZW50ZXIsXHJcbiAgICAgICAgICB5Y2VudGVyLFxyXG4gICAgICAgICAgZ3JpZCxcclxuICAgICAgICAgIHJvdyxcclxuICAgICAgICAgIGNvbCxcclxuICAgICAgICAgIG1pblhCb3gsXHJcbiAgICAgICAgICBtYXhYQm94LFxyXG4gICAgICAgICAgbWluWUJveCxcclxuICAgICAgICAgIG1heFlCb3gsXHJcbiAgICAgICAgICBhZGphY2VudE5vZGVzLFxyXG4gICAgICAgICAgc3ViUm93LFxyXG4gICAgICAgICAgc3ViQ29sLFxyXG4gICAgICAgICAgbnhtaW4sXHJcbiAgICAgICAgICBueG1heCxcclxuICAgICAgICAgIG55bWluLFxyXG4gICAgICAgICAgbnltYXg7XHJcblxyXG4gICAgICB0aGlzLml0ZXJDb3VudC0tO1xyXG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgIG4uZG4uZHggPSAwO1xyXG4gICAgICAgIG4uZG4uZHkgPSAwO1xyXG5cclxuICAgICAgICAvL0ZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBib3RoIHggYW5kIHkgYWNyb3NzIGFsbCBub2Rlc1xyXG4gICAgICAgIHhtaW4gPSBNYXRoLm1pbih4bWluLCBuLmRuX3ggLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xyXG4gICAgICAgIHhtYXggPSBNYXRoLm1heCh4bWF4LCBuLmRuX3ggKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xyXG4gICAgICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBuLmRuX3kgLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xyXG4gICAgICAgIHltYXggPSBNYXRoLm1heCh5bWF4LCBuLmRuX3kgKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgeHdpZHRoID0geG1heCAtIHhtaW47XHJcbiAgICAgIHloZWlnaHQgPSB5bWF4IC0geW1pbjtcclxuICAgICAgeGNlbnRlciA9ICh4bWluICsgeG1heCkgLyAyO1xyXG4gICAgICB5Y2VudGVyID0gKHltaW4gKyB5bWF4KSAvIDI7XHJcbiAgICAgIHhtaW4gPSB4Y2VudGVyIC0gc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnh3aWR0aCAvIDI7XHJcbiAgICAgIHhtYXggPSB4Y2VudGVyICsgc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnh3aWR0aCAvIDI7XHJcbiAgICAgIHltaW4gPSB5Y2VudGVyIC0gc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnloZWlnaHQgLyAyO1xyXG4gICAgICB5bWF4ID0geWNlbnRlciArIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip5aGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgIGdyaWQgPSB7fTsgLy9BbiBvYmplY3Qgb2Ygb2JqZWN0cyB3aGVyZSBncmlkW3Jvd11bY29sXSBpcyBhbiBhcnJheSBvZiBub2RlIGlkcyByZXByZXNlbnRpbmcgbm9kZXMgdGhhdCBmYWxsIGluIHRoYXQgZ3JpZC4gTm9kZXMgY2FuIGZhbGwgaW4gbW9yZSB0aGFuIG9uZSBncmlkXHJcblxyXG4gICAgICBmb3Iocm93ID0gMDsgcm93IDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IHJvdysrKSB7XHJcbiAgICAgICAgZ3JpZFtyb3ddID0ge307XHJcbiAgICAgICAgZm9yKGNvbCA9IDA7IGNvbCA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyBjb2wrKykge1xyXG4gICAgICAgICAgZ3JpZFtyb3ddW2NvbF0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vUGxhY2Ugbm9kZXMgaW4gZ3JpZFxyXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xyXG4gICAgICAgIG4gPSBub2Rlc1tpXTtcclxuXHJcbiAgICAgICAgbnhtaW4gPSBuLmRuX3ggLSAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcclxuICAgICAgICBueG1heCA9IG4uZG5feCArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pO1xyXG4gICAgICAgIG55bWluID0gbi5kbl95IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbik7XHJcbiAgICAgICAgbnltYXggPSBuLmRuX3kgKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKTtcclxuXHJcbiAgICAgICAgbWluWEJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueG1pbiAtIHhtaW4pIC8gKHhtYXggLSB4bWluKSApO1xyXG4gICAgICAgIG1heFhCb3ggPSBNYXRoLmZsb29yKHNlbGYuY29uZmlnLmdyaWRTaXplKiAobnhtYXggLSB4bWluKSAvICh4bWF4IC0geG1pbikgKTtcclxuICAgICAgICBtaW5ZQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG55bWluIC0geW1pbikgLyAoeW1heCAtIHltaW4pICk7XHJcbiAgICAgICAgbWF4WUJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueW1heCAtIHltaW4pIC8gKHltYXggLSB5bWluKSApO1xyXG4gICAgICAgIGZvcihjb2wgPSBtaW5YQm94OyBjb2wgPD0gbWF4WEJveDsgY29sKyspIHtcclxuICAgICAgICAgIGZvcihyb3cgPSBtaW5ZQm94OyByb3cgPD0gbWF4WUJveDsgcm93KyspIHtcclxuICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbF0ucHVzaChuLmlkKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBhZGphY2VudE5vZGVzID0ge307IC8vQW4gb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBub2RlIGlkcyBvZiBhZGphY2VudCBub2RlcyAoZWl0aGVyIGluIHNhbWUgZ3JpZCBib3ggb3IgYWRqYWNlbnQgZ3JpZCBib3gpIGZvciBhbGwgbm9kZXNcclxuXHJcbiAgICAgIGZvcihyb3cgPSAwOyByb3cgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgcm93KyspIHtcclxuICAgICAgICBmb3IoY29sID0gMDsgY29sIDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IGNvbCsrKSB7XHJcbiAgICAgICAgICBncmlkW3Jvd11bY29sXS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVJZCkge1xyXG4gICAgICAgICAgICBpZighYWRqYWNlbnROb2Rlc1tub2RlSWRdKSB7XHJcbiAgICAgICAgICAgICAgYWRqYWNlbnROb2Rlc1tub2RlSWRdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHN1YlJvdyA9IE1hdGgubWF4KDAsIHJvdyAtIDEpOyBzdWJSb3cgPD0gTWF0aC5taW4ocm93ICsgMSwgc2VsZi5jb25maWcuZ3JpZFNpemUgLSAxKTsgc3ViUm93KyspIHtcclxuICAgICAgICAgICAgICBmb3Ioc3ViQ29sID0gTWF0aC5tYXgoMCwgY29sIC0gMSk7IHN1YkNvbCA8PSBNYXRoLm1pbihjb2wgKyAxLCAgc2VsZi5jb25maWcuZ3JpZFNpemUgLSAxKTsgc3ViQ29sKyspIHtcclxuICAgICAgICAgICAgICAgIGdyaWRbc3ViUm93XVtzdWJDb2xdLmZvckVhY2goZnVuY3Rpb24oc3ViTm9kZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmKHN1Yk5vZGVJZCAhPT0gbm9kZUlkICYmIGFkamFjZW50Tm9kZXNbbm9kZUlkXS5pbmRleE9mKHN1Yk5vZGVJZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnROb2Rlc1tub2RlSWRdLnB1c2goc3ViTm9kZUlkKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vSWYgdHdvIG5vZGVzIG92ZXJsYXAgdGhlbiByZXB1bHNlIHRoZW1cclxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcclxuICAgICAgICBuMSA9IG5vZGVzW2ldO1xyXG4gICAgICAgIGFkamFjZW50Tm9kZXNbbjEuaWRdLmZvckVhY2goZnVuY3Rpb24obm9kZUlkKSB7XHJcbiAgICAgICAgICB2YXIgbjIgPSBzZWxmLnNpZ0luc3QuZ3JhcGgubm9kZXMobm9kZUlkKTtcclxuICAgICAgICAgIHZhciB4RGlzdCA9IG4yLmRuX3ggLSBuMS5kbl94O1xyXG4gICAgICAgICAgdmFyIHlEaXN0ID0gbjIuZG5feSAtIG4xLmRuX3k7XHJcbiAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCh4RGlzdCp4RGlzdCArIHlEaXN0KnlEaXN0KTtcclxuICAgICAgICAgIHZhciBjb2xsaXNpb24gPSAoZGlzdCA8ICgobjEuZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKyAobjIuZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikpKTtcclxuICAgICAgICAgIGlmKGNvbGxpc2lvbikge1xyXG4gICAgICAgICAgICBzZWxmLnJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZihkaXN0ID4gMCkge1xyXG4gICAgICAgICAgICAgIG4yLmRuLmR4ICs9IHhEaXN0IC8gZGlzdCAqICgxICsgbjEuZG5fc2l6ZSk7XHJcbiAgICAgICAgICAgICAgbjIuZG4uZHkgKz0geURpc3QgLyBkaXN0ICogKDEgKyBuMS5kbl9zaXplKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuMi5kbi5keCArPSB4d2lkdGggKiAwLjAxICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xyXG4gICAgICAgICAgICAgIG4yLmRuLmR5ICs9IHloZWlnaHQgKiAwLjAxICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgIGlmKCFuLmZpeGVkKSB7XHJcbiAgICAgICAgICBuLmRuX3ggPSBuLmRuX3ggKyBuLmRuLmR4ICogMC4xICogc2VsZi5jb25maWcuc3BlZWQ7XHJcbiAgICAgICAgICBuLmRuX3kgPSBuLmRuX3kgKyBuLmRuLmR5ICogMC4xICogc2VsZi5jb25maWcuc3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZih0aGlzLnJ1bm5pbmcgJiYgdGhpcy5pdGVyQ291bnQgPCAxKSB7XHJcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ28gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuaXRlckNvdW50ID0gdGhpcy5jb25maWcubWF4SXRlcmF0aW9ucztcclxuXHJcbiAgICAgIHdoaWxlICh0aGlzLnJ1bm5pbmcpIHtcclxuICAgICAgICB0aGlzLmF0b21pY0dvKCk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5ydW5uaW5nKSByZXR1cm47XHJcblxyXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLnNpZ0luc3QuZ3JhcGgubm9kZXMoKTtcclxuXHJcbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLnNpZ0luc3QucmVuZGVyZXJzW3NlbGYuY29uZmlnLnJlbmRlcmVySW5kZXhdLm9wdGlvbnMucHJlZml4O1xyXG5cclxuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8vIEluaXQgbm9kZXNcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG5vZGVzW2ldLmRuX3ggPSBub2Rlc1tpXVtwcmVmaXggKyAneCddO1xyXG4gICAgICAgIG5vZGVzW2ldLmRuX3kgPSBub2Rlc1tpXVtwcmVmaXggKyAneSddO1xyXG4gICAgICAgIG5vZGVzW2ldLmRuX3NpemUgPSBub2Rlc1tpXVtwcmVmaXggKyAnc2l6ZSddO1xyXG4gICAgICAgIG5vZGVzW2ldLmRuID0ge1xyXG4gICAgICAgICAgZHg6IDAsXHJcbiAgICAgICAgICBkeTogMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgX2V2ZW50RW1pdHRlcltzZWxmLnNpZ0luc3QuaWRdLmRpc3BhdGNoRXZlbnQoJ3N0YXJ0Jyk7XHJcbiAgICAgIHRoaXMuZ28oKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuc2lnSW5zdC5ncmFwaC5ub2RlcygpO1xyXG5cclxuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAodGhpcy5lYXNpbmcpIHtcclxuICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnaW50ZXJwb2xhdGUnKTtcclxuICAgICAgICBzaWdtYS5wbHVnaW5zLmFuaW1hdGUoXHJcbiAgICAgICAgICBzZWxmLnNpZ0luc3QsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHg6ICdkbl94JyxcclxuICAgICAgICAgICAgeTogJ2RuX3knXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBlYXNpbmc6IHNlbGYuZWFzaW5nLFxyXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICBzZWxmLnNpZ0luc3QucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldLmRuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIG5vZGVzW2ldLmRuX3ggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uZG5feSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIF9ldmVudEVtaXR0ZXJbc2VsZi5zaWdJbnN0LmlkXS5kaXNwYXRjaEV2ZW50KCdzdG9wJyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzZWxmLmR1cmF0aW9uXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAvLyBBcHBseSBjaGFuZ2VzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbm9kZXNbaV0ueCA9IG5vZGVzW2ldLmRuX3g7XHJcbiAgICAgICAgICBub2Rlc1tpXS55ID0gbm9kZXNbaV0uZG5feTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2lnSW5zdC5yZWZyZXNoKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIG5vZGVzW2ldLmRuID0gbnVsbDtcclxuICAgICAgICAgIG5vZGVzW2ldLmRuX3ggPSBudWxsO1xyXG4gICAgICAgICAgbm9kZXNbaV0uZG5feSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ldmVudEVtaXR0ZXJbc2VsZi5zaWdJbnN0LmlkXS5kaXNwYXRjaEV2ZW50KCdzdG9wJyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuc2lnSW5zdCA9IG51bGw7XHJcbiAgICAgIHRoaXMuY29uZmlnID0gbnVsbDtcclxuICAgICAgdGhpcy5lYXNpbmcgPSBudWxsO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJbnRlcmZhY2VcclxuICAgKiAtLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbmZpZ3VyZSB0aGUgbGF5b3V0IGFsZ29yaXRobS5cclxuXHJcbiAgICogUmVjb2duaXplZCBvcHRpb25zOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVyIGluIHRoZSBzZXR0aW5nc1xyXG4gICAqIG9iamVjdDpcclxuICAgKlxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc2NhbGVOb2RlcyAgICAgICAgICBUaGUgcmF0aW8gdG8gc2NhbGUgbm9kZXMgYnkgLSBhIGxhcmdlciByYXRpbyB3aWxsIGxlYWQgdG8gbW9yZSBzcGFjZSBhcm91bmQgbGFyZ2VyIG5vZGVzXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBub2RlTWFyZ2luICAgICAgICAgIEEgZml4ZWQgbWFyZ2luIHRvIGFwcGx5IGFyb3VuZCBub2RlcyByZWdhcmRsZXNzIG9mIHNpemVcclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXHJcbiAgICogICB7P2ludGVnZXJ9ICAgICAgICAgICBncmlkU2l6ZSAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyB0byB1c2Ugd2hlbiBwYXJ0aW9uaW5nIG5vZGVzIGludG8gYSBncmlkIGZvciBlZmZpY2llbnQgY29tcHV0YXRpb25cclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHBlcm1pdHRlZEV4cGFuc2lvbiAgQSBwZXJtaXR0ZWQgZXhwYW5zaW9uIGZhY3RvciB0byB0aGUgb3ZlcmFsbCBzaXplIG9mIHRoZSBuZXR3b3JrIGFwcGxpZWQgYXQgZWFjaCBpdGVyYXRpb25cclxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxyXG4gICAqICAgez8oZnVuY3Rpb258c3RyaW5nKX0gZWFzaW5nICAgICAgICAgICAgICBFaXRoZXIgdGhlIG5hbWUgb2YgYW4gZWFzaW5nIGluIHRoZSBzaWdtYS51dGlscy5lYXNpbmdzIHBhY2thZ2Ugb3IgYSBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY0luT3V0IGVhc2luZyBmcm9tIHRoaXMgcGFja2FnZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICpcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnICBUaGUgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXJ9IFJldHVybnMgYW4gZXZlbnQgZW1pdHRlci5cclxuICAgKi9cclxuICBzaWdtYS5wcm90b3R5cGUuY29uZmlnTm92ZXJsYXAgPSBmdW5jdGlvbihjb25maWcpIHtcclxuXHJcbiAgICB2YXIgc2lnSW5zdCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKCFjb25maWcpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJjb25maWdcIicpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBpbnN0YW5jZSBpZiB1bmRlZmluZWRcclxuICAgIGlmICghX2luc3RhbmNlW3NpZ0luc3QuaWRdKSB7XHJcbiAgICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXSA9IG5ldyBOb3ZlcmxhcCgpO1xyXG5cclxuICAgICAgX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXSA9IHt9O1xyXG4gICAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF0pO1xyXG5cclxuICAgICAgLy8gQmluZGluZyBvbiBraWxsIHRvIGNsZWFyIHRoZSByZWZlcmVuY2VzXHJcbiAgICAgIHNpZ0luc3QuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5raWxsKCk7XHJcbiAgICAgICAgX2luc3RhbmNlW3NpZ0luc3QuaWRdID0gbnVsbDtcclxuICAgICAgICBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdID0gbnVsbDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgX2luc3RhbmNlW3NpZ0luc3QuaWRdLmluaXQoc2lnSW5zdCwgY29uZmlnKTtcclxuXHJcbiAgICByZXR1cm4gX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgbGF5b3V0IGFsZ29yaXRobS4gSXQgd2lsbCB1c2UgdGhlIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb24gaWYgbm9cclxuICAgKiBuZXcgY29uZmlndXJhdGlvbiBpcyBwYXNzZWQuXHJcblxyXG4gICAqIFJlY29nbml6ZWQgb3B0aW9uczpcclxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlciBpbiB0aGUgc2V0dGluZ3NcclxuICAgKiBvYmplY3RcclxuICAgKlxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc3BlZWQgICAgICAgICAgICAgICBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgdGhlIGNvbnZlcmdlbmNlIHNwZWVkIGF0IHRoZSBjb3N0IG9mIHByZWNpc2lvblxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgc2NhbGVOb2RlcyAgICAgICAgICBUaGUgcmF0aW8gdG8gc2NhbGUgbm9kZXMgYnkgLSBhIGxhcmdlciByYXRpbyB3aWxsIGxlYWQgdG8gbW9yZSBzcGFjZSBhcm91bmQgbGFyZ2VyIG5vZGVzXHJcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBub2RlTWFyZ2luICAgICAgICAgIEEgZml4ZWQgbWFyZ2luIHRvIGFwcGx5IGFyb3VuZCBub2RlcyByZWdhcmRsZXNzIG9mIHNpemVcclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIG1heEl0ZXJhdGlvbnMgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBiZWZvcmUgdGhlIGxheW91dCBjb21wbGV0ZXMuXHJcbiAgICogICB7P2ludGVnZXJ9ICAgICAgICAgICBncmlkU2l6ZSAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyB0byB1c2Ugd2hlbiBwYXJ0aW9uaW5nIG5vZGVzIGludG8gYSBncmlkIGZvciBlZmZpY2llbnQgY29tcHV0YXRpb25cclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHBlcm1pdHRlZEV4cGFuc2lvbiAgQSBwZXJtaXR0ZWQgZXhwYW5zaW9uIGZhY3RvciB0byB0aGUgb3ZlcmFsbCBzaXplIG9mIHRoZSBuZXR3b3JrIGFwcGxpZWQgYXQgZWFjaCBpdGVyYXRpb25cclxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIHJlbmRlcmVySW5kZXggICAgICAgVGhlIGluZGV4IG9mIHRoZSByZW5kZXJlciB0byB1c2UgZm9yIG5vZGUgY28tb3JkaW5hdGVzLiBEZWZhdWx0cyB0byB6ZXJvLlxyXG4gICAqICAgez8oZnVuY3Rpb258c3RyaW5nKX0gZWFzaW5nICAgICAgICAgICAgICBFaXRoZXIgdGhlIG5hbWUgb2YgYW4gZWFzaW5nIGluIHRoZSBzaWdtYS51dGlscy5lYXNpbmdzIHBhY2thZ2Ugb3IgYSBmdW5jdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY0luT3V0IGVhc2luZyBmcm9tIHRoaXMgcGFja2FnZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIGR1cmF0aW9uICAgICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBcImFuaW1hdGlvbnNUaW1lXCIgc2V0dGluZyB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICpcclxuICAgKlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgIFRoZSBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3NpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlcn0gUmV0dXJucyBhbiBldmVudCBlbWl0dGVyLlxyXG4gICAqL1xyXG5cclxuICBzaWdtYS5wcm90b3R5cGUuc3RhcnROb3ZlcmxhcCA9IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cclxuICAgIHZhciBzaWdJbnN0ID0gdGhpcztcclxuXHJcbiAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgIHRoaXMuY29uZmlnTm92ZXJsYXAoc2lnSW5zdCwgY29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0uc3RhcnQoKTtcclxuXHJcbiAgICByZXR1cm4gX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBoYXMgc3RhcnRlZCBhbmQgaXMgbm90IGNvbXBsZXRlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2lnbWEucHJvdG90eXBlLmlzTm92ZXJsYXBSdW5uaW5nID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xyXG5cclxuICAgIHJldHVybiAhIV9pbnN0YW5jZVtzaWdJbnN0LmlkXSAmJiBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0ucnVubmluZztcclxuICB9O1xyXG5cclxufSkuY2FsbCh0aGlzKTsiLCIvKipcclxuICogVGhpcyBwbHVnaW4gcHJvdmlkZXMgYSBtZXRob2QgdG8gYW5pbWF0ZSBhIHNpZ21hIGluc3RhbmNlIGJ5IGludGVycG9sYXRpbmdcclxuICogc29tZSBub2RlIHByb3BlcnRpZXMuIENoZWNrIHRoZSBzaWdtYS5wbHVnaW5zLmFuaW1hdGUgZnVuY3Rpb24gZG9jIG9yIHRoZVxyXG4gKiBleGFtcGxlcy9hbmltYXRlLmh0bWwgY29kZSBzYW1wbGUgdG8ga25vdyBtb3JlLlxyXG4gKi9cclxuKGZ1bmN0aW9uKCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcclxuXHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5wbHVnaW5zJyk7XHJcblxyXG4gIHZhciBfaWQgPSAwLFxyXG4gICAgICBfY2FjaGUgPSB7fTtcclxuXHJcbiAgLy8gVE9PTElORyBGVU5DVElPTlM6XHJcbiAgLy8gKioqKioqKioqKioqKioqKioqXHJcbiAgZnVuY3Rpb24gcGFyc2VDb2xvcih2YWwpIHtcclxuICAgIGlmIChfY2FjaGVbdmFsXSlcclxuICAgICAgcmV0dXJuIF9jYWNoZVt2YWxdO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBbMCwgMCwgMF07XHJcblxyXG4gICAgaWYgKHZhbC5tYXRjaCgvXiMvKSkge1xyXG4gICAgICB2YWwgPSAodmFsIHx8ICcnKS5yZXBsYWNlKC9eIy8sICcnKTtcclxuICAgICAgcmVzdWx0ID0gKHZhbC5sZW5ndGggPT09IDMpID9cclxuICAgICAgICBbXHJcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpLFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KSxcclxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNilcclxuICAgICAgICBdIDpcclxuICAgICAgICBbXHJcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgxKSwgMTYpLFxyXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMyksIDE2KSxcclxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoNCkgKyB2YWwuY2hhckF0KDUpLCAxNilcclxuICAgICAgICBdO1xyXG4gICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL14gKnJnYmE/ICpcXCgvKSkge1xyXG4gICAgICB2YWwgPSB2YWwubWF0Y2goXHJcbiAgICAgICAgL14gKnJnYmE/ICpcXCggKihbMC05XSopICosICooWzAtOV0qKSAqLCAqKFswLTldKikgKigsLiopP1xcKSAqJC9cclxuICAgICAgKTtcclxuICAgICAgcmVzdWx0ID0gW1xyXG4gICAgICAgICt2YWxbMV0sXHJcbiAgICAgICAgK3ZhbFsyXSxcclxuICAgICAgICArdmFsWzNdXHJcbiAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgX2NhY2hlW3ZhbF0gPSB7XHJcbiAgICAgIHI6IHJlc3VsdFswXSxcclxuICAgICAgZzogcmVzdWx0WzFdLFxyXG4gICAgICBiOiByZXN1bHRbMl1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIF9jYWNoZVt2YWxdO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVDb2xvcnMoYzEsIGMyLCBwKSB7XHJcbiAgICBjMSA9IHBhcnNlQ29sb3IoYzEpO1xyXG4gICAgYzIgPSBwYXJzZUNvbG9yKGMyKTtcclxuXHJcbiAgICB2YXIgYyA9IHtcclxuICAgICAgcjogYzEuciAqICgxIC0gcCkgKyBjMi5yICogcCxcclxuICAgICAgZzogYzEuZyAqICgxIC0gcCkgKyBjMi5nICogcCxcclxuICAgICAgYjogYzEuYiAqICgxIC0gcCkgKyBjMi5iICogcFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gJ3JnYignICsgW2MuciB8IDAsIGMuZyB8IDAsIGMuYiB8IDBdLmpvaW4oJywnKSArICcpJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhbmltYXRlIHNvbWUgc3BlY2lmaWVkIG5vZGUgcHJvcGVydGllcy4gSXQgd2lsbFxyXG4gICAqIGJhc2ljYWxseSBjYWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgaW50ZXJwb2xhdGUgdGhlIHZhbHVlcyBhbmQgY2FsbCB0aGVcclxuICAgKiByZWZyZXNoIG1ldGhvZCBkdXJpbmcgYSBzcGVjaWZpZWQgZHVyYXRpb24uXHJcbiAgICpcclxuICAgKiBFdmVudHMgZmlyZWQgdGhvdWdoIHNpZ21hIGluc3RhbmNlOlxyXG4gICAqICoqKioqKioqKioqKipcclxuICAgKiBhbmltYXRlLnN0YXJ0ICBGaXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICogYW5pbWF0ZS5lbmQgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcclxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgc2V0dGluZ3NcclxuICAgKiBvYmplY3Q6XHJcbiAgICpcclxuICAgKiAgIHs/YXJyYXl9ICAgICAgICAgICAgIG5vZGVzICAgICAgQW4gYXJyYXkgb2Ygbm9kZSBvYmplY3RzIG9yIG5vZGUgaWRzLiBJZlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3Qgc3BlY2lmaWVkLCBhbGwgbm9kZXMgb2YgdGhlIGdyYXBoXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgYW5pbWF0ZWQuXHJcbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi4gSWYgbm90XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgdGhlIFwiYW5pbWF0aW9uc1RpbWVcIiBzZXR0aW5nXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIG9mIHRoZSBzaWdtYSBpbnN0YW5jZSB3aWxsIGJlIHVzZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGVhZC5cclxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgRXZlbnR1YWxseSBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uIGlzIGVuZGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c2lnbWF9ICAgcyAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBhbmltYXRlIEFuIGhhc2ggd2l0aCB0aGUga2V5cyBiZWluZyB0aGUgbm9kZSBwcm9wZXJ0aWVzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0byBpbnRlcnBvbGF0ZSwgYW5kIHRoZSB2YWx1ZXMgYmVpbmcgdGhlIHJlbGF0ZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCB2YWx1ZXMuXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBFdmVudHVhbGx5IGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgc2lnbWEucGx1Z2lucy5hbmltYXRlID0gZnVuY3Rpb24ocywgYW5pbWF0ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIG8gPSBvcHRpb25zIHx8IHt9LFxyXG4gICAgICAgIGlkID0gKytfaWQsXHJcbiAgICAgICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uIHx8IHMuc2V0dGluZ3MoJ2FuaW1hdGlvbnNUaW1lJyksXHJcbiAgICAgICAgZWFzaW5nID0gdHlwZW9mIG8uZWFzaW5nID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzW28uZWFzaW5nXSA6XHJcbiAgICAgICAgICB0eXBlb2Ygby5lYXNpbmcgPT09ICdmdW5jdGlvbicgP1xyXG4gICAgICAgICAgby5lYXNpbmcgOlxyXG4gICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbk91dCxcclxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKSxcclxuICAgICAgICBub2RlcyxcclxuICAgICAgICBzdGFydFBvc2l0aW9ucztcclxuXHJcbiAgICBpZiAoby5ub2RlcyAmJiBvLm5vZGVzLmxlbmd0aCkge1xyXG4gICAgICBpZiAodHlwZW9mIG8ubm9kZXNbMF0gPT09ICdvYmplY3QnKVxyXG4gICAgICAgIG5vZGVzID0gby5ub2RlcztcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG5vZGVzID0gcy5ncmFwaC5ub2RlcyhvLm5vZGVzKTsgLy8gYXJndW1lbnQgaXMgYW4gYXJyYXkgb2YgSURzXHJcbiAgICB9XHJcbiAgICBlbHNlXHJcbiAgICAgIG5vZGVzID0gcy5ncmFwaC5ub2RlcygpO1xyXG5cclxuICAgIC8vIFN0b3JlIGluaXRpYWwgcG9zaXRpb25zOlxyXG4gICAgc3RhcnRQb3NpdGlvbnMgPSBub2Rlcy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBub2RlKSB7XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICByZXNbbm9kZS5pZF0gPSB7fTtcclxuICAgICAgZm9yIChrIGluIGFuaW1hdGUpXHJcbiAgICAgICAgaWYgKGsgaW4gbm9kZSlcclxuICAgICAgICAgIHJlc1tub2RlLmlkXVtrXSA9IG5vZGVba107XHJcbiAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LCB7fSk7XHJcblxyXG4gICAgcy5hbmltYXRpb25zID0gcy5hbmltYXRpb25zIHx8IE9iamVjdC5jcmVhdGUoe30pO1xyXG4gICAgc2lnbWEucGx1Z2lucy5raWxsQW5pbWF0ZShzKTtcclxuXHJcbiAgICBzLmRpc3BhdGNoRXZlbnQoJ2FuaW1hdGUuc3RhcnQnKTsgLy8gc2VuZCBhIHNpZ21hIGV2ZW50XHJcblxyXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcclxuICAgICAgdmFyIHAgPSAoc2lnbWEudXRpbHMuZGF0ZU5vdygpIC0gc3RhcnQpIC8gZHVyYXRpb247XHJcblxyXG4gICAgICBpZiAocCA+PSAxKSB7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGFuaW1hdGUpXHJcbiAgICAgICAgICAgIGlmIChrIGluIGFuaW1hdGUgJiYgYW5pbWF0ZVtrXSBpbiBub2RlKVxyXG4gICAgICAgICAgICAgIG5vZGVba10gPSBub2RlW2FuaW1hdGVba11dO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBzLnJlZnJlc2goe3NraXBJbmRleGF0aW9uOiB0cnVlfSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzLmRpc3BhdGNoRXZlbnQoJ2FuaW1hdGUuZW5kJyk7IC8vIHNlbmQgYSBzaWdtYSBldmVudFxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHAgPSBlYXNpbmcocCk7XHJcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGFuaW1hdGUpXHJcbiAgICAgICAgICAgIGlmIChrIGluIGFuaW1hdGUgJiYgYW5pbWF0ZVtrXSBpbiBub2RlKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGsubWF0Y2goL2NvbG9yJC8pKVxyXG4gICAgICAgICAgICAgICAgbm9kZVtrXSA9IGludGVycG9sYXRlQ29sb3JzKFxyXG4gICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uc1tub2RlLmlkXVtrXSxcclxuICAgICAgICAgICAgICAgICAgbm9kZVthbmltYXRlW2tdXSxcclxuICAgICAgICAgICAgICAgICAgcFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBub2RlW2tdID1cclxuICAgICAgICAgICAgICAgICAgbm9kZVthbmltYXRlW2tdXSAqIHAgK1xyXG4gICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uc1tub2RlLmlkXVtrXSAqICgxIC0gcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcy5yZWZyZXNoKHtza2lwSW5kZXhhdGlvbjogdHJ1ZX0pO1xyXG4gICAgICAgIHMuYW5pbWF0aW9uc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGVwKCk7XHJcbiAgfTtcclxuXHJcbiAgc2lnbWEucGx1Z2lucy5raWxsQW5pbWF0ZSA9IGZ1bmN0aW9uKHMpIHtcclxuICAgIGZvciAodmFyIGsgaW4gKHMuYW5pbWF0aW9ucyB8fCB7fSkpXHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHMuYW5pbWF0aW9uc1trXSk7XHJcbiAgfTtcclxufSkuY2FsbCh3aW5kb3cpO1xyXG4iLCI7KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCcpO1xyXG5cclxuICAvLyBJbml0aWFsaXplIHBhY2thZ2U6XHJcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5wbHVnaW5zJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNpZ21hIGRlc2lnblxyXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICpcclxuICAgKiBAYXV0aG9yIFPDqWJhc3RpZW4gSGV5bWFubiA8c2ViQGxpbmt1cmlvLnVzPiAoTGlua3VyaW91cylcclxuICAgKiBAdmVyc2lvbiAwLjRcclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgSmF2YXNjcmlwdCBzdHJpbmcgaW4gZG90IG5vdGF0aW9uIGludG8gYW4gb2JqZWN0IHJlZmVyZW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gb2JqIFRoZSBvYmplY3QuXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LCBlLmcuICdhLmIuZXRjJy5cclxuICAgKiBAcmV0dXJuIHs/fSAgICAgICAgICBUaGUgb2JqZWN0IHJlZmVyZW5jZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBzdHJUb09iamVjdFJlZihvYmosIHN0cikge1xyXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjM5Mzk0M1xyXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLicpLnJlZHVjZShmdW5jdGlvbihvYmosIGkpIHsgcmV0dXJuIG9ialtpXSB9LCBvYmopO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBjdXN0b20gdG9vbCBmdW5jdGlvbiByZW1vdmVzIGV2ZXJ5IHBhaXIga2V5L3ZhbHVlIGZyb20gYW4gaGFzaC4gVGhlXHJcbiAgICogZ29hbCBpcyB0byBhdm9pZCBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2hpbGUgc29tZSBvdGhlciByZWZlcmVuY2VzIGFyZVxyXG4gICAqIHN0aWxsIGhhbmdpbmcgaW4gc29tZSBzY29wZXMuLi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZW1wdHkuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIGVtcHR5IG9iamVjdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBlbXB0eU9iamVjdChvYmopIHtcclxuICAgIHZhciBrO1xyXG5cclxuICAgIGZvciAoayBpbiBvYmopXHJcbiAgICAgIGlmICghKCdoYXNPd25Qcm9wZXJ0eScgaW4gb2JqKSB8fCBvYmouaGFzT3duUHJvcGVydHkoaykpXHJcbiAgICAgICAgZGVsZXRlIG9ialtrXTtcclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmFzdCBkZWVwIGNvcHkgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG8gVGhlIG9iamVjdC5cclxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIG9iamVjdCBjb3B5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRlZXBDb3B5KG8pIHtcclxuICAgIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGZvciAodmFyIGkgaW4gbykge1xyXG4gICAgICBpZiAodHlwZW9mIG9baV0gPT09IFwib2JqZWN0XCIgJiYgb1tpXSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvcHlbaV0gPSBkZWVwQ29weShvW2ldKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygb1tpXSA9PT0gXCJmdW5jdGlvblwiICYmIG9baV0gIT09IG51bGwpIHtcclxuICAgICAgICAvLyBjbG9uZSBmdW5jdGlvbjpcclxuICAgICAgICBldmFsKFwiIGNvcHlbaV0gPSBcIiArICBvW2ldLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIC8vY29weVtpXSA9IG9baV0uYmluZChfZyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsc2VcclxuICAgICAgICBjb3B5W2ldID0gb1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb3B5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBwdXQgdGhlIHZhbHVlcyBpbiBkaWZmZXJlbnQgYmlucyB1c2luZyBhIGxpbmVhciBzY2FsZSxcclxuICAgKiBmb3IgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJpbnMgKGkuZS4gaGlzdG9ncmFtKS4gSXQgd2lsbCByZXR1cm4gYVxyXG4gICAqIGRpY3Rpb25hcnkgb2YgYmlucyBpbmRleGVkIGJ5IHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7YXJyYXl9ICB2YWx1ZXMgVGhlIHZhbHVlcy5cclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG5iaW5zICBUaGUgbnVtYmVyIG9mIGJpbnMuXHJcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgVGhlIGJhc2ljIGhpc3RvZ3JhbS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBiYXNlSGlzdG9ncmFtKHZhbHVlcywgbmJpbnMpIHtcclxuICAgIHZhciBudW1saXN0LFxyXG4gICAgICAgIG1pbixcclxuICAgICAgICBtYXgsXHJcbiAgICAgICAgYmluLFxyXG4gICAgICAgIHJlcyA9IHt9O1xyXG5cclxuICAgIGlmICghdmFsdWVzLmxlbmd0aClcclxuICAgICAgcmV0dXJuIHJlcztcclxuXHJcbiAgICAvLyBzb3J0IHZhbHVlcyBieSBpbnZlcnNlIG9yZGVyOlxyXG4gICAgbnVtbGlzdCA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgfSlcclxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbWluID0gbnVtbGlzdFswXTtcclxuICAgIG1heCA9IG51bWxpc3RbbnVtbGlzdC5sZW5ndGggLSAxXTtcclxuXHJcblxyXG4gICAgaWYgKG1heCAtIG1pbiAhPT0gMCkge1xyXG4gICAgICBudW1saXN0LmZvckVhY2goZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIGJpbiA9IE1hdGguZmxvb3IobmJpbnMgKiBNYXRoLmFicyhudW0gLSBtaW4pIC8gTWF0aC5hYnMobWF4IC0gbWluKSk7XHJcbiAgICAgICAgYmluIC09IChiaW4gPT0gbmJpbnMpID8gMSA6IDA7XHJcbiAgICAgICAgcmVzW251bV0gPSBiaW47XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gaWYgdGhlIG1heCBpcyB0aGUgc2FtZSBhcyB0aGUgbWluaW11bSwgd2UgcHV0IGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgc2FtZSBiaW4uXHJcbiAgICAgIG51bWxpc3QuZm9yRWFjaChmdW5jdGlvbihudW0pe1xyXG4gICAgICAgIHJlc1tudW1dID0gMDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZSBhIGNvbnNvbGlkYXRlZCBoaXN0b2dyYW0gb2YgdmFsdWVzIGdyb3VwZWQgYnlcclxuICAgKiBiaW5zLiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgb3JkZXJlZCBieSBiaW5zLiBFYWNoIG9iamVjdFxyXG4gICAqIGNvbnRhaW5zIHRoZSBsaXN0IG9mIGB2YWx1ZXNgIGluIHRoZSBgYmluYCwgdGhlIGBtaW5gIGFuZCBgbWF4YCB2YWx1ZXMsXHJcbiAgICogYW5kIHRoZSBgcmF0aW9gIG9mIHZhbHVlcyBpbiB0aGUgYmluIGNvbXBhcmVkIHRvIHRoZSBsYXJnZXN0IGJpbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gaCAgICAgICAgIFRoZSBub2RlcyBvciBlZGdlcyBoaXN0b2dyYW1zLlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcCAgICAgICAgIFRoZSBwcm9wZXJ0eSBhY2Nlc3Nvci5cclxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICBUaGUgY29uc29saWRhdGVkIGhpc3RvZ3JhbS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBoaXN0b2dyYW0oaCwgcCkge1xyXG4gICAgdmFyIGQgPSBbXSxcclxuICAgICAgICBiaW5zLFxyXG4gICAgICAgIG1heE9jYyA9IDA7XHJcblxyXG4gICAgaWYgKGggJiYgaFtwXSkge1xyXG4gICAgICBPYmplY3Qua2V5cyhoW3BdKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGJpbiA9IGhbcF1bdmFsdWVdO1xyXG4gICAgICAgIGRbYmluXSA9IGRbYmluXSB8fCBbXTtcclxuICAgICAgICBkW2Jpbl0ucHVzaCgrdmFsdWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGJpbnMgPSAoZC5sZW5ndGggIT09IDEgKSA/IGQubGVuZ3RoIDogNztcclxuXHJcbiAgICAgIGZvciAodmFyIGJpbiA9IDA7IGJpbiA8IGJpbnM7IGJpbisrKSB7XHJcbiAgICAgICAgaWYgKGRbYmluXSkge1xyXG4gICAgICAgICAgbWF4T2NjID0gKG1heE9jYyA+IGRbYmluXS5sZW5ndGgpID8gbWF4T2NjIDogZFtiaW5dLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGJpbiA9IDA7IGJpbiA8IGJpbnM7IGJpbisrKSB7XHJcbiAgICAgICAgaWYgKGRbYmluXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBkW2Jpbl0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZFtiaW5dID0ge1xyXG4gICAgICAgICAgYmluOiBiaW4sXHJcbiAgICAgICAgICB2YWx1ZXM6IGRbYmluXSxcclxuICAgICAgICAgIHJhdGlvOiBkW2Jpbl0ubGVuZ3RoIC8gbWF4T2NjXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBkW2Jpbl1bdmlzdWFsVmFyXSA9IGRlc2lnbi5wYWxldHRlLnNlcXVlbnRpYWxbYmluc11bYmluXTtcclxuXHJcbiAgICAgICAgaWYgKGRbYmluXS52YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBkW2Jpbl0ubWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgZFtiaW5dLnZhbHVlcyk7XHJcbiAgICAgICAgICBkW2Jpbl0ubWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgZFtiaW5dLnZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCByZWZlcmVuY2UgdG8gbm9kZXMgb3IgZWRnZXMgaW4gaGlzdG9ncmFtIGJpbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGggICAgICAgICBUaGUgbm9kZXMgb3IgZWRnZXMgaGlzdG9ncmFtcy5cclxuICAgKiBAcGFyYW0gIHtWaXNpb259IHZpc2lvbiAgICBUaGUgdmlzaW9uIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHAgICAgICAgICBUaGUgcHJvcGVydHkgYWNjZXNzb3IuXHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgVGhlIGNvbnNvbGlkYXRlZCBoaXN0b2dyYW0uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcmVzb2x2ZUhpc3RvZ3JhbShoLCB2aXNpb24sIHApIHtcclxuICAgIHZhciBpdGVtcyA9IHZpc2lvbi5nZXQocCksXHJcbiAgICAgIGl0ZW0sXHJcbiAgICAgIHZhbHVlLFxyXG4gICAgICBuQmlucyA9IGgubGVuZ3RoLFxyXG4gICAgICBtYXhPY2MgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGJpbiA9IDA7IGJpbiA8IG5CaW5zOyBiaW4rKykge1xyXG4gICAgICBoW2Jpbl0uaXRlbXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3Qua2V5cyhpdGVtcykuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zW3ZhbHVlXS5pdGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGl0ZW0gPSBpdGVtc1t2YWx1ZV0uaXRlbXNbaV07XHJcbiAgICAgICAgdmFsdWUgPSBzdHJUb09iamVjdFJlZihpdGVtLCBwKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgYmluID0gMDsgYmluIDwgaC5sZW5ndGg7IGJpbisrKSB7XHJcbiAgICAgICAgICBpZiAoKCEnbWluJyBpbiBoW2Jpbl0pIHx8ICghJ21heCcgaW4gaFtiaW5dKSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgaWYgKGhbYmluXS5taW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gaFtiaW5dLm1heCkge1xyXG4gICAgICAgICAgICBoW2Jpbl0uaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZvciAodmFyIGJpbiA9IDA7IGJpbiA8IG5CaW5zOyBiaW4rKykge1xyXG4gICAgICBpZiAoaFtiaW5dLml0ZW1zKSB7XHJcbiAgICAgICAgbWF4T2NjID0gKG1heE9jYyA+IGhbYmluXS5pdGVtcy5sZW5ndGgpID8gbWF4T2NjIDogaFtiaW5dLml0ZW1zLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGJpbiA9IDA7IGJpbiA8IG5CaW5zOyBiaW4rKykge1xyXG4gICAgICBoW2Jpbl0uaXRlbXNSYXRpbyA9IGhbYmluXS5pdGVtcy5sZW5ndGggLyBtYXhPY2M7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGg7XHJcbiAgfVxyXG5cclxuICAvLyBVdGlsaXRpZXNcclxuICBmdW5jdGlvbiBkb3dubG9hZChmaWxlRW50cnksIGV4dGVuc2lvbiwgZmlsZW5hbWUpIHtcclxuICAgIHZhciBibG9iID0gbnVsbCxcclxuICAgICAgICBvYmplY3RVcmwgPSBudWxsLFxyXG4gICAgICAgIGRhdGFVcmwgPSBudWxsO1xyXG5cclxuICAgIGlmKHdpbmRvdy5CbG9iKXtcclxuICAgICAgLy8gdXNlIEJsb2IgaWYgYXZhaWxhYmxlXHJcbiAgICAgIGJsb2IgPSBuZXcgQmxvYihbZmlsZUVudHJ5XSwge3R5cGU6ICd0ZXh0L2pzb24nfSk7XHJcbiAgICAgIG9iamVjdFVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIGVsc2UgdXNlIGRhdGFVUklcclxuICAgICAgZGF0YVVybCA9ICdkYXRhOnRleHQvanNvbjtjaGFyc2V0PVVURi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQoZmlsZUVudHJ5KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobmF2aWdhdG9yLm1zU2F2ZUJsb2IpIHsgLy8gSUUxMSsgOiAoaGFzIEJsb2IsIGJ1dCBub3QgYVtkb3dubG9hZF0pXHJcbiAgICAgIG5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIGZpbGVuYW1lKTtcclxuICAgIH0gZWxzZSBpZiAobmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHsgLy8gSUUxMCsgOiAoaGFzIEJsb2IsIGJ1dCBub3QgYVtkb3dubG9hZF0pXHJcbiAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIGZpbGVuYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEEtZG93bmxvYWRcclxuICAgICAgdmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnaHJlZicsICh3aW5kb3cuQmxvYikgPyBvYmplY3RVcmwgOiBkYXRhVXJsKTtcclxuICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBmaWxlbmFtZSB8fCAnZ3JhcGguJyArIGV4dGVuc2lvbik7XHJcblxyXG4gICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHRoZSBsaW5rIHRvIGJlIGFkZGVkIHRvIHRoZSBET00gYmVmb3JlIGl0IGNhbiBiZSBjbGlja2VkLlxyXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGFuY2hvcik7XHJcbiAgICAgIGFuY2hvci5jbGljaygpO1xyXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGFuY2hvcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9iamVjdFVybCkge1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyAvLyBGaXJlZm94IG5lZWRzIGEgdGltZW91dFxyXG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgY29uc3RydWN0b3IgaW5zdGFuY2lhdGVzIGEgbmV3IHZpc2lvbiBvbiBhIHNwZWNpZmllZCBkYXRhc2V0IChub2Rlc1xyXG4gICAqIG9yIGVkZ2VzKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hfSBzICAgICAgICAgICAgICBUaGUgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGRhdGFzZXROYW1lIFRoZSBkYXRhc2V0LiBBdmFpbGFibGUgb3B0aW9uczogJ25vZGVzJyxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VkZ2VzJy5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG1hcHBpbmdzICAgICAgVGhlIHN0eWxlIG1hcHBpbmdzIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhbGV0dGUgICAgICAgVGhlIHBhbGV0dGUgb2JqZWN0LlxyXG4gICAqIEByZXR1cm4ge1Zpc2lvbn0gICAgICAgICAgICAgICBUaGUgdmlzaW9uIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFZpc2lvbihzLCBkYXRhc2V0TmFtZSwgbWFwcGluZ3MsIHBhbGV0dGUpIHtcclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICAvLyBkZWZpbmVkIGJlbG93OlxyXG4gICAgdGhpcy52aXN1YWxWYXJzID0gbnVsbDtcclxuXHJcbiAgICAvLyBtYXBwaW5ncyBtYXkgYmUgb3ZlcnJpZGVuOlxyXG4gICAgdGhpcy5tYXBwaW5ncyA9IG51bGw7XHJcblxyXG4gICAgLy8gcGFsZXR0ZSBtYXkgYmUgb3ZlcnJpZGVuOlxyXG4gICAgdGhpcy5wYWxldHRlID0gcGFsZXR0ZTtcclxuXHJcbiAgICAvLyBpbmRleCBvZiBkYXRhIHByb3BlcnRpZXM6XHJcbiAgICB0aGlzLmlkeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgLy8gaGlzdG9ncmFtcyBvZiBkYXRhIHByb3BlcnRpZXMgZm9yIHZpc3VhbCB2YXJpYWJsZXM6XHJcbiAgICB0aGlzLmhpc3RvZ3JhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8vIGluZGV4IG9mIGRlcHJlY2F0ZWQgdmlzaW9ucyBvbiBkYXRhIHByb3BlcnRpZXM6XHJcbiAgICB0aGlzLmRlcHJlY2F0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8vIHNvbWUgb3JpZ2luYWwgc2lnbWEgc2V0dGluZ3M6XHJcbiAgICB0aGlzLnNpZ21hU2V0dGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNlcXVlbnRpYWwgb3IgcXVhbGl0YXRpdmUgZGF0YVxyXG4gICAgdGhpcy5kYXRhVHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8vIG9yaWdpbmFsIHZhbHVlcyBvZiB2aXN1YWwgdmFyaWFibGVzXHJcbiAgICB0aGlzLm9yaWdpbmFsVmlzdWFsVmFyaWFibGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgIC8vIG5vZGVzIG9yIGVkZ2VzOlxyXG4gICAgaWYgKGRhdGFzZXROYW1lID09PSAnbm9kZXMnKSB7XHJcbiAgICAgIHRoaXMudmlzdWFsVmFycyA9IFsnY29sb3InLCAnc2l6ZScsICdsYWJlbCcsICd0eXBlJywgJ2ljb24nLCAnaW1hZ2UnXTtcclxuICAgICAgdGhpcy5tYXBwaW5ncyA9IG1hcHBpbmdzLm5vZGVzO1xyXG4gICAgICB0aGlzLmRhdGFzZXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHMuZ3JhcGgubm9kZXMoKTsgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgPT09ICdlZGdlcycpIHtcclxuICAgICAgdGhpcy52aXN1YWxWYXJzID0gWydjb2xvcicsICdzaXplJywgJ2xhYmVsJywgJ3R5cGUnXTtcclxuICAgICAgdGhpcy5tYXBwaW5ncyA9IG1hcHBpbmdzLmVkZ2VzO1xyXG4gICAgICB0aGlzLmRhdGFzZXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHMuZ3JhcGguZWRnZXMoKTsgfVxyXG4gICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IFwiZGF0YXNldE5hbWVcIiBpcyBub3QgXCJub2Rlc1wiIG9yIFwiZWRnZXNcIiwgd2FzICcgKyBkYXRhc2V0TmFtZSk7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBpbmRleCB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZFxyXG4gICAgICogd2lsbCBjb21wdXRlIGFsbCBzdHlsZXMgcmVsYXRlZCB0byB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGZvciBlYWNoIGl0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAga2V5IFRoZSBwcm9wZXJ0eSBhY2Nlc3Nvci5cclxuICAgICAqL1xyXG4gICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coJ1Zpc2lvbi51cGRhdGUnLCBrZXkpO1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGFyZ3VtZW50OiBcImtleVwiLicpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogXCJrZXlcIiBpcyBub3QgYSBzdHJpbmcsIHdhcyAnICsga2V5KTtcclxuXHJcbiAgICAgIHZhciB2YWwsXHJcbiAgICAgICAgICBieUZuLFxyXG4gICAgICAgICAgc2NoZW1lRm4sXHJcbiAgICAgICAgICBpc1NlcXVlbnRpYWwgPSB1bmRlZmluZWQsXHJcbiAgICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcclxuXHJcbiAgICAgIGJ5Rm4gPSBmdW5jdGlvbihpdGVtLCBrZXkpIHsgcmV0dXJuIHN0clRvT2JqZWN0UmVmKGl0ZW0sIGtleSk7IH07XHJcbiAgICAgIHNjaGVtZUZuID0gZnVuY3Rpb24ocGFsZXR0ZSwga2V5KSB7IHJldHVybiBzdHJUb09iamVjdFJlZihwYWxldHRlLCBrZXkpOyB9O1xyXG5cclxuICAgICAgZnVuY3Rpb24gaW5zZXJ0SXRlbSh2YWwsIGl0ZW0pIHtcclxuICAgICAgICBpZiAoc2VsZi5pZHhba2V5XVt2YWxdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHNlbGYuaWR4W2tleV1bdmFsXSA9IHtcclxuICAgICAgICAgICAga2V5OiB2YWwsXHJcbiAgICAgICAgICAgIGl0ZW1zOiBbXSxcclxuICAgICAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxmLmlkeFtrZXldW3ZhbF0uaXRlbXMucHVzaChpdGVtKTtcclxuXHJcbiAgICAgICAgaWYgKGlzU2VxdWVudGlhbCB8fCBpc1NlcXVlbnRpYWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgaXNTZXF1ZW50aWFsID0gKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcclxuICAgICAgICAgIC8vIFRPRE86IHRocm93IGVycm9yIGlmIGlzIG51bWJlciBBTkQgKGlzIE5hTiBvciBpcyBJbmZpbml0eSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZGV4IHRoZSBjb2xsZWN0aW9uOlxyXG4gICAgICB0aGlzLmlkeFtrZXldID0ge307XHJcbiAgICAgIHRoaXMuZGF0YXNldCgpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YWwgPSBieUZuKGl0ZW0sIGtleSk7XHJcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpZiAoaXNBcnJheSkge1xyXG4gICAgICAgICAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWwpID8gaXNBcnJheSA6IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICBpbnNlcnRJdGVtKHZhbFswXSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGluc2VydEl0ZW0odiwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnNlcnRJdGVtKHZhbCwgaXRlbSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuZGF0YVR5cGVzW2tleV0gPSB7IHNlcXVlbnRpYWw6IGlzU2VxdWVudGlhbCwgYXJyYXk6IGlzQXJyYXkgfTtcclxuICAgICAgdGhpcy5kZXByZWNhdGVkW2tleV0gPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIG1heCBudW1iZXIgb2Ygb2NjdXJyZW5jZSBvZiB2YWx1ZXM6XHJcbiAgICAgIHZhciBtYXhPY2MgPSAwO1xyXG4gICAgICBmb3IgKHZhbCBpbiB0aGlzLmlkeFtrZXldKSB7XHJcbiAgICAgICAgbWF4T2NjID1cclxuICAgICAgICAgIChtYXhPY2MgPCB0aGlzLmlkeFtrZXldW3ZhbF0uaXRlbXMubGVuZ3RoKSA/XHJcbiAgICAgICAgICB0aGlzLmlkeFtrZXldW3ZhbF0uaXRlbXMubGVuZ3RoIDpcclxuICAgICAgICAgIG1heE9jYztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbnVtYmVyIG9mIG9jY3VycmVuY2UgLyBtYXggbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHRoZSB2YWx1ZTpcclxuICAgICAgT2JqZWN0LmtleXModGhpcy5pZHhba2V5XSkuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgc2VsZi5pZHhba2V5XVt2YWxdLnJhdGlvID1cclxuICAgICAgICAgIHBhcnNlRmxvYXQoc2VsZi5pZHhba2V5XVt2YWxdLml0ZW1zLmxlbmd0aCAvIG1heE9jYyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGZvcm1hdCxcclxuICAgICAgICAgIGNvbG9ySGlzdCxcclxuICAgICAgICAgIHNpemVIaXN0LFxyXG4gICAgICAgICAgY29sb3JTY2hlbWUsXHJcbiAgICAgICAgICB0eXBlU2NoZW1lLFxyXG4gICAgICAgICAgaWNvblNjaGVtZSxcclxuICAgICAgICAgIGltYWdlU2NoZW1lLFxyXG4gICAgICAgICAgYmlucyxcclxuICAgICAgICAgIHZpc3VhbFZhcnMsXHJcbiAgICAgICAgICBuc2V0ID0gMDtcclxuXHJcbiAgICAgIC8vIFZpc3VhbCB2YXJpYWJsZXMgbWFwcGVkIHRvIHRoZSBzcGVjaWZpZWQgcHJvcGVydHk6XHJcbiAgICAgIHZpc3VhbFZhcnMgPSBPYmplY3Qua2V5cyh0aGF0Lm1hcHBpbmdzKS5maWx0ZXIoZnVuY3Rpb24gKHZpc3VhbFZhcikge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAodGhhdC5tYXBwaW5nc1t2aXN1YWxWYXJdKSAmJlxyXG4gICAgICAgICAgKHRoYXQubWFwcGluZ3NbdmlzdWFsVmFyXS5ieSAhPT0gdW5kZWZpbmVkKSAmJlxyXG4gICAgICAgICAgKHRoYXQubWFwcGluZ3NbdmlzdWFsVmFyXS5ieS50b1N0cmluZygpID09IGtleSlcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBtYXBwaW5ncyBhbmQgY29tcHV0ZSBoaXN0b2dyYW1zIGlmIG5lZWRlZDpcclxuICAgICAgdmlzdWFsVmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2aXN1YWxWYXIpIHtcclxuICAgICAgICBzd2l0Y2ggKHZpc3VhbFZhcikge1xyXG4gICAgICAgICAgY2FzZSAnY29sb3InOlxyXG4gICAgICAgICAgICBjb2xvclNjaGVtZSA9IHRoYXQubWFwcGluZ3MuY29sb3Iuc2NoZW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvclNjaGVtZSAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2xvci5zY2hlbWUgXCInICsgY29sb3JTY2hlbWUgKyAnXCIgaXMgbm90IGEgc3RyaW5nLicpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzU2VxdWVudGlhbCkge1xyXG4gICAgICAgICAgICAgIGJpbnMgPSB0aGF0Lm1hcHBpbmdzLmNvbG9yLmJpbnMgfHwgNztcclxuICAgICAgICAgICAgICBzZWxmLmhpc3RvZ3JhbXMuY29sb3IgPSBzZWxmLmhpc3RvZ3JhbXMuY29sb3IgfHwge307XHJcbiAgICAgICAgICAgICAgc2VsZi5oaXN0b2dyYW1zLmNvbG9yW2tleV0gPSBiYXNlSGlzdG9ncmFtKE9iamVjdC5rZXlzKHNlbGYuaWR4W2tleV0pLCBiaW5zKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICBmb3JtYXQgPSB0aGF0Lm1hcHBpbmdzLmxhYmVsLmZvcm1hdCB8fCBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpID8gaXRlbSA6IGl0ZW0ubGFiZWw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVsLmZvcm1hdCBcIicgKyBmb3JtYXQgKyAnXCIgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ3NpemUnOlxyXG4gICAgICAgICAgICBpZiAoaXNTZXF1ZW50aWFsID09PSB1bmRlZmluZWQpIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc1NlcXVlbnRpYWwpXHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IFwiJyArIGtleSArICdcIiBpcyBub3QgYSBudW1iZXIuJyk7XHJcblxyXG4gICAgICAgICAgICBzZWxmLmhpc3RvZ3JhbXMuc2l6ZSA9IHNlbGYuaGlzdG9ncmFtcy5zaXplIHx8IHt9O1xyXG4gICAgICAgICAgICBzZWxmLmhpc3RvZ3JhbXMuc2l6ZVtrZXldID0gYmFzZUhpc3RvZ3JhbShcclxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLmlkeFtrZXldKSxcclxuICAgICAgICAgICAgICAodGhhdC5tYXBwaW5ncy5zaXplLmJpbnMgfHwgNylcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAndHlwZSc6XHJcbiAgICAgICAgICAgIHR5cGVTY2hlbWUgPSB0aGF0Lm1hcHBpbmdzLnR5cGUuc2NoZW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU2NoZW1lICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUuc2NoZW1lIFwiJyArIHR5cGVTY2hlbWUgKyAnXCIgaXMgbm90IGEgc3RyaW5nLicpO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnaWNvbic6XHJcbiAgICAgICAgICAgIGljb25TY2hlbWUgPSB0aGF0Lm1hcHBpbmdzLmljb24uc2NoZW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpY29uU2NoZW1lICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ljb24uc2NoZW1lIFwiJyArIGljb25TY2hlbWUgKyAnXCIgaXMgbm90IGEgc3RyaW5nLicpO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnaW1hZ2UnOlxyXG4gICAgICAgICAgICBpbWFnZVNjaGVtZSA9IHRoYXQubWFwcGluZ3MuaW1hZ2Uuc2NoZW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNjaGVtZSAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlLnNjaGVtZSBcIicgKyBpbWFnZVNjaGVtZSArICdcIiBpcyBub3QgYSBzdHJpbmcuJyk7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSBhbGwgc3R5bGVzIHJlbGF0ZWQgdG8gdGhlIHByb3BlcnR5IGZvciBlYWNoIGl0ZW06XHJcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuaWR4W2tleV0pLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHZpc3VhbFZhcnMuZm9yRWFjaChmdW5jdGlvbiAodmlzdWFsVmFyKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHZpc3VhbFZhcikge1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnY29sb3InOlxyXG4gICAgICAgICAgICAgIGlmIChpc1NlcXVlbnRpYWwpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuaWR4W2tleV1bdmFsXS5zdHlsZXMuY29sb3IgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgdmFyIGJpbiA9IHNlbGYuaGlzdG9ncmFtcy5jb2xvcltrZXldW3ZhbF07XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWVGbih0aGF0LnBhbGV0dGUsIGNvbG9yU2NoZW1lKVtiaW5zXVtiaW5dO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmlkeFtrZXldW3ZhbF0uc3R5bGVzLmNvbG9yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWVGbih0aGF0LnBhbGV0dGUsIGNvbG9yU2NoZW1lKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3Jvbmcgb3IgdW5kZWZpbmVkIGNvbG9yIHNjaGVtZS4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm1hcHBpbmdzLmNvbG9yLnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0SXRlbSA9IHNjaGVtZUZuKHRoYXQucGFsZXR0ZSwgY29sb3JTY2hlbWUpW3RoYXQubWFwcGluZ3MuY29sb3Iuc2V0XVtuc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICBuc2V0ID0gKG5zZXQgKyAxKSAlIHRoYXQubWFwcGluZ3MuY29sb3Iuc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJdGVtO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1lRm4odGhhdC5wYWxldHRlLCBjb2xvclNjaGVtZSlbdmFsXTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICAgIHNlbGYuaWR4W2tleV1bdmFsXS5zdHlsZXMubGFiZWwgPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0KGJ5Rm4oaXRlbSwga2V5KSk7XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3NpemUnOlxyXG4gICAgICAgICAgICAgIHNlbGYuaWR4W2tleV1bdmFsXS5zdHlsZXMuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgKyBzZWxmLmhpc3RvZ3JhbXMuc2l6ZVtrZXldW3ZhbF07XHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ3R5cGUnOlxyXG4gICAgICAgICAgICAgIHNlbGYuaWR4W2tleV1bdmFsXS5zdHlsZXMudHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtZUZuKHRoYXQucGFsZXR0ZSwgdHlwZVNjaGVtZSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBvciB1bmRlZmluZWQgdHlwZSBzY2hlbWUuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtZUZuKHRoYXQucGFsZXR0ZSwgdHlwZVNjaGVtZSlbdmFsXTtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnaWNvbic6XHJcbiAgICAgICAgICAgICAgc2VsZi5pZHhba2V5XVt2YWxdLnN0eWxlcy5pY29uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1lRm4odGhhdC5wYWxldHRlLCBpY29uU2NoZW1lKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG9yIHVuZGVmaW5lZCBpY29uIHNjaGVtZS4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1lRm4odGhhdC5wYWxldHRlLCBpY29uU2NoZW1lKVt2YWxdO1xyXG4gICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XHJcbiAgICAgICAgICAgICAgc2VsZi5pZHhba2V5XVt2YWxdLnN0eWxlcy5pbWFnZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtZUZuKHRoYXQucGFsZXR0ZSwgaW1hZ2VTY2hlbWUpID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3Jvbmcgb3IgdW5kZWZpbmVkIGltYWdlIHNjaGVtZS4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NoZW1lRm4odGhhdC5wYWxldHRlLCBpbWFnZVNjaGVtZSlbdmFsXTtcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgdmlzaW9uIG9uIGEgc3BlY2lmaWVkIHByb3BlcnR5LiBJdCB3aWxsIHVwZGF0ZVxyXG4gICAgICogdGhlIHZpc2lvbiBvbiB0aGUgcHJvcGVydHkgaWYgaXQgaXMgZGVwcmVjYXRlZCBvciBtaXNzaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5ICBUaGUgcHJvcGVydHkgYWNjZXNzb3IuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIHZpc2lvbiBvbiB0aGUgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJrZXlcIi4nKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBcImtleVwiIGlzIG5vdCBhIHN0cmluZywgd2FzICcgKyBrZXkpO1xyXG5cclxuICAgICAgLy8gbGF6eSB1cGRhdGluZzpcclxuICAgICAgaWYgKHRoaXMuZGVwcmVjYXRlZFtrZXldKSB0aGlzLnVwZGF0ZShrZXkpO1xyXG5cclxuICAgICAgLy8gbGF6eSBpbmRleGluZzpcclxuICAgICAgaWYgKHRoaXMuaWR4W2tleV0gPT09IHVuZGVmaW5lZCkgdGhpcy51cGRhdGUoa2V5KTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmlkeFtrZXldO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXBwbHkgYSBtYXBwaW5nIGJldHdlZW4gYSB2aXN1YWwgdmFyaWFibGUgYW5kIGEgcHJvcGVydHkuXHJcbiAgICAgKiBJdCB3aWxsIHVwZGF0ZSB0aGUgdmlzaW9uIG9uIHRoZSBwcm9wZXJ0eSBpZiBpdCBpcyBkZXByZWNhdGVkIG9yIG1pc3NpbmcuXHJcbiAgICAgKiBJdCB3aWxsIHN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHZpc3VhbCB2YXJpYWJsZSBmb3IgZWFjaCBpdGVtLlxyXG4gICAgICogSWYgdGhlIG5ldyB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgaXQgd2lsbCBrZWVwIHRoZSBvcmlnaW5hbCB2YWx1ZS5cclxuICAgICAqIEF2YWlsYWJsZSB2aXN1YWwgdmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gYHZpc3VhbFZhcnNgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxWYXIgVGhlIG5hbWUgb2YgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgICAgICAgVGhlIHByb3BlcnR5IGFjY2Vzc29yLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFwcGx5U3R5bGUgPSBmdW5jdGlvbih2aXN1YWxWYXIsIGtleSkge1xyXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJrZXlcIicpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IFwia2V5XCIgaXMgbm90IGEgc3RyaW5nLCB3YXMgJyArIGtleSk7XHJcblxyXG4gICAgICBpZiAodGhpcy52aXN1YWxWYXJzLmluZGV4T2YodmlzdWFsVmFyKSA9PSAtMSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3R5bGUgXCInICsgdmlzdWFsVmFyICsgJ1wiJyk7XHJcblxyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICBpZHhwID0gdGhpcy5nZXQoa2V5KTtcclxuXHJcbiAgICAgIGlmICh2aXN1YWxWYXIgPT09ICdjb2xvcicgJiYgc2VsZi5kYXRhVHlwZXNba2V5XS5hcnJheSkge1xyXG4gICAgICAgIHRoaXMuZGF0YXNldCgpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgIGRlbGV0ZSBpdGVtLmNvbG9ycztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmtleXMoaWR4cCkuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICB2YXIgbyA9IGlkeHBbdmFsXTtcclxuICAgICAgICAgIG8uaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpdGVtLmNvbG9ycyA9IFtdO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKGlkeHApLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHZhciBvID0gaWR4cFt2YWxdO1xyXG4gICAgICAgIG8uaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgIG8uc3R5bGVzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICB0eXBlb2Ygby5zdHlsZXNbdmlzdWFsVmFyXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzZWxmLm9yaWdpbmFsVmlzdWFsVmFyaWFibGVbaXRlbS5pZF0pIHtcclxuICAgICAgICAgICAgICBzZWxmLm9yaWdpbmFsVmlzdWFsVmFyaWFibGVbaXRlbS5pZF0gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISh2aXN1YWxWYXIgaW4gc2VsZi5vcmlnaW5hbFZpc3VhbFZhcmlhYmxlW2l0ZW0uaWRdKSkge1xyXG4gICAgICAgICAgICAgIC8vIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLm9yaWdpbmFsVmlzdWFsVmFyaWFibGVbaXRlbS5pZF0sIHZpc3VhbFZhciwge1xyXG4gICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICB2YWx1ZTogaXRlbVt2aXN1YWxWYXJdXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvLnN0eWxlc1t2aXN1YWxWYXJdKGl0ZW0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpc3VhbFZhciA9PT0gJ2NvbG9yJyAmJiBzZWxmLmRhdGFUeXBlc1trZXldLmFycmF5KSB7XHJcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmNvbG9yID0gbmV3VmFsOyAgLy8gYmFja3dhcmQtY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgaXRlbS5jb2xvcnMucHVzaChuZXdWYWwpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIGl0ZW1bdmlzdWFsVmFyXSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygby5zdHlsZXNbdmlzdWFsVmFyXSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG8uc3R5bGVzICsgJy4nICsgdmlzdWFsVmFyICsgJ2lzIG5vdCBhIGZ1bmN0aW9uLCB3YXMgJyArIG8uc3R5bGVzW3Zpc3VhbFZhcl0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmICh2aXN1YWxWYXIgPT09ICdzaXplJykge1xyXG4gICAgICAgIGlmIChkYXRhc2V0TmFtZSA9PT0gJ25vZGVzJykge1xyXG4gICAgICAgICAgaWYgKHRoaXMubWFwcGluZ3Muc2l6ZS5taW4gPiB0aGlzLm1hcHBpbmdzLnNpemUubWF4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdub2Rlcy5zaXplLm1pbiBtdXN0IGJlICcgK1xyXG4gICAgICAgICAgICAnbG93ZXIgb3IgZXF1YWwgdGhhbiBub2Rlcy5zaXplLm1heCcpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh0aGlzLm1hcHBpbmdzLnNpemUubWluKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zaWdtYVNldHRpbmdzLm1pbk5vZGVTaXplKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5zaWdtYVNldHRpbmdzLm1pbk5vZGVTaXplID0gcy5zZXR0aW5ncygnbWluTm9kZVNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzLnNldHRpbmdzKCdtaW5Ob2RlU2l6ZScsIHRoaXMubWFwcGluZ3Muc2l6ZS5taW4pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh0aGlzLm1hcHBpbmdzLnNpemUubWF4KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zaWdtYVNldHRpbmdzLm1heE5vZGVTaXplKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5zaWdtYVNldHRpbmdzLm1heE5vZGVTaXplID0gcy5zZXR0aW5ncygnbWF4Tm9kZVNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzLnNldHRpbmdzKCdtYXhOb2RlU2l6ZScsIHRoaXMubWFwcGluZ3Muc2l6ZS5tYXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSA9PT0gJ2VkZ2VzJykge1xyXG4gICAgICAgICAgaWYgKHRoaXMubWFwcGluZ3Muc2l6ZS5taW4gPiB0aGlzLm1hcHBpbmdzLnNpemUubWF4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlZGdlcy5zaXplLm1pbiBtdXN0IGJlICcrXHJcbiAgICAgICAgICAgICdsb3dlciBvciBlcXVhbCB0aGFuIGVkZ2VzLnNpemUubWF4Jyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMubWFwcGluZ3Muc2l6ZS5taW4pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ21hU2V0dGluZ3MubWluRWRnZVNpemUpIHtcclxuICAgICAgICAgICAgICB0aGlzLnNpZ21hU2V0dGluZ3MubWluRWRnZVNpemUgPSBzLnNldHRpbmdzKCdtaW5FZGdlU2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMuc2V0dGluZ3MoJ21pbkVkZ2VTaXplJywgdGhpcy5tYXBwaW5ncy5zaXplLm1pbik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMubWFwcGluZ3Muc2l6ZS5tYXgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ21hU2V0dGluZ3MubWF4RWRnZVNpemUpIHtcclxuICAgICAgICAgICAgICB0aGlzLnNpZ21hU2V0dGluZ3MubWF4RWRnZVNpemUgPSBzLnNldHRpbmdzKCdtYXhFZGdlU2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMuc2V0dGluZ3MoJ21heEVkZ2VTaXplJywgdGhpcy5tYXBwaW5ncy5zaXplLm1heCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCByZXNldCBhIG1hcHBpbmcgYmV0d2VlbiBhIHZpc3VhbCB2YXJpYWJsZSBhbmQgYSBwcm9wZXJ0eS5cclxuICAgICAqIEl0IHJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgdmlzdWFsIHZhcmlhYmxlIGZvciBlYWNoIGl0ZW0uIEl0XHJcbiAgICAgKiB3aWxsIGRvIG5vdGhpbmcgaWYgdGhlIHZpc2lvbiBvbiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZy5cclxuICAgICAqIEF2YWlsYWJsZSB2aXN1YWwgdmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gYHZpc3VhbFZhcnNgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aXN1YWxWYXIgVGhlIG5hbWUgb2YgdGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgICAgICAgVGhlIHByb3BlcnR5IGFjY2Vzc29yLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2V0U3R5bGUgPSBmdW5jdGlvbih2aXN1YWxWYXIsIGtleSkge1xyXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJrZXlcIicpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IFwia2V5XCIgaXMgbm90IGEgc3RyaW5nLCB3YXMgJyArIGtleSk7XHJcblxyXG4gICAgICBpZiAodGhpcy52aXN1YWxWYXJzLmluZGV4T2YodmlzdWFsVmFyKSA9PSAtMSlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3R5bGUgXCInICsgdmlzdWFsVmFyICsgJ1wiLicpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaWR4W2tleV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgaWR4cCA9IHRoaXMuZ2V0KGtleSk7XHJcblxyXG4gICAgICBpZiAodmlzdWFsVmFyID09PSAnY29sb3InICYmIHNlbGYuZGF0YVR5cGVzW2tleV0uYXJyYXkpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhpZHhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgIHZhciBvID0gaWR4cFt2YWxdO1xyXG4gICAgICAgICAgby5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtLmNvbG9ycztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhpZHhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICB2YXIgbyA9IGlkeHBbdmFsXTtcclxuICAgICAgICBvLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQgJiYgaXRlbVt2aXN1YWxWYXJdICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLm9yaWdpbmFsVmlzdWFsVmFyaWFibGVbaXRlbS5pZF0gPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgIHNlbGYub3JpZ2luYWxWaXN1YWxWYXJpYWJsZVtpdGVtLmlkXVt2aXN1YWxWYXJdID09PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQXZvaWQgU2lnbWEgYnVnIG9uIGVkZ2Ugd2l0aCBubyBzaXplXHJcbiAgICAgICAgICAgICAgaWYgKHNlbGYua2V5ID09PSAnZWRnZXMnICYmIHZpc3VhbFZhciA9PT0gJ3NpemUnKVxyXG4gICAgICAgICAgICAgICAgaXRlbS5zaXplID0gMTtcclxuICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbVt2aXN1YWxWYXJdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgaXRlbVt2aXN1YWxWYXJdID0gc2VsZi5vcmlnaW5hbFZpc3VhbFZhcmlhYmxlW2l0ZW0uaWRdW3Zpc3VhbFZhcl07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHZpc3VhbFZhciA9PT0gJ3NpemUnKSB7XHJcbiAgICAgICAgaWYgKGRhdGFzZXROYW1lID09PSAnbm9kZXMnKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5zaWdtYVNldHRpbmdzLm1pbk5vZGVTaXplKSB7XHJcbiAgICAgICAgICAgIHMuc2V0dGluZ3MoJ21pbk5vZGVTaXplJywgdGhpcy5zaWdtYVNldHRpbmdzLm1pbk5vZGVTaXplKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnNpZ21hU2V0dGluZ3MubWF4Tm9kZVNpemUpIHtcclxuICAgICAgICAgICAgcy5zZXR0aW5ncygnbWF4Tm9kZVNpemUnLCB0aGlzLnNpZ21hU2V0dGluZ3MubWF4Tm9kZVNpemUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSA9PT0gJ2VkZ2VzJykge1xyXG4gICAgICAgICAgaWYgKHRoaXMuc2lnbWFTZXR0aW5ncy5taW5FZGdlU2l6ZSkge1xyXG4gICAgICAgICAgICBzLnNldHRpbmdzKCdtaW5FZGdlU2l6ZScsIHRoaXMuc2lnbWFTZXR0aW5ncy5taW5FZGdlU2l6ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5zaWdtYVNldHRpbmdzLm1heEVkZ2VTaXplKSB7XHJcbiAgICAgICAgICAgIHMuc2V0dGluZ3MoJ21heEVkZ2VTaXplJywgdGhpcy5zaWdtYVNldHRpbmdzLm1heEVkZ2VTaXplKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBlbXB0aWVzIHRoZSBhcnJheXMgYW5kIGluZGV4ZXMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy52aXN1YWxWYXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgIGVtcHR5T2JqZWN0KHRoaXMuaWR4KTtcclxuICAgICAgZW1wdHlPYmplY3QodGhpcy5oaXN0b2dyYW1zKTtcclxuICAgICAgZW1wdHlPYmplY3QodGhpcy5kZXByZWNhdGVkKTtcclxuICAgICAgZW1wdHlPYmplY3QodGhpcy5zaWdtYVNldHRpbmdzKTtcclxuICAgICAgZW1wdHlPYmplY3QodGhpcy5kYXRhVHlwZXMpO1xyXG4gICAgICBlbXB0eU9iamVjdCh0aGlzLm9yaWdpbmFsVmlzdWFsVmFyaWFibGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogZGVzaWduIE9iamVjdFxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEBwYXJhbSAge3NpZ21hfSAgIHMgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGNvbnRhaW5zIGBwYWxldHRlYCBhbmQgYHN0eWxlc2AuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBTdHlsZXMgYXJlIG1hcHBpbmdzIGJldHdlZW4gdmlzdWFsIHZhcmlhYmxlcyBhbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgcHJvcGVydGllcyBvbiBub2RlcyBhbmQgZWRnZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZGVzaWduKHMsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMucGFsZXR0ZSA9IChvcHRpb25zIHx8IHt9KS5wYWxldHRlIHx8IHt9O1xyXG4gICAgdGhpcy5zdHlsZXMgPSBzaWdtYS51dGlscy5leHRlbmQoKG9wdGlvbnMgfHwge30pLnN0eWxlcyB8fCB7fSwge1xyXG4gICAgICBub2Rlczoge30sXHJcbiAgICAgIGVkZ2VzOiB7fVxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIF92aXNpb25Pbk5vZGVzID0gbmV3IFZpc2lvbihzLCAnbm9kZXMnLCB0aGlzLnN0eWxlcywgdGhpcy5wYWxldHRlKSxcclxuICAgICAgICBfdmlzaW9uT25FZGdlcyA9IG5ldyBWaXNpb24ocywgJ2VkZ2VzJywgdGhpcy5zdHlsZXMsIHRoaXMucGFsZXR0ZSk7XHJcblxyXG4gICAgcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNpZ21hLnBsdWdpbnMua2lsbERlc2lnbihzKTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IG5ldyBzdHlsZXMuIFN0eWxlcyBhcmUgbWFwcGluZ3MgYmV0d2VlbiB2aXN1YWxcclxuICAgICAqIHZhcmlhYmxlcyBhbmQgZGF0YSBwcm9wZXJ0aWVzIG9uIG5vZGVzIGFuZCBlZGdlcy4gSXQgd2lsbCBkZXByZWNhdGVcclxuICAgICAqIGV4aXN0aW5nIHN0eWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzdHlsZXMgVGhlIHN0eWxlcyBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJuIHtkZXNpZ259ICAgICAgIFRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRTdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMpIHtcclxuICAgICAgdGhpcy5zdHlsZXMgPSBzaWdtYS51dGlscy5leHRlbmQoc3R5bGVzIHx8IHt9LCB7XHJcbiAgICAgICAgbm9kZXM6IHt9LFxyXG4gICAgICAgIGVkZ2VzOiB7fVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIF92aXNpb25Pbk5vZGVzLm1hcHBpbmdzID0gdGhpcy5zdHlsZXMubm9kZXM7XHJcbiAgICAgIF92aXNpb25PbkVkZ2VzLm1hcHBpbmdzID0gdGhpcy5zdHlsZXMuZWRnZXM7XHJcblxyXG4gICAgICB0aGlzLmRlcHJlY2F0ZSgpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCBhIHNwZWNpZmllZCBub2RlIHN0eWxlLiBTdHlsZXMgYXJlIG1hcHBpbmdzIGJldHdlZW5cclxuICAgICAqIHZpc3VhbCB2YXJpYWJsZXMgYW5kIGRhdGEgcHJvcGVydGllcyBvbiBub2RlcyBhbmQgZWRnZXMuIEl0IHdpbGxcclxuICAgICAqIGRlcHJlY2F0ZSBleGlzdGluZyBub2RlIHN0eWxlcyBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGRhdGEgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdmlzdWFsVmFyIFRoZSB2aXN1YWwgdmFyaWFibGUuXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwYXJhbXMgICAgVGhlIHN0eWxlIHBhcmFtZXRlci5cclxuICAgICAqIEByZXR1cm4ge2Rlc2lnbn0gICAgICAgICAgVGhlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLm5vZGVzQnkgPSBmdW5jdGlvbih2aXN1YWxWYXIsIHBhcmFtcykge1xyXG4gICAgICB0aGlzLnN0eWxlcyA9IHNpZ21hLnV0aWxzLmV4dGVuZCh0aGlzLnN0eWxlcyB8fCB7fSwge1xyXG4gICAgICAgIG5vZGVzOiB7fSxcclxuICAgICAgICBlZGdlczoge31cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB0aGlzLnN0eWxlcy5ub2Rlc1t2aXN1YWxWYXJdID0gcGFyYW1zO1xyXG4gICAgICBfdmlzaW9uT25Ob2Rlcy5tYXBwaW5ncyA9IHRoaXMuc3R5bGVzLm5vZGVzO1xyXG5cclxuICAgICAgaWYgKHBhcmFtcy5ieSkge1xyXG4gICAgICAgIHRoaXMuZGVwcmVjYXRlKCdub2RlcycsIHBhcmFtcy5ieSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IGEgc3BlY2lmaWVkIGVkZ2Ugc3R5bGUuIFN0eWxlcyBhcmUgbWFwcGluZ3MgYmV0d2VlblxyXG4gICAgICogdmlzdWFsIHZhcmlhYmxlcyBhbmQgZGF0YSBwcm9wZXJ0aWVzIG9uIG5vZGVzIGFuZCBlZGdlcy4gSXQgd2lsbFxyXG4gICAgICogZGVwcmVjYXRlIGV4aXN0aW5nIGVkZ2Ugc3R5bGVzIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgZGF0YSBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB2aXN1YWxWYXIgVGhlIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIHBhcmFtcyAgICBUaGUgc3R5bGUgcGFyYW1ldGVyLlxyXG4gICAgICogQHJldHVybiB7ZGVzaWdufSAgICAgICAgICBUaGUgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZWRnZXNCeSA9IGZ1bmN0aW9uKHZpc3VhbFZhciwgcGFyYW1zKSB7XHJcbiAgICAgIHRoaXMuc3R5bGVzID0gc2lnbWEudXRpbHMuZXh0ZW5kKHRoaXMuc3R5bGVzIHx8IHt9LCB7XHJcbiAgICAgICAgbm9kZXM6IHt9LFxyXG4gICAgICAgIGVkZ2VzOiB7fVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHRoaXMuc3R5bGVzLmVkZ2VzW3Zpc3VhbFZhcl0gPSBwYXJhbXM7XHJcbiAgICAgIF92aXNpb25PbkVkZ2VzLm1hcHBpbmdzID0gdGhpcy5zdHlsZXMuZWRnZXM7XHJcblxyXG4gICAgICBpZiAocGFyYW1zLmJ5KSB7XHJcbiAgICAgICAgdGhpcy5kZXByZWNhdGUoJ2VkZ2VzJywgcGFyYW1zLmJ5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgc2V0IGEgbmV3IHBhbGV0dGUuIEl0IHdpbGwgZGVwcmVjYXRlIGV4aXN0aW5nIHN0eWxlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwYWxldHRlIFRoZSBwYWxldHRlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm4ge2Rlc2lnbn0gICAgICAgIFRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zZXRQYWxldHRlID0gZnVuY3Rpb24ocGFsZXR0ZSkge1xyXG4gICAgICB0aGlzLnBhbGV0dGUgPSBwYWxldHRlO1xyXG5cclxuICAgICAgX3Zpc2lvbk9uTm9kZXMucGFsZXR0ZSA9IHRoaXMucGFsZXR0ZTtcclxuICAgICAgX3Zpc2lvbk9uRWRnZXMucGFsZXR0ZSA9IHRoaXMucGFsZXR0ZTtcclxuXHJcbiAgICAgIHRoaXMuZGVwcmVjYXRlKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZ2V0IHRoZSBzdHlsZXMgYm91bmQgdG8gZWFjaCBub2RlIG9mIHRoZSBncmFwaCBmb3JcclxuICAgICAqIGEgc3BlY2lmaWVkIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBhY2Nlc3Nvci4gVXNlIGEgZG90IG5vdGF0aW9uIGxpa2VcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICdkYXRhLm15UHJvcGVydHknLlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIHN0eWxlcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5ub2RlcyA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICByZXR1cm4gX3Zpc2lvbk9uTm9kZXMuZ2V0KGtleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBnZXQgdGhlIHN0eWxlcyBib3VuZCB0byBlYWNoIGVkZ2Ugb2YgdGhlIGdyYXBoIGZvclxyXG4gICAgICogYSBzcGVjaWZpZWQgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgVGhlIHByb3BlcnR5IGFjY2Vzc29yLiBVc2UgYSBkb3Qgbm90YXRpb24gbGlrZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgJ2RhdGEubXlQcm9wZXJ0eScuXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgc3R5bGVzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmVkZ2VzID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIHJldHVybiBfdmlzaW9uT25FZGdlcy5nZXQoa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGV4cG9ydCBhIGRlZXAgY29weSBvZiB0aGUgaW50ZXJuYWwgYFZpc2lvbmAgb2JqZWN0cyxcclxuICAgICAqIHdoaWNoIHN0b3JlIHRoZSBpbmRleGVzLCBib3VuZCBzdHlsZXMgYW5kIGhpc3RvZ3JhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAgVGhlIG9iamVjdCBvZiBrZXlzIGBub2Rlc2AgYW5kIGBlZGdlc2AuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG5vZGVzOiBkZWVwQ29weShfdmlzaW9uT25Ob2RlcyksXHJcbiAgICAgICAgZWRnZXM6IGRlZXBDb3B5KF92aXNpb25PbkVkZ2VzKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX2FwcGx5KG1hcHBpbmdzLCB2aXNpb24sIHZpc3VhbFZhcikge1xyXG4gICAgICBpZiAoIXZpc3VhbFZhcikge1xyXG4gICAgICAgIC8vIGFwcGx5IGFsbCBzdHlsZXMgaWYgbm8gdmlzdWFsIHZhcmlhYmxlIGlzIHNwZWNpZmllZDpcclxuICAgICAgICBPYmplY3Qua2V5cyhtYXBwaW5ncykuZm9yRWFjaChmdW5jdGlvbiAodmlzdVZhcikge1xyXG4gICAgICAgICAgbWFwcGluZ3NbdmlzdVZhcl0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAobWFwcGluZ3NbdmlzdVZhcl0gJiYgbWFwcGluZ3NbdmlzdVZhcl0uYnkpIHtcclxuICAgICAgICAgICAgdmlzaW9uLmFwcGx5U3R5bGUodmlzdVZhciwgbWFwcGluZ3NbdmlzdVZhcl0uYnkpO1xyXG4gICAgICAgICAgICBtYXBwaW5nc1t2aXN1VmFyXS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKG1hcHBpbmdzW3Zpc3VhbFZhcl0gJiYgbWFwcGluZ3NbdmlzdWFsVmFyXS5ieSkge1xyXG4gICAgICAgIC8vIGFwcGx5IHRoZSBzdHlsZSBvZiB0aGUgc3BlY2lmaWVkIHZpc3VhbCB2YXJpYWJsZTpcclxuICAgICAgICB2aXNpb24uYXBwbHlTdHlsZSh2aXN1YWxWYXIsIG1hcHBpbmdzW3Zpc3VhbFZhcl0uYnkpO1xyXG4gICAgICAgIG1hcHBpbmdzW3Zpc3VhbFZhcl0uYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHMpIHMucmVmcmVzaCh7c2tpcEluZGV4YXRpb246IHRydWV9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFwcGx5IGFsbCB0YXJnZXQgc3R5bGVzIG9yIGEgc3BlY2lmaWVkIHRhcmdldFxyXG4gICAgICogc3R5bGUsIGRlcGVuZGluZyBvbiBob3cgaXQgaXMgY2FsbGVkLiBBcHBseSBhbGwgc3R5bGVzIGlmIGl0IGlzIGNhbGxlZFxyXG4gICAgICogd2l0aG91dCBhcmd1bWVudC4gSXQgd2lsbCByZWZyZXNoIHRoZSBkaXNwbGF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgez9zdHJpbmd9IHRhcmdldCAgICAgVGhlIGRhdGEgdGFyZ2V0LiBBdmFpbGFibGUgdmFsdWVzOlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVzXCIsIFwiZWRnZXNcIi5cclxuICAgICAqIEBwYXJhbSAgez9zdHJpbmd9IHZpc3VhbFZhciAgVGhlIHZpc3VhbCB2YXJpYWJsZS4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLCBcInNpemVcIiwgXCJsYWJlbFwiLlxyXG4gICAgICogQHJldHVybiB7ZGVzaWdufSAgICAgICAgICAgIFRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5hcHBseSA9IGZ1bmN0aW9uKHRhcmdldCwgdmlzdWFsVmFyKSB7XHJcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHJldHVybjtcclxuXHJcbiAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgX19hcHBseSh0aGlzLnN0eWxlcy5ub2RlcywgX3Zpc2lvbk9uTm9kZXMsIHZpc3VhbFZhcik7XHJcbiAgICAgICAgX19hcHBseSh0aGlzLnN0eWxlcy5lZGdlcywgX3Zpc2lvbk9uRWRnZXMsIHZpc3VhbFZhcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAodGFyZ2V0KSB7XHJcbiAgICAgICAgY2FzZSAnbm9kZXMnOlxyXG4gICAgICAgICAgX19hcHBseSh0aGlzLnN0eWxlcy5ub2RlcywgX3Zpc2lvbk9uTm9kZXMsIHZpc3VhbFZhcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdlZGdlcyc6XHJcbiAgICAgICAgICBfX2FwcGx5KHRoaXMuc3R5bGVzLmVkZ2VzLCBfdmlzaW9uT25FZGdlcywgdmlzdWFsVmFyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IFwidGFyZ2V0XCIgaXMgbm90IFwibm9kZXNcIiBvciBcImVkZ2VzXCIsIHdhcyAnICsgdGFyZ2V0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fcmVzZXQobWFwcGluZ3MsIHZpc2lvbiwgdmlzdWFsVmFyKSB7XHJcbiAgICAgIGlmICghdmlzdWFsVmFyKSB7XHJcbiAgICAgICAgLy8gcmVzZXQgYWxsIHN0eWxlcyBpZiBubyB2aXN1YWwgdmFyaWFibGUgaXMgc3BlY2lmaWVkOlxyXG4gICAgICAgIE9iamVjdC5rZXlzKG1hcHBpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uICh2aXN1VmFyKSB7XHJcbiAgICAgICAgICBpZiAobWFwcGluZ3NbdmlzdVZhcl0uYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZpc2lvbi5yZXNldFN0eWxlKHZpc3VWYXIsIG1hcHBpbmdzW3Zpc3VWYXJdLmJ5KTtcclxuICAgICAgICAgICAgbWFwcGluZ3NbdmlzdVZhcl0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAobWFwcGluZ3NbdmlzdWFsVmFyXSAmJiBtYXBwaW5nc1t2aXN1YWxWYXJdLmFjdGl2ZSkge1xyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBzdHlsZSBvZiB0aGUgc3BlY2lmaWVkIHZpc3VhbCB2YXJpYWJsZTpcclxuICAgICAgICB2aXNpb24ucmVzZXRTdHlsZSh2aXN1YWxWYXIsIG1hcHBpbmdzW3Zpc3VhbFZhcl0uYnkpO1xyXG4gICAgICAgIG1hcHBpbmdzW3Zpc3VhbFZhcl0uYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzKSBzLnJlZnJlc2goe3NraXBJbmRleGF0aW9uOiB0cnVlfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byByZXNldCBhbGwgdGFyZ2V0IHN0eWxlcyBvciBhIHNwZWNpZmllZCB0YXJnZXQgc3R5bGUsXHJcbiAgICAgKiBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC4gcmVzZXQgYWxsIHN0eWxlcyBpZiBpdCBpcyBjYWxsZWRcclxuICAgICAqIHdpdGhvdXQgYXJndW1lbnQuIEl0IHdpbGwgZG8gbm90aGluZyBpZiB0aGUgdmlzdWFsIHZhcmlhYmxlXHJcbiAgICAgKiBpcyBub3QgaW4gdGhlIGV4aXN0aW5nIHN0eWxlcy4gSXQgd2lsbCBmaW5hbGx5IHJlZnJlc2ggdGhlIGRpc3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7P3N0cmluZ30gdGFyZ2V0ICAgICBUaGUgZGF0YSB0YXJnZXQuIEF2YWlsYWJsZSB2YWx1ZXM6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVzXCIsIFwiZWRnZXNcIi5cclxuICAgICAqIEBwYXJhbSAgez9zdHJpbmd9IHZpc3VhbFZhciAgVGhlIHZpc3VhbCB2YXJpYWJsZS4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCIsIFwic2l6ZVwiLCBcImxhYmVsXCIuXHJcbiAgICAgKiBAcmV0dXJuIHtkZXNpZ259ICBUaGUgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZpc3VhbFZhcikge1xyXG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSByZXR1cm47XHJcblxyXG4gICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgIF9fcmVzZXQodGhpcy5zdHlsZXMubm9kZXMsIF92aXNpb25Pbk5vZGVzLCB2aXN1YWxWYXIpO1xyXG4gICAgICAgIF9fcmVzZXQodGhpcy5zdHlsZXMuZWRnZXMsIF92aXNpb25PbkVkZ2VzLCB2aXN1YWxWYXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzd2l0Y2ggKHRhcmdldCkge1xyXG4gICAgICAgIGNhc2UgJ25vZGVzJzpcclxuICAgICAgICAgIF9fcmVzZXQodGhpcy5zdHlsZXMubm9kZXMsIF92aXNpb25Pbk5vZGVzLCB2aXN1YWxWYXIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZWRnZXMnOlxyXG4gICAgICAgICAgX19yZXNldCh0aGlzLnN0eWxlcy5lZGdlcywgX3Zpc2lvbk9uRWRnZXMsIHZpc3VhbFZhcik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBcInRhcmdldFwiIGlzIG5vdCBcIm5vZGVzXCIgb3IgXCJlZGdlc1wiLCB3YXMgJyArIHRhcmdldCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiB0aGUgc3R5bGVzIGFyZSBkZXByZWNhdGVkLCBmb3IgaW5zdGFuY2Ugd2hlbiB0aGVcclxuICAgICAqIGdyYXBoIGhhcyBjaGFuZ2VkLiBUaGUgc3BlY2lmaWVkIHByb3BlcnR5IHN0eWxlIHdpbGwgYmUgcmVtYWRlIHRoZSBuZXh0XHJcbiAgICAgKiB0aW1lIGl0IGlzIGNhbGxlZCB1c2luZyBgLmFwcGx5KClgLCBgLm5vZGVzKClgLCBvciBgLmVkZ2VzKClgXHJcbiAgICAgKiBvciBhbGwgcHJvcGVydHkgc3R5bGVzIGlmIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgez9zdHJpbmd9IHRhcmdldCAgVGhlIGRhdGEgdGFyZ2V0LiBBdmFpbGFibGUgdmFsdWVzOlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVzXCIsIFwiZWRnZXNcIi5cclxuICAgICAqIEBwYXJhbSAgez9zdHJpbmd9IGtleSAgICAgVGhlIHByb3BlcnR5IGFjY2Vzc29yLiBVc2UgYSBkb3Qgbm90YXRpb24gbGlrZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS5teVByb3BlcnR5Jy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtkZXNpZ259ICAgICAgICAgIFRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZXByZWNhdGUgPSBmdW5jdGlvbih0YXJnZXQsIGtleSkge1xyXG4gICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gJ25vZGVzJyAmJiB0YXJnZXQgIT09ICdlZGdlcycpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IFwidGFyZ2V0XCIgaXMgbm90IFwibm9kZXNcIiBvciBcImVkZ2VzXCIsIHdhcyAnICsgdGFyZ2V0KTtcclxuXHJcbiAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ25vZGVzJykge1xyXG4gICAgICAgICAgICBfdmlzaW9uT25Ob2Rlcy5kZXByZWNhdGVkW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSAnZWRnZXMnKSB7XHJcbiAgICAgICAgICAgIF92aXNpb25PbkVkZ2VzLmRlcHJlY2F0ZWRba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ25vZGVzJykge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdmlzaW9uT25Ob2Rlcy5kZXByZWNhdGVkKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICAgICAgICBfdmlzaW9uT25Ob2Rlcy5kZXByZWNhdGVkW3Byb3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09ICdlZGdlcycpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3Zpc2lvbk9uRWRnZXMuZGVwcmVjYXRlZCkuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XHJcbiAgICAgICAgICAgICAgX3Zpc2lvbk9uRWRnZXMuZGVwcmVjYXRlZFtwcm9wXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhfdmlzaW9uT25Ob2Rlcy5kZXByZWNhdGVkKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICAgIF92aXNpb25Pbk5vZGVzLmRlcHJlY2F0ZWRbcHJvcF0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBPYmplY3Qua2V5cyhfdmlzaW9uT25FZGdlcy5kZXByZWNhdGVkKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICAgIF92aXNpb25PbkVkZ2VzLmRlcHJlY2F0ZWRbcHJvcF0gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgc3R5bGVzIGZyb20gYSBub2RlIG9yIGFuIGVkZ2UgYWNjb3JkaW5nIHRvIGl0cyBzcGVjaWZpZWQgaWQsXHJcbiAgICAgKiB0YXJnZXQgdHlwZSBhbmQgcHJvcGVydHkgcmVmZXJlbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgdGFyZ2V0IFRoZSBkYXRhIHRhcmdldC4gQXZhaWxhYmxlIHZhbHVlczogXCJub2Rlc1wiLCBcImVkZ2VzXCIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIGlkICAgICBUaGUgaWQgb2YgdGhlIG5vZGUgb3IgZWRnZSB0byB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAga2V5ICAgIFRoZSBwcm9wZXJ0eSBrZXkgdG8gZGVsZXRlIHN0eWxlcyBmcm9tLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Rlc2lnbn0gICAgICAgIFRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWxldGVQcm9wZXJ0eVN0eWxlc0Zyb20gPSBmdW5jdGlvbih0YXJnZXQsIGlkLCBrZXkpe1xyXG5cclxuICAgICAgaWYgKGlkID09IG51bGwpe1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYXJndW1lbnQ6IFwiaWRcIi4nKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGFyZ2V0ICE9PSAnbm9kZXMnICYmIHRhcmdldCAhPT0gJ2VkZ2VzJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogXCJ0YXJnZXRcIiBpcyBub3QgXCJub2Rlc1wiIG9yIFwiZWRnZXNcIiwgd2FzICcgKyB0YXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChrZXkgPT0gbnVsbCl7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJrZXlcIi4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyXHJcbiAgICAgICAgY29tcHV0ZWRTdHlsZXMsXHJcbiAgICAgICAgY29tcHV0ZWRTdHlsZSxcclxuICAgICAgICBhcHBsaWVkU3R5bGVzLFxyXG4gICAgICAgIGl0ZW07XHJcblxyXG4gICAgICBpZiAodGFyZ2V0ID09PSAnbm9kZXMnKXtcclxuICAgICAgICBjb21wdXRlZFN0eWxlcyA9IF92aXNpb25Pbk5vZGVzLmdldChrZXkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXB1dGVkU3R5bGVzID0gX3Zpc2lvbk9uRWRnZXMuZ2V0KGtleSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB2YWx1ZXMgPSBPYmplY3Qua2V5cyhjb21wdXRlZFN0eWxlcyk7XHJcblxyXG4gICAgICBmb3IgKHZhciBrID0gMCA7IGsgPCB2YWx1ZXMubGVuZ3RoIDsgaysrKXtcclxuXHJcbiAgICAgICAgY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGVzW3ZhbHVlc1trXV07XHJcbiAgICAgICAgYXBwbGllZFN0eWxlcyA9IE9iamVjdC5rZXlzKGNvbXB1dGVkU3R5bGUuc3R5bGVzKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY29tcHV0ZWRTdHlsZS5pdGVtcy5sZW5ndGggOyBpKyspe1xyXG5cclxuICAgICAgICAgIGl0ZW0gPSBjb21wdXRlZFN0eWxlLml0ZW1zW2ldO1xyXG4gICAgICAgICAgaWYgKGl0ZW0uaWQgPT09IGlkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3IgYSBnaXZlbiBwcm9wZXJ0eSwgd2Ugd2FudCB0byBkZWxldGUgYWxsIHRoZSBzdHlsZXMgcmVmZXJlbmNlcyB0aGF0IGFyZSBjb21wdXRlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIGl0IGZvciBhIGdpdmVuIG5vZGVcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcHBsaWVkU3R5bGVzLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChhcHBsaWVkU3R5bGVzW2pdICE9PSAnbGFiZWwnICYmIGFwcGxpZWRTdHlsZXNbal0gIT09ICdzaXplJykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1bYXBwbGllZFN0eWxlc1tqXV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcHBsaWVkU3R5bGVzW2pdID09PSAnc2l6ZScpe1xyXG4gICAgICAgICAgICAgICAgaXRlbS5zaXplID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgbm9kZSB0aGF0IHNob3VsZCBjb3JyZXNwb25kIHRvIHRoaXMuIE9uY2Ugd2UgaGF2ZSBmb3VuZCBpdCwgd2VcclxuICAgICAgICAgICAgLy8gY2FuIHJldHVybi5cclxuICAgICAgICAgICAgdGhpcy5kZXByZWNhdGUodGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY2xlYXIgYWxsIHN0eWxlcy4gSXQgd2lsbCByZWZyZXNoIHRoZSBkaXNwbGF5LiBVc2VcclxuICAgICAqIGAucmVzZXQoKWAgaW5zdGVhZCB0byByZXNldCBzdHlsZXMgd2l0aG91dCBsb3NpbmcgdGhlIGNvbmZpZ3VyYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7ZGVzaWdufSAgVGhlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgdGhpcy5zdHlsZXMgPSB7XHJcbiAgICAgICAgbm9kZXM6IHt9LFxyXG4gICAgICAgIGVkZ2VzOiB7fVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnBhbGV0dGUgPSB7fTtcclxuXHJcbiAgICAgIF92aXNpb25Pbk5vZGVzLmNsZWFyKCk7XHJcbiAgICAgIF92aXNpb25PbkVkZ2VzLmNsZWFyKCk7XHJcblxyXG4gICAgICBfdmlzaW9uT25Ob2RlcyA9IG5ldyBWaXNpb24ocywgJ25vZGVzJywgdGhpcy5zdHlsZXMsIHRoaXMucGFsZXR0ZSk7XHJcbiAgICAgIF92aXNpb25PbkVkZ2VzID0gbmV3IFZpc2lvbihzLCAnZWRnZXMnLCB0aGlzLnN0eWxlcywgdGhpcy5wYWxldHRlKTtcclxuXHJcbiAgICAgIGlmIChzKSBzLnJlZnJlc2goe3NraXBJbmRleGF0aW9uOiB0cnVlfSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBkZXN0cm95cyB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlcztcclxuICAgICAgZGVsZXRlIHRoaXMucGFsZXR0ZTtcclxuICAgICAgX3Zpc2lvbk9uTm9kZXMuY2xlYXIoKTtcclxuICAgICAgX3Zpc2lvbk9uRWRnZXMuY2xlYXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIHN0eWxlcyBhbmQgcGFsZXR0ZSBpbnRvIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyBUaGUgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgIFRoZSBKU09OIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgdGhpcy50b0pTT04gPSBmdW5jdGlvbihwYXJhbXMpIHtcclxuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xyXG5cclxuICAgICAgdmFyIG8gPSB7XHJcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlcyxcclxuICAgICAgICBwYWxldHRlOiB0aGlzLnBhbGV0dGVcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmFtcy5wcmV0dHkpIHtcclxuICAgICAgICB2YXIganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG8sIG51bGwsICcgJyk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmFtcy5kb3dubG9hZCkge1xyXG4gICAgICAgIGRvd25sb2FkKGpzb25TdHJpbmcsICdqc29uJywgcGFyYW1zLmZpbGVuYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGpzb25TdHJpbmc7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudXRpbHMgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZ2V0IHRoZSBkYXRhIHR5cGUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgb24gbm9kZXNcclxuICAgICAqIG9yIGVkZ2VzLiBJdCBpcyB0cnVlIGlmIGRhdGEgaXMgc2VxdWVudGlhbCwgZmFsc2Ugb3RoZXJ3aXNlIChxdWFsaXRhdGl2ZSksXHJcbiAgICAgKiBvciB1bmRlZmluZWQgaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0YXJnZXQgICAgIFRoZSBkYXRhIHRhcmdldC4gQXZhaWxhYmxlIHZhbHVlczpcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGVzXCIsIFwiZWRnZXNcIi5cclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcHJvcGVydHkgICBUaGUgcHJvcGVydHkgYWNjZXNzb3IuXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgICAgVGhlIGRhdGEgdHlwZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy51dGlscy5pc1NlcXVlbnRpYWwgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5KSB7XHJcbiAgICAgIGlmICghdGFyZ2V0KVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYXJndW1lbnQ6IFwidGFyZ2V0XCInKTtcclxuXHJcbiAgICAgIHZhciB2O1xyXG4gICAgICBzd2l0Y2ggKHRhcmdldCkge1xyXG4gICAgICAgIGNhc2UgJ25vZGVzJzpcclxuICAgICAgICAgIHYgPSBfdmlzaW9uT25Ob2RlcztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2VkZ2VzJzpcclxuICAgICAgICAgIHYgPSBfdmlzaW9uT25FZGdlcztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IFwidGFyZ2V0XCIgaXMgbm90IFwibm9kZXNcIiBvciBcImVkZ2VzXCIsIHdhcyAnICsgdGFyZ2V0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJwcm9wZXJ0eVwiJyk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIHByb3BlcnR5ICE9PSAnc3RyaW5nJylcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBcInByb3BlcnR5XCIgaXMgbm90IGEgc3RyaW5nLCB3YXMgJyArIHByb3BlcnR5KTtcclxuXHJcbiAgICAgIGlmICghKHByb3BlcnR5IGluIHYuZGF0YVR5cGVzKSB8fCB2LmRhdGFUeXBlc1twcm9wZXJ0eV0uc2VxdWVudGlhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIHZhbCxcclxuICAgICAgICAgICAgZm91bmQgPSBmYWxzZSxcclxuICAgICAgICAgICAgaXNTZXF1ZW50aWFsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdi5kYXRhc2V0KCkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgdmFsID0gc3RyVG9PYmplY3RSZWYoaXRlbSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgaXNTZXF1ZW50aWFsID0gKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSA/IGlzU2VxdWVudGlhbCA6IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB0aHJvdyBlcnJvciBpZiBpcyBudW1iZXIgQU5EIChpcyBOYU4gb3IgaXMgSW5maW5pdHkpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgdi5kYXRhVHlwZXNbcHJvcGVydHldID0geyBzZXF1ZW50aWFsOiBpc1NlcXVlbnRpYWwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih2LmRhdGFUeXBlc1twcm9wZXJ0eV0pIHtcclxuICAgICAgICAgIHYuZGF0YVR5cGVzW3Byb3BlcnR5XS5zZXF1ZW50aWFsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuICh2LmRhdGFUeXBlc1twcm9wZXJ0eV0gfHwge30pLnNlcXVlbnRpYWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBnZXQgdGhlIGhpc3RvZ3JhbSBvZiB2YWx1ZXMsIGdyb3VwZWQgYnkgYmlucywgb25cclxuICAgICAqIGEgc3BlY2lmaWVkIHByb3BlcnR5IG9mIG5vZGVzIG9yIGVkZ2VzIGNvbXB1dGVkIGZvciBhIHZpc3VhbCB2YXJpYWJsZS5cclxuICAgICAqIFRoZSBwcm9wZXJ0eSBtdXN0IGhhdmUgYmVlbiB1c2VkIG9uIGEgc3R5bGUgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBvYmplY3RzIG9yZGVyZWQgYnkgYmlucy4gRWFjaCBvYmplY3QgY29udGFpbnNcclxuICAgICAqIHRoZSBsaXN0IG9mIGB2YWx1ZXNgIGluIHRoZSBgYmluYCwgdGhlIGBtaW5gIGFuZCBgbWF4YCB2YWx1ZXMsIGFuZCB0aGVcclxuICAgICAqIGByYXRpb2Agb2YgdmFsdWVzIGluIHRoZSBiaW4gY29tcGFyZWQgdG8gdGhlIGxhcmdlc3QgYmluLlxyXG4gICAgICogSWYgdGhlIHZpc3VhbCB2YXJpYWJsZSBpcyB0aGUgYGNvbG9yYCwgaXQgYWxzbyBjb250YWlucyB0aGUgYGNvbG9yYCBvZiB0aGVcclxuICAgICAqIGJpbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhcmdldCAgICAgVGhlIGRhdGEgdGFyZ2V0LiBBdmFpbGFibGUgdmFsdWVzOlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibm9kZXNcIiwgXCJlZGdlc1wiLlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB2aXN1YWxWYXIgIFRoZSB2aXN1YWwgdmFyaWFibGUuIEF2YWlsYWJsZSB2YWx1ZXM6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiLCBcInNpemVcIiwgXCJsYWJlbFwiLlxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBwcm9wZXJ0eSAgIFRoZSBwcm9wZXJ0eSBhY2Nlc3Nvci5cclxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICBUaGUgaGlzdG9ncmFtLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnV0aWxzLmhpc3RvZ3JhbSA9IGZ1bmN0aW9uKHRhcmdldCwgdmlzdWFsVmFyLCBwcm9wZXJ0eSkge1xyXG4gICAgICBpZiAoIXRhcmdldClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGFyZ3VtZW50OiBcInRhcmdldFwiJyk7XHJcblxyXG4gICAgICB2YXIgdjtcclxuICAgICAgc3dpdGNoICh0YXJnZXQpIHtcclxuICAgICAgICBjYXNlICdub2Rlcyc6XHJcbiAgICAgICAgICB2ID0gX3Zpc2lvbk9uTm9kZXM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdlZGdlcyc6XHJcbiAgICAgICAgICB2ID0gX3Zpc2lvbk9uRWRnZXM7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBcInRhcmdldFwiIGlzIG5vdCBcIm5vZGVzXCIgb3IgXCJlZGdlc1wiLCB3YXMgJyArIHRhcmdldCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh2LnZpc3VhbFZhcnMuaW5kZXhPZih2aXN1YWxWYXIpID09IC0xKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB2aXN1YWwgdmFyaWFibGUgXCInICsgdmlzdWFsVmFyICsgJ1wiLicpO1xyXG5cclxuICAgICAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJwcm9wZXJ0eVwiLicpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudDogXCJwcm9wZXJ0eVwiIGlzIG5vdCBhIHN0cmluZywgd2FzJyArIHByb3BlcnR5KTtcclxuXHJcbiAgICAgIHZhciBpc1NlcXVlbnRpYWwgPSBzZWxmLnV0aWxzLmlzU2VxdWVudGlhbCh0YXJnZXQsIHByb3BlcnR5KTtcclxuXHJcbiAgICAgIGlmICghaXNTZXF1ZW50aWFsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3BlcnR5IFwiJysgcHJvcGVydHkgKydcIiBpcyBub3Qgc2VxdWVudGlhbC4nKTtcclxuXHJcbiAgICAgIHZhciBoID0gaGlzdG9ncmFtKHYuaGlzdG9ncmFtc1t2aXN1YWxWYXJdLCBwcm9wZXJ0eSk7XHJcbiAgICAgIGggPSByZXNvbHZlSGlzdG9ncmFtKGgsIHYsIHByb3BlcnR5KTtcclxuXHJcbiAgICAgIGlmICh2aXN1YWxWYXIgPT09ICdjb2xvcicpIHtcclxuICAgICAgICBpZiAoIXNlbGYuc3R5bGVzW3RhcmdldF0uY29sb3IpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBrZXkgXCJjb2xvclwiIGluICcrIHRhcmdldCArJyBwYWxldHRlLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmlucyA9IGgubGVuZ3RoLFxyXG4gICAgICAgICAgbyA9IHN0clRvT2JqZWN0UmVmKHNlbGYucGFsZXR0ZSwgc2VsZi5zdHlsZXNbdGFyZ2V0XS5jb2xvci5zY2hlbWUpO1xyXG5cclxuICAgICAgICBpZiAoIW8pXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbG9yIHNjaGVtZSBcIicgKyBzZWxmLnN0eWxlc1t0YXJnZXRdLmNvbG9yLnNjaGVtZSArICdcIiBub3QgaW4gJysgdGFyZ2V0ICsnIHBhbGV0dGUuJyk7XHJcblxyXG4gICAgICAgIGlmIChpc1NlcXVlbnRpYWwpIHtcclxuICAgICAgICAgIGZvciAodmFyIGJpbiA9IDA7IGJpbiA8IGJpbnM7IGJpbisrKSB7XHJcbiAgICAgICAgICAgIGlmICghb1tiaW5zXSlcclxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcga2V5IFwiJysgYmlucyArJ1wiIGluICcrIHRhcmdldCArJyBwYWxldHRlIFwiIG9mIGNvbG9yIHNjaGVtZSAnICsgc2VsZi5zdHlsZXNbdGFyZ2V0XS5jb2xvci5zY2hlbWUgKyAnXCIuJyk7XHJcblxyXG4gICAgICAgICAgICBoW2Jpbl1bdmlzdWFsVmFyXSA9IG9bYmluc11bYmluXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBoO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJmYWNlXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICpcclxuICAgKiA+IHZhciBkZXNpZ24gPSBzaWdtYS5wbHVnaW5zLmRlc2lnbihzLCBvcHRpb25zKTtcclxuICAgKi9cclxuICB2YXIgX2luc3RhbmNlID0ge307XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hfSAgIHMgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7P29iamVjdH0gb3B0aW9ucyBUaGUgb2JqZWN0IGNvbnRhaW5zIGBwYWxldHRlYCBhbmQgYHN0eWxlc2AuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBTdHlsZXMgYXJlIG1hcHBpbmdzIGJldHdlZW4gdmlzdWFsIHZhcmlhYmxlcyBhbmRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgcHJvcGVydGllcyBvbiBub2RlcyBhbmQgZWRnZXMuXHJcbiAgICogQHJldHVybiB7ZGVzaWdufSAgICAgICAgVGhlIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnBsdWdpbnMuZGVzaWduID0gZnVuY3Rpb24ocywgb3B0aW9ucykge1xyXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlIGlmIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFfaW5zdGFuY2Vbcy5pZF0pIHtcclxuICAgICAgX2luc3RhbmNlW3MuaWRdID0gbmV3IGRlc2lnbihzLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfaW5zdGFuY2Vbcy5pZF07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogIFRoaXMgZnVuY3Rpb24ga2lsbHMgdGhlIGRlc2lnbiBpbnN0YW5jZS5cclxuICAgKi9cclxuICBzaWdtYS5wbHVnaW5zLmtpbGxEZXNpZ24gPSBmdW5jdGlvbihzKSB7XHJcbiAgICBpZiAoX2luc3RhbmNlW3MuaWRdIGluc3RhbmNlb2YgZGVzaWduKSB7XHJcbiAgICAgIF9pbnN0YW5jZVtzLmlkXS5raWxsKCk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUgX2luc3RhbmNlW3MuaWRdO1xyXG4gIH07XHJcblxyXG59KS5jYWxsKHRoaXMpO1xyXG4iLCIvKipcclxuICogVGhpcyBwbHVnaW4gcHJvdmlkZXMgYSBtZXRob2QgdG8gZHJhZyAmIGRyb3Agbm9kZXMuIENoZWNrIHRoZVxyXG4gKiBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyBmdW5jdGlvbiBkb2Mgb3IgdGhlIGV4YW1wbGVzL2RyYWctbm9kZXMuaHRtbCBjb2RlXHJcbiAqIHNhbXBsZSB0byBrbm93IG1vcmUuXHJcbiAqL1xyXG4oZnVuY3Rpb24oKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcclxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xyXG5cclxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnBsdWdpbnMnKTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgYG1vdXNlZG93bmAsIGBtb3VzZXVwYCAmIGBtb3VzZW1vdmVgIGV2ZW50cyB0byB0aGVcclxuICAgKiBub2RlcyBpbiB0aGUgYG92ZXJOb2RlYGV2ZW50IHRvIHBlcmZvcm0gZHJhZyAmIGRyb3Agb3BlcmF0aW9ucy4gSXQgdXNlc1xyXG4gICAqIGBsaW5lYXIgaW50ZXJwb2xhdGlvbmAgW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25dXHJcbiAgICogYW5kIGByb3RhdGlvbiBtYXRyaXhgIFtodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvdGF0aW9uX21hdHJpeF0gdG9cclxuICAgKiBjYWxjdWxhdGUgdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMgZnJvbSB0aGUgYGNhbWAgb3IgYHJlbmRlcmVyYCBub2RlXHJcbiAgICogYXR0cmlidXRlcy4gVGhlc2UgYXR0cmlidXRlcyByZXByZXNlbnQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBub2RlcyBpblxyXG4gICAqIHRoZSByZWFsIGNvbnRhaW5lciwgbm90IGluIGNhbnZhcy5cclxuICAgKlxyXG4gICAqIEZpcmVkIGV2ZW50czpcclxuICAgKiAqKioqKioqKioqKioqXHJcbiAgICogc3RhcnRkcmFnICBGaXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkcmFnLlxyXG4gICAqIGRyYWcgICAgICAgRmlyZWQgd2hpbGUgdGhlIG5vZGUgaXMgZHJhZ2dlZC5cclxuICAgKiBkcm9wICAgICAgIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGRyYWcgaWYgdGhlIG5vZGUgaGFzIGJlZW4gZHJhZ2dlZC5cclxuICAgKiBkcmFnZW5kICAgIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGRyYWcuXHJcbiAgICpcclxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XHJcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqIEBwYXJhbSAge3NpZ21hfSAgICAgICAgICAgICAgICAgICAgICBzICAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cclxuICAgKiBAcGFyYW0gIHtyZW5kZXJlcn0gICAgICAgICAgICAgICAgICAgcmVuZGVyZXIgVGhlIHJlbGF0ZWQgcmVuZGVyZXIgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7P3NpZ21hLnBsdWdpbnMuYWN0aXZlU3RhdGV9IGEgICAgICAgIFRoZSBhY3RpdmVTdGF0ZSBwbHVnaW4gaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gRHJhZ05vZGVzKHMsIHJlbmRlcmVyLCBhKSB7XHJcbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xyXG5cclxuICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIHBsdWdpbiB3aXRoIHRoZVxyXG4gICAgLy8gV2ViR0wgcmVuZGVyZXIgKHdoaWNoIGlzIGltcG9zc2libGUgYXQgdGhlIG1vbWVudCk6XHJcbiAgICBpZiAoXHJcbiAgICAgIHNpZ21hLnJlbmRlcmVycy53ZWJnbCAmJlxyXG4gICAgICByZW5kZXJlciBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy53ZWJnbFxyXG4gICAgKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgJ1RoZSBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBXZWJHTCByZW5kZXJlcidcclxuICAgICAgKTtcclxuXHJcbiAgICAvLyBJbml0IHZhcmlhYmxlczpcclxuICAgIHZhciBfc2VsZiA9IHRoaXMsXHJcbiAgICAgIF9zID0gcyxcclxuICAgICAgX2EgPSBhLFxyXG4gICAgICBfYm9keSA9IGRvY3VtZW50LmJvZHksXHJcbiAgICAgIF9yZW5kZXJlciA9IHJlbmRlcmVyLFxyXG4gICAgICBfbW91c2UgPSByZW5kZXJlci5jb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2lnbWEtbW91c2UnKVswXSxcclxuICAgICAgX3ByZWZpeCA9IHJlbmRlcmVyLm9wdGlvbnMucHJlZml4LFxyXG4gICAgICBfbm9kZSA9IG51bGwsXHJcbiAgICAgIF9kcmFnZ2luZ05vZGUgPSBudWxsLFxyXG4gICAgICBfaG92ZXJlZE5vZGUgPSBudWxsLFxyXG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZSxcclxuICAgICAgX2lzTW91c2VPdmVyQ2FudmFzID0gZmFsc2UsXHJcbiAgICAgIF9kcmFnID0gZmFsc2UsXHJcbiAgICAgIF9zdGlja3kgPSB0cnVlLFxyXG4gICAgICBfZW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLnN2Zykge1xyXG4gICAgICAgIF9tb3VzZSA9IHJlbmRlcmVyLmNvbnRhaW5lci5maXJzdENoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcmVyLmJpbmQoJ2hvdmVycycsIG5vZGVNb3VzZU92ZXIpO1xyXG4gICAgcmVuZGVyZXIuYmluZCgnaG92ZXJzJywgdHJlYXRPdXROb2RlKTtcclxuICAgIHJlbmRlcmVyLmJpbmQoJ2NsaWNrJywgY2xpY2spO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIGRyYWdnaW5nIGFuZCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9lbmFibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgZHJhZ2dpbmcgYW5kIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgIF9ub2RlID0gbnVsbCxcclxuICAgICAgX2RyYWdnaW5nTm9kZSA9IG51bGwsXHJcbiAgICAgIF9ob3ZlcmVkTm9kZSA9IG51bGw7XHJcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlLFxyXG4gICAgICBfaXNNb3VzZU92ZXJDYW52YXMgPSBmYWxzZSxcclxuICAgICAgX2RyYWcgPSBmYWxzZSxcclxuICAgICAgX3N0aWNreSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmJpbmQgYWxsIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAqL1xyXG4gICAgdGhpcy51bmJpbmRBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgX21vdXNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xyXG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBub2RlTW91c2VNb3ZlKTtcclxuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG5vZGVNb3VzZVVwKTtcclxuICAgICAgX3JlbmRlcmVyLnVuYmluZCgnaG92ZXJzJywgbm9kZU1vdXNlT3Zlcik7XHJcbiAgICAgIF9yZW5kZXJlci51bmJpbmQoJ2hvdmVycycsIHRyZWF0T3V0Tm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIG9mZnNldCBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBtb3JlIGFjY3VyYXRlbHkgdGhhblxyXG4gICAgLy8gZWxlbWVudC5vZmZzZXRUb3AgYW5kIGVsZW1lbnQub2Zmc2V0TGVmdC5cclxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChlbGVtZW50KSB7XHJcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xyXG4gICAgICB2YXIgZ2V0Q3NzUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCkucmVwbGFjZSgncHgnLCAnJykpIHx8IDA7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctbGVmdCcpLFxyXG4gICAgICAgIHRvcDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBnZXRDc3NQcm9wZXJ0eSgncGFkZGluZy10b3AnKVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjbGljayhldmVudCkge1xyXG4gICAgICAvLyBldmVudCB0cmlnZ2VyZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2xpY2tcclxuICAgICAgX2lzTW91c2VEb3duID0gZmFsc2U7XHJcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xyXG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xyXG5cclxuICAgICAgaWYgKCFfaG92ZXJlZE5vZGUpIHtcclxuICAgICAgICBfbm9kZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gRHJhZyBub2RlIHJpZ2h0IGFmdGVyIGNsaWNrIGluc3RlYWQgb2YgbmVlZGluZyBtb3VzZSBvdXQgKyBtb3VzZSBvdmVyOlxyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgbm9kZSB0byBiZSB0aGUgbGFzdCBob3ZlcmVkIG5vZGVcclxuICAgICAgICAgIF9ub2RlID0gX2hvdmVyZWROb2RlO1xyXG4gICAgICAgICAgX21vdXNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZU92ZXIoZXZlbnQpIHtcclxuICAgICAgaWYgKGV2ZW50LmRhdGEuZW50ZXIubm9kZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG4gPSBldmVudC5kYXRhLmVudGVyLm5vZGVzWzBdO1xyXG5cclxuICAgICAgLy8gRG9uJ3QgdHJlYXQgdGhlIG5vZGUgaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkXHJcbiAgICAgIGlmIChfaG92ZXJlZE5vZGUgJiYgX2hvdmVyZWROb2RlLmlkID09PSBuLmlkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgcmVmZXJlbmNlIHRvIHRoZSBob3ZlcmVkIG5vZGVcclxuICAgICAgX2hvdmVyZWROb2RlID0gbjtcclxuXHJcbiAgICAgIGlmKCFfaXNNb3VzZURvd24pIHtcclxuICAgICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgbm9kZSB0byBiZSB0aGUgbGFzdCBob3ZlcmVkIG5vZGVcclxuICAgICAgICBfbm9kZSA9IF9ob3ZlcmVkTm9kZTtcclxuICAgICAgICBfbW91c2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gdHJlYXRPdXROb2RlKGV2ZW50KSB7XHJcbiAgICAgIGlmIChldmVudC5kYXRhLmxlYXZlLm5vZGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBuID0gZXZlbnQuZGF0YS5sZWF2ZS5ub2Rlc1swXTtcclxuXHJcbiAgICAgIGlmIChfaG92ZXJlZE5vZGUgJiYgX2hvdmVyZWROb2RlLmlkID09PSBuLmlkKSB7XHJcbiAgICAgICAgX2hvdmVyZWROb2RlID0gbnVsbDtcclxuICAgICAgICBfbm9kZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoIV9ob3ZlcmVkTm9kZSkge1xyXG4gICAgICAgIF9tb3VzZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBub2RlTW91c2VEb3duKGV2ZW50KSB7XHJcbiAgICAgIGlmKCFfZW5hYmxlZCB8fCBldmVudC53aGljaCA9PSAzKSByZXR1cm47IC8vIFJpZ2h0IG1vdXNlIGJ1dHRvbiBwcmVzc2VkXHJcblxyXG4gICAgICBfaXNNb3VzZURvd24gPSB0cnVlO1xyXG4gICAgICBpZiAoX25vZGUgJiYgX3MuZ3JhcGgubm9kZXMoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgX3N0aWNreSA9IHRydWU7XHJcbiAgICAgICAgX21vdXNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xyXG4gICAgICAgIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xyXG4gICAgICAgIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XHJcblxyXG4gICAgICAgIC8vIERlYWN0aXZhdGUgZHJhZyBncmFwaC5cclxuICAgICAgICBfcmVuZGVyZXIuc2V0dGluZ3Moe21vdXNlRW5hYmxlZDogZmFsc2UsIGVuYWJsZUhvdmVyaW5nOiBmYWxzZX0pO1xyXG5cclxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdzdGFydGRyYWcnLCB7XHJcbiAgICAgICAgICBub2RlOiBfbm9kZSxcclxuICAgICAgICAgIGNhcHRvcjogZXZlbnQsXHJcbiAgICAgICAgICByZW5kZXJlcjogX3JlbmRlcmVyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlVXAoZXZlbnQpIHtcclxuICAgICAgX2lzTW91c2VEb3duID0gZmFsc2U7XHJcbiAgICAgIF9tb3VzZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcclxuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XHJcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBub2RlTW91c2VVcCk7XHJcblxyXG4gICAgICAvLyBBY3RpdmF0ZSBkcmFnIGdyYXBoLlxyXG4gICAgICBfcmVuZGVyZXIuc2V0dGluZ3Moe21vdXNlRW5hYmxlZDogdHJ1ZSwgZW5hYmxlSG92ZXJpbmc6IHRydWV9KTtcclxuXHJcbiAgICAgIGlmIChfZHJhZykge1xyXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2Ryb3AnLCB7XHJcbiAgICAgICAgICBub2RlOiBfZHJhZ2dpbmdOb2RlLFxyXG4gICAgICAgICAgY2FwdG9yOiBldmVudCxcclxuICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYoX2EpIHtcclxuICAgICAgICAgIHZhciBhY3RpdmVOb2RlcyA9IF9hLm5vZGVzKCk7XHJcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYWN0aXZlTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWN0aXZlTm9kZXNbaV0uYWxwaGFYID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBhY3RpdmVOb2Rlc1tpXS5hbHBoYVkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfcy5yZWZyZXNoKCk7XHJcbiAgICAgIH1cclxuICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZ2VuZCcsIHtcclxuICAgICAgICBub2RlOiBfbm9kZSxcclxuICAgICAgICBjYXB0b3I6IGV2ZW50LFxyXG4gICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBfZHJhZyA9IGZhbHNlO1xyXG4gICAgICBfZHJhZ2dpbmdOb2RlID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbm9kZU1vdXNlTW92ZShldmVudCkge1xyXG4gICAgICBpZihuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTEpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZU91dCk7XHJcbiAgICAgICAgdmFyIHRpbWVPdXQgPSBzZXRUaW1lb3V0KGV4ZWN1dGVOb2RlTW91c2VNb3ZlLCAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBleGVjdXRlTm9kZU1vdXNlTW92ZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBleGVjdXRlTm9kZU1vdXNlTW92ZSgpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gY2FsY3VsYXRlT2Zmc2V0KF9yZW5kZXJlci5jb250YWluZXIpLFxyXG4gICAgICAgICAgICB4ID0gZXZlbnQuY2xpZW50WCAtIG9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WSAtIG9mZnNldC50b3AsXHJcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKF9yZW5kZXJlci5jYW1lcmEuYW5nbGUpLFxyXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihfcmVuZGVyZXIuY2FtZXJhLmFuZ2xlKSxcclxuICAgICAgICAgICAgbm9kZXMgPSBfcy5ncmFwaC5ub2RlcygpLFxyXG4gICAgICAgICAgICByZWYgPSBbXSxcclxuICAgICAgICAgICAgeDIsXHJcbiAgICAgICAgICAgIHkyLFxyXG4gICAgICAgICAgICBhY3RpdmVOb2RlcyxcclxuICAgICAgICAgICAgbixcclxuICAgICAgICAgICAgYXV4LFxyXG4gICAgICAgICAgICBpc0hvdmVyZWROb2RlQWN0aXZlLFxyXG4gICAgICAgICAgICBkaXN0O1xyXG5cclxuICAgICAgICBpZiAoX2EgJiYgX2EubmJOb2RlcygpID09PSBub2Rlcy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKCFfZW5hYmxlZCB8fCBub2Rlcy5sZW5ndGggPCAyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGRpc3QgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBfbm9kZVtfcHJlZml4ICsgJ3gnXSxfbm9kZVtfcHJlZml4ICsgJ3knXSk7XHJcblxyXG4gICAgICAgIGlmIChfc3RpY2t5ICYmIGRpc3QgPCBfbm9kZVtfcHJlZml4ICsgJ3NpemUnXSkgcmV0dXJuO1xyXG4gICAgICAgIF9zdGlja3kgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0d28gcmVmZXJlbmNlIHBvaW50cyBhbmQgZGVyb3RhdGUgdGhlbVxyXG4gICAgICAgIC8vIFdlIHRha2UgdGhlIGZpcnN0IG5vZGUgYXMgYSBmaXJzdCByZWZlcmVuY2UgcG9pbnQgYW5kIHRoZW4gdHJ5IHRvIGZpbmRcclxuICAgICAgICAvLyBhbm90aGVyIG5vZGUgbm90IGFsaWduZWQgd2l0aCBpdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOztpKyspIHtcclxuICAgICAgICAgIGlmKCFfZW5hYmxlZCkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgbiA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgaWYgKG4pIHtcclxuICAgICAgICAgICAgYXV4ID0ge1xyXG4gICAgICAgICAgICAgIHg6IG4ueCAqIGNvcyArIG4ueSAqIHNpbixcclxuICAgICAgICAgICAgICB5OiBuLnkgKiBjb3MgLSBuLnggKiBzaW4sXHJcbiAgICAgICAgICAgICAgcmVuWDogbltfcHJlZml4ICsgJ3gnXSwgLy9yZW5kZXJlciBYXHJcbiAgICAgICAgICAgICAgcmVuWTogbltfcHJlZml4ICsgJ3knXSwgLy9yZW5kZXJlciBZXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlZi5wdXNoKGF1eCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZihpID09IG5vZGVzLmxlbmd0aCAtIDEpIHsgLy93ZSB0cmllZCBhbGwgbm9kZXNcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocmVmWzBdLnggPT0gcmVmWzFdLnggfHwgcmVmWzBdLnkgPT0gcmVmWzFdLnkpIHtcclxuICAgICAgICAgICAgICByZWYucG9wKCkgLy8gZHJvcCBsYXN0IG5vZGVzIGFuZCB0cnkgdG8gZmluZCBhbm90aGVyIG9uZVxyXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB3ZSBtYW5hZ2VkIHRvIGZpbmQgdHdvIG5vZGVzIG5vdCBhbGlnbmVkXHJcbiAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGEgPSByZWZbMF0sIGIgPSByZWZbMV07XHJcblxyXG4gICAgICAgIC8vIEFwcGx5aW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxyXG4gICAgICAgIHZhciBkaXZ4ID0gKGIucmVuWCAtIGEucmVuWCk7XHJcbiAgICAgICAgaWYgKGRpdnggPT09IDApIGRpdnggPSAxOyAvL2ZpeCBlZGdlIGNhc2Ugd2hlcmUgYXhpcyBhcmUgYWxpZ25lZFxyXG5cclxuICAgICAgICB2YXIgZGl2eSA9IChiLnJlblkgLSBhLnJlblkpO1xyXG4gICAgICAgIGlmIChkaXZ5ID09PSAwKSBkaXZ5ID0gMTsgLy9maXggZWRnZSBjYXNlIHdoZXJlIGF4aXMgYXJlIGFsaWduZWRcclxuXHJcbiAgICAgICAgeCA9ICgoeCAtIGEucmVuWCkgLyBkaXZ4KSAqIChiLnggLSBhLngpICsgYS54O1xyXG4gICAgICAgIHkgPSAoKHkgLSBhLnJlblkpIC8gZGl2eSkgKiAoYi55IC0gYS55KSArIGEueTtcclxuXHJcbiAgICAgICAgeDIgPSB4ICogY29zIC0geSAqIHNpbjtcclxuICAgICAgICB5MiA9IHkgKiBjb3MgKyB4ICogc2luO1xyXG5cclxuICAgICAgICAvLyBEcmFnIG11bHRpcGxlIG5vZGVzLCBLZWVwIGRpc3RhbmNlXHJcbiAgICAgICAgaWYoX2EpIHtcclxuICAgICAgICAgIGFjdGl2ZU5vZGVzID0gX2Eubm9kZXMoKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBob3ZlcmVkIG5vZGUgaXMgYWN0aXZlLCBkcmFnIGFjdGl2ZSBub2Rlc1xyXG4gICAgICAgICAgaXNIb3ZlcmVkTm9kZUFjdGl2ZSA9ICgtMSA8IGFjdGl2ZU5vZGVzLm1hcChmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmlkO1xyXG4gICAgICAgICAgfSkuaW5kZXhPZihfbm9kZS5pZCkpO1xyXG5cclxuICAgICAgICAgIGlmIChpc0hvdmVyZWROb2RlQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhY3RpdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIC8vIERlbGV0ZSBvbGQgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgaWYoX2RyYWdnaW5nTm9kZSAhPSBfbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlTm9kZXNbaV0uYWxwaGFYID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlTm9kZXNbaV0uYWxwaGFZID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsIGZpcnN0IHBvc2l0aW9uIG9mIGFjdGl2ZU5vZGVzXHJcbiAgICAgICAgICAgICAgaWYoIWFjdGl2ZU5vZGVzW2ldLmFscGhhWCB8fCAhYWN0aXZlTm9kZXNbaV0uYWxwaGFZKSB7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVOb2Rlc1tpXS5hbHBoYVggPSBhY3RpdmVOb2Rlc1tpXS54IC0geDtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZU5vZGVzW2ldLmFscGhhWSA9IGFjdGl2ZU5vZGVzW2ldLnkgLSB5O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gTW92ZSBhY3RpdmVOb2RlcyB0byBrZWVwIHNhbWUgZGlzdGFuY2UgYmV0d2VlbiBkcmFnZ2VkIG5vZGVzXHJcbiAgICAgICAgICAgICAgLy8gYW5kIGFjdGl2ZSBub2Rlc1xyXG4gICAgICAgICAgICAgIGFjdGl2ZU5vZGVzW2ldLnggPSBfbm9kZS54ICsgYWN0aXZlTm9kZXNbaV0uYWxwaGFYO1xyXG4gICAgICAgICAgICAgIGFjdGl2ZU5vZGVzW2ldLnkgPSBfbm9kZS55ICsgYWN0aXZlTm9kZXNbaV0uYWxwaGFZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSb3RhdGluZyB0aGUgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgX25vZGUueCA9IHgyO1xyXG4gICAgICAgIF9ub2RlLnkgPSB5MjtcclxuXHJcbiAgICAgICAgX3MucmVmcmVzaCh7c2tpcEluZGV4YXRpb246IHRydWV9KTtcclxuXHJcbiAgICAgICAgX2RyYWcgPSB0cnVlO1xyXG4gICAgICAgIF9kcmFnZ2luZ05vZGUgPSBfbm9kZTtcclxuXHJcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycsIHtcclxuICAgICAgICAgIG5vZGU6IF9kcmFnZ2luZ05vZGUsXHJcbiAgICAgICAgICBjYXB0b3I6IGV2ZW50LFxyXG4gICAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqXHJcbiAgICogPiB2YXIgZHJhZ05vZGVzTGlzdGVuZXIgPSBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyhzLCBzLnJlbmRlcmVyc1swXSwgYSk7XHJcbiAgICovXHJcbiAgdmFyIF9pbnN0YW5jZSA9IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gIHtzaWdtYX0gICAgICAgICAgICAgICAgICAgICAgcyAgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtICB7cmVuZGVyZXJ9ICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyIFRoZSByZWxhdGVkIHJlbmRlcmVyIGluc3RhbmNlLlxyXG4gICAqIEBwYXJhbSAgez9zaWdtYS5wbHVnaW5zLmFjdGl2ZVN0YXRlfSBhICAgICAgICBUaGUgYWN0aXZlU3RhdGUgcGx1Z2luIGluc3RhbmNlLlxyXG4gICAqL1xyXG4gIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzID0gZnVuY3Rpb24ocywgcmVuZGVyZXIsIGEpIHtcclxuICAgIC8vIENyZWF0ZSBvYmplY3QgaWYgdW5kZWZpbmVkXHJcbiAgICBpZiAoIV9pbnN0YW5jZVtzLmlkXSkge1xyXG4gICAgICAvLyBIYW5kbGUgZHJhZyBldmVudHM6XHJcbiAgICAgIF9pbnN0YW5jZVtzLmlkXSA9IG5ldyBEcmFnTm9kZXMocywgcmVuZGVyZXIsIGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHMuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBzaWdtYS5wbHVnaW5zLmtpbGxEcmFnTm9kZXMocyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBkaXNhYmxlIG9uIHBsdWdpbnMuYW5pbWF0ZSBzdGFydC5cclxuICAgIHMuYmluZCgnYW5pbWF0ZS5zdGFydCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICBfaW5zdGFuY2Vbcy5pZF0uZGlzYWJsZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZW5hYmxlIG9uIHBsdWdpbnMuYW5pbWF0ZSBlbmQuXHJcbiAgICBzLmJpbmQoJ2FuaW1hdGUuZW5kJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIF9pbnN0YW5jZVtzLmlkXS5lbmFibGUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBfaW5zdGFuY2Vbcy5pZF07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGFuZCBraWxscyB0aGUgZHJhZ05vZGVzIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c2lnbWF9IHMgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEucGx1Z2lucy5raWxsRHJhZ05vZGVzID0gZnVuY3Rpb24ocykge1xyXG4gICAgaWYgKF9pbnN0YW5jZVtzLmlkXSBpbnN0YW5jZW9mIERyYWdOb2Rlcykge1xyXG4gICAgICBfaW5zdGFuY2Vbcy5pZF0udW5iaW5kQWxsKCk7XHJcbiAgICAgIGRlbGV0ZSBfaW5zdGFuY2Vbcy5pZF07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbn0pLmNhbGwod2luZG93KTtcclxuIiwiLyoqXHJcbiAqIFRoaXMgcGx1Z2luIHByb3ZpZGVzIGEgbWV0aG9kIHRvIGRpc3BsYXkgYSB0b29sdGlwIGF0IGEgc3BlY2lmaWMgZXZlbnQsIGUuZy5cclxuICogdG8gZGlzcGxheSBzb21lIG5vZGUgcHJvcGVydGllcyBvbiBub2RlIGhvdmVyLiBDaGVjayB0aGVcclxuICogc2lnbWEucGx1Z2lucy50b29sdGlwIGZ1bmN0aW9uIGRvYyBvciB0aGUgZXhhbXBsZXMvdG9vbHRpcC5odG1sIGNvZGUgc2FtcGxlXHJcbiAqIHRvIGtub3cgbW9yZS5cclxuICovXHJcbihmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYSBpcyBub3QgZGVjbGFyZWQnKTtcclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlOlxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucGx1Z2lucycpO1xyXG5cclxuICAvKipcclxuICAgKiBTaWdtYSB0b29sdGlwXHJcbiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgKlxyXG4gICAqIEBhdXRob3IgU8OpYmFzdGllbiBIZXltYW5uIDxzZWJAbGlua3VyaW8udXM+IChMaW5rdXJpb3VzKVxyXG4gICAqIEB2ZXJzaW9uIDAuM1xyXG4gICAqL1xyXG5cclxuICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICBzdGFnZToge1xyXG4gICAgICBzaG93OiAncmlnaHRDbGlja1N0YWdlJyxcclxuICAgICAgaGlkZTogJ2NsaWNrU3RhZ2UnLFxyXG4gICAgICBjc3NDbGFzczogJ3NpZ21hLXRvb2x0aXAnLFxyXG4gICAgICBwb3NpdGlvbjogJ3RvcCcsICAgIC8vIHRvcCB8IGJvdHRvbSB8IGxlZnQgfCByaWdodFxyXG4gICAgICBhdXRvYWRqdXN0OiBmYWxzZSxcclxuICAgICAgZGVsYXk6IDAsXHJcbiAgICAgIGhpZGVEZWxheTogMCxcclxuICAgICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBIVE1MIHN0cmluZ1xyXG4gICAgICByZW5kZXJlcjogbnVsbCAgICAgIC8vIGZ1bmN0aW9uXHJcbiAgICB9LFxyXG4gICAgbm9kZToge1xyXG4gICAgICBzaG93OiAnY2xpY2tOb2RlJyxcclxuICAgICAgaGlkZTogJ2NsaWNrU3RhZ2UnLFxyXG4gICAgICBjc3NDbGFzczogJ3NpZ21hLXRvb2x0aXAnLFxyXG4gICAgICBwb3NpdGlvbjogJ3RvcCcsICAgIC8vIHRvcCB8IGJvdHRvbSB8IGxlZnQgfCByaWdodFxyXG4gICAgICBhdXRvYWRqdXN0OiBmYWxzZSxcclxuICAgICAgZGVsYXk6IDAsXHJcbiAgICAgIGhpZGVEZWxheTogMCxcclxuICAgICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBIVE1MIHN0cmluZ1xyXG4gICAgICByZW5kZXJlcjogbnVsbCAgICAgIC8vIGZ1bmN0aW9uXHJcbiAgICB9LFxyXG4gICAgZWRnZToge1xyXG4gICAgICBzaG93OiAnY2xpY2tFZGdlJyxcclxuICAgICAgaGlkZTogJ2NsaWNrU3RhZ2UnLFxyXG4gICAgICBjc3NDbGFzczogJ3NpZ21hLXRvb2x0aXAnLFxyXG4gICAgICBwb3NpdGlvbjogJ3RvcCcsICAgIC8vIHRvcCB8IGJvdHRvbSB8IGxlZnQgfCByaWdodFxyXG4gICAgICBhdXRvYWRqdXN0OiBmYWxzZSxcclxuICAgICAgZGVsYXk6IDAsXHJcbiAgICAgIGhpZGVEZWxheTogMCxcclxuICAgICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBIVE1MIHN0cmluZ1xyXG4gICAgICByZW5kZXJlcjogbnVsbCAgICAgIC8vIGZ1bmN0aW9uXHJcbiAgICB9LFxyXG4gICAgZG91YmxlQ2xpY2tEZWxheTogODAwXHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBkaXNwbGF5IGEgdG9vbHRpcCB3aGVuIGEgc2lnbWEgZXZlbnQgaXMgZmlyZWQuIEl0IHdpbGxcclxuICAgKiBiYXNpY2FsbHkgY3JlYXRlIGEgRE9NIGVsZW1lbnQsIGZpbGwgaXQgd2l0aCB0aGUgdGVtcGxhdGUgb3IgdGhlIHJlc3VsdCBvZlxyXG4gICAqIHRoZSByZW5kZXJlciBmdW5jdGlvbiwgc2V0IGl0cyBwb3NpdGlvbiBhbmQgQ1NTIGNsYXNzLCBhbmQgaW5zZXJ0IHRoZVxyXG4gICAqIGVsZW1lbnQgYXMgYSBjaGlsZCBvZiB0aGUgc2lnbWEgY29udGFpbmVyLiBPbmx5IG9uZSB0b29sdGlwIG1heSBleGlzdC5cclxuICAgKlxyXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVycyBvZiBvcHRpb25zOlxyXG4gICAqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAqIEVuYWJsZSBub2RlIHRvb2x0aXBzIGJ5IGFkZGluZyB0aGUgXCJub2RlXCIga2V5IHRvIHRoZSBvcHRpb25zIG9iamVjdC5cclxuICAgKiBFbmFibGUgZWRnZSB0b29sdGlwcyBieSBhZGRpbmcgdGhlIFwiZWRnZVwiIGtleSB0byB0aGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICogRWFjaCB2YWx1ZSBjb3VsZCBiZSBhbiBhcnJheSBvZiBvYmplY3RzIGZvciBtdWx0aXBsZSB0b29sdGlwcyxcclxuICAgKiBvciBhbiBvYmplY3QgZm9yIG9uZSB0b29sdGlwLlxyXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXIgaW4gdGhlc2Ugb2JqZWN0czpcclxuICAgKlxyXG4gICAqICAgez9zdHJpbmd9ICAgc2hvdyAgICAgICBUaGUgZXZlbnQgdGhhdCB0cmlnZ2VycyB0aGUgdG9vbHRpcC4gRGVmYXVsdFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFwiY2xpY2tOb2RlXCIsIFwiY2xpY2tFZGdlXCIuIE90aGVyIHN1Z2dlc3RlZFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFwib3Zlck5vZGVcIiwgXCJkb3VibGVDbGlja05vZGVcIixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyaWdodENsaWNrTm9kZVwiLCBcImhvdmVyc1wiLCBcImRvdWJsZUNsaWNrRWRnZVwiLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBcInJpZ2h0Q2xpY2tFZGdlXCIsIFwiZG91YmxlQ2xpY2tOb2RlXCIsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFwicmlnaHRDbGlja05vZGVcIi5cclxuICAgKiAgIHs/c3RyaW5nfSAgIGhpZGUgICAgICAgVGhlIGV2ZW50IHRoYXQgaGlkZXMgdGhlIHRvb2x0aXAuIERlZmF1bHQgdmFsdWU6XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xpY2tTdGFnZVwiLiBPdGhlciBzdWdnZXN0ZWQgdmFsdWVzOiBcImhvdmVyc1wiXHJcbiAgICogICB7P3N0cmluZ30gICB0ZW1wbGF0ZSAgIFRoZSBIVE1MIHRlbXBsYXRlLiBJdCBpcyBkaXJlY3RseSBpbnNlcnRlZCBpbnNpZGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYSBkaXYgZWxlbWVudCB1bmxlc3MgYSByZW5kZXJlciBpcyBzcGVjaWZpZWQuXHJcbiAgICogICB7P2Z1bmN0aW9ufSByZW5kZXJlciAgIFRoaXMgZnVuY3Rpb24gbWF5IHByb2Nlc3MgdGhlIHRlbXBsYXRlIG9yIGJlIHVzZWRcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXBlbmRlbnRseS4gSXQgc2hvdWxkIHJldHVybiBhbiBIVE1MIHN0cmluZyBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhIERPTSBlbGVtZW50LiBJdCBpcyBleGVjdXRlZCBhdCBydW50aW1lLiBJdHNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCBpcyBzaWdtYS5ncmFwaC5cclxuICAgKiAgIHs/c3RyaW5nfSAgIGNzc0NsYXNzICAgVGhlIENTUyBjbGFzcyBhdHRhY2hlZCB0byB0aGUgdG9wIGRpdiBlbGVtZW50LlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0IHZhbHVlOiBcInNpZ21hLXRvb2x0aXBcIi5cclxuICAgKiAgIHs/c3RyaW5nfSAgIHBvc2l0aW9uICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwIHJlZ2FyZGluZyB0aGUgbW91c2UuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIElmIGl0IGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB0b29sdGlwIHRvcC1sZWZ0XHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lciBpcyBwb3NpdGlvbm5lZCBhdCB0aGUgbW91c2UgcG9zaXRpb24uXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSB2YWx1ZXM6IFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBcInJpZ2h0XCIuXHJcbiAgICogICB7P251bWJlcn0gICBkZWxheSAgICAgIFRoZSBkZWxheSBpbiBtaWxpc2Vjb25kcyBiZWZvcmUgZGlzcGxheWluZyB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCBhZnRlciB0aGUgc2hvdyBldmVudCBpcyB0cmlnZ2VyZWQuXHJcbiAgICogICB7P2Jvb2xlYW59ICBhdXRvYWRqdXN0IFtFWFBFUklNRU5UQUxdIElmIHRydWUsIHRyaWVzIHRvIGFkanVzdCB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcCBwb3NpdGlvbiB0byBiZSBmdWxseSBpbmNsdWRlZCBpbiB0aGUgYm9keVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLiBEb2Vzbid0IHdvcmsgb24gRmlyZWZveCAzMC4gQmV0dGVyIHdvcmsgb25cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgd2l0aCBmaXhlZCB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gICAqXHJcbiAgICogPiBzaWdtYS5wbHVnaW5zLnRvb2x0aXAocywge1xyXG4gICAqID4gICBub2RlOiB7XHJcbiAgICogPiAgICAgdGVtcGxhdGU6ICdIZWxsbyBub2RlISdcclxuICAgKiA+ICAgfSxcclxuICAgKiA+ICAgZWRnZToge1xyXG4gICAqID4gICAgIHRlbXBsYXRlOiAnSGVsbG8gZWRnZSEnXHJcbiAgICogPiAgIH0sXHJcbiAgICogPiAgIHN0YWdlOiB7XHJcbiAgICogPiAgICAgdGVtcGxhdGU6ICdIZWxsbyBzdGFnZSEnXHJcbiAgICogPiAgIH1cclxuICAgKiA+IH0pO1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzaWdtYX0gICAgcyAgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtyZW5kZXJlcn0gcmVuZGVyZXIgVGhlIHJlbGF0ZWQgc2lnbWEgcmVuZGVyZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgb3B0aW9ucyAgQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBUb29sdGlwcyhzLCByZW5kZXJlciwgb3B0aW9ucykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIF90b29sdGlwLFxyXG4gICAgICAgIF90aW1lb3V0SGFuZGxlLFxyXG4gICAgICAgIF90aW1lb3V0SGlkZUhhbmRsZSxcclxuICAgICAgICBfc3RhZ2VUb29sdGlwcyA9IFtdLFxyXG4gICAgICAgIF9ub2RlVG9vbHRpcHMgPSBbXSxcclxuICAgICAgICBfZWRnZVRvb2x0aXBzID0gW10sXHJcbiAgICAgICAgX21vdXNlT3ZlclRvb2x0aXAgPSBmYWxzZSxcclxuICAgICAgICBfZG91YmxlQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnN0YWdlKSkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuc3RhZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBfc3RhZ2VUb29sdGlwcy5wdXNoKHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLnN0YWdlW2ldLCBzZXR0aW5ncy5zdGFnZSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfc3RhZ2VUb29sdGlwcy5wdXNoKHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLnN0YWdlLCBzZXR0aW5ncy5zdGFnZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMubm9kZSkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm5vZGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBfbm9kZVRvb2x0aXBzLnB1c2goc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMubm9kZVtpXSwgc2V0dGluZ3Mubm9kZSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfbm9kZVRvb2x0aXBzLnB1c2goc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMubm9kZSwgc2V0dGluZ3Mubm9kZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZWRnZSkpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmVkZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBfZWRnZVRvb2x0aXBzLnB1c2goc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMuZWRnZVtpXSwgc2V0dGluZ3MuZWRnZSkpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBfZWRnZVRvb2x0aXBzLnB1c2goc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMuZWRnZSwgc2V0dGluZ3MuZWRnZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XHJcblxyXG4gICAgcy5iaW5kKCdraWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHNpZ21hLnBsdWdpbnMua2lsbFRvb2x0aXBzKHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gY29udGV4dG1lbnVMaXN0ZW5lcihldmVudCkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgZXhpc3RpbmcgdG9vbHRpcCBhbmQgY3JlYXRlcyBhIG5ldyB0b29sdGlwIGZvciBhXHJcbiAgICAgKiBzcGVjaWZpZWQgbm9kZSBvciBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICBvICAgICAgICAgIFRoZSBub2RlIG9yIHRoZSBlZGdlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgIG9wdGlvbnMgICAgVGhlIG9wdGlvbnMgcmVsYXRlZCB0byB0aGUgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgIHggICAgICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbW91c2UuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICAgeSAgICAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBtb3VzZS5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvbkNvbXBsZXRlIE9wdGlvbmFsIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG9wZW4gZmluaXNoXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BlbiA9IGZ1bmN0aW9uKG8sIG9wdGlvbnMsIHgsIHksIG9uQ29tcGxldGUpIHtcclxuICAgICAgcmVtb3ZlKCk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIERPTSBlbGVtZW50OlxyXG4gICAgICBfdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICBpZiAob3B0aW9ucy5yZW5kZXJlcikge1xyXG4gICAgICAgIC8vIENvcHkgdGhlIG9iamVjdDpcclxuICAgICAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgICAgICB0b29sdGlwUmVuZGVyZXIsXHJcbiAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgIGs7XHJcbiAgICAgICAgZm9yIChrIGluIG8pXHJcbiAgICAgICAgICBjbG9uZVtrXSA9IG9ba107XHJcblxyXG4gICAgICAgIHRvb2x0aXBSZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXIuY2FsbChzLmdyYXBoLCBjbG9uZSwgb3B0aW9ucy50ZW1wbGF0ZSk7XHJcblxyXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdG9vbHRpcFJlbmRlcmVyO1xyXG5cclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgX3Rvb2x0aXAuaW5uZXJIVE1MID0gdG9vbHRpcFJlbmRlcmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vIHRvb2x0aXBSZW5kZXJlciBpcyBhIGRvbSBlbGVtZW50OlxyXG4gICAgICAgICAgX3Rvb2x0aXAuYXBwZW5kQ2hpbGQodG9vbHRpcFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgX3Rvb2x0aXAuaW5uZXJIVE1MID0gb3B0aW9ucy50ZW1wbGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbnRhaW5lclBvc2l0aW9uID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocmVuZGVyZXIuY29udGFpbmVyKS5wb3NpdGlvbjtcclxuXHJcbiAgICAgIGlmKGNvbnRhaW5lclBvc2l0aW9uICE9PSAnc3RhdGljJykge1xyXG4gICAgICAgIF90b29sdGlwLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IHJlbmRlcmVyLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB4ID0gfn4oeCAtIGNvbnRhaW5lclJlY3QubGVmdCk7XHJcbiAgICAgICAgeSA9IH5+KHkgLSBjb250YWluZXJSZWN0LnRvcCk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICAvLyBTdHlsZSBpdDpcclxuICAgICAgX3Rvb2x0aXAuY2xhc3NOYW1lID0gb3B0aW9ucy5jc3NDbGFzcztcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uICE9PSAnY3NzJykge1xyXG4gICAgICAgIGlmKGNvbnRhaW5lclBvc2l0aW9uID09PSAnc3RhdGljJykge1xyXG4gICAgICAgICAgX3Rvb2x0aXAuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCBwb3NpdGlvbiBpcyBtb3VzZSBwb3NpdGlvbjpcclxuICAgICAgICBfdG9vbHRpcC5zdHlsZS5sZWZ0ID0geCArICdweCc7XHJcbiAgICAgICAgX3Rvb2x0aXAuc3R5bGUudG9wID0geSArICdweCc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBfbW91c2VPdmVyVG9vbHRpcCA9IHRydWU7XHJcbiAgICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAgIF90b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcclxuICAgICAgICBfbW91c2VPdmVyVG9vbHRpcCA9IGZhbHNlO1xyXG4gICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAvLyBFeGVjdXRlIGFmdGVyIHJlbmRlcmluZzpcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIV90b29sdGlwKVxyXG4gICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBJbnNlcnQgdGhlIGVsZW1lbnQgaW4gdGhlIERPTTpcclxuICAgICAgICByZW5kZXJlci5jb250YWluZXIuYXBwZW5kQ2hpbGQoX3Rvb2x0aXApO1xyXG5cclxuICAgICAgICAvLyBGaW5kIG9mZnNldDpcclxuICAgICAgICB2YXIgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICB0b29sdGlwUmVjdCA9IF90b29sdGlwLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAgdG9vbHRpcFJlY3QudG9wIC0gYm9keVJlY3QudG9wLFxyXG4gICAgICAgICAgICBvZmZzZXRCb3R0b20gPSBib2R5UmVjdC5ib3R0b20gLSB0b29sdGlwUmVjdC5ib3R0b20sXHJcbiAgICAgICAgICAgIG9mZnNldExlZnQgPSAgdG9vbHRpcFJlY3QubGVmdCAtIGJvZHlSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgIG9mZnNldFJpZ2h0ID0gYm9keVJlY3QucmlnaHQgLSB0b29sdGlwUmVjdC5yaWdodDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnKSB7XHJcbiAgICAgICAgICAvLyBOZXcgcG9zaXRpb24gdmVydGljYWxseSBhbGlnbmVkIGFuZCBvbiB0b3Agb2YgdGhlIG1vdXNlOlxyXG4gICAgICAgICAgX3Rvb2x0aXAuY2xhc3NOYW1lID0gb3B0aW9ucy5jc3NDbGFzcyArICcgdG9wJztcclxuICAgICAgICAgIF90b29sdGlwLnN0eWxlLmxlZnQgPSB4IC0gKHRvb2x0aXBSZWN0LndpZHRoIC8gMikgKyAncHgnO1xyXG4gICAgICAgICAgX3Rvb2x0aXAuc3R5bGUudG9wID0geSAtIHRvb2x0aXBSZWN0LmhlaWdodCArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgICAvLyBOZXcgcG9zaXRpb24gdmVydGljYWxseSBhbGlnbmVkIGFuZCBvbiBib3R0b20gb2YgdGhlIG1vdXNlOlxyXG4gICAgICAgICAgX3Rvb2x0aXAuY2xhc3NOYW1lID0gb3B0aW9ucy5jc3NDbGFzcyArICcgYm90dG9tJztcclxuICAgICAgICAgIF90b29sdGlwLnN0eWxlLmxlZnQgPSB4IC0gKHRvb2x0aXBSZWN0LndpZHRoIC8gMikgKyAncHgnO1xyXG4gICAgICAgICAgX3Rvb2x0aXAuc3R5bGUudG9wID0geSArICdweCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgLy8gTmV3IHBvc2l0aW9uIHZlcnRpY2FsbHkgYWxpZ25lZCBhbmQgb24gYm90dG9tIG9mIHRoZSBtb3VzZTpcclxuICAgICAgICAgIF90b29sdGlwLmNsYXNzTmFtZSA9IG9wdGlvbnMuY3NzQ2xhc3MrICcgbGVmdCc7XHJcbiAgICAgICAgICBfdG9vbHRpcC5zdHlsZS5sZWZ0ID0geCAtIHRvb2x0aXBSZWN0LndpZHRoICsgJ3B4JztcclxuICAgICAgICAgIF90b29sdGlwLnN0eWxlLnRvcCA9IHkgLSAodG9vbHRpcFJlY3QuaGVpZ2h0IC8gMikgKyAncHgnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAvLyBOZXcgcG9zaXRpb24gdmVydGljYWxseSBhbGlnbmVkIGFuZCBvbiBib3R0b20gb2YgdGhlIG1vdXNlOlxyXG4gICAgICAgICAgX3Rvb2x0aXAuY2xhc3NOYW1lID0gb3B0aW9ucy5jc3NDbGFzcyArICcgcmlnaHQnO1xyXG4gICAgICAgICAgX3Rvb2x0aXAuc3R5bGUubGVmdCA9IHggKyAncHgnO1xyXG4gICAgICAgICAgX3Rvb2x0aXAuc3R5bGUudG9wID0geSAtICh0b29sdGlwUmVjdC5oZWlnaHQgLyAyKSArICdweCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gdG8ga2VlcCB0aGUgdG9vbHRpcCBpbnNpZGUgYm9keTpcclxuICAgICAgICAvLyBGSVhNRTogZG9lc24ndCB3b3JrIG9uIEZpcmVmb3hcclxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvYWRqdXN0KSB7XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIG9mZnNldFxyXG4gICAgICAgICAgdG9vbHRpcFJlY3QgPSBfdG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgIG9mZnNldFRvcCA9IHRvb2x0aXBSZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcclxuICAgICAgICAgIG9mZnNldEJvdHRvbSA9IGJvZHlSZWN0LmJvdHRvbSAtIHRvb2x0aXBSZWN0LmJvdHRvbTtcclxuICAgICAgICAgIG9mZnNldExlZnQgPSB0b29sdGlwUmVjdC5sZWZ0IC0gYm9keVJlY3QubGVmdDtcclxuICAgICAgICAgIG9mZnNldFJpZ2h0ID0gYm9keVJlY3QucmlnaHQgLSB0b29sdGlwUmVjdC5yaWdodDtcclxuXHJcbiAgICAgICAgICBpZiAob2Zmc2V0Qm90dG9tIDwgMCkge1xyXG4gICAgICAgICAgICBfdG9vbHRpcC5jbGFzc05hbWUgPSBvcHRpb25zLmNzc0NsYXNzO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgICBfdG9vbHRpcC5jbGFzc05hbWUgPSBvcHRpb25zLmNzc0NsYXNzICsgJyB0b3AnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90b29sdGlwLnN0eWxlLnRvcCA9IHkgLSB0b29sdGlwUmVjdC5oZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAob2Zmc2V0VG9wIDwgMCkge1xyXG4gICAgICAgICAgICBfdG9vbHRpcC5jbGFzc05hbWUgPSBvcHRpb25zLmNzc0NsYXNzO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcclxuICAgICAgICAgICAgICBfdG9vbHRpcC5jbGFzc05hbWUgPSBvcHRpb25zLmNzc0NsYXNzICsgJyBib3R0b20nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90b29sdGlwLnN0eWxlLnRvcCA9IHkgKyAncHgnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKG9mZnNldFJpZ2h0IDwgMCkge1xyXG4gICAgICAgICAgICAvLyEgaW5jb3JyZWN0IHRvb2x0aXBSZWN0LndpZHRoIG9uIG5vbiBmaXhlZCB3aWR0aCBlbGVtZW50LlxyXG4gICAgICAgICAgICBfdG9vbHRpcC5jbGFzc05hbWUgPSBvcHRpb25zLmNzc0NsYXNzO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IG9wdGlvbnMucG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICBfdG9vbHRpcC5jbGFzc05hbWUgPSBvcHRpb25zLmNzc0NsYXNzICsgJyBsZWZ0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdG9vbHRpcC5zdHlsZS5sZWZ0ID0geCAtIHRvb2x0aXBSZWN0LndpZHRoICsgJ3B4JztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKG9mZnNldExlZnQgPCAwKSB7XHJcbiAgICAgICAgICAgIF90b29sdGlwLmNsYXNzTmFtZSA9IG9wdGlvbnMuY3NzQ2xhc3M7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcgfHwgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgIF90b29sdGlwLmNsYXNzTmFtZSA9IG9wdGlvbnMuY3NzQ2xhc3MgKyAnIHJpZ2h0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdG9vbHRpcC5zdHlsZS5sZWZ0ID0geCArICdweCc7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbkNvbXBsZXRlKSBvbkNvbXBsZXRlKCk7XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgdG9vbHRpcCBlbGVtZW50IGZyb20gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICBpZiAoX3Rvb2x0aXAgJiYgX3Rvb2x0aXAucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBET006XHJcbiAgICAgICAgX3Rvb2x0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdG9vbHRpcCk7XHJcbiAgICAgICAgX3Rvb2x0aXAgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBjbGVhcnMgYWxsIHRpbWVvdXRzIHJlbGF0ZWQgdG8gdGhlIHRvb2x0aXBcclxuICAgICAqIGFuZCByZW1vdmVzIHRoZSB0b29sdGlwLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChfdGltZW91dEhhbmRsZSk7XHJcbiAgICAgIGNsZWFyVGltZW91dChfdGltZW91dEhpZGVIYW5kbGUpO1xyXG4gICAgICBfdGltZW91dEhhbmRsZSA9IGZhbHNlO1xyXG4gICAgICBfdGltZW91dEhpZGVIYW5kbGUgPSBmYWxzZTtcclxuICAgICAgcmVtb3ZlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltaWxhciB0byBjYW5jZWwoKSBidXQgY2FuIGJlIGRlbGF5ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5LiBUaGUgZGVsYXkgaW4gbWlsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlbGF5ZWRDYW5jZWwoZGVsYXkpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SGFuZGxlKTtcclxuICAgICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SGlkZUhhbmRsZSk7XHJcbiAgICAgIF90aW1lb3V0SGFuZGxlID0gZmFsc2U7XHJcbiAgICAgIF90aW1lb3V0SGlkZUhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCFfbW91c2VPdmVyVG9vbHRpcCkgcmVtb3ZlKCk7XHJcbiAgICAgIH0sIGRlbGF5KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gSU5URVJGQUNFOlxyXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBjYW5jZWwoKTtcclxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdoaWRkZW4nKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xyXG4gICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRIYW5kbGUpO1xyXG4gICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRIaWRlSGFuZGxlKTtcclxuICAgICAgX3Rvb2x0aXAgPSBudWxsO1xyXG4gICAgICBfdGltZW91dEhhbmRsZSA9IG51bGw7XHJcbiAgICAgIF90aW1lb3V0SGlkZUhhbmRsZSA9IG51bGw7XHJcbiAgICAgIF9kb3VibGVDbGljayA9IGZhbHNlO1xyXG4gICAgICBfc3RhZ2VUb29sdGlwcyA9IFtdO1xyXG4gICAgICBfbm9kZVRvb2x0aXBzID0gW107XHJcbiAgICAgIF9lZGdlVG9vbHRpcHMgPSBbXTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy51bmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHRvb2x0aXBzID0gX3N0YWdlVG9vbHRpcHMuY29uY2F0KF9ub2RlVG9vbHRpcHMpLmNvbmNhdChfZWRnZVRvb2x0aXBzKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzLnVuYmluZCh0b29sdGlwc1tpXS5zaG93KTtcclxuICAgICAgICBzLnVuYmluZCh0b29sdGlwc1tpXS5oaWRlKTtcclxuXHJcbiAgICAgICAgaWYgKHRvb2x0aXBzW2ldLnNob3cgPT09ICdyaWdodENsaWNrTm9kZScgfHwgdG9vbHRpcHNbaV0uc2hvdyA9PT0gJ3JpZ2h0Q2xpY2tFZGdlJykge1xyXG4gICAgICAgICAgcmVuZGVyZXIuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICdjb250ZXh0bWVudScsXHJcbiAgICAgICAgICAgIGNvbnRleHRtZW51TGlzdGVuZXJcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgZGVmYXVsdCBldmVudCBoYW5kbGVyc1xyXG4gICAgICBzLnVuYmluZCgnZG91YmxlQ2xpY2tTdGFnZScpO1xyXG4gICAgICBzLnVuYmluZCgnZG91YmxlQ2xpY2tOb2RlJyk7XHJcbiAgICAgIHMudW5iaW5kKCdkb3VibGVDbGlja0VkZ2UnKTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5iaW5kU3RhZ2VFdmVudHMgPSBmdW5jdGlvbih0b29sdGlwKSB7XHJcbiAgICAgIHMuYmluZCh0b29sdGlwLnNob3csIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRvb2x0aXAuc2hvdyAhPT0gJ2RvdWJsZUNsaWNrU3RhZ2UnICYmIF9kb3VibGVDbGljaykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNsaWVudFggPSBldmVudC5kYXRhLmNhcHRvci5jbGllbnRYLFxyXG4gICAgICAgICAgICBjbGllbnRZID0gZXZlbnQuZGF0YS5jYXB0b3IuY2xpZW50WTtcclxuXHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SGFuZGxlKTtcclxuICAgICAgICBfdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBzZWxmLm9wZW4oXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIHRvb2x0aXAsXHJcbiAgICAgICAgICAgIGNsaWVudFgsXHJcbiAgICAgICAgICAgIGNsaWVudFksXHJcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudC5iaW5kKHNlbGYsJ3Nob3duJywgZXZlbnQuZGF0YSkpO1xyXG4gICAgICAgIH0sIHRvb2x0aXAuZGVsYXkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHMuYmluZCh0b29sdGlwLmhpZGUsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIHAgPSBfdG9vbHRpcDtcclxuICAgICAgICBkZWxheWVkQ2FuY2VsKHNldHRpbmdzLnN0YWdlLmhpZGVEZWxheSk7XHJcbiAgICAgICAgaWYgKHApXHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2hpZGRlbicsIGV2ZW50LmRhdGEpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5iaW5kTm9kZUV2ZW50cyA9IGZ1bmN0aW9uKHRvb2x0aXApIHtcclxuICAgICAgcy5iaW5kKHRvb2x0aXAuc2hvdywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAodG9vbHRpcC5zaG93ICE9PSAnZG91YmxlQ2xpY2tOb2RlJyAmJiBfZG91YmxlQ2xpY2spIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuID0gZXZlbnQuZGF0YS5ub2RlO1xyXG4gICAgICAgIGlmICghbiAmJiBldmVudC5kYXRhLmVudGVyKSB7XHJcbiAgICAgICAgICBuID0gZXZlbnQuZGF0YS5lbnRlci5ub2Rlc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4gPT0gdW5kZWZpbmVkKSByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBjbGllbnRYID0gZXZlbnQuZGF0YS5jYXB0b3IuY2xpZW50WCxcclxuICAgICAgICAgICAgY2xpZW50WSA9IGV2ZW50LmRhdGEuY2FwdG9yLmNsaWVudFk7XHJcblxyXG4gICAgICAgIGNsZWFyVGltZW91dChfdGltZW91dEhhbmRsZSk7XHJcbiAgICAgICAgX3RpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgc2VsZi5vcGVuKFxyXG4gICAgICAgICAgICBuLFxyXG4gICAgICAgICAgICB0b29sdGlwLFxyXG4gICAgICAgICAgICBjbGllbnRYLFxyXG4gICAgICAgICAgICBjbGllbnRZLFxyXG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQuYmluZChzZWxmLCdzaG93bicsIGV2ZW50LmRhdGEpKTtcclxuICAgICAgICB9LCB0b29sdGlwLmRlbGF5KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzLmJpbmQodG9vbHRpcC5oaWRlLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC5kYXRhLmxlYXZlICYmIGV2ZW50LmRhdGEubGVhdmUubm9kZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICByZXR1cm5cclxuICAgICAgICB2YXIgcCA9IF90b29sdGlwO1xyXG4gICAgICAgIGRlbGF5ZWRDYW5jZWwoc2V0dGluZ3Mubm9kZS5oaWRlRGVsYXkpO1xyXG4gICAgICAgIGlmIChwKVxyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdoaWRkZW4nLCBldmVudC5kYXRhKTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuYmluZEVkZ2VFdmVudHMgPSBmdW5jdGlvbih0b29sdGlwKSB7XHJcbiAgICAgIHMuYmluZCh0b29sdGlwLnNob3csIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKHRvb2x0aXAuc2hvdyAhPT0gJ2RvdWJsZUNsaWNrRWRnZScgJiYgX2RvdWJsZUNsaWNrKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZSA9IGV2ZW50LmRhdGEuZWRnZTtcclxuICAgICAgICBpZiAoIWUgJiYgZXZlbnQuZGF0YS5lbnRlcikge1xyXG4gICAgICAgICAgZSA9IGV2ZW50LmRhdGEuZW50ZXIuZWRnZXNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlID09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmRhdGEuY2FwdG9yLmNsaWVudFgsXHJcbiAgICAgICAgICAgIGNsaWVudFkgPSBldmVudC5kYXRhLmNhcHRvci5jbGllbnRZO1xyXG5cclxuICAgICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRIYW5kbGUpO1xyXG4gICAgICAgIF90aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNlbGYub3BlbihcclxuICAgICAgICAgICAgZSxcclxuICAgICAgICAgICAgdG9vbHRpcCxcclxuICAgICAgICAgICAgY2xpZW50WCxcclxuICAgICAgICAgICAgY2xpZW50WSxcclxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50LmJpbmQoc2VsZiwnc2hvd24nLCBldmVudC5kYXRhKSk7XHJcbiAgICAgICAgfSwgdG9vbHRpcC5kZWxheSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcy5iaW5kKHRvb2x0aXAuaGlkZSwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQuZGF0YS5sZWF2ZSAmJiBldmVudC5kYXRhLmxlYXZlLmVkZ2VzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgdmFyIHAgPSBfdG9vbHRpcDtcclxuICAgICAgICBkZWxheWVkQ2FuY2VsKHNldHRpbmdzLmVkZ2UuaGlkZURlbGF5KTtcclxuICAgICAgICBpZiAocClcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnaGlkZGVuJywgZXZlbnQuZGF0YSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTVEFHRSB0b29sdGlwOlxyXG4gICAgaWYgKG9wdGlvbnMuc3RhZ2UpIHtcclxuICAgICAgdmFyIGhhc0RvdWJsZUNsaWNrU3RhZ2UgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3N0YWdlVG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoX3N0YWdlVG9vbHRpcHNbaV0ucmVuZGVyZXIgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgdHlwZW9mIF9zdGFnZVRvb2x0aXBzW2ldLnJlbmRlcmVyICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnN0YWdlLnJlbmRlcmVyXCIgaXMgbm90IGEgZnVuY3Rpb24sIHdhcyAnICsgX3N0YWdlVG9vbHRpcHNbaV0ucmVuZGVyZXIpO1xyXG5cclxuICAgICAgICBpZiAoX3N0YWdlVG9vbHRpcHNbaV0ucG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgaWYgKF9zdGFnZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAndG9wJyAmJlxyXG4gICAgICAgICAgICAgIF9zdGFnZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAnYm90dG9tJyAmJlxyXG4gICAgICAgICAgICAgIF9zdGFnZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAnbGVmdCcgJiZcclxuICAgICAgICAgICAgICBfc3RhZ2VUb29sdGlwc1tpXS5wb3NpdGlvbiAhPT0gJ3JpZ2h0JyAmJlxyXG4gICAgICAgICAgICAgIF9zdGFnZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAnY3NzJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5wb3NpdGlvblwiIGlzIG5vdCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBvciBcImNzc1wiLCB3YXMgJyArIF9zdGFnZVRvb2x0aXBzW2ldLnBvc2l0aW9uKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfc3RhZ2VUb29sdGlwc1tpXS5zaG93ID09PSAnZG91YmxlQ2xpY2tTdGFnZScpIHtcclxuICAgICAgICAgIGhhc0RvdWJsZUNsaWNrU3RhZ2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc3RhZ2VUb29sdGlwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuYmluZFN0YWdlRXZlbnRzKF9zdGFnZVRvb2x0aXBzW2ldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFoYXNEb3VibGVDbGlja1N0YWdlKSB7XHJcbiAgICAgICAgcy5iaW5kKCdkb3VibGVDbGlja1N0YWdlJywgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgIGNhbmNlbCgpO1xyXG4gICAgICAgICAgX2RvdWJsZUNsaWNrID0gdHJ1ZTtcclxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnaGlkZGVuJywgZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBfZG91YmxlQ2xpY2sgPSBmYWxzZTtcclxuICAgICAgICAgIH0sIHNldHRpbmdzLmRvdWJsZUNsaWNrRGVsYXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTk9ERSB0b29sdGlwOlxyXG4gICAgaWYgKG9wdGlvbnMubm9kZSkge1xyXG4gICAgICB2YXIgaGFzUmlnaHRDbGlja05vZGUgPSBmYWxzZTtcclxuICAgICAgdmFyIGhhc0RvdWJsZUNsaWNrTm9kZSA9IGZhbHNlO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbm9kZVRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKF9ub2RlVG9vbHRpcHNbaV0ucmVuZGVyZXIgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgdHlwZW9mIF9ub2RlVG9vbHRpcHNbaV0ucmVuZGVyZXIgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMubm9kZS5yZW5kZXJlclwiIGlzIG5vdCBhIGZ1bmN0aW9uLCB3YXMgJyArIF9ub2RlVG9vbHRpcHNbaV0ucmVuZGVyZXIpO1xyXG5cclxuICAgICAgICBpZiAoX25vZGVUb29sdGlwc1tpXS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBpZiAoX25vZGVUb29sdGlwc1tpXS5wb3NpdGlvbiAhPT0gJ3RvcCcgJiZcclxuICAgICAgICAgICAgICBfbm9kZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAnYm90dG9tJyAmJlxyXG4gICAgICAgICAgICAgIF9ub2RlVG9vbHRpcHNbaV0ucG9zaXRpb24gIT09ICdsZWZ0JyAmJlxyXG4gICAgICAgICAgICAgIF9ub2RlVG9vbHRpcHNbaV0ucG9zaXRpb24gIT09ICdyaWdodCcgJiZcclxuICAgICAgICAgICAgICBfbm9kZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAnY3NzJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wib3B0aW9ucy5wb3NpdGlvblwiIGlzIG5vdCBcInRvcFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBvciBcImNzc1wiLCB3YXMgJyArIF9ub2RlVG9vbHRpcHNbaV0ucG9zaXRpb24pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKF9ub2RlVG9vbHRpcHNbaV0uc2hvdyA9PT0gJ2RvdWJsZUNsaWNrTm9kZScpIHtcclxuICAgICAgICAgIGhhc0RvdWJsZUNsaWNrTm9kZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChfbm9kZVRvb2x0aXBzW2ldLnNob3cgPT09ICdyaWdodENsaWNrTm9kZScpIHtcclxuICAgICAgICAgIGhhc1JpZ2h0Q2xpY2tOb2RlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX25vZGVUb29sdGlwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuYmluZE5vZGVFdmVudHMoX25vZGVUb29sdGlwc1tpXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaGFzRG91YmxlQ2xpY2tOb2RlKSB7XHJcbiAgICAgICAgcy5iaW5kKCdkb3VibGVDbGlja05vZGUnLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgY2FuY2VsKCk7XHJcbiAgICAgICAgICBfZG91YmxlQ2xpY2sgPSB0cnVlO1xyXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdoaWRkZW4nLCBldmVudC5kYXRhKTtcclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIF9kb3VibGVDbGljayA9IGZhbHNlO1xyXG4gICAgICAgICAgfSwgc2V0dGluZ3MuZG91YmxlQ2xpY2tEZWxheSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFREdFIHRvb2x0aXA6XHJcbiAgICBpZiAob3B0aW9ucy5lZGdlKSB7XHJcbiAgICAgIHZhciBoYXNSaWdodENsaWNrRWRnZSA9IGZhbHNlO1xyXG4gICAgICB2YXIgaGFzRG91YmxlQ2xpY2tFZGdlID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9lZGdlVG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoX2VkZ2VUb29sdGlwc1tpXS5yZW5kZXJlciAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgX2VkZ2VUb29sdGlwc1tpXS5yZW5kZXJlciAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5lZGdlLnJlbmRlcmVyXCIgaXMgbm90IGEgZnVuY3Rpb24sIHdhcyAnICsgX2VkZ2VUb29sdGlwc1tpXS5yZW5kZXJlcik7XHJcblxyXG4gICAgICAgIGlmIChfZWRnZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGlmIChfZWRnZVRvb2x0aXBzW2ldLnBvc2l0aW9uICE9PSAndG9wJyAmJlxyXG4gICAgICAgICAgICAgIF9lZGdlVG9vbHRpcHNbaV0ucG9zaXRpb24gIT09ICdib3R0b20nICYmXHJcbiAgICAgICAgICAgICAgX2VkZ2VUb29sdGlwc1tpXS5wb3NpdGlvbiAhPT0gJ2xlZnQnICYmXHJcbiAgICAgICAgICAgICAgX2VkZ2VUb29sdGlwc1tpXS5wb3NpdGlvbiAhPT0gJ3JpZ2h0JyAmJlxyXG4gICAgICAgICAgICAgIF9lZGdlVG9vbHRpcHNbaV0ucG9zaXRpb24gIT09ICdjc3MnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLnBvc2l0aW9uXCIgaXMgbm90IFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIG9yIFwiY3NzXCIsIHdhcyAnICsgX2VkZ2VUb29sdGlwc1tpXS5wb3NpdGlvbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoX2VkZ2VUb29sdGlwc1tpXS5zaG93ID09PSAnZG91YmxlQ2xpY2tFZGdlJykge1xyXG4gICAgICAgICAgaGFzRG91YmxlQ2xpY2tFZGdlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKF9lZGdlVG9vbHRpcHNbaV0uc2hvdyA9PT0gJ3JpZ2h0Q2xpY2tFZGdlJykge1xyXG4gICAgICAgICAgaGFzUmlnaHRDbGlja0VkZ2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfZWRnZVRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kRWRnZUV2ZW50cyhfZWRnZVRvb2x0aXBzW2ldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFoYXNEb3VibGVDbGlja0VkZ2UpIHtcclxuICAgICAgICBzLmJpbmQoJ2RvdWJsZUNsaWNrRWRnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICBjYW5jZWwoKTtcclxuICAgICAgICAgIF9kb3VibGVDbGljayA9IHRydWU7XHJcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2hpZGRlbicsIGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgX2RvdWJsZUNsaWNrID0gZmFsc2U7XHJcbiAgICAgICAgICB9LCBzZXR0aW5ncy5kb3VibGVDbGlja0RlbGF5KTtcclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJldmVudCB0aGUgYnJvd3NlciBjb250ZXh0IG1lbnUgdG8gYXBwZWFyXHJcbiAgICAvLyBpZiB0aGUgcmlnaHQgY2xpY2sgZXZlbnQgaXMgYWxyZWFkeSBoYW5kbGVkOlxyXG4gICAgaWYgKGhhc1JpZ2h0Q2xpY2tOb2RlIHx8IGhhc1JpZ2h0Q2xpY2tFZGdlKSB7XHJcbiAgICAgIHJlbmRlcmVyLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICdjb250ZXh0bWVudScsXHJcbiAgICAgICAgY29udGV4dG1lbnVMaXN0ZW5lclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVyZmFjZVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG4gIHZhciBfaW5zdGFuY2UgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtzaWdtYX0gICAgcyAgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtyZW5kZXJlcn0gcmVuZGVyZXIgVGhlIHJlbGF0ZWQgc2lnbWEgcmVuZGVyZXIuXHJcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgb3B0aW9ucyAgQW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cclxuICAgKi9cclxuICBzaWdtYS5wbHVnaW5zLnRvb2x0aXBzID0gZnVuY3Rpb24ocywgcmVuZGVyZXIsIG9wdGlvbnMpIHtcclxuICAgIC8vIENyZWF0ZSBvYmplY3QgaWYgdW5kZWZpbmVkXHJcbiAgICBpZiAoIV9pbnN0YW5jZVtzLmlkXSkge1xyXG4gICAgICBfaW5zdGFuY2Vbcy5pZF0gPSBuZXcgVG9vbHRpcHMocywgcmVuZGVyZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pbnN0YW5jZVtzLmlkXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiAgVGhpcyBmdW5jdGlvbiBraWxscyB0aGUgdG9vbHRpcHMgaW5zdGFuY2UuXHJcbiAgICovXHJcbiAgc2lnbWEucGx1Z2lucy5raWxsVG9vbHRpcHMgPSBmdW5jdGlvbihzKSB7XHJcbiAgICBpZiAoX2luc3RhbmNlW3MuaWRdIGluc3RhbmNlb2YgVG9vbHRpcHMpIHtcclxuICAgICAgX2luc3RhbmNlW3MuaWRdLmtpbGwoKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBfaW5zdGFuY2Vbcy5pZF07XHJcbiAgfTtcclxuXHJcbn0pLmNhbGwod2luZG93KTtcclxuIiwiOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLm5vZGVzJyk7XHJcblxyXG4gIHZhciBkcmF3Qm9yZGVyID0gZnVuY3Rpb24oY29udGV4dCwgeCwgeSwgcmFkaXVzLCBjb2xvciwgbGluZV93aWR0aCkge1xyXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuXHQgIGNvbnRleHQubGluZVdpZHRoID0gbGluZV93aWR0aDtcclxuICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBkZWZhdWx0IG5vZGUgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIG5vZGUgYXMgYSBzaW1wbGUgZGlzYy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgICAgb3B0aW9ucyAgRm9yY2Ugb3B0aW9uYWwgcGFyYW1ldGVycyAoZS5nLiBjb2xvcikuXHJcbiAgICovXHJcbiAgc2lnbWEuY2FudmFzLm5vZGVzLmRlZiA9IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgbyA9IG9wdGlvbnMgfHwge30sXHJcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxyXG4gICAgICAgIHNpemUgPSBub2RlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcclxuICAgICAgICB4ID0gbm9kZVtwcmVmaXggKyAneCddLFxyXG4gICAgICAgIHkgPSBub2RlW3ByZWZpeCArICd5J10sXHJcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXHJcbiAgICAgICAgaW1nQ3Jvc3NPcmlnaW4gPSBzZXR0aW5ncygnaW1nQ3Jvc3NPcmlnaW4nKSB8fCAnYW5vbnltb3VzJyxcclxuICAgICAgICBib3JkZXJTaXplID0gbm9kZS5ib3JkZXJfc2l6ZSB8fCBzZXR0aW5ncygnbm9kZUJvcmRlclNpemUnKSxcclxuICAgICAgICBvdXRlckJvcmRlclNpemUgPSBzZXR0aW5ncygnbm9kZU91dGVyQm9yZGVyU2l6ZScpLFxyXG4gICAgICAgIGFjdGl2ZUJvcmRlclNpemUgPSBub2RlLmJvcmRlcl9zaXplIHx8IHNldHRpbmdzKCdub2RlQWN0aXZlQm9yZGVyU2l6ZScpLFxyXG4gICAgICAgIGFjdGl2ZU91dGVyQm9yZGVyU2l6ZSA9IHNldHRpbmdzKCdub2RlQWN0aXZlT3V0ZXJCb3JkZXJTaXplJyksXHJcbiAgICAgICAgY29sb3IgPSBvLmNvbG9yIHx8IG5vZGUuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcixcclxuXHQgICAgICBib3JkZXJDb2xvciA9IHNldHRpbmdzKCdub2RlQm9yZGVyQ29sb3InKSA9PT0gJ2RlZmF1bHQnXHJcbiAgICAgICAgICA/IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUJvcmRlckNvbG9yJylcclxuICAgICAgICAgIDogKG8uYm9yZGVyQ29sb3IgfHwgbm9kZS5ib3JkZXJfY29sb3IgfHwgbm9kZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yKSxcclxuICAgICAgICBsZXZlbCA9IG5vZGUuYWN0aXZlID8gc2V0dGluZ3MoJ25vZGVBY3RpdmVMZXZlbCcpIDogbm9kZS5sZXZlbDtcclxuXHJcbiAgICAvLyBMZXZlbDpcclxuICAgIHNpZ21hLnV0aWxzLmNhbnZhcy5zZXRMZXZlbChsZXZlbCwgY29udGV4dCk7XHJcblxyXG4gICAgaWYgKG5vZGUuYWN0aXZlKSB7XHJcbiAgICAgIC8vIENvbG9yOlxyXG4gICAgICBpZiAoc2V0dGluZ3MoJ25vZGVBY3RpdmVDb2xvcicpID09PSAnbm9kZScpIHtcclxuICAgICAgICBjb2xvciA9IG5vZGUuYWN0aXZlX2NvbG9yIHx8IGNvbG9yO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQWN0aXZlQ29sb3InKSB8fCBjb2xvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3V0ZXIgQm9yZGVyOlxyXG4gICAgICBpZiAoYWN0aXZlT3V0ZXJCb3JkZXJTaXplID4gMCkge1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUFjdGl2ZU91dGVyQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnID9cclxuICAgICAgICAgIChjb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yKSA6XHJcbiAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdE5vZGVBY3RpdmVPdXRlckJvcmRlckNvbG9yJyk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSArIGFjdGl2ZUJvcmRlclNpemUgKyBhY3RpdmVPdXRlckJvcmRlclNpemUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEJvcmRlcjpcclxuICAgICAgaWYgKGFjdGl2ZUJvcmRlclNpemUgPiAwKSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdub2RlQWN0aXZlQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnXHJcbiAgICAgICAgICA/IGJvcmRlckNvbG9yXHJcbiAgICAgICAgICA6IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUFjdGl2ZUJvcmRlckNvbG9yJyk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSArIGFjdGl2ZUJvcmRlclNpemUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gT3V0ZXIgQm9yZGVyOlxyXG4gICAgICBpZiAob3V0ZXJCb3JkZXJTaXplID4gMCkge1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZU91dGVyQm9yZGVyQ29sb3InKSA9PT0gJ25vZGUnID9cclxuICAgICAgICAgIChjb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yKSA6XHJcbiAgICAgICAgICBzZXR0aW5ncygnZGVmYXVsdE5vZGVPdXRlckJvcmRlckNvbG9yJyk7XHJcbiAgICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSArIGJvcmRlclNpemUgKyBvdXRlckJvcmRlclNpemUsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBCb3JkZXI6XHJcbiAgICAgIGlmIChib3JkZXJTaXplID4gMCkge1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUJvcmRlckNvbG9yJykgPT09ICdub2RlJ1xyXG4gICAgICAgICAgPyBib3JkZXJDb2xvclxyXG4gICAgICAgICAgOiBzZXR0aW5ncygnZGVmYXVsdE5vZGVCb3JkZXJDb2xvcicpO1xyXG4gICAgICAgIGNvbnRleHQuYXJjKHgsIHksIHNpemUgKyBib3JkZXJTaXplLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XHJcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgoIW5vZGUuYWN0aXZlIHx8XHJcbiAgICAgIChub2RlLmFjdGl2ZSAmJiBzZXR0aW5ncygnbm9kZUFjdGl2ZUNvbG9yJykgPT09ICdub2RlJykpICYmXHJcbiAgICAgIG5vZGUuY29sb3JzICYmXHJcbiAgICAgIG5vZGUuY29sb3JzLmxlbmd0aCkge1xyXG5cclxuICAgICAgLy8gc2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvaHZZa00vMS9cclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgICBsID0gbm9kZS5jb2xvcnMubGVuZ3RoLFxyXG4gICAgICAgICAgaiA9IDEgLyBsLFxyXG4gICAgICAgICAgbGFzdGVuZCA9IDA7XHJcblxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBub2RlLmNvbG9yc1tpXTtcclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgIGNvbnRleHQuYXJjKHgsIHksIHNpemUsIGxhc3RlbmQsIGxhc3RlbmQgKyAoTWF0aC5QSSAqIDIgKiBqKSwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xyXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgbGFzdGVuZCArPSBNYXRoLlBJICogMiAqIGo7XHJcbiAgICAgIH1cclxuICAgICAgc2lnbWEudXRpbHMuY2FudmFzLnJlc2V0TGV2ZWwoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgY29udGV4dC5hcmMoeCwgeSwgc2l6ZSwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xyXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICBjb250ZXh0LmZpbGwoKTtcclxuXHJcbiAgICAgIHNpZ21hLnV0aWxzLmNhbnZhcy5yZXNldExldmVsKGNvbnRleHQpO1xyXG5cclxuICAgICAgaWYgKCFub2RlLmFjdGl2ZSAmJiBib3JkZXJTaXplID4gMCAmJiAoc2l6ZSA+IDIgKiBib3JkZXJTaXplKSkge1xyXG5cdFx0ICAgIGRyYXdCb3JkZXIoY29udGV4dCwgeCwgeSwgc2l6ZSwgYm9yZGVyQ29sb3IsIGJvcmRlclNpemUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW1hZ2U6XHJcbiAgICBpZiAobm9kZS5pbWFnZSkge1xyXG4gICAgICBzaWdtYS51dGlscy5jYW52YXMuZHJhd0ltYWdlKFxyXG4gICAgICAgIG5vZGUsIHgsIHksIHNpemUsIGNvbnRleHQsIGltZ0Nyb3NzT3JpZ2luLCBzZXR0aW5ncygnaW1hZ2VUaHJlc2hvbGQnKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEljb246XHJcbiAgICBpZiAobm9kZS5pY29uKSB7XHJcbiAgICAgIHNpZ21hLnV0aWxzLmNhbnZhcy5kcmF3SWNvbihub2RlLCB4LCB5LCBzaXplLCBjb250ZXh0LCBzZXR0aW5ncygnaWNvblRocmVzaG9sZCcpKTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxufSkoKTtcclxuIiwiOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfX2luc3RhbmNlcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBzaWdtYSBpbnN0YW5jZXMgY29uc3RydWN0b3IuIE9uZSBpbnN0YW5jZSBvZiBzaWdtYSByZXByZXNlbnRcbiAgICogb25lIGdyYXBoLiBJdCBpcyBwb3NzaWJsZSB0byByZXByZXNlbnQgdGhpcyBncmFwxKUgd2l0aCBzZXZlcmFsIHJlbmRlcmVyc1xuICAgKiBhdCB0aGUgc2FtZSB0aW1lLiBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdCByZW5kZXJlciAoV2ViR0wgKyBDYW52YXNcbiAgICogcG9seWZpbGwpIHdpbGwgYmUgdXNlZCBhcyB0aGUgb25seSByZW5kZXJlciwgd2l0aCB0aGUgY29udGFpbmVyIHNwZWNpZmllZFxuICAgKiBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Pyp9ICAgIGNvbmYgVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGluc3RhbmNlLiBUaGVyZSBhcmUgYSBsb3Qgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW50IHJlY29nbml6ZWQgZm9ybXMgdG8gaW5zdGFudGlhdGUgc2lnbWEsIGNoZWNrXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGUgZmlsZXMsIGRvY3VtZW50YXRpb24gaW4gdGhpcyBmaWxlIGFuZCB1bml0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIHRlc3RzIHRvIGtub3cgbW9yZS5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgVGhlIGZyZXNoIG5ldyBzaWdtYSBpbnN0YW5jZS5cbiAgICpcbiAgICogSW5zdGFuY2lhdGluZyBzaWdtYTpcbiAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICogSWYgbm8gcGFyYW1ldGVyIGlzIGdpdmVuIHRvIHRoZSBjb25zdHJ1Y3RvciwgdGhlIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZFxuICAgKiB3aXRob3V0IGFueSByZW5kZXJlciBvciBjYW1lcmEuIEl0IHdpbGwganVzdCBpbnN0YW50aWF0ZSB0aGUgZ3JhcGgsIGFuZFxuICAgKiBvdGhlciBtb2R1bGVzIHdpbGwgaGF2ZSB0byBiZSBpbnN0YW50aWF0ZWQgdGhyb3VnaCB0aGUgcHVibGljIG1ldGhvZHMsXG4gICAqIGxpa2UgXCJhZGRSZW5kZXJlclwiIGV0YzpcbiAgICpcbiAgICogID4gczAgPSBuZXcgc2lnbWEoKTtcbiAgICogID4gczAuYWRkUmVuZGVyZXIoe1xuICAgKiAgPiAgIHR5cGU6ICdjYW52YXMnLFxuICAgKiAgPiAgIGNvbnRhaW5lcjogJ215LWNvbnRhaW5lci1pZCdcbiAgICogID4gfSk7XG4gICAqXG4gICAqIEluIG1vc3Qgb2YgdGhlIGNhc2VzLCBzaWdtYSB3aWxsIHNpbXBseSBiZSB1c2VkIHdpdGggdGhlIGRlZmF1bHQgcmVuZGVyZXIuXG4gICAqIFRoZW4sIHNpbmNlIHRoZSBvbmx5IHJlcXVpcmVkIHBhcmFtZXRlciBpcyB0aGUgRE9NIGNvbnRhaW5lciwgdGhlcmUgYXJlXG4gICAqIHNvbWUgc2ltcGxlciB3YXkgdG8gY2FsbCB0aGUgY29uc3RydWN0b3IuIFRoZSBmb3VyIGZvbGxvd2luZyBjYWxscyBkbyB0aGVcbiAgICogZXhhY3Qgc2FtZSB0aGluZ3M6XG4gICAqXG4gICAqICA+IHMxID0gbmV3IHNpZ21hKCdteS1jb250YWluZXItaWQnKTtcbiAgICogID4gczIgPSBuZXcgc2lnbWEoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpKTtcbiAgICogID4gczMgPSBuZXcgc2lnbWEoe1xuICAgKiAgPiAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215LWNvbnRhaW5lci1pZCcpXG4gICAqICA+IH0pO1xuICAgKiAgPiBzNCA9IG5ldyBzaWdtYSh7XG4gICAqICA+ICAgcmVuZGVyZXJzOiBbe1xuICAgKiAgPiAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXktY29udGFpbmVyLWlkJylcbiAgICogID4gICB9XVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzLCB3aGVuIGNhbGxpbmcgdGhlXG4gICAqIGNvbnN0cnVjdG9yIHdpdGggdG8gdG9wIGxldmVsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChmb3VydGggY2FzZSBpbiB0aGVcbiAgICogcHJldmlvdXMgZXhhbXBsZXMpOlxuICAgKlxuICAgKiAgIHs/c3RyaW5nfSBpZCAgICAgICAgVGhlIGlkIG9mIHRoZSBpbnN0YW5jZS4gSXQgd2lsbCBiZSBnZW5lcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY2FsbHkgaWYgbm90IHNwZWNpZmllZC5cbiAgICogICB7P2FycmF5fSAgcmVuZGVyZXJzIEFuIGFycmF5IGNvbnRhaW5pbmcgb2JqZWN0cyBkZXNjcmliaW5nIHJlbmRlcmVycy5cbiAgICogICB7P29iamVjdH0gZ3JhcGggICAgIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIG5vZGVzIGFuZCBhbiBhcnJheVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgb2YgZWRnZXMsIHRvIGF2b2lkIGhhdmluZyB0byBhZGQgdGhlbSBieSBoYW5kIGxhdGVyLlxuICAgKiAgIHs/b2JqZWN0fSBzZXR0aW5ncyAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5zdGFuY2Ugc3BlY2lmaWMgc2V0dGluZ3MgdGhhdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBvbmVzIGRlZmluZWQgaW4gdGhlIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEuc2V0dGluZ3MuXG4gICAqL1xuICB2YXIgc2lnbWEgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgLy8gTG9jYWwgdmFyaWFibGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKipcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgbyxcbiAgICAgICAgaWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gUHJpdmF0ZSBhdHRyaWJ1dGVzOlxuICAgIC8vICoqKioqKioqKioqKioqKioqKipcbiAgICB2YXIgX3NlbGYgPSB0aGlzLFxuICAgICAgICBfY29uZiA9IGNvbmYgfHwge307XG5cbiAgICAvLyBMaXR0bGUgc2hvcnRjdXQ6XG4gICAgLy8gKioqKioqKioqKioqKioqKlxuICAgIC8vIFRoZSBjb25maWd1cmF0aW9uIGlzIHN1cHBvc2VkIHRvIGhhdmUgYSBsaXN0IG9mIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb2JqZWN0cyBmb3IgZWFjaCByZW5kZXJlci5cbiAgICAvLyAgLSBJZiB0aGVyZSBhcmUgbm8gY29uZmlndXJhdGlvbiBhdCBhbGwsIHRoZW4gbm90aGluZyBpcyBkb25lLlxuICAgIC8vICAtIElmIHRoZXJlIGFyZSBubyByZW5kZXJlciBsaXN0LCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbiBvYmplY3Qgd2lsbCBiZVxuICAgIC8vICAgIGNvbnNpZGVyZWQgYXMgZGVzY3JpYmluZyB0aGUgZmlyc3QgYW5kIG9ubHkgcmVuZGVyZXIuXG4gICAgLy8gIC0gSWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVyIGxpc3Qgbm9yIFwiY29udGFpbmVyXCIgb2JqZWN0LCBpdCB3aWxsIGJlXG4gICAgLy8gICAgY29uc2lkZXJlZCBhcyB0aGUgY29udGFpbmVyIGl0c2VsZiAoYSBET00gZWxlbWVudCkuXG4gICAgLy8gIC0gSWYgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzaWdtYSgpIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWRcbiAgICAvLyAgICBhcyB0aGUgSUQgb2YgdGhlIERPTSBjb250YWluZXIuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIF9jb25mID09PSAnc3RyaW5nJyB8fFxuICAgICAgX2NvbmYgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgIClcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IFtfY29uZl1cbiAgICAgIH07XG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9jb25mKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgIF9jb25mID0ge1xuICAgICAgICByZW5kZXJlcnM6IF9jb25mXG4gICAgICB9O1xuXG4gICAgLy8gQWxzbyBjaGVjayBcInJlbmRlcmVyXCIgYW5kIFwiY29udGFpbmVyXCIga2V5czpcbiAgICBvID0gX2NvbmYucmVuZGVyZXJzIHx8IF9jb25mLnJlbmRlcmVyIHx8IF9jb25mLmNvbnRhaW5lcjtcbiAgICBpZiAoIV9jb25mLnJlbmRlcmVycyB8fCBfY29uZi5yZW5kZXJlcnMubGVuZ3RoID09PSAwKVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgbyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICh0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgJ2NvbnRhaW5lcicgaW4gbylcbiAgICAgIClcbiAgICAgICAgX2NvbmYucmVuZGVyZXJzID0gW29dO1xuXG4gICAgLy8gUmVjZW5zZSB0aGUgaW5zdGFuY2U6XG4gICAgaWYgKF9jb25mLmlkKSB7XG4gICAgICBpZiAoX19pbnN0YW5jZXNbX2NvbmYuaWRdKVxuICAgICAgICB0aHJvdyAnc2lnbWE6IEluc3RhbmNlIFwiJyArIF9jb25mLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgICB2YWx1ZTogX2NvbmYuaWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IDA7XG4gICAgICB3aGlsZSAoX19pbnN0YW5jZXNbaWRdKVxuICAgICAgICBpZCsrO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpZCcsIHtcbiAgICAgICAgdmFsdWU6ICcnICsgaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfX2luc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICAvLyBJbml0aWFsaXplIHNldHRpbmdzIGZ1bmN0aW9uOlxuICAgIHRoaXMuc2V0dGluZ3MgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jb25maWd1cmFibGUoXG4gICAgICBzaWdtYS5zZXR0aW5ncyxcbiAgICAgIF9jb25mLnNldHRpbmdzIHx8IHt9XG4gICAgKTtcblxuICAgIC8vIEluaXRpYWxpemUgbG9ja2VkIGF0dHJpYnV0ZXM6XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdncmFwaCcsIHtcbiAgICAgIHZhbHVlOiBuZXcgc2lnbWEuY2xhc3Nlcy5ncmFwaCh0aGlzLnNldHRpbmdzKSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWlkZGxld2FyZXMnLCB7XG4gICAgICB2YWx1ZTogW10sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JlbmRlcmVycycsIHtcbiAgICAgIHZhbHVlOiB7fSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVuZGVyZXJzUGVyQ2FtZXJhJywge1xuICAgICAgdmFsdWU6IHt9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW1lcmFGcmFtZXMnLCB7XG4gICAgICB2YWx1ZToge30sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NhbWVyYScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbWVyYXNbMF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdldmVudHMnLCB7XG4gICAgICB2YWx1ZTogW1xuICAgICAgICAnY2xpY2snLFxuICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICdjbGlja1N0YWdlJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrU3RhZ2UnLFxuICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgJ2NsaWNrTm9kZScsXG4gICAgICAgICdjbGlja05vZGVzJyxcbiAgICAgICAgJ2RvdWJsZUNsaWNrTm9kZScsXG4gICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlcycsXG4gICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICdvdmVyTm9kZXMnLFxuICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICdvdXROb2RlcycsXG4gICAgICAgICdkb3duTm9kZScsXG4gICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAndXBOb2RlJyxcbiAgICAgICAgJ3VwTm9kZXMnXG4gICAgICBdLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYSBjdXN0b20gaGFuZGxlciwgdG8gcmVkaXNwYXRjaCBldmVudHMgZnJvbSByZW5kZXJlcnM6XG4gICAgdGhpcy5faGFuZGxlciA9IChmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICBkYXRhID0ge307XG5cbiAgICAgIGZvciAoayBpbiBlLmRhdGEpXG4gICAgICAgIGRhdGFba10gPSBlLmRhdGFba107XG5cbiAgICAgIGRhdGEucmVuZGVyZXIgPSBlLnRhcmdldDtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlLnR5cGUsIGRhdGEpO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHJlbmRlcmVyczpcbiAgICBhID0gX2NvbmYucmVuZGVyZXJzIHx8IFtdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHRoaXMuYWRkUmVuZGVyZXIoYVtpXSk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1pZGRsZXdhcmVzOlxuICAgIGEgPSBfY29uZi5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2goXG4gICAgICAgIHR5cGVvZiBhW2ldID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgc2lnbWEubWlkZGxld2FyZXNbYVtpXV0gOlxuICAgICAgICAgIGFbaV1cbiAgICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgZ3JhcGggdG8gZmlsbCBpbjpcbiAgICBpZiAodHlwZW9mIF9jb25mLmdyYXBoID09PSAnb2JqZWN0JyAmJiBfY29uZi5ncmFwaCkge1xuICAgICAgdGhpcy5ncmFwaC5yZWFkKF9jb25mLmdyYXBoKTtcblxuICAgICAgLy8gSWYgYSBncmFwaCBpcyBnaXZlbiB0byB0aGUgdG8gdGhlIGluc3RhbmNlLCB0aGUgXCJyZWZyZXNoXCIgbWV0aG9kIGlzXG4gICAgICAvLyBkaXJlY3RseSBjYWxsZWQ6XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcmVzaXplOlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChfc2VsZi5zZXR0aW5ncylcbiAgICAgICAgX3NlbGYucmVmcmVzaCgpO1xuICAgIH0pO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IGNhbWVyYS4gSWYgbm8gaWQgaXNcbiAgICogc3BlY2lmaWVkLCB0aGVuIGFuIGF1dG9tYXRpYyBpZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7P3N0cmluZ30gICAgICAgICAgICAgIGlkIEV2ZW50dWFsbHkgdGhlIGNhbWVyYSBpZC5cbiAgICogQHJldHVybiB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9ICAgIFRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLmFkZENhbWVyYSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjYW1lcmE7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLmNhbWVyYXNbJycgKyBpZF0pXG4gICAgICAgIGlkKys7XG4gICAgICBpZCA9ICcnICsgaWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2FtZXJhc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkQ2FtZXJhOiBUaGUgY2FtZXJhIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBjYW1lcmEgPSBuZXcgc2lnbWEuY2xhc3Nlcy5jYW1lcmEoaWQsIHRoaXMuZ3JhcGgsIHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuY2FtZXJhc1tpZF0gPSBjYW1lcmE7XG5cbiAgICAvLyBBZGQgYSBxdWFkdHJlZSB0byB0aGUgY2FtZXJhOlxuICAgIGNhbWVyYS5xdWFkdHJlZSA9IG5ldyBzaWdtYS5jbGFzc2VzLnF1YWQoKTtcblxuICAgIC8vIEFkZCBhbiBlZGdlcXVhZHRyZWUgdG8gdGhlIGNhbWVyYTpcbiAgICBpZiAoc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW1lcmEuZWRnZXF1YWR0cmVlID0gbmV3IHNpZ21hLmNsYXNzZXMuZWRnZXF1YWQoKTtcbiAgICB9XG5cbiAgICBjYW1lcmEuYmluZCgnY29vcmRpbmF0ZXNVcGRhdGVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2VsZi5yZW5kZXJDYW1lcmEoY2FtZXJhLCBjYW1lcmEuaXNBbmltYXRlZCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtpZF0gPSBbXTtcblxuICAgIHJldHVybiBjYW1lcmE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgY2FtZXJhLCBhbmQgZXZlcnkgcmVuZGVyZXIgYXR0YWNoZWQgdG8gaXQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xjYW1lcmF9IHYgVGhlIGNhbWVyYSB0byBraWxsIG9yIGl0cyBJRC5cbiAgICogQHJldHVybiB7c2lnbWF9ICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsQ2FtZXJhID0gZnVuY3Rpb24odikge1xuICAgIHYgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB0aGlzLmNhbWVyYXNbdl0gOiB2O1xuXG4gICAgaWYgKCF2KVxuICAgICAgdGhyb3cgJ3NpZ21hLmtpbGxDYW1lcmE6IFRoZSBjYW1lcmEgaXMgdW5kZWZpbmVkLic7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSA9IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW3YuaWRdO1xuXG4gICAgZm9yIChsID0gYS5sZW5ndGgsIGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICB0aGlzLmtpbGxSZW5kZXJlcihhW2ldKTtcblxuICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVt2LmlkXTtcbiAgICBkZWxldGUgdGhpcy5jYW1lcmFGcmFtZXNbdi5pZF07XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhc1t2LmlkXTtcblxuICAgIGlmICh2LmtpbGwpXG4gICAgICB2LmtpbGwoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgd2lsbCBpbnN0YW50aWF0ZSBhbmQgcmVmZXJlbmNlIGEgbmV3IHJlbmRlcmVyLiBUaGUgXCJ0eXBlXCJcbiAgICogYXJndW1lbnQgY2FuIGJlIHRoZSBjb25zdHJ1Y3RvciBvciBpdHMgbmFtZSBpbiB0aGUgXCJzaWdtYS5yZW5kZXJlcnNcIlxuICAgKiBwYWNrYWdlLiBJZiBubyB0eXBlIGlzIHNwZWNpZmllZCwgdGhlbiBcInNpZ21hLnJlbmRlcmVycy5kZWZcIiB3aWxsIGJlIHVzZWQuXG4gICAqIElmIG5vIGlkIGlzIHNwZWNpZmllZCwgdGhlbiBhbiBhdXRvbWF0aWMgaWQgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICBvcHRpb25zIEV2ZW50dWFsbHkgc29tZSBvcHRpb25zIHRvIGdpdmUgdG8gdGhlIHJlbmRlcmVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJuIHtyZW5kZXJlcn0gICAgICAgICBUaGUgZnJlc2ggbmV3IHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIFwib3B0aW9uc1wiXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P3N0cmluZ30gICAgICAgICAgICBpZCAgICAgRXZlbnR1YWxseSB0aGUgcmVuZGVyZXIgaWQuXG4gICAqICAgez8oZnVuY3Rpb258c3RyaW5nKX0gdHlwZSAgIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNvbnN0cnVjdG9yIG9yIGl0c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lIGluIHRoZSBcInNpZ21hLnJlbmRlcmVyc1wiIHBhY2thZ2UuXG4gICAqICAgez8oY2FtZXJhfHN0cmluZyl9ICAgY2FtZXJhIEV2ZW50dWFsbHkgdGhlIHJlbmRlcmVyIGNhbWVyYSBvciBpdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUuYWRkUmVuZGVyZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGlkLFxuICAgICAgICBmbixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgbyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBQb2x5bW9ycGhpc206XG4gICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJylcbiAgICAgIG8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobylcbiAgICAgIH07XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiBvXG4gICAgICB9O1xuXG4gICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzdGlsbCBpcyBhIHN0cmluZywgd2UgZ2V0IGl0IGJ5IGlkXG4gICAgaWYgKHR5cGVvZiBvLmNvbnRhaW5lciA9PT0gJ3N0cmluZycpXG4gICAgICBvLmNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8uY29udGFpbmVyKTtcblxuICAgIC8vIFJlZmVyZW5jZSB0aGUgbmV3IHJlbmRlcmVyOlxuICAgIGlmICghKCdpZCcgaW4gbykpIHtcbiAgICAgIGlkID0gMDtcbiAgICAgIHdoaWxlICh0aGlzLnJlbmRlcmVyc1snJyArIGlkXSlcbiAgICAgICAgaWQrKztcbiAgICAgIGlkID0gJycgKyBpZDtcbiAgICB9IGVsc2VcbiAgICAgIGlkID0gby5pZDtcblxuICAgIGlmICh0aGlzLnJlbmRlcmVyc1tpZF0pXG4gICAgICB0aHJvdyAnc2lnbWEuYWRkUmVuZGVyZXI6IFRoZSByZW5kZXJlciBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgLy8gRmluZCB0aGUgZ29vZCBjb25zdHJ1Y3RvcjpcbiAgICBmbiA9IHR5cGVvZiBvLnR5cGUgPT09ICdmdW5jdGlvbicgPyBvLnR5cGUgOiBzaWdtYS5yZW5kZXJlcnNbby50eXBlXTtcbiAgICBmbiA9IGZuIHx8IHNpZ21hLnJlbmRlcmVycy5kZWY7XG5cbiAgICAvLyBGaW5kIHRoZSBnb29kIGNhbWVyYTpcbiAgICBjYW1lcmEgPSAnY2FtZXJhJyBpbiBvID9cbiAgICAgIChcbiAgICAgICAgby5jYW1lcmEgaW5zdGFuY2VvZiBzaWdtYS5jbGFzc2VzLmNhbWVyYSA/XG4gICAgICAgICAgby5jYW1lcmEgOlxuICAgICAgICAgIHRoaXMuY2FtZXJhc1tvLmNhbWVyYV0gfHwgdGhpcy5hZGRDYW1lcmEoby5jYW1lcmEpXG4gICAgICApIDpcbiAgICAgIHRoaXMuYWRkQ2FtZXJhKCk7XG5cbiAgICBpZiAodGhpcy5jYW1lcmFzW2NhbWVyYS5pZF0gIT09IGNhbWVyYSlcbiAgICAgIHRocm93ICdzaWdtYS5hZGRSZW5kZXJlcjogVGhlIGNhbWVyYSBpcyBub3QgcHJvcGVybHkgcmVmZXJlbmNlZC4nO1xuXG4gICAgLy8gSW5zdGFudGlhdGU6XG4gICAgcmVuZGVyZXIgPSBuZXcgZm4odGhpcy5ncmFwaCwgY2FtZXJhLCB0aGlzLnNldHRpbmdzLCBvKTtcbiAgICB0aGlzLnJlbmRlcmVyc1tpZF0gPSByZW5kZXJlcjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVuZGVyZXIsICdpZCcsIHtcbiAgICAgIHZhbHVlOiBpZFxuICAgIH0pO1xuXG4gICAgLy8gQmluZCBldmVudHM6XG4gICAgaWYgKHJlbmRlcmVyLmJpbmQpXG4gICAgICByZW5kZXJlci5iaW5kKFxuICAgICAgICBbXG4gICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICAncmlnaHRDbGljaycsXG4gICAgICAgICAgJ2NsaWNrU3RhZ2UnLFxuICAgICAgICAgICdkb3VibGVDbGlja1N0YWdlJyxcbiAgICAgICAgICAncmlnaHRDbGlja1N0YWdlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlJyxcbiAgICAgICAgICAnY2xpY2tOb2RlcycsXG4gICAgICAgICAgJ2NsaWNrRWRnZScsXG4gICAgICAgICAgJ2NsaWNrRWRnZXMnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGUnLFxuICAgICAgICAgICdkb3VibGVDbGlja05vZGVzJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlJyxcbiAgICAgICAgICAnZG91YmxlQ2xpY2tFZGdlcycsXG4gICAgICAgICAgJ3JpZ2h0Q2xpY2tOb2RlJyxcbiAgICAgICAgICAncmlnaHRDbGlja05vZGVzJyxcbiAgICAgICAgICAncmlnaHRDbGlja0VkZ2UnLFxuICAgICAgICAgICdyaWdodENsaWNrRWRnZXMnLFxuICAgICAgICAgICdvdmVyTm9kZScsXG4gICAgICAgICAgJ292ZXJOb2RlcycsXG4gICAgICAgICAgJ292ZXJFZGdlJyxcbiAgICAgICAgICAnb3ZlckVkZ2VzJyxcbiAgICAgICAgICAnb3V0Tm9kZScsXG4gICAgICAgICAgJ291dE5vZGVzJyxcbiAgICAgICAgICAnb3V0RWRnZScsXG4gICAgICAgICAgJ291dEVkZ2VzJyxcbiAgICAgICAgICAnZG93bk5vZGUnLFxuICAgICAgICAgICdkb3duTm9kZXMnLFxuICAgICAgICAgICdkb3duRWRnZScsXG4gICAgICAgICAgJ2Rvd25FZGdlcycsXG4gICAgICAgICAgJ3VwTm9kZScsXG4gICAgICAgICAgJ3VwTm9kZXMnLFxuICAgICAgICAgICd1cEVkZ2UnLFxuICAgICAgICAgICd1cEVkZ2VzJ1xuICAgICAgICBdLFxuICAgICAgICB0aGlzLl9oYW5kbGVyXG4gICAgICApO1xuXG4gICAgLy8gUmVmZXJlbmNlIHRoZSByZW5kZXJlciBieSBpdHMgY2FtZXJhOlxuICAgIHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2NhbWVyYS5pZF0ucHVzaChyZW5kZXJlcik7XG5cbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGtpbGxzIGEgcmVuZGVyZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xyZW5kZXJlcn0gdiBUaGUgcmVuZGVyZXIgdG8ga2lsbCBvciBpdHMgSUQuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsUmVuZGVyZXIgPSBmdW5jdGlvbih2KSB7XG4gICAgdiA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHRoaXMucmVuZGVyZXJzW3ZdIDogdjtcblxuICAgIGlmICghdilcbiAgICAgIHRocm93ICdzaWdtYS5raWxsUmVuZGVyZXI6IFRoZSByZW5kZXJlciBpcyB1bmRlZmluZWQuJztcblxuICAgIHZhciBhID0gdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbdi5jYW1lcmEuaWRdLFxuICAgICAgICBpID0gYS5pbmRleE9mKHYpO1xuXG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGEuc3BsaWNlKGksIDEpO1xuXG4gICAgaWYgKHYua2lsbClcbiAgICAgIHYua2lsbCgpO1xuXG4gICAgZGVsZXRlIHRoaXMucmVuZGVyZXJzW3YuaWRdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBcInJlbmRlclwiIG1ldGhvZCBvZiBlYWNoIHJlbmRlcmVyLCB3aXRoIHRoZSBzYW1lXG4gICAqIGFyZ3VtZW50cyB0aGFuIHRoZSBcInJlbmRlclwiIG1ldGhvZCwgYnV0IHdpbGwgYWxzbyBjaGVjayBpZiB0aGUgcmVuZGVyZXJcbiAgICogaGFzIGEgXCJwcm9jZXNzXCIgbWV0aG9kLCBhbmQgY2FsbCBpdCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIEl0IGlzIHVzZWZ1bCBmb3IgcXVhZHRyZWVzIG9yIFdlYkdMIHByb2Nlc3NpbmcsIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gIG9wdGlvbnMgRXZlbnR1YWxseSBzb21lIG9wdGlvbnMgdG8gZ2l2ZSB0byB0aGUgcmVmcmVzaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICpcbiAgICogUmVjb2duaXplZCBwYXJhbWV0ZXJzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzIGluIHRoZSBcIm9wdGlvbnNcIlxuICAgKiBvYmplY3Q6XG4gICAqXG4gICAqICAgez9ib29sZWFufSBza2lwSW5kZXhhdGlvbiBBIGZsYWcgc3BlY2lmeWluZyB3ZXRoZXIgb3Igbm90IHRoZSByZWZyZXNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzaG91bGQgcmVpbmRleCB0aGUgZ3JhcGggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWFkdHJlZXMgb3Igbm90IChkZWZhdWx0OiBmYWxzZSkuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgYyxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBwcmVmaXggPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBDYWxsIGVhY2ggbWlkZGxld2FyZTpcbiAgICBhID0gdGhpcy5taWRkbGV3YXJlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBhW2ldLmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIChpID09PSAwKSA/ICcnIDogJ3RtcCcgKyBwcmVmaXggKyAnOicsXG4gICAgICAgIChpID09PSBsIC0gMSkgPyAncmVhZHk6JyA6ICgndG1wJyArICgrK3ByZWZpeCkgKyAnOicpXG4gICAgICApO1xuXG4gICAgLy8gVGhlbiwgZm9yIGVhY2ggY2FtZXJhLCBjYWxsIHRoZSBcInJlc2NhbGVcIiBtaWRkbGV3YXJlLCB1bmxlc3MgdGhlXG4gICAgLy8gc2V0dGluZ3Mgc3BlY2lmeSBub3QgdG86XG4gICAgZm9yIChrIGluIHRoaXMuY2FtZXJhcykge1xuICAgICAgYyA9IHRoaXMuY2FtZXJhc1trXTtcbiAgICAgIGlmIChcbiAgICAgICAgYy5zZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXSAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjLmlkXS5sZW5ndGhcbiAgICAgIClcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5yZW5kZXJlcnNQZXJDYW1lcmFbYy5pZF1bMF0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMucmVuZGVyZXJzUGVyQ2FtZXJhW2MuaWRdWzBdLmhlaWdodFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc2lnbWEubWlkZGxld2FyZXMuY29weS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYS5sZW5ndGggPyAncmVhZHk6JyA6ICcnLFxuICAgICAgICAgIGMucmVhZFByZWZpeFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgLy8gRmluZCBncmFwaCBib3VuZGFyaWVzOlxuICAgICAgICBib3VuZHMgPSBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgYy5yZWFkUHJlZml4XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBxdWFkdHJlZTpcbiAgICAgICAgYy5xdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLm5vZGVzKCksIHtcbiAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICBib3VuZHM6IHtcbiAgICAgICAgICAgIHg6IGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICB3aWR0aDogYm91bmRzLm1heFggLSBib3VuZHMubWluWCxcbiAgICAgICAgICAgIGhlaWdodDogYm91bmRzLm1heFkgLSBib3VuZHMubWluWVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgYy5zZXR0aW5ncygnZHJhd0VkZ2VzJykgJiZcbiAgICAgICAgICBjLnNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5pbmRleCh0aGlzLmdyYXBoLCB7XG4gICAgICAgICAgICBwcmVmaXg6IGMucmVhZFByZWZpeCxcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICB4OiBib3VuZHMubWluWCxcbiAgICAgICAgICAgICAgeTogYm91bmRzLm1pblksXG4gICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMubWF4WCAtIGJvdW5kcy5taW5YLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5tYXhZIC0gYm91bmRzLm1pbllcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGwgZWFjaCByZW5kZXJlcjpcbiAgICBhID0gT2JqZWN0LmtleXModGhpcy5yZW5kZXJlcnMpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyc1thW2ldXS5wcm9jZXNzKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCdza2lwRXJyb3JzJykpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgJ1dhcm5pbmc6IFRoZSByZW5kZXJlciBcIicgKyBhW2ldICsgJ1wiIGNyYXNoZWQgb24gXCIucHJvY2VzcygpXCInXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnByb2Nlc3MoKTtcbiAgICAgIH1cblxuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwicmVuZGVyXCIgbWV0aG9kIG9mIGVhY2ggcmVuZGVyZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge3NpZ21hfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIHByZWZpeCA9IDA7XG5cbiAgICAvLyBDYWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgYSA9IE9iamVjdC5rZXlzKHRoaXMucmVuZGVyZXJzKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXJzW2FbaV1dLnJlbmRlcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3ZlcmJvc2UnKSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArIGFbaV0gKyAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLnJlbmRlcmVyc1thW2ldXS5yZW5kZXIoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgXCJyZW5kZXJcIiBtZXRob2Qgb2YgZWFjaCByZW5kZXJlciB0aGF0IGlzIGJvdW5kIHRvXG4gICAqIHRoZSBzcGVjaWZpZWQgY2FtZXJhLiBUbyBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZXMsIGlmIHRoaXMgbWV0aG9kIGlzXG4gICAqIGNhbGxlZCB0b28gb2Z0ZW4sIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIHJlbmRlcmluZ3MgaXMgbGltaXRhdGVkIHRvIG9uZVxuICAgKiBwZXIgZnJhbWUsIHVubGVzcyB5b3UgYXJlIHVzaW5nIHRoZSBcImZvcmNlXCIgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5jYW1lcmF9IGNhbWVyYSBUaGUgY2FtZXJhIHRvIHJlbmRlci5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59ICAgICAgICAgICAgIGZvcmNlICBJZiB0cnVlLCB3aWxsIHJlbmRlciB0aGUgY2FtZXJhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0bHkuXG4gICAqIEByZXR1cm4ge3NpZ21hfSAgICAgICAgICAgICAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucHJvdG90eXBlLnJlbmRlckNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYSwgZm9yY2UpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncygnc2tpcEVycm9ycycpKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhW2ldLnJlbmRlcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICdXYXJuaW5nOiBUaGUgcmVuZGVyZXIgXCInICsgYVtpXS5pZCArICdcIiBjcmFzaGVkIG9uIFwiLnJlbmRlcigpXCInXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYVtpXS5yZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdKSB7XG4gICAgICAgIGEgPSB0aGlzLnJlbmRlcmVyc1BlckNhbWVyYVtjYW1lcmEuaWRdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MoJ3NraXBFcnJvcnMnKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGFbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKCd2ZXJib3NlJykpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAnV2FybmluZzogVGhlIHJlbmRlcmVyIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGFbaV0uaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgY3Jhc2hlZCBvbiBcIi5yZW5kZXIoKVwiJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYVtpXS5yZW5kZXIoKTtcblxuICAgICAgICB0aGlzLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmNhbWVyYUZyYW1lc1tjYW1lcmEuaWRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FsbHMgdGhlIFwia2lsbFwiIG1ldGhvZCBvZiBlYWNoIG1vZHVsZSBhbmQgZGVzdHJveXMgYW55XG4gICAqIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGs7XG5cbiAgICAvLyBEaXNwYXRjaGluZyBldmVudFxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgna2lsbCcpO1xuXG4gICAgLy8gS2lsbCBncmFwaDpcbiAgICB0aGlzLmdyYXBoLmtpbGwoKTtcblxuICAgIC8vIEtpbGwgbWlkZGxld2FyZXM6XG4gICAgZGVsZXRlIHRoaXMubWlkZGxld2FyZXM7XG5cbiAgICAvLyBLaWxsIGVhY2ggcmVuZGVyZXI6XG4gICAgZm9yIChrIGluIHRoaXMucmVuZGVyZXJzKVxuICAgICAgdGhpcy5raWxsUmVuZGVyZXIodGhpcy5yZW5kZXJlcnNba10pO1xuXG4gICAgLy8gS2lsbCBlYWNoIGNhbWVyYTpcbiAgICBmb3IgKGsgaW4gdGhpcy5jYW1lcmFzKVxuICAgICAgdGhpcy5raWxsQ2FtZXJhKHRoaXMuY2FtZXJhc1trXSk7XG5cbiAgICBkZWxldGUgdGhpcy5yZW5kZXJlcnM7XG4gICAgZGVsZXRlIHRoaXMuY2FtZXJhcztcblxuICAgIC8vIEtpbGwgZXZlcnl0aGluZyBlbHNlOlxuICAgIGZvciAoayBpbiB0aGlzKVxuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIGRlbGV0ZSB0aGlzW2tdO1xuXG4gICAgZGVsZXRlIF9faW5zdGFuY2VzW3RoaXMuaWRdO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGluc3RhbmNlcyBvYmplY3Qgb3IgYSBzcGVjaWZpYyBydW5uaW5nIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSBpZCBFdmVudHVhbGx5IGFuIGluc3RhbmNlIElELlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICBUaGUgcmVsYXRlZCBpbnN0YW5jZSBvciBhIGNsb25lIG9mIHRoZSBpbnN0YW5jZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlxuICAgKi9cbiAgc2lnbWEuaW5zdGFuY2VzID0gZnVuY3Rpb24oaWQpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/XG4gICAgICBfX2luc3RhbmNlc1tpZF0gOlxuICAgICAgc2lnbWEudXRpbHMuZXh0ZW5kKHt9LCBfX2luc3RhbmNlcyk7XG4gIH07XG5cblxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHNpZ21hOlxuICAgKi9cbiAgc2lnbWEudmVyc2lvbiA9ICcxLjIuMSc7XG5cblxuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnQW4gb2JqZWN0IGNhbGxlZCBzaWdtYSBpcyBhbHJlYWR5IGluIHRoZSBnbG9iYWwgc2NvcGUuJztcblxuICB0aGlzLnNpZ21hID0gc2lnbWE7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qKlxuICogY29ucmFkLmpzIGlzIGEgdGlueSBKYXZhU2NyaXB0IGpvYnMgc2NoZWR1bGVyLFxuICpcbiAqIFZlcnNpb246IDAuMS4wXG4gKiBTb3VyY2VzOiBodHRwOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9jb25yYWQuanNcbiAqIERvYzogICAgIGh0dHA6Ly9naXRodWIuY29tL2phY29teWFsL2NvbnJhZC5qcyNyZWFkbWVcbiAqXG4gKiBMaWNlbnNlOlxuICogLS0tLS0tLS1cbiAqIENvcHlyaWdodCDCqSAyMDEzIEFsZXhpcyBKYWNvbXksIFNjaWVuY2VzLVBvIG3DqWRpYWxhYlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4gKiBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICogcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVGhlIFNvZnR3YXJlIGlzIHByb3ZpZGVkIFwiYXMgaXNcIiwgd2l0aG91dCB3YXJyYW50eSBvZiBhbnkga2luZCwgZXhwcmVzcyBvclxuICogaW1wbGllZCwgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byB0aGUgd2FycmFudGllcyBvZiBtZXJjaGFudGFiaWxpdHksXG4gKiBmaXRuZXNzIGZvciBhIHBhcnRpY3VsYXIgcHVycG9zZSBhbmQgbm9uaW5mcmluZ2VtZW50LiBJbiBubyBldmVudCBzaGFsbCB0aGVcbiAqIGF1dGhvcnMgb3IgY29weXJpZ2h0IGhvbGRlcnMgYmUgbGlhYmxlIGZvciBhbnkgY2xhaW0sIGRhbWFnZXMgb3Igb3RoZXJcbiAqIGxpYWJpbGl0eSwgd2hldGhlciBpbiBhbiBhY3Rpb24gb2YgY29udHJhY3QsIHRvcnQgb3Igb3RoZXJ3aXNlLCBhcmlzaW5nXG4gKiBmcm9tLCBvdXQgb2Ygb3IgaW4gY29ubmVjdGlvbiB3aXRoIHRoZSBzb2Z0d2FyZSBvciB0aGUgdXNlIG9yIG90aGVyIGRlYWxpbmdzXG4gKiBpbiB0aGUgU29mdHdhcmUuXG4gKi9cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENoZWNrIHRoYXQgY29ucmFkLmpzIGhhcyBub3QgYmVlbiBsb2FkZWQgeWV0OlxuICBpZiAoZ2xvYmFsLmNvbnJhZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnJhZCBhbHJlYWR5IGV4aXN0cycpO1xuXG5cbiAgLyoqXG4gICAqIFBSSVZBVEUgVkFSSUFCTEVTOlxuICAgKiAqKioqKioqKioqKioqKioqKipcbiAgICovXG5cbiAgLyoqXG4gICAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgY29ucmFkIGlzIHJ1bm5pbmcgb3Igbm90LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgdmFyIF9sYXN0RnJhbWVUaW1lO1xuXG4gIC8qKlxuICAgKiBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGNvbnJhZCBpcyBydW5uaW5nIG9yIG5vdC5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBvZiByZWdpc3RlcmVkIGpvYnMuIEVhY2ggam9iIG11c3QgYXQgbGVhc3QgaGF2ZSBhIHVuaXF1ZSBJRFxuICAgKiB1bmRlciB0aGUga2V5IFwiaWRcIiBhbmQgYSBmdW5jdGlvbiB1bmRlciB0aGUga2V5IFwiam9iXCIuIFRoaXMgaGFzaFxuICAgKiBjb250YWlucyBlYWNoIHJ1bm5pbmcgam9iIGFuZCBlYWNoIHdhaXRpbmcgam9iLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9qb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBoYXNoIG9mIGN1cnJlbnRseSBydW5uaW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3J1bm5pbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgcnVubmluZyBqb2JzLCBzb3J0ZWQgYnkgcHJpb3JpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHZhciBfc29ydGVkQnlQcmlvcml0eUpvYnMgPSBbXTtcblxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSB3YWl0aW5nIGpvYnMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICB2YXIgX3dhaXRpbmdKb2JzID0ge307XG5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBmaW5pc2hlZCBqb2JzLiBUaGV5IGFyZSBzdG9yZWQgaW4gYW4gYXJyYXksIHNpbmNlIHR3byBqb2JzXG4gICAqIHdpdGggdGhlIHNhbWUgXCJpZFwiIGNhbiBoYXBwZW4gYXQgdHdvIGRpZmZlcmVudCB0aW1lcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgdmFyIF9kb25lSm9icyA9IFtdO1xuXG4gIC8qKlxuICAgKiBBIGRpcnR5IGZsYWcgdG8ga2VlcCBjb25yYWQgZnJvbSBzdGFydGluZzogSW5kZWVkLCB3aGVuIGFkZEpvYigpIGlzIGNhbGxlZFxuICAgKiB3aXRoIHNldmVyYWwgam9icywgY29ucmFkIG11c3QgYmUgc3RhcnRlZCBvbmx5IGF0IHRoZSBlbmQuIFRoaXMgZmxhZyBrZWVwc1xuICAgKiBtZSBmcm9tIGR1cGxpY2F0aW5nIHRoZSBjb2RlIHRoYXQgZWZmZWN0aXZlbHkgYWRkcyBhIGpvYi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICB2YXIgX25vU3RhcnQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQW4gaGFzaCBjb250YWluaW5nIHNvbWUgZ2xvYmFsIHNldHRpbmdzIGFib3V0IGhvdyBjb25yYWQuanMgc2hvdWxkXG4gICAqIGJlaGF2ZS5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHZhciBfcGFyYW1ldGVycyA9IHtcbiAgICBmcmFtZUR1cmF0aW9uOiAyMCxcbiAgICBoaXN0b3J5OiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGV2ZXJ5IGhhbmRsZXJzIGJvdW5kIHRvIGNvbnJhZCBldmVudHMuIEl0IGRvZXMgbm90XG4gICAqIHJlcXVpcmVhIGFueSBET00gaW1wbGVtZW50YXRpb24sIHNpbmNlIHRoZSBldmVudHMgYXJlIGFsbCBKYXZhU2NyaXB0LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdmFyIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblxuICAvKipcbiAgICogUFJJVkFURSBGVU5DVElPTlM6XG4gICAqICoqKioqKioqKioqKioqKioqKlxuICAgKi9cblxuICAvKipcbiAgICogV2lsbCBleGVjdXRlIHRoZSBoYW5kbGVyIGV2ZXJ5dGltZSB0aGF0IHRoZSBpbmRpY2F0ZWQgZXZlbnQgKG9yIHRoZVxuICAgKiBpbmRpY2F0ZWQgZXZlbnRzKSB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfGFycmF5fG9iamVjdH0gZXZlbnRzICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb24oT2JqZWN0KX0gICAgaGFuZGxlciBUaGUgaGFuZGxlciB0byBiaW5kLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2JpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5O1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgT2JqZWN0KGFyZ3VtZW50c1swXSkgPT09IGFyZ3VtZW50c1swXVxuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgX2JpbmQoZXZlbnRzLCBhcmd1bWVudHNbMF1bZXZlbnRzXSk7XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVBcnJheSA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuXG4gICAgICAgIGlmICghX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICBfaGFuZGxlcnNbZXZlbnRdID0gW107XG5cbiAgICAgICAgLy8gVXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgZGlyZWN0bHkgdGhlIGhhbmRsZXIgd2lsbCBtYWtlIHBvc3NpYmxlXG4gICAgICAgIC8vIGxhdGVyIHRvIGFkZCBmbGFnc1xuICAgICAgICBfaGFuZGxlcnNbZXZlbnRdLnB1c2goe1xuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF91bmJpbmQoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGlfZW5kLFxuICAgICAgICBqLFxuICAgICAgICBqX2VuZCxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZXZlbnRzKSA/XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzIDpcbiAgICAgICAgICAgICAgICAgICBldmVudHMuc3BsaXQoLyAvKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgIF9oYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICAgIGV2ZW50ID0gZUFycmF5W2ldO1xuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBqX2VuZCA9IF9oYW5kbGVyc1tldmVudF0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKF9oYW5kbGVyc1tldmVudF1bal0uaGFuZGxlciAhPT0gaGFuZGxlcilcbiAgICAgICAgICAgICAgYS5wdXNoKF9oYW5kbGVyc1tldmVudF1bal0pO1xuXG4gICAgICAgICAgX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2hhbmRsZXJzW2V2ZW50XSAmJiBfaGFuZGxlcnNbZXZlbnRdLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICBkZWxldGUgX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIGlfZW5kID0gZUFycmF5Lmxlbmd0aDsgaSAhPT0gaV9lbmQ7IGkgKz0gMSlcbiAgICAgICAgZGVsZXRlIF9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKG9yIHRoZSBldmVudHMgc2VwYXJhdGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBieSBzcGFjZXMpLlxuICAgKiBAcGFyYW0gIHs/T2JqZWN0fSBkYXRhICAgVGhlIGNvbnRlbnQgb2YgdGhlIGV2ZW50IChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIGNvbnJhZC5cbiAgICovXG4gIGZ1bmN0aW9uIF9kaXNwYXRjaChldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgaV9lbmQsXG4gICAgICAgIGpfZW5kLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBlQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgP1xuICAgICAgICAgICAgICAgICAgIGV2ZW50cyA6XG4gICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGl0KC8gLyk7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgaV9lbmQgPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBpX2VuZDsgaSArPSAxKSB7XG4gICAgICBldmVudE5hbWUgPSBlQXJyYXlbaV07XG5cbiAgICAgIGlmIChfaGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICB0eXBlOiBldmVudE5hbWUsXG4gICAgICAgICAgZGF0YTogZGF0YSB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpfZW5kID0gX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoOyBqICE9PSBqX2VuZDsgaiArPSAxKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfaGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgbW9zdCBwcmlvcml0YXJ5IGpvYiBvbmNlLCBhbmQgZGVhbHMgd2l0aCBmaWxsaW5nIHRoZSBzdGF0c1xuICAgKiAoZG9uZSwgdGltZSwgYXZlcmFnZVRpbWUsIGN1cnJlbnRUaW1lLCBldGMuLi4pLlxuICAgKlxuICAgKiBAcmV0dXJuIHs/T2JqZWN0fSBSZXR1cm5zIHRoZSBqb2Igb2JqZWN0IGlmIGl0IGhhcyB0byBiZSBraWxsZWQsIG51bGwgZWxzZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9leGVjdXRlRmlyc3RKb2IoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGtpbGwsXG4gICAgICAgIHB1c2hlZCA9IGZhbHNlLFxuICAgICAgICB0aW1lID0gX19kYXRlTm93KCksXG4gICAgICAgIGpvYiA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5zaGlmdCgpO1xuXG4gICAgLy8gRXhlY3V0ZSB0aGUgam9iIGFuZCBsb29rIGF0IHRoZSByZXN1bHQ6XG4gICAgdGVzdCA9IGpvYi5qb2IoKTtcblxuICAgIC8vIERlYWwgd2l0aCBzdGF0czpcbiAgICB0aW1lID0gX19kYXRlTm93KCkgLSB0aW1lO1xuICAgIGpvYi5kb25lKys7XG4gICAgam9iLnRpbWUgKz0gdGltZTtcbiAgICBqb2IuY3VycmVudFRpbWUgKz0gdGltZTtcbiAgICBqb2Iud2VpZ2h0VGltZSA9IGpvYi5jdXJyZW50VGltZSAvIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIGpvYi5hdmVyYWdlVGltZSA9IGpvYi50aW1lIC8gam9iLmRvbmU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgam9iIGhhcyB0byBiZSBraWxsZWQ6XG4gICAga2lsbCA9IGpvYi5jb3VudCA/IChqb2IuY291bnQgPD0gam9iLmRvbmUpIDogIXRlc3Q7XG5cbiAgICAvLyBSZXNldCBwcmlvcml0aWVzOlxuICAgIGlmICgha2lsbCkge1xuICAgICAgZm9yIChpID0gMCwgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChfc29ydGVkQnlQcmlvcml0eUpvYnNbaV0ud2VpZ2h0VGltZSA+IGpvYi53ZWlnaHRUaW1lKSB7XG4gICAgICAgICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzLnNwbGljZShpLCAwLCBqb2IpO1xuICAgICAgICAgIHB1c2hlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFwdXNoZWQpXG4gICAgICAgIF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5wdXNoKGpvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtpbGwgPyBqb2IgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyBhIGpvYiwgYnkgYWRkaW5nIGl0IHRvIHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0IGFuZCB0aGVcbiAgICogX3NvcnRlZEJ5UHJpb3JpdHlKb2JzIGFycmF5LiBJdCBhbHNvIGluaXRpYWxpemVzIGl0cyBjdXJyZW50VGltZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBqb2IgVGhlIGpvYiB0byBhY3RpdmF0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9hY3RpdmF0ZUpvYihqb2IpIHtcbiAgICB2YXIgbCA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icy5sZW5ndGg7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcnVubmluZyBqb2JzOlxuICAgIF9ydW5uaW5nSm9ic1tqb2IuaWRdID0gam9iO1xuICAgIGpvYi5zdGF0dXMgPSAncnVubmluZyc7XG5cbiAgICAvLyBBZGQgdGhlIGpvYiB0byB0aGUgcHJpb3JpdGllczpcbiAgICBpZiAobCkge1xuICAgICAgam9iLndlaWdodFRpbWUgPSBfc29ydGVkQnlQcmlvcml0eUpvYnNbbCAtIDFdLndlaWdodFRpbWU7XG4gICAgICBqb2IuY3VycmVudFRpbWUgPSBqb2Iud2VpZ2h0VGltZSAqIChqb2Iud2VpZ2h0IHx8IDEpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGpvYiBhbmQgZGlzcGF0Y2g6XG4gICAgam9iLnN0YXJ0VGltZSA9IF9fZGF0ZU5vdygpO1xuICAgIF9kaXNwYXRjaCgnam9iU3RhcnRlZCcsIF9fY2xvbmUoam9iKSk7XG5cbiAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMucHVzaChqb2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGxvb3Agb2YgY29ucmFkLmpzOlxuICAgKiAgLiBJdCBleGVjdXRlcyBqb2Igc3VjaCB0aGF0IHRoZXkgYWxsIG9jY3VwYXRlIHRoZSBzYW1lIHByb2Nlc3NpbmcgdGltZS5cbiAgICogIC4gSXQgc3RvcHMgam9icyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGV4ZWN1dGVkIGFueW1vcmUuXG4gICAqICAuIEl0IHRyaWdnZXJzIGNhbGxiYWNrcyB3aGVuIGl0IGlzIHJlbGV2YW50LlxuICAgKiAgLiBJdCBzdGFydHMgd2FpdGluZyBqb2JzIHdoZW4gdGhleSBuZWVkIHRvIGJlIHN0YXJ0ZWQuXG4gICAqICAuIEl0IGluamVjdHMgZnJhbWVzIHRvIGtlZXAgYSBjb25zdGFudCBmcmFwZXMgcGVyIHNlY29uZCByYXRpby5cbiAgICogIC4gSXQgc3RvcHMgaXRzZWxmIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgam9icyB0byBleGVjdXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIG8sXG4gICAgICAgIGwsXG4gICAgICAgIGpvYixcbiAgICAgICAgdGltZSxcbiAgICAgICAgZGVhZEpvYjtcblxuICAgIC8vIERlYWwgd2l0aCB0aGUgbmV3bHkgYWRkZWQgam9icyAodGhlIF9qb2JzIG9iamVjdCk6XG4gICAgZm9yIChrIGluIF9qb2JzKSB7XG4gICAgICBqb2IgPSBfam9ic1trXTtcblxuICAgICAgaWYgKGpvYi5hZnRlcilcbiAgICAgICAgX3dhaXRpbmdKb2JzW2tdID0gam9iO1xuICAgICAgZWxzZVxuICAgICAgICBfYWN0aXZhdGVKb2Ioam9iKTtcblxuICAgICAgZGVsZXRlIF9qb2JzW2tdO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgX2lzUnVubmluZyBmbGFnIHRvIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBydW5uaW5nIGpvYjpcbiAgICBfaXNSdW5uaW5nID0gISFfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoO1xuXG4gICAgLy8gRGVhbCB3aXRoIHRoZSBydW5uaW5nIGpvYnMgKHRoZSBfcnVubmluZ0pvYnMgb2JqZWN0KTpcbiAgICB3aGlsZSAoXG4gICAgICBfc29ydGVkQnlQcmlvcml0eUpvYnMubGVuZ3RoICYmXG4gICAgICBfX2RhdGVOb3coKSAtIF9sYXN0RnJhbWVUaW1lIDwgX3BhcmFtZXRlcnMuZnJhbWVEdXJhdGlvblxuICAgICkge1xuICAgICAgZGVhZEpvYiA9IF9leGVjdXRlRmlyc3RKb2IoKTtcblxuICAgICAgLy8gRGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBqb2IgaGFzIGVuZGVkOlxuICAgICAgaWYgKGRlYWRKb2IpIHtcbiAgICAgICAgX2tpbGxKb2IoZGVhZEpvYi5pZCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHdhaXRpbmcgam9iczpcbiAgICAgICAgZm9yIChrIGluIF93YWl0aW5nSm9icylcbiAgICAgICAgICBpZiAoX3dhaXRpbmdKb2JzW2tdLmFmdGVyID09PSBkZWFkSm9iLmlkKSB7XG4gICAgICAgICAgICBfYWN0aXZhdGVKb2IoX3dhaXRpbmdKb2JzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfd2FpdGluZ0pvYnNba107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvbnJhZCBzdGlsbCBoYXMgam9icyB0byBkZWFsIHdpdGgsIGFuZCBraWxsIGl0IGlmIG5vdDpcbiAgICBpZiAoX2lzUnVubmluZykge1xuICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgIF9kaXNwYXRjaCgnZW50ZXJGcmFtZScpO1xuICAgICAgc2V0VGltZW91dChfbG9vcCwgMCk7XG4gICAgfSBlbHNlXG4gICAgICBfZGlzcGF0Y2goJ3N0b3AnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9uZSBvciBtb3JlIGpvYnMsIGFuZCBzdGFydHMgdGhlIGxvb3AgaWYgbm8gam9iIHdhcyBydW5uaW5nIGJlZm9yZS4gQVxuICAgKiBqb2IgaXMgYXQgbGVhc3QgYSB1bmlxdWUgc3RyaW5nIFwiaWRcIiBhbmQgYSBmdW5jdGlvbiwgYW5kIHRoZXJlIGFyZSBzb21lXG4gICAqIHBhcmFtZXRlcnMgdGhhdCB5b3UgY2FuIHNwZWNpZnkgZm9yIGVhY2ggam9iIHRvIG1vZGlmeSB0aGUgd2F5IGNvbnJhZCB3aWxsXG4gICAqIGV4ZWN1dGUgaXQuIElmIGEgam9iIGlzIGFkZGVkIHdpdGggdGhlIFwiaWRcIiBvZiBhbm90aGVyIGpvYiB0aGF0IGlzIHdhaXRpbmdcbiAgICogb3Igc3RpbGwgcnVubmluZywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIFdoZW4gYSBqb2IgaXMgYWRkZWQsIGl0IGlzIHJlZmVyZW5jZWQgaW4gdGhlIF9qb2JzIG9iamVjdCwgYnkgaXRzIGlkLlxuICAgKiBUaGVuLCBpZiBpdCBoYXMgdG8gYmUgZXhlY3V0ZWQgcmlnaHQgbm93LCBpdCB3aWxsIGJlIGFsc28gcmVmZXJlbmNlZCBpblxuICAgKiB0aGUgX3J1bm5pbmdKb2JzIG9iamVjdC4gSWYgaXQgaGFzIHRvIHdhaXQsIHRoZW4gaXQgd2lsbCBiZSBhZGRlZCBpbnRvIHRoZVxuICAgKiBfd2FpdGluZ0pvYnMgb2JqZWN0LCB1bnRpbCBpdCBjYW4gc3RhcnQuXG4gICAqXG4gICAqIEtlZXAgcmVhZGluZyB0aGlzIGRvY3VtZW50YXRpb24gdG8gc2VlIGhvdyB0byBjYWxsIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKlxuICAgKiBBZGRpbmcgb25lIGpvYjpcbiAgICogKioqKioqKioqKioqKioqXG4gICAqIEJhc2ljYWxseSwgYSBqb2IgaXMgZGVmaW5lZCBieSBpdHMgc3RyaW5nIGlkIGFuZCBhIGZ1bmN0aW9uICh0aGUgam9iKS4gSXRcbiAgICogaXMgYWxzbyBwb3NzaWJsZSB0byBhZGQgc29tZSBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgPiBjb25yYWQuYWRkSm9iKCdteUpvYklkJywgbXlKb2JGdW5jdGlvbik7XG4gICAqICA+IGNvbnJhZC5hZGRKb2IoJ215Sm9iSWQnLCB7XG4gICAqICA+ICAgam9iOiBteUpvYkZ1bmN0aW9uLFxuICAgKiAgPiAgIHNvbWVQYXJhbWV0ZXI6IHNvbWVWYWx1ZVxuICAgKiAgPiB9KTtcbiAgICogID4gY29ucmFkLmFkZEpvYih7XG4gICAqICA+ICAgaWQ6ICdteUpvYklkJyxcbiAgICogID4gICBqb2I6IG15Sm9iRnVuY3Rpb24sXG4gICAqICA+ICAgc29tZVBhcmFtZXRlcjogc29tZVZhbHVlXG4gICAqICA+IH0pO1xuICAgKlxuICAgKiBBZGRpbmcgc2V2ZXJhbCBqb2JzOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKlxuICAgKiBXaGVuIGFkZGluZyBzZXZlcmFsIGpvYnMgYXQgdGhlIHNhbWUgdGltZSwgaXQgaXMgcG9zc2libGUgdG8gc3BlY2lmeVxuICAgKiBwYXJhbWV0ZXJzIGZvciBlYWNoIG9uZSBpbmRpdmlkdWFsbHkgb3IgZm9yIGFsbDpcbiAgICpcbiAgICogID4gY29ucmFkLmFkZEpvYihbXG4gICAqICA+ICAge1xuICAgKiAgPiAgICAgaWQ6ICdteUpvYklkMScsXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24xLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjE6IHNvbWVWYWx1ZTFcbiAgICogID4gICB9LFxuICAgKiAgPiAgIHtcbiAgICogID4gICAgIGlkOiAnbXlKb2JJZDInLFxuICAgKiAgPiAgICAgam9iOiBteUpvYkZ1bmN0aW9uMixcbiAgICogID4gICAgIHNvbWVQYXJhbWV0ZXIyOiBzb21lVmFsdWUyXG4gICAqICA+ICAgfVxuICAgKiAgPiBdLCB7XG4gICAqICA+ICAgc29tZUNvbW1vblBhcmFtZXRlcjogc29tZUNvbW1vblZhbHVlXG4gICAqICA+IH0pO1xuICAgKiAgPiBjb25yYWQuYWRkSm9iKHtcbiAgICogID4gICBteUpvYklkMTogeyxcbiAgICogID4gICAgIGpvYjogbXlKb2JGdW5jdGlvbjEsXG4gICAqICA+ICAgICBzb21lUGFyYW1ldGVyMTogc29tZVZhbHVlMVxuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgbXlKb2JJZDI6IHssXG4gICAqICA+ICAgICBqb2I6IG15Sm9iRnVuY3Rpb24yLFxuICAgKiAgPiAgICAgc29tZVBhcmFtZXRlcjI6IHNvbWVWYWx1ZTJcbiAgICogID4gICB9XG4gICAqICA+IH0sIHtcbiAgICogID4gICBzb21lQ29tbW9uUGFyYW1ldGVyOiBzb21lQ29tbW9uVmFsdWVcbiAgICogID4gfSk7XG4gICAqICA+IGNvbnJhZC5hZGRKb2Ioe1xuICAgKiAgPiAgIG15Sm9iSWQxOiBteUpvYkZ1bmN0aW9uMSxcbiAgICogID4gICBteUpvYklkMjogbXlKb2JGdW5jdGlvbjJcbiAgICogID4gfSwge1xuICAgKiAgPiAgIHNvbWVDb21tb25QYXJhbWV0ZXI6IHNvbWVDb21tb25WYWx1ZVxuICAgKiAgPiB9KTtcbiAgICpcbiAgICogIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICB7P0Z1bmN0aW9ufSBlbmQgICAgICBBIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgam9iIGlzIGVuZGVkLiBJdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub3QgZXhlY3V0ZWQgaWYgdGhlIGpvYiBpcyBraWxsZWQgaW5zdGVhZCBvZiBlbmRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hdHVyYWxseVwiLlxuICAgKiAgICB7P0ludGVnZXJ9ICBjb3VudCAgICBUaGUgbnVtYmVyIG9mIHRpbWUgdGhlIGpvYiBoYXMgdG8gYmUgZXhlY3V0ZWQuXG4gICAqICAgIHs/TnVtYmVyfSAgIHdlaWdodCAgIElmIHNwZWNpZmllZCwgdGhlIGpvYiB3aWxsIGJlIGV4ZWN1dGVkIGFzIGl0IHdhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCBcIndlaWdodFwiIHRpbWVzLlxuICAgKiAgICB7P1N0cmluZ30gICBhZnRlciAgICBUaGUgaWQgb2YgYW5vdGhlciBqb2IgKGV2ZW50dWFsbHkgbm90IGFkZGVkIHlldCkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIElmIHNwZWNpZmllZCwgdGhpcyBqb2Igd2lsbCBzdGFydCBvbmx5IHdoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCBcImFmdGVyXCIgam9iIGlzIGVuZGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZEpvYih2MSwgdjIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbztcblxuICAgIC8vIEFycmF5IG9mIGpvYnM6XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodjEpKSB7XG4gICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICBfbm9TdGFydCA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9hZGRKb2IodjFbaV0uaWQsIF9fZXh0ZW5kKHYxW2ldLCB2MikpO1xuXG4gICAgICBfbm9TdGFydCA9IGZhbHNlO1xuICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgX2xhc3RGcmFtZVRpbWU6XG4gICAgICAgIF9sYXN0RnJhbWVUaW1lID0gX19kYXRlTm93KCk7XG5cbiAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYxID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gT25lIGpvYiAob2JqZWN0KTpcbiAgICAgIGlmICh0eXBlb2YgdjEuaWQgPT09ICdzdHJpbmcnKVxuICAgICAgICBfYWRkSm9iKHYxLmlkLCB2MSk7XG5cbiAgICAgIC8vIEhhc2ggb2Ygam9iczpcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGNvbnJhZCB0byBzdGFydCB1bnRpbCB0aGUgbGFzdCBqb2IgaXMgYWRkZWQ6XG4gICAgICAgIF9ub1N0YXJ0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgaW4gdjEpXG4gICAgICAgICAgaWYgKHR5cGVvZiB2MVtpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQoe1xuICAgICAgICAgICAgICBqb2I6IHYxW2ldXG4gICAgICAgICAgICB9LCB2MikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9hZGRKb2IoaSwgX19leHRlbmQodjFbaV0sIHYyKSk7XG5cbiAgICAgICAgX25vU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFfaXNSdW5uaW5nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgICBfbGFzdEZyYW1lVGltZSA9IF9fZGF0ZU5vdygpO1xuXG4gICAgICAgICAgX2Rpc3BhdGNoKCdzdGFydCcpO1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIE9uZSBqb2IgKHN0cmluZywgKik6XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoX2hhc0pvYih2MSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnW2NvbnJhZC5hZGRKb2JdIEpvYiB3aXRoIGlkIFwiJyArIHYxICsgJ1wiIGFscmVhZHkgZXhpc3RzLidcbiAgICAgICAgKTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBmdW5jdGlvbik6XG4gICAgICBpZiAodHlwZW9mIHYyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7XG4gICAgICAgICAgaWQ6IHYxLFxuICAgICAgICAgIGRvbmU6IDAsXG4gICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICBzdGF0dXM6ICd3YWl0aW5nJyxcbiAgICAgICAgICBjdXJyZW50VGltZTogMCxcbiAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICB3ZWlnaHRUaW1lOiAwLFxuICAgICAgICAgIGpvYjogdjJcbiAgICAgICAgfTtcblxuICAgICAgLy8gT25lIGpvYiAoc3RyaW5nLCBvYmplY3QpOlxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdjIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBfX2V4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogdjEsXG4gICAgICAgICAgICBkb25lOiAwLFxuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHN0YXR1czogJ3dhaXRpbmcnLFxuICAgICAgICAgICAgY3VycmVudFRpbWU6IDAsXG4gICAgICAgICAgICBhdmVyYWdlVGltZTogMCxcbiAgICAgICAgICAgIHdlaWdodFRpbWU6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHYyXG4gICAgICAgICk7XG5cbiAgICAgIC8vIElmIG5vbmUgb2YgdGhvc2UgY2FzZXMsIHRocm93IGFuIGVycm9yOlxuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgICAgLy8gRWZmZWN0aXZlbHkgYWRkIHRoZSBqb2I6XG4gICAgICBfam9ic1t2MV0gPSBvO1xuICAgICAgX2Rpc3BhdGNoKCdqb2JBZGRlZCcsIF9fY2xvbmUobykpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgbG9vcCBoYXMgdG8gYmUgc3RhcnRlZDpcbiAgICAgIGlmICghX2lzUnVubmluZyAmJiAhX25vU3RhcnQpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBfbGFzdEZyYW1lVGltZTpcbiAgICAgICAgX2xhc3RGcmFtZVRpbWUgPSBfX2RhdGVOb3coKTtcblxuICAgICAgICBfZGlzcGF0Y2goJ3N0YXJ0Jyk7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5hZGRKb2JdIFdyb25nIGFyZ3VtZW50cy4nKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEtpbGxzIG9uZSBvciBtb3JlIGpvYnMsIGluZGljYXRlZCBieSB0aGVpciBpZHMuIEl0IGlzIG9ubHkgcG9zc2libGUgdG9cbiAgICoga2lsbCBydW5uaW5nIGpvYnMgb3Igd2FpdGluZyBqb2JzLiBJZiB5b3UgdHJ5IHRvIGtpbGwgYSBqb2IgdGhhdCBkb2VzIG5vdFxuICAgKiBleGlzdCBvciB0aGF0IGlzIGFscmVhZHkga2lsbGVkLCBhIHdhcm5pbmcgd2lsbCBiZSB0aHJvd24uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fFN0cmluZ30gdjEgQSBzdHJpbmcgam9iIGlkIG9yIGFuIGFycmF5IG9mIGpvYiBpZHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyBjb25yYWQuXG4gICAqL1xuICBmdW5jdGlvbiBfa2lsbEpvYih2MSkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBqb2IsXG4gICAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBBcnJheSBvZiBqb2IgaWRzOlxuICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSlcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2MS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIF9raWxsSm9iKHYxW2ldKTtcblxuICAgIC8vIE9uZSBqb2IncyBpZDpcbiAgICBlbHNlIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhID0gW19ydW5uaW5nSm9icywgX3dhaXRpbmdKb2JzLCBfam9ic107XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgam9iIGZyb20gdGhlIGhhc2hlczpcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHYxIGluIGFbaV0pIHtcbiAgICAgICAgICBqb2IgPSBhW2ldW3YxXTtcblxuICAgICAgICAgIGlmIChfcGFyYW1ldGVycy5oaXN0b3J5KSB7XG4gICAgICAgICAgICBqb2Iuc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICAgICAgX2RvbmVKb2JzLnB1c2goam9iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZGlzcGF0Y2goJ2pvYkVuZGVkJywgX19jbG9uZShqb2IpKTtcbiAgICAgICAgICBkZWxldGUgYVtpXVt2MV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGpvYi5lbmQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBqb2IuZW5kKCk7XG5cbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBwcmlvcml0aWVzIGFycmF5OlxuICAgICAgYSA9IF9zb3J0ZWRCeVByaW9yaXR5Sm9icztcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGFbaV0uaWQgPT09IHYxKSB7XG4gICAgICAgICAgYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY29ucmFkLmtpbGxKb2JdIEpvYiBcIicgKyB2MSArICdcIiBub3QgZm91bmQuJyk7XG5cbiAgICAvLyBJZiBub25lIG9mIHRob3NlIGNhc2VzLCB0aHJvdyBhbiBlcnJvcjpcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignW2NvbnJhZC5raWxsSm9iXSBXcm9uZyBhcmd1bWVudHMuJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nLCB3YWl0aW5nLCBhbmQganVzdCBhZGRlZCBqb2JzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2tpbGxBbGwoKSB7XG4gICAgdmFyIGssXG4gICAgICAgIGpvYnMgPSBfX2V4dGVuZChfam9icywgX3J1bm5pbmdKb2JzLCBfd2FpdGluZ0pvYnMpO1xuXG4gICAgLy8gVGFrZSBldmVyeSBqb2JzIGFuZCBwdXNoIHRoZW0gaW50byB0aGUgX2RvbmVKb2JzIG9iamVjdDpcbiAgICBpZiAoX3BhcmFtZXRlcnMuaGlzdG9yeSlcbiAgICAgIGZvciAoayBpbiBqb2JzKSB7XG4gICAgICAgIGpvYnNba10uc3RhdHVzID0gJ2RvbmUnO1xuICAgICAgICBfZG9uZUpvYnMucHVzaChqb2JzW2tdKTtcblxuICAgICAgICBpZiAodHlwZW9mIGpvYnNba10uZW5kID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGpvYnNba10uZW5kKCk7XG4gICAgICB9XG5cbiAgICAvLyBSZWluaXRpYWxpemUgdGhlIGRpZmZlcmVudCBqb2JzIGxpc3RzOlxuICAgIF9qb2JzID0ge307XG4gICAgX3dhaXRpbmdKb2JzID0ge307XG4gICAgX3J1bm5pbmdKb2JzID0ge307XG4gICAgX3NvcnRlZEJ5UHJpb3JpdHlKb2JzID0gW107XG5cbiAgICAvLyBJbiBjYXNlIHNvbWUgam9icyBhcmUgYWRkZWQgcmlnaHQgYWZ0ZXIgdGhlIGtpbGw6XG4gICAgX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgam9iIHdpdGggdGhlIHNwZWNpZmllZCBpZCBpcyBjdXJyZW50bHkgcnVubmluZyBvclxuICAgKiB3YWl0aW5nLCBhbmQgZmFsc2UgZWxzZS5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgaWQgVGhlIGlkIG9mIHRoZSBqb2IuXG4gICAqIEByZXR1cm4gez9PYmplY3R9IFJldHVybnMgdGhlIGpvYiBvYmplY3QgaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gX2hhc0pvYihpZCkge1xuICAgIHZhciBqb2IgPSBfam9ic1tpZF0gfHwgX3J1bm5pbmdKb2JzW2lkXSB8fCBfd2FpdGluZ0pvYnNbaWRdO1xuICAgIHJldHVybiBqb2IgPyBfX2V4dGVuZChqb2IpIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB0aGUgc2V0dGluZyBzcGVjaWZpZWQgYnkgXCJ2MVwiIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICogYnkgXCJ2MlwiIGlmIGJvdGggYXJlIGdpdmVuLCBhbmQgZWxzZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlXG4gICAqIHNldHRpbmdzIFwidjFcIi5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIHYxIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtICB7Pyp9ICAgICAgIHYyIEV2ZW50dWFsbHksIGEgdmFsdWUgdG8gc2V0IHRvIHRoZSBzcGVjaWZpZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtPYmplY3R8Kn0gUmV0dXJucyB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIHZhbHVlIGlmIFwidjJcIiBpcyBub3RcbiAgICogICAgICAgICAgICAgICAgICAgIGdpdmVuLCBhbmQgY29ucmFkIGVsc2UuXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0dGluZ3ModjEsIHYyKSB7XG4gICAgdmFyIG87XG5cbiAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIF9wYXJhbWV0ZXJzW2ExXTtcbiAgICBlbHNlIHtcbiAgICAgIG8gPSAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSA/XG4gICAgICAgIGExIHx8IHt9IDpcbiAgICAgICAge307XG4gICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgb1thMV0gPSBhMjtcblxuICAgICAgZm9yICh2YXIgayBpbiBvKVxuICAgICAgICBpZiAob1trXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9wYXJhbWV0ZXJzW2tdID0gb1trXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRlbGV0ZSBfcGFyYW1ldGVyc1trXTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb25yYWQgaXMgY3VycmVudGx5IHJ1bm5pbmcsIGFuZCBmYWxzZSBlbHNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIF9pc1J1bm5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0SXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBfaXNSdW5uaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVmZXJlbmNlIGV2ZXJ5IGpvYiB0aGF0IGlzIHN0b3JlZCBpbiB0aGUgX2RvbmVKb2JzIG9iamVjdC4gSXQgd2lsbFxuICAgKiBub3QgYmUgcG9zc2libGUgYW55bW9yZSB0byBnZXQgc3RhdHMgYWJvdXQgdGhlc2Ugam9icywgYnV0IGl0IHdpbGwgcmVsZWFzZVxuICAgKiB0aGUgbWVtb3J5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgY29ucmFkLlxuICAgKi9cbiAgZnVuY3Rpb24gX2NsZWFySGlzdG9yeSgpIHtcbiAgICBfZG9uZUpvYnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgZXZlcnkgZGF0YSBhYm91dCBqb2JzIHRoYXQgd2FpdCB0byBiZSBzdGFydGVkLCBhcmVcbiAgICogY3VycmVudGx5IHJ1bm5pbmcgb3IgYXJlIGRvbmUuXG4gICAqXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIGdldCBvbmx5IHJ1bm5pbmcsIHdhaXRpbmcgb3IgZG9uZSBqb2JzIGJ5IGdpdmluZ1xuICAgKiBcInJ1bm5pbmdcIiwgXCJ3YWl0aW5nXCIgb3IgXCJkb25lXCIgYXMgZmlzdCBhcmd1bWVudC5cbiAgICpcbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBnZXQgZXZlcnkgam9iIHdpdGggYSBzcGVjaWZpZWQgaWQgYnkgZ2l2aW5nIGl0IGFzXG4gICAqIGZpcnN0IGFyZ3VtZW50LiBBbHNvLCB1c2luZyBhIFJlZ0V4cCBpbnN0ZWFkIG9mIGFuIGlkIHdpbGwgcmV0dXJuIGV2ZXJ5XG4gICAqIGpvYnMgd2hvc2UgaWRzIG1hdGNoIHRoZSBSZWdFeHAuIEFuZCB0aGVzZSB0d28gbGFzdCB1c2UgY2FzZXMgd29yayBhcyB3ZWxsXG4gICAqIGJ5IGdpdmluZyBiZWZvcmUgXCJydW5uaW5nXCIsIFwid2FpdGluZ1wiIG9yIFwiZG9uZVwiLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGFycmF5IG9mIHRoZSBtYXRjaGluZyBqb2JzLlxuICAgKlxuICAgKiBTb21lIGNhbGwgZXhhbXBsZXM6XG4gICAqICoqKioqKioqKioqKioqKioqKipcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdydW5uaW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCd3YWl0aW5nJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdkb25lJylcbiAgICogID4gY29ucmFkLmdldFN0YXRzKCdteUpvYicpXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygvdGVzdC8pXG4gICAqICA+IGNvbnJhZC5nZXRTdGF0cygncnVubmluZycsICdteVJ1bm5pbmdKb2InKVxuICAgKiAgPiBjb25yYWQuZ2V0U3RhdHMoJ3J1bm5pbmcnLCAvdGVzdC8pXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U3RhdHModjEsIHYyKSB7XG4gICAgdmFyIGEsXG4gICAgICAgIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBpc1BhdHRlcm5TdHJpbmc7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHN0YXRzID0gW107XG5cbiAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgc3RhdHMucHVzaChfam9ic1trXSk7XG5cbiAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgIHN0YXRzLnB1c2goX3dhaXRpbmdKb2JzW2tdKTtcblxuICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgc3RhdHMucHVzaChfcnVubmluZ0pvYnNba10pO1xuXG4gICAgICBzdGF0cyA9IHN0YXRzLmNvbmNhdChfZG9uZUpvYnMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdjEgPT09ICdzdHJpbmcnKVxuICAgICAgc3dpdGNoICh2MSkge1xuICAgICAgICBjYXNlICd3YWl0aW5nJzpcbiAgICAgICAgICBzdGF0cyA9IF9fb2JqZWN0VmFsdWVzKF93YWl0aW5nSm9icyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bm5pbmcnOlxuICAgICAgICAgIHN0YXRzID0gX19vYmplY3RWYWx1ZXMoX3J1bm5pbmdKb2JzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgc3RhdHMgPSBfZG9uZUpvYnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGF0dGVybiA9IHYxO1xuICAgICAgfVxuXG4gICAgaWYgKHYxIGluc3RhbmNlb2YgUmVnRXhwKVxuICAgICAgcGF0dGVybiA9IHYxO1xuXG4gICAgaWYgKCFwYXR0ZXJuICYmICh0eXBlb2YgdjIgPT09ICdzdHJpbmcnIHx8IHYyIGluc3RhbmNlb2YgUmVnRXhwKSlcbiAgICAgIHBhdHRlcm4gPSB2MjtcblxuICAgIC8vIEZpbHRlciBqb2JzIGlmIGEgcGF0dGVybiBpcyBnaXZlbjpcbiAgICBpZiAocGF0dGVybikge1xuICAgICAgaXNQYXR0ZXJuU3RyaW5nID0gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoc3RhdHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhID0gc3RhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGF0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBzdGF0cylcbiAgICAgICAgICBhID0gYS5jb25jYXQoc3RhdHNba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBfam9icylcbiAgICAgICAgICBhLnB1c2goX2pvYnNba10pO1xuXG4gICAgICAgIGZvciAoayBpbiBfd2FpdGluZ0pvYnMpXG4gICAgICAgICAgYS5wdXNoKF93YWl0aW5nSm9ic1trXSk7XG5cbiAgICAgICAgZm9yIChrIGluIF9ydW5uaW5nSm9icylcbiAgICAgICAgICBhLnB1c2goX3J1bm5pbmdKb2JzW2tdKTtcblxuICAgICAgICBhID0gYS5jb25jYXQoX2RvbmVKb2JzKTtcbiAgICAgIH1cblxuICAgICAgc3RhdHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKGlzUGF0dGVyblN0cmluZyA/IGFbaV0uaWQgPT09IHBhdHRlcm4gOiBhW2ldLmlkLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICAgIHN0YXRzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9fY2xvbmUoc3RhdHMpO1xuICB9XG5cblxuICAvKipcbiAgICogVE9PTFMgRlVOQ1RJT05TOlxuICAgKiAqKioqKioqKioqKioqKioqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFueSBudW1iZXIgb2Ygb2JqZWN0cyBhcyBhcmd1bWVudHMsIGNvcGllcyBmcm9tIGVhY2hcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBlYWNoIHBhaXIga2V5L3ZhbHVlIGludG8gYSBuZXcgb2JqZWN0LCBhbmQgZmluYWxseVxuICAgKiByZXR1cm5zIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgYXJndW1lbnRzIGFyZSBwYXJzZWQgZnJvbSB0aGUgbGFzdCBvbmUgdG8gdGhlIGZpcnN0IG9uZSwgc3VjaCB0aGF0XG4gICAqIHdoZW4gdHdvIG9iamVjdHMgaGF2ZSBrZXlzIGluIGNvbW1vbiwgdGhlIFwiZWFybGllc3RcIiBvYmplY3Qgd2lucy5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogKioqKioqKipcbiAgICogID4gdmFyIG8xID0ge1xuICAgKiAgPiAgICAgICBhOiAxLFxuICAgKiAgPiAgICAgICBiOiAyLFxuICAgKiAgPiAgICAgICBjOiAnMydcbiAgICogID4gICAgIH0sXG4gICAqICA+ICAgICBvMiA9IHtcbiAgICogID4gICAgICAgYzogJzQnLFxuICAgKiAgPiAgICAgICBkOiBbIDUgXVxuICAgKiAgPiAgICAgfTtcbiAgICogID4gX19leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNsb25lcyBhbiBvYmplY3QuIFRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBvbmx5XG4gICAqIG9iamVjdHMsIGFycmF5cyBhbmQgaW1tdXRhYmxlIHZhbHVlcy4gU2luY2UgaXQgaXMgbm90IHB1YmxpYywgaXQgZG9lcyBub3RcbiAgICogZGVhbCB3aXRoIGN5Y2xpYyByZWZlcmVuY2VzLCBET00gZWxlbWVudHMgYW5kIGluc3RhbnRpYXRlZCBvYmplY3RzIC0gc29cbiAgICogdXNlIGl0IGNhcmVmdWxseS5cbiAgICpcbiAgICogQHBhcmFtICB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9fY2xvbmUoaXRlbSkge1xuICAgIHZhciByZXN1bHQsIGksIGssIGw7XG5cbiAgICBpZiAoIWl0ZW0pXG4gICAgICByZXR1cm4gaXRlbTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBpdGVtLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goX19jbG9uZShpdGVtW2ldKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChpIGluIGl0ZW0pXG4gICAgICAgIHJlc3VsdFtpXSA9IF9fY2xvbmUoaXRlbVtpXSk7XG4gICAgfSBlbHNlXG4gICAgICByZXN1bHQgPSBpdGVtO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gVGhlIG9iamVjdC5cbiAgICogQHJldHVybiB7QXJyYXl9ICBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gX19vYmplY3RWYWx1ZXMobykge1xuICAgIHZhciBrLFxuICAgICAgICBhID0gW107XG5cbiAgICBmb3IgKGsgaW4gbylcbiAgICAgIGEucHVzaChvW2tdKTtcblxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgXCJEYXRlLm5vdygpXCIgcG9seWZpbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gVGhlIGN1cnJlbnQgdGltZSAoaW4gbXMpLlxuICAgKi9cbiAgZnVuY3Rpb24gX19kYXRlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5ZmlsbCBmb3IgdGhlIEFycmF5LmlzQXJyYXkgZnVuY3Rpb246XG4gICAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkpXG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQgUFVCTElDIEFQSTpcbiAgICogKioqKioqKioqKioqKioqKioqXG4gICAqL1xuICB2YXIgY29ucmFkID0ge1xuICAgIGhhc0pvYjogX2hhc0pvYixcbiAgICBhZGRKb2I6IF9hZGRKb2IsXG4gICAga2lsbEpvYjogX2tpbGxKb2IsXG4gICAga2lsbEFsbDogX2tpbGxBbGwsXG4gICAgc2V0dGluZ3M6IF9zZXR0aW5ncyxcbiAgICBnZXRTdGF0czogX2dldFN0YXRzLFxuICAgIGlzUnVubmluZzogX2dldElzUnVubmluZyxcbiAgICBjbGVhckhpc3Rvcnk6IF9jbGVhckhpc3RvcnksXG5cbiAgICAvLyBFdmVudHMgbWFuYWdlbWVudDpcbiAgICBiaW5kOiBfYmluZCxcbiAgICB1bmJpbmQ6IF91bmJpbmQsXG5cbiAgICAvLyBWZXJzaW9uOlxuICAgIHZlcnNpb246ICcwLjEuMCdcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29ucmFkO1xuICAgIGV4cG9ydHMuY29ucmFkID0gY29ucmFkO1xuICB9XG4gIGdsb2JhbC5jb25yYWQgPSBjb25yYWQ7XG59KSh0aGlzKTtcblxuLy8gSGFyZGNvZGVkIGV4cG9ydCBmb3IgdGhlIG5vZGUuanMgdmVyc2lvbjpcbnZhciBzaWdtYSA9IHRoaXMuc2lnbWEsXG4gICAgY29ucmFkID0gdGhpcy5jb25yYWQ7XG5cbnNpZ21hLmNvbnJhZCA9IGNvbnJhZDtcblxuLy8gRGlydHkgcG9seWZpbGxzIHRvIHBlcm1pdCBzaWdtYSB1c2FnZSBpbiBub2RlXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJylcbiAgSFRNTEVsZW1lbnQgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gIHdpbmRvdyA9IHtcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG4gIH07XG5cbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHNpZ21hO1xuICBleHBvcnRzLnNpZ21hID0gc2lnbWE7XG59XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICB2YXIgX3Jvb3QgPSB0aGlzO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzID0gc2lnbWEudXRpbHMgfHwge307XG5cbiAgLyoqXG4gICAqIE1JU0MgVVRJTFM6XG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbnkgbnVtYmVyIG9mIG9iamVjdHMgYXMgYXJndW1lbnRzLCBjb3BpZXMgZnJvbSBlYWNoXG4gICAqIG9mIHRoZXNlIG9iamVjdHMgZWFjaCBwYWlyIGtleS92YWx1ZSBpbnRvIGEgbmV3IG9iamVjdCwgYW5kIGZpbmFsbHlcbiAgICogcmV0dXJucyB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGFyZ3VtZW50cyBhcmUgcGFyc2VkIGZyb20gdGhlIGxhc3Qgb25lIHRvIHRoZSBmaXJzdCBvbmUsIHN1Y2ggdGhhdFxuICAgKiB3aGVuIHNldmVyYWwgb2JqZWN0cyBoYXZlIGtleXMgaW4gY29tbW9uLCB0aGUgXCJlYXJsaWVzdFwiIG9iamVjdCB3aW5zLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiAqKioqKioqKlxuICAgKiAgPiB2YXIgbzEgPSB7XG4gICAqICA+ICAgICAgIGE6IDEsXG4gICAqICA+ICAgICAgIGI6IDIsXG4gICAqICA+ICAgICAgIGM6ICczJ1xuICAgKiAgPiAgICAgfSxcbiAgICogID4gICAgIG8yID0ge1xuICAgKiAgPiAgICAgICBjOiAnNCcsXG4gICAqICA+ICAgICAgIGQ6IFsgNSBdXG4gICAqICA+ICAgICB9O1xuICAgKiAgPiBzaWdtYS51dGlscy5leHRlbmQobzEsIG8yKTtcbiAgICogID4gLy8gUmV0dXJuczoge1xuICAgKiAgPiAvLyAgIGE6IDEsXG4gICAqICA+IC8vICAgYjogMixcbiAgICogID4gLy8gICBjOiAnMycsXG4gICAqICA+IC8vICAgZDogWyA1IF1cbiAgICogID4gLy8gfTtcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0K30gQW55IG51bWJlciBvZiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICBUaGUgbWVyZ2VkIG9iamVjdC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBrLFxuICAgICAgICByZXMgPSB7fSxcbiAgICAgICAgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBmb3IgKGsgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICByZXNba10gPSBhcmd1bWVudHNbaV1ba107XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHNob3J0IFwiRGF0ZS5ub3coKVwiIHBvbHlmaWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjdXJyZW50IHRpbWUgKGluIG1zKS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRhdGVOb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgcGFja2FnZSBuYW1lIGFzIHBhcmFtZXRlciBhbmQgY2hlY2tzIGF0IGVhY2ggbGViZWwgaWYgaXQgZXhpc3RzLFxuICAgKiBhbmQgaWYgaXQgZG9lcyBub3QsIGNyZWF0ZXMgaXQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLnBrZygnYS5iLmMnKTtcbiAgICogID4gYS5iLmM7XG4gICAqICA+IC8vIE9iamVjdCB7fTtcbiAgICogID5cbiAgICogID4gc2lnbWEudXRpbHMucGtnKCdhLmIuZCcpO1xuICAgKiAgPiBhLmI7XG4gICAqICA+IC8vIE9iamVjdCB7IGM6IHt9LCBkOiB7fSB9O1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBrZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHBhY2thZ2UgdG8gY3JlYXRlL2ZpbmQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcmVsYXRlZCBwYWNrYWdlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnID0gZnVuY3Rpb24ocGtnTmFtZSkge1xuICAgIHJldHVybiAocGtnTmFtZSB8fCAnJykuc3BsaXQoJy4nKS5yZWR1Y2UoZnVuY3Rpb24oY29udGV4dCwgb2JqTmFtZSkge1xuICAgICAgcmV0dXJuIChvYmpOYW1lIGluIGNvbnRleHQpID9cbiAgICAgICAgY29udGV4dFtvYmpOYW1lXSA6XG4gICAgICAgIChjb250ZXh0W29iak5hbWVdID0ge30pO1xuICAgIH0sIF9yb290KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBpbmNyZW1lbnRhbCBudW1iZXIgSUQuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqICoqKioqKioqXG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDE7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDI7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLnV0aWxzLmlkKCk7XG4gICAqICA+IC8vIDM7XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcGtnTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFja2FnZSB0byBjcmVhdGUvZmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSByZWxhdGVkIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5pZCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICsraTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGhleGEgY29sb3IgKGZvciBpbnN0YW5jZSBcIiNmZmNjMDBcIiBvciBcIiNmYzBcIikgb3IgYVxuICAgKiByZ2IgLyByZ2JhIGNvbG9yIChsaWtlIFwicmdiKDI1NSwyNTUsMTIpXCIgb3IgXCJyZ2JhKDI1NSwyNTUsMTIsMSlcIikgYW5kXG4gICAqIHJldHVybnMgYW4gaW50ZWdlciBlcXVhbCB0byBcInIgKiAyNTUgKiAyNTUgKyBnICogMjU1ICsgYlwiLCB0byBnYWluIHNvbWVcbiAgICogbWVtb3J5IGluIHRoZSBkYXRhIGdpdmVuIHRvIFdlYkdMIHNoYWRlcnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgY2FjaGVzIGl0cyByZXN1bHRzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsIFRoZSBoZXhhIG9yIHJnYmEgY29sb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBudW1iZXIgdmFsdWUuXG4gICAqL1xuICB2YXIgZmxvYXRDb2xvckNhY2hlID0ge307XG5cbiAgc2lnbWEudXRpbHMuZmxvYXRDb2xvciA9IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgLy8gSXMgdGhlIGNvbG9yIGFscmVhZHkgY29tcHV0ZWQ/XG4gICAgaWYgKGZsb2F0Q29sb3JDYWNoZVt2YWxdKVxuICAgICAgcmV0dXJuIGZsb2F0Q29sb3JDYWNoZVt2YWxdO1xuXG4gICAgdmFyIG9yaWdpbmFsID0gdmFsLFxuICAgICAgICByID0gMCxcbiAgICAgICAgZyA9IDAsXG4gICAgICAgIGIgPSAwO1xuXG4gICAgaWYgKHZhbFswXSA9PT0gJyMnKSB7XG4gICAgICB2YWwgPSB2YWwuc2xpY2UoMSk7XG5cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpO1xuICAgICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNik7XG4gICAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgzKSwgMTYpO1xuICAgICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg0KSArIHZhbC5jaGFyQXQoNSksIDE2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbC5tYXRjaCgvXiAqcmdiYT8gKlxcKC8pKSB7XG4gICAgICB2YWwgPSB2YWwubWF0Y2goXG4gICAgICAgIC9eICpyZ2JhPyAqXFwoICooWzAtOV0qKSAqLCAqKFswLTldKikgKiwgKihbMC05XSopICooLC4qKT9cXCkgKiQvXG4gICAgICApO1xuICAgICAgciA9ICt2YWxbMV07XG4gICAgICBnID0gK3ZhbFsyXTtcbiAgICAgIGIgPSArdmFsWzNdO1xuICAgIH1cblxuICAgIHZhciBjb2xvciA9IChcbiAgICAgIHIgKiAyNTYgKiAyNTYgK1xuICAgICAgZyAqIDI1NiArXG4gICAgICBiXG4gICAgKTtcblxuICAgIC8vIENhY2hpbmcgdGhlIGNvbG9yXG4gICAgZmxvYXRDb2xvckNhY2hlW29yaWdpbmFsXSA9IGNvbG9yO1xuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9O1xuXG4gICAgLyoqXG4gICAqIFBlcmZvcm0gYSB6b29tIGludG8gYSBjYW1lcmEsIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24sIHRvIHRoZVxuICAgKiBjb29yZGluYXRlcyBpbmRpY2F0ZWQgdXNpbmcgYSBzcGVjaWZpZWQgcmF0aW8uXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgYW5pbWF0aW9uXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7P251bWJlcn0gZHVyYXRpb24gICAgIEFuIGFtb3VudCBvZiB0aW1lIHRoYXQgbWVhbnMgdGhlIGR1cmF0aW9uIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLiBJZiB0aGlzIHBhcmFtZXRlciBkb2Vzbid0IGV4aXN0IHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbSB3aWxsIGJlIHBlcmZvcm1lZCB3aXRob3V0IGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSBvbkNvbXBsZXRlIEEgZnVuY3Rpb24gdG8gcGVyZm9ybSBpdCBhZnRlciB0aGUgYW5pbWF0aW9uLiBJdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBwZXJmb3JtZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtjYW1lcmF9ICAgICBUaGUgY2FtZXJhIHdoZXJlIHBlcmZvcm0gdGhlIHpvb20uXG4gICAqIEBwYXJhbSB7eH0gICAgICAgICAgVGhlIFggY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7eX0gICAgICAgICAgVGhlIFkgY29vcmRpYW50aW9uIHdoZXJlIHRoZSB6b29tIGdvZXMuXG4gICAqIEBwYXJhbSB7cmF0aW99ICAgICAgVGhlIHJhdGlvIHRvIGFwcGx5IGl0IHRvIHRoZSBjdXJyZW50IGNhbWVyYSByYXRpby5cbiAgICogQHBhcmFtIHs/YW5pbWF0aW9ufSBBIGRpY3Rpb25hcnkgd2l0aCBvcHRpb25zIGZvciBhIHBvc3NpYmxlIGFuaW1hdGlvbi5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnpvb21UbyA9IGZ1bmN0aW9uKGNhbWVyYSwgeCwgeSwgcmF0aW8sIGFuaW1hdGlvbikge1xuICAgIHZhciBzZXR0aW5ncyA9IGNhbWVyYS5zZXR0aW5ncyxcbiAgICAgICAgY291bnQsXG4gICAgICAgIG5ld1JhdGlvLFxuICAgICAgICBhbmltYXRpb25TZXR0aW5ncyxcbiAgICAgICAgY29vcmRpbmF0ZXM7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG5ld1JhdGlvIGRlYWxpbmcgd2l0aCBtaW4gLyBtYXg6XG4gICAgbmV3UmF0aW8gPSBNYXRoLm1heChcbiAgICAgIHNldHRpbmdzKCd6b29tTWluJyksXG4gICAgICBNYXRoLm1pbihcbiAgICAgICAgc2V0dGluZ3MoJ3pvb21NYXgnKSxcbiAgICAgICAgY2FtZXJhLnJhdGlvICogcmF0aW9cbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgbmV3IHJhdGlvIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBpbml0aWFsIG9uZTpcbiAgICBpZiAobmV3UmF0aW8gIT09IGNhbWVyYS5yYXRpbykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBjb29yZGluYXRlcyB2YXJpYWJsZTpcbiAgICAgIHJhdGlvID0gbmV3UmF0aW8gLyBjYW1lcmEucmF0aW87XG4gICAgICBjb29yZGluYXRlcyA9IHtcbiAgICAgICAgeDogeCAqICgxIC0gcmF0aW8pICsgY2FtZXJhLngsXG4gICAgICAgIHk6IHkgKiAoMSAtIHJhdGlvKSArIGNhbWVyYS55LFxuICAgICAgICByYXRpbzogbmV3UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSBhbmltYXRpb24gc2V0aW5nczpcbiAgICAgICAgY291bnQgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsQWxsKGNhbWVyYSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IHNpZ21hLnV0aWxzLmV4dGVuZChcbiAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWFzaW5nOiBjb3VudCA/ICdxdWFkcmF0aWNPdXQnIDogJ3F1YWRyYXRpY0luT3V0J1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoY2FtZXJhLCBjb29yZGluYXRlcywgYW5pbWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWVyYS5nb1RvKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24ub25Db21wbGV0ZSlcbiAgICAgICAgICBhbmltYXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHN0YXJ0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzdGFydCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge3gseX0gICAgICAgIFRoZSBjb250cm9sIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHgxICsgeDIpIC8gMiArICh5MiAtIHkxKSAvIDQsXG4gICAgICB5OiAoeTEgKyB5MikgLyAyICsgKHgxIC0geDIpIC8gNFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDb21wdXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQgcG9zaXRpb25lZFxuICAgICogYXQgbGVuZ3RoIHQgaW4gdGhlIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB0ICBJbiBbMCwxXSB0aGUgc3RlcCBwZXJjZW50YWdlIHRvIHJlYWNoXG4gICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBwb2ludCBpbiB0aGUgY3VydmUgZnJvbSB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udGV4dCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgZW5kaW5nIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBlbmRpbmcgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhpIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlpIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbih0LCB4MSwgeTEsIHgyLCB5MiwgeGksIHlpKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTYzNDUyOFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLnBvdygxIC0gdCwgMikgKiB4MSArIDIgKiAoMSAtIHQpICogdCAqIHhpICsgTWF0aC5wb3codCwgMikgKiB4MixcbiAgICAgIHk6IE1hdGgucG93KDEgLSB0LCAyKSAqIHkxICsgMiAqICgxIC0gdCkgKiB0ICogeWkgKyBNYXRoLnBvdyh0LCAyKSAqIHkyXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICAqIENvbXB1dGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBwb3NpdGlvbmVkXG4gICAgKiBhdCBsZW5ndGggdCBpbiB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW4gWzAsMV0gdGhlIHN0ZXAgcGVyY2VudGFnZSB0byByZWFjaFxuICAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9pbnQgaW4gdGhlIGN1cnZlIGZyb20gdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRleHQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjeSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIHt4LHl9IFRoZSBwb2ludCBhdCB0LlxuICAqL1xuICBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUgPVxuICAgIGZ1bmN0aW9uKHQsIHgxLCB5MSwgeDIsIHkyLCBjeCwgY3ksIGR4LCBkeSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1Mzk3NTk2XG4gICAgLy8gQmxlbmRpbmcgZnVuY3Rpb25zOlxuICAgIHZhciBCMF90ID0gTWF0aC5wb3coMSAtIHQsIDMpLFxuICAgICAgICBCMV90ID0gMyAqIHQgKiBNYXRoLnBvdygxIC0gdCwgMiksXG4gICAgICAgIEIyX3QgPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpLFxuICAgICAgICBCM190ID0gTWF0aC5wb3codCwgMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogKEIwX3QgKiB4MSkgKyAoQjFfdCAqIGN4KSArIChCMl90ICogZHgpICsgKEIzX3QgKiB4MiksXG4gICAgICB5OiAoQjBfdCAqIHkxKSArIChCMV90ICogY3kpICsgKEIyX3QgKiBkeSkgKyAoQjNfdCAqIHkyKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cyBmb3IgYSBzZWxmIGxvb3AgKGkuZS5cbiAgICogd2hlcmUgdGhlIHN0YXJ0IHBvaW50IGlzIGFsc28gdGhlIGVuZCBwb2ludCkgY29tcHV0ZWQgYXMgYSBjdWJpYyBiZXppZXJcbiAgICogY3VydmUuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbm9kZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBzaXplIFRoZSBub2RlIHNpemUuXG4gICAqIEByZXR1cm4ge3gxLHkxLHgyLHkyfSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjb250cm9sIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFNlbGZMb29wQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKHggLCB5LCBzaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4IC0gc2l6ZSAqIDcsXG4gICAgICB5MTogeSxcbiAgICAgIHgyOiB4LFxuICAgICAgeTI6IHkgKyBzaXplICogN1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBvZiBhIHBsYW5lXG4gICAqIHdpdGggYW4gb3J0aG9ub3JtYWwgYmFzaXMuXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDEgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSBldWNsaWRpYW4gZGlzdGFuY2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgwLCAyKSArIE1hdGgucG93KHkxIC0geTAsIDIpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiB0d28gY2lyY2xlcy5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MCAgVGhlIFggY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MCAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIGZpcnN0XG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSByMCAgVGhlIHJhZGl1cyBvZiB0aGUgZmlyc3QgY2lyY2xlLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxICBUaGUgWCBjb29yZGluYXRlIG9mIGNlbnRlciBsb2NhdGlvbiBvZiB0aGUgc2Vjb25kXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgVGhlIFkgY29vcmRpbmF0ZSBvZiBjZW50ZXIgbG9jYXRpb24gb2YgdGhlIHNlY29uZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuXG4gICAqIEBwYXJhbSAge251bWJlcn0gcjEgIFRoZSByYWRpdXMgb2YgdGhlIHNlY29uZCBjaXJjbGUuXG4gICAqIEByZXR1cm4ge3hpLHlpfSAgICAgIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldENpcmNsZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjIxOTgwMlxuICAgIHZhciBhLCBkeCwgZHksIGQsIGgsIHJ4LCByeSwgeDIsIHkyO1xuXG4gICAgLy8gZHggYW5kIGR5IGFyZSB0aGUgdmVydGljYWwgYW5kIGhvcml6b250YWwgZGlzdGFuY2VzIGJldHdlZW4gdGhlIGNpcmNsZVxuICAgIC8vIGNlbnRlcnM6XG4gICAgZHggPSB4MSAtIHgwO1xuICAgIGR5ID0geTEgLSB5MDtcblxuICAgIC8vIERldGVybWluZSB0aGUgc3RyYWlnaHQtbGluZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjZW50ZXJzOlxuICAgIGQgPSBNYXRoLnNxcnQoKGR5ICogZHkpICsgKGR4ICogZHgpKTtcblxuICAgIC8vIENoZWNrIGZvciBzb2x2YWJpbGl0eTpcbiAgICBpZiAoZCA+IChyMCArIHIxKSkge1xuICAgICAgICAvLyBObyBzb2x1dGlvbi4gY2lyY2xlcyBkbyBub3QgaW50ZXJzZWN0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkIDwgTWF0aC5hYnMocjAgLSByMSkpIHtcbiAgICAgICAgLy8gTm8gc29sdXRpb24uIG9uZSBjaXJjbGUgaXMgY29udGFpbmVkIGluIHRoZSBvdGhlci5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vJ3BvaW50IDInIGlzIHRoZSBwb2ludCB3aGVyZSB0aGUgbGluZSB0aHJvdWdoIHRoZSBjaXJjbGUgaW50ZXJzZWN0aW9uXG4gICAgLy8gcG9pbnRzIGNyb3NzZXMgdGhlIGxpbmUgYmV0d2VlbiB0aGUgY2lyY2xlIGNlbnRlcnMuXG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGZyb20gcG9pbnQgMCB0byBwb2ludCAyOlxuICAgIGEgPSAoKHIwICogcjApIC0gKHIxICogcjEpICsgKGQgKiBkKSkgLyAoMi4wICogZCk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNvb3JkaW5hdGVzIG9mIHBvaW50IDI6XG4gICAgeDIgPSB4MCArIChkeCAqIGEgLyBkKTtcbiAgICB5MiA9IHkwICsgKGR5ICogYSAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBmcm9tIHBvaW50IDIgdG8gZWl0aGVyIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAvLyBwb2ludHM6XG4gICAgaCA9IE1hdGguc3FydCgocjAgKiByMCkgLSAoYSAqIGEpKTtcblxuICAgIC8vIERldGVybWluZSB0aGUgb2Zmc2V0cyBvZiB0aGUgaW50ZXJzZWN0aW9uIHBvaW50cyBmcm9tIHBvaW50IDI6XG4gICAgcnggPSAtZHkgKiAoaCAvIGQpO1xuICAgIHJ5ID0gZHggKiAoaCAvIGQpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhYnNvbHV0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzOlxuICAgIHZhciB4aSA9IHgyICsgcng7XG4gICAgdmFyIHhpX3ByaW1lID0geDIgLSByeDtcbiAgICB2YXIgeWkgPSB5MiArIHJ5O1xuICAgIHZhciB5aV9wcmltZSA9IHkyIC0gcnk7XG5cbiAgICByZXR1cm4ge3hpOiB4aSwgeGlfcHJpbWU6IHhpX3ByaW1lLCB5aTogeWksIHlpX3ByaW1lOiB5aV9wcmltZX07XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgbGluZSBzZWdtZW50LlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBsaW5lIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGxpbmUgc3RhcnQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyICAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgbGluZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGVwc2lsb24gVGhlIHByZWNpc2lvbiAoY29uc2lkZXIgdGhlIGxpbmUgdGhpY2tuZXNzKS5cbiAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICBUcnVlIGlmIHBvaW50IGlzIFwiY2xvc2UgdG9cIiB0aGUgbGluZVxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKi9cbiAgc2lnbWEudXRpbHMuaXNQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uKHgsIHksIHgxLCB5MSwgeDIsIHkyLCBlcHNpbG9uKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI4MTIyXG4gICAgdmFyIGNyb3NzUHJvZHVjdCA9IE1hdGguYWJzKCh5IC0geTEpICogKHgyIC0geDEpIC0gKHggLSB4MSkgKiAoeTIgLSB5MSkpLFxuICAgICAgICBkID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpLFxuICAgICAgICBuQ3Jvc3NQcm9kdWN0ID0gY3Jvc3NQcm9kdWN0IC8gZDsgLy8gbm9ybWFsaXplZCBjcm9zcyBwcm9kdWN0XG5cbiAgICByZXR1cm4gKG5Dcm9zc1Byb2R1Y3QgPCBlcHNpbG9uICYmXG4gICAgIE1hdGgubWluKHgxLCB4MikgPD0geCAmJiB4IDw9IE1hdGgubWF4KHgxLCB4MikgJiZcbiAgICAgTWF0aC5taW4oeTEsIHkyKSA8PSB5ICYmIHkgPD0gTWF0aC5tYXgoeTEsIHkyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBzZWdtZW50IHdpdGggYSB0aGlja25lc3MuXG4gICAgKlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4ICAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5ICAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIGNoZWNrLlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB5MSAgICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIHN0YXJ0IHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSB4MiAgICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGVuZCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTIgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IGNweCAgICAgVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY29udHJvbCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0gY3B5ICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4LCBjcHksIGVwc2lsb24pIHtcbiAgICAvLyBGYWlscyBpZiB0aGUgcG9pbnQgaXMgdG9vIGZhciBmcm9tIHRoZSBleHRyZW1pdGllcyBvZiB0aGUgc2VnbWVudCxcbiAgICAvLyBwcmV2ZW50aW5nIGZvciBtb3JlIGNvc3RseSBjb21wdXRhdGlvbjpcbiAgICB2YXIgZFAxUDIgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgaWYgKE1hdGguYWJzKHggLSB4MSkgPiBkUDFQMiB8fCBNYXRoLmFicyh5IC0geTEpID4gZFAxUDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSksXG4gICAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSksXG4gICAgICAgIG9sZF9kdDtcblxuICAgIC8vIFRoaXMgYWxnb3JpdGhtIG1pbmltaXplcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGN1cnZlLiBJdFxuICAgIC8vIGZpbmQgdGhlIG9wdGltYWwgdCB2YWx1ZSB3aGVyZSB0PTAgaXMgdGhlIHN0YXJ0IHBvaW50IGFuZCB0PTEgaXMgdGhlIGVuZFxuICAgIC8vIHBvaW50IG9mIHRoZSBjdXJ2ZSwgc3RhcnRpbmcgZnJvbSB0PTAuNS5cbiAgICAvLyBJdCB0ZXJtaW5hdGVzIGJlY2F1c2UgaXQgcnVucyBhIG1heGltdW0gb2YgaSBpbnRlcmF0aW9ucy5cbiAgICB3aGlsZSAoaS0tID4gMCAmJlxuICAgICAgdCA+PSAwICYmIHQgPD0gMSAmJlxuICAgICAgKGR0ID4gZXBzaWxvbikgJiZcbiAgICAgIChyID4gclRocmVzaG9sZCB8fCByIDwgLXJUaHJlc2hvbGQpKSB7XG4gICAgICBvbGRfZHQgPSBkdDtcbiAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPblF1YWRyYXRpY0N1cnZlKHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgsIGNweSk7XG4gICAgICBkdCA9IHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKHgsIHksIHB0LngsIHB0LnkpO1xuXG4gICAgICBpZiAoZHQgPiBvbGRfZHQpIHtcbiAgICAgICAgLy8gbm90IHRoZSByaWdodCBkaXJlY3Rpb246XG4gICAgICAgIC8vIGhhbGZzdGVwIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgciA9IC1yIC8gMjtcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodCArIHIgPCAwIHx8IHQgKyByID4gMSkge1xuICAgICAgICAvLyBvb3BzLCB3ZSd2ZSBnb25lIHRvbyBmYXI6XG4gICAgICAgIC8vIHJldmVydCB3aXRoIGEgaGFsZnN0ZXBcbiAgICAgICAgciA9IHIgLyAyO1xuICAgICAgICBkdCA9IG9sZF9kdDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBwcm9ncmVzczpcbiAgICAgICAgdCArPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkdCA8IGVwc2lsb247XG4gIH07XG5cblxuICAvKipcbiAgICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgc2VnbWVudCB3aXRoIGEgdGhpY2tuZXNzLlxuICAgICpcbiAgICAqIEBwYXJhbSAge251bWJlcn0geCAgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geSAgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byBjaGVjay5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDEgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geTEgICAgICBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBzdGFydCBwb2ludC5cbiAgICAqIEBwYXJhbSAge251bWJlcn0geDIgICAgICBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjdXJ2ZSBlbmQgcG9pbnQuXG4gICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyICAgICAgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgZW5kIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgxICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkxICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDFzdCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHgyICAgIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBjcHkyICAgIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIDJuZCBjdXJ2ZSBjb250cm9sIHBvaW50LlxuICAgICogQHBhcmFtICB7bnVtYmVyfSBlcHNpbG9uIFRoZSBwcmVjaXNpb24gKGNvbnNpZGVyIHRoZSBsaW5lIHRoaWNrbmVzcykuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSAgICAgICAgVHJ1ZSBpZiAoeCx5KSBpcyBvbiB0aGUgY3VydmUgc2VnbWVudCxcbiAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBvdGhlcndpc2UuXG4gICovXG4gIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlID1cbiAgICBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgZXBzaWxvbikge1xuICAgIC8vIEZhaWxzIGlmIHRoZSBwb2ludCBpcyB0b28gZmFyIGZyb20gdGhlIGV4dHJlbWl0aWVzIG9mIHRoZSBzZWdtZW50LFxuICAgIC8vIHByZXZlbnRpbmcgZm9yIG1vcmUgY29zdGx5IGNvbXB1dGF0aW9uOlxuICAgIHZhciBkUDFDUDEgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4MSwgeTEsIGNweDEsIGNweTEpO1xuICAgIGlmIChNYXRoLmFicyh4IC0geDEpID4gZFAxQ1AxIHx8IE1hdGguYWJzKHkgLSB5MSkgPiBkUDFDUDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZFAxID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDEsIHkxKSxcbiAgICAgICAgZFAyID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgeDIsIHkyKSxcbiAgICAgICAgdCA9IDAuNSxcbiAgICAgICAgciA9IChkUDEgPCBkUDIpID8gLTAuMDEgOiAwLjAxLFxuICAgICAgICByVGhyZXNob2xkID0gMC4wMDEsXG4gICAgICAgIGkgPSAxMDAsXG4gICAgICAgIHB0ID0gc2lnbWEudXRpbHMuZ2V0UG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKSxcbiAgICAgICAgZHQgPSBzaWdtYS51dGlscy5nZXREaXN0YW5jZSh4LCB5LCBwdC54LCBwdC55KSxcbiAgICAgICAgb2xkX2R0O1xuXG4gICAgLy8gVGhpcyBhbGdvcml0aG0gbWluaW1pemVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgY3VydmUuIEl0XG4gICAgLy8gZmluZCB0aGUgb3B0aW1hbCB0IHZhbHVlIHdoZXJlIHQ9MCBpcyB0aGUgc3RhcnQgcG9pbnQgYW5kIHQ9MSBpcyB0aGUgZW5kXG4gICAgLy8gcG9pbnQgb2YgdGhlIGN1cnZlLCBzdGFydGluZyBmcm9tIHQ9MC41LlxuICAgIC8vIEl0IHRlcm1pbmF0ZXMgYmVjYXVzZSBpdCBydW5zIGEgbWF4aW11bSBvZiBpIGludGVyYXRpb25zLlxuICAgIHdoaWxlIChpLS0gPiAwICYmXG4gICAgICB0ID49IDAgJiYgdCA8PSAxICYmXG4gICAgICAoZHQgPiBlcHNpbG9uKSAmJlxuICAgICAgKHIgPiByVGhyZXNob2xkIHx8IHIgPCAtclRocmVzaG9sZCkpIHtcbiAgICAgIG9sZF9kdCA9IGR0O1xuICAgICAgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uQmV6aWVyQ3VydmUoXG4gICAgICAgIHQsIHgxLCB5MSwgeDIsIHkyLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyKTtcbiAgICAgIGR0ID0gc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoeCwgeSwgcHQueCwgcHQueSk7XG5cbiAgICAgIGlmIChkdCA+IG9sZF9kdCkge1xuICAgICAgICAvLyBub3QgdGhlIHJpZ2h0IGRpcmVjdGlvbjpcbiAgICAgICAgLy8gaGFsZnN0ZXAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICByID0gLXIgLyAyO1xuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0ICsgciA8IDAgfHwgdCArIHIgPiAxKSB7XG4gICAgICAgIC8vIG9vcHMsIHdlJ3ZlIGdvbmUgdG9vIGZhcjpcbiAgICAgICAgLy8gcmV2ZXJ0IHdpdGggYSBoYWxmc3RlcFxuICAgICAgICByID0gciAvIDI7XG4gICAgICAgIGR0ID0gb2xkX2R0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2dyZXNzOlxuICAgICAgICB0ICs9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGR0IDwgZXBzaWxvbjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiAqKioqKioqKioqKipcbiAgICogRVZFTlRTIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBIZXJlIGFyZSBzb21lIHVzZWZ1bCBmdW5jdGlvbnMgdG8gdW5pZnkgZXh0cmFjdGlvbiBvZiB0aGUgaW5mb3JtYXRpb24gd2VcbiAgICogbmVlZCB3aXRoIG1vdXNlIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLCBmcm9tIGRpZmZlcmVudCBicm93c2VyczpcbiAgICovXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIGxvY2FsIFggcG9zaXRpb24gZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSBsb2NhbCBYIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFggPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIChlLm9mZnNldFggIT09IHVuZGVmaW5lZCAmJiBlLm9mZnNldFgpIHx8XG4gICAgICAoZS5sYXllclggIT09IHVuZGVmaW5lZCAmJiBlLmxheWVyWCkgfHxcbiAgICAgIChlLmNsaWVudFggIT09IHVuZGVmaW5lZCAmJiBlLmNsaWVudFgpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgbG9jYWwgWSBwb3NpdGlvbiBmcm9tIGEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge2V2ZW50fSAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgVGhlIGxvY2FsIFkgdmFsdWUgb2YgdGhlIG1vdXNlLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0WSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUub2Zmc2V0WSAhPT0gdW5kZWZpbmVkICYmIGUub2Zmc2V0WSkgfHxcbiAgICAgIChlLmxheWVyWSAhPT0gdW5kZWZpbmVkICYmIGUubGF5ZXJZKSB8fFxuICAgICAgKGUuY2xpZW50WSAhPT0gdW5kZWZpbmVkICYmIGUuY2xpZW50WSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcGl4ZWwgcmF0aW8gb2YgdGhlIHNjcmVlbi4gVGFraW5nIHpvb20gaW50byBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFBpeGVsIHJhdGlvIG9mIHRoZSBzY3JlZW5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmF0aW8gPSAxO1xuICAgIGlmICh3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgPiB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSB7XG4gICAgICAgIHJhdGlvID0gd2luZG93LnNjcmVlbi5zeXN0ZW1YRFBJIC8gd2luZG93LnNjcmVlbi5sb2dpY2FsWERQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gcmF0aW87XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgdGhlIHdpZHRoIGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgd2lkdGggb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0V2lkdGggPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHcgPSAoIWUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCkgP1xuICAgICAgICAgICAgICBlLnRhcmdldC53aWR0aCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC53aWR0aDtcblxuICAgIHJldHVybiAoXG4gICAgICAodHlwZW9mIHcgPT09ICdudW1iZXInICYmIHcpIHx8XG4gICAgICAodyAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbCAhPT0gdW5kZWZpbmVkICYmIHcuYmFzZVZhbC52YWx1ZSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBjZW50ZXIgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgIFRoZSBjZW50ZXIgb2YgdGhlIGV2ZW50J3MgdGFyZ2V0LlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0Q2VudGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciByYXRpbyA9IGUudGFyZ2V0Lm5hbWVzcGFjZVVSSS5pbmRleE9mKCdzdmcnKSAhPT0gLTEgPyAxIDpcbiAgICAgICAgc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBzaWdtYS51dGlscy5nZXRXaWR0aChlKSAvICgyICogcmF0aW8pLFxuICAgICAgeTogc2lnbWEudXRpbHMuZ2V0SGVpZ2h0KGUpIC8gKDIgKiByYXRpbylcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHNcbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICAgZSBBIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKiBAcGFyYW0gIHtudW1iZXI/fSB4IFRoZSB4IGNvb3JkIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtICB7bnVtYmVyP30geCBUaGUgeSBjb29yZCB0byBjb252ZXJ0XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIHN0YW5kYXJkaXplZCBldmVudFxuICAgKi9cbiAgc2lnbWEudXRpbHMubW91c2VDb29yZHMgPSBmdW5jdGlvbihlLCB4LCB5KSB7XG4gICAgeCA9IHggfHwgc2lnbWEudXRpbHMuZ2V0WChlKTtcbiAgICB5ID0geSB8fCBzaWdtYS51dGlscy5nZXRZKGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgeTogeSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gICAgICAgIGFsdEtleTogZS5hbHRLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgaGVpZ2h0IGZyb20gYSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtICB7ZXZlbnR9ICBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICBUaGUgaGVpZ2h0IG9mIHRoZSBldmVudCdzIHRhcmdldC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmdldEhlaWdodCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaCA9ICghZS50YXJnZXQub3duZXJTVkdFbGVtZW50KSA/XG4gICAgICAgICAgICAgIGUudGFyZ2V0LmhlaWdodCA6XG4gICAgICAgICAgICAgIGUudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudC5oZWlnaHQ7XG5cbiAgICByZXR1cm4gKFxuICAgICAgKHR5cGVvZiBoID09PSAnbnVtYmVyJyAmJiBoKSB8fFxuICAgICAgKGggIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwgIT09IHVuZGVmaW5lZCAmJiBoLmJhc2VWYWwudmFsdWUpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRXh0cmFjdCB0aGUgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNlIG9yIHRvdWNoIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtldmVudH0gIGUgQSBtb3VzZSBvciB0b3VjaCBldmVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgIFRoZSB3aGVlbCBkZWx0YSBvZiB0aGUgbW91c2UuXG4gICAqL1xuICBzaWdtYS51dGlscy5nZXREZWx0YSA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKGUud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICYmIGUud2hlZWxEZWx0YSkgfHxcbiAgICAgIChlLmRldGFpbCAhPT0gdW5kZWZpbmVkICYmIC1lLmRldGFpbClcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tIFRoZSBlbGVtZW50IHRvIHJldHJpZXZlIHRoZSBwb3NpdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFRoZSBvZmZzZXQgb2YgdGhlIERPTSBlbGVtZW50ICh0b3AsIGxlZnQpLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24oZG9tKSB7XG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwO1xuXG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgdG9wID0gdG9wICsgcGFyc2VJbnQoZG9tLm9mZnNldFRvcCk7XG4gICAgICBsZWZ0ID0gbGVmdCArIHBhcnNlSW50KGRvbS5vZmZzZXRMZWZ0KTtcbiAgICAgIGRvbSA9IGRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdG9wLFxuICAgICAgbGVmdDogbGVmdFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIFwiZG91YmxlIGNsaWNrXCIgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0YXJnZXQgICBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgdHlwZSAgICAgVGhlIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBjbGlja3MgPSAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaGFuZGxlcnM7XG5cbiAgICB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciA9IHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9O1xuICAgIHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyW3R5cGVdID0gdGFyZ2V0Ll9kb3VibGVDbGlja0hhbmRsZXJbdHlwZV0gfHwgW107XG4gICAgaGFuZGxlcnMgPSB0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlclt0eXBlXTtcblxuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oZSkge1xuICAgICAgY2xpY2tzKys7XG5cbiAgICAgIGlmIChjbGlja3MgPT09IDIpIHtcbiAgICAgICAgY2xpY2tzID0gMDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgfSBlbHNlIGlmIChjbGlja3MgPT09IDEpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlja3MgPSAwO1xuICAgICAgICB9LCBzaWdtYS5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcnNbaGFuZGxlcnMubGVuZ3RoIC0gMV0sIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5iaW5kIHNpbXVsYXRlZCBcImRvdWJsZSBjbGlja1wiIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAgIFRoZSBldmVudCB0YXJnZXQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICB0eXBlICAgICBUaGUgZXZlbnQgdHlwZS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnVuYmluZERvdWJsZUNsaWNrID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlKSB7XG4gICAgdmFyIGhhbmRsZXIsXG4gICAgICAgIGhhbmRsZXJzID0gKHRhcmdldC5fZG91YmxlQ2xpY2tIYW5kbGVyIHx8IHt9KVt0eXBlXSB8fCBbXTtcblxuICAgIHdoaWxlICgoaGFuZGxlciA9IGhhbmRsZXJzLnBvcCgpKSkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgZGVsZXRlICh0YXJnZXQuX2RvdWJsZUNsaWNrSGFuZGxlciB8fCB7fSlbdHlwZV07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIEhlcmUgYXJlIGp1c3Qgc29tZSBvZiB0aGUgbW9zdCBiYXNpYyBlYXNpbmcgZnVuY3Rpb25zLCB1c2VkIGZvciB0aGVcbiAgICogYW5pbWF0ZWQgY2FtZXJhIFwiZ29Ub1wiIGNhbGxzLlxuICAgKlxuICAgKiBJZiB5b3UgbmVlZCBzb21lIG1vcmUgZWFzaW5ncyBmdW5jdGlvbnMsIGRvbid0IGhlc2l0YXRlIHRvIGFkZCB0aGVtIHRvXG4gICAqIHNpZ21hLnV0aWxzLmVhc2luZ3MuIEJ1dCBJIHdpbGwgbm90IGFkZCBzb21lIG1vcmUgaGVyZSBvciBtZXJnZSBQUnNcbiAgICogY29udGFpbmluZywgYmVjYXVzZSBJIGRvIG5vdCB3YW50IHNpZ21hIHNvdXJjZXMgZnVsbCBvZiBvdmVya2lsbCBhbmQgbmV2ZXJcbiAgICogdXNlZCBzdHVmZi4uLlxuICAgKi9cbiAgc2lnbWEudXRpbHMuZWFzaW5ncyA9IHNpZ21hLnV0aWxzLmVhc2luZ3MgfHwge307XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MubGluZWFyTm9uZSA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gaztcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MucXVhZHJhdGljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgfTtcbiAgc2lnbWEudXRpbHMuZWFzaW5ncy5xdWFkcmF0aWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIHJldHVybiAtIDAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbiA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9O1xuICBzaWdtYS51dGlscy5lYXNpbmdzLmN1YmljT3V0ID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XG4gIH07XG4gIHNpZ21hLnV0aWxzLmVhc2luZ3MuY3ViaWNJbk91dCA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKVxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogKioqKioqKioqKioqXG4gICAqIFdFQkdMIFVUSUxTOlxuICAgKiAqKioqKioqKioqKipcbiAgICovXG4gIC8qKlxuICAgKiBMb2FkcyBhIFdlYkdMIHNoYWRlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHBhcmFtICB7V2ViR0xDb250ZXh0fSAgICAgICAgICAgZ2wgICAgICAgICAgIFRoZSBXZWJHTENvbnRleHQgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBzaGFkZXJTb3VyY2UgVGhlIHNoYWRlciBzb3VyY2UuXG4gICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgIHNoYWRlclR5cGUgICBUaGUgdHlwZSBvZiBzaGFkZXIuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKHN0cmluZyk6IHZvaWR9IGVycm9yICAgICAgICBDYWxsYmFjayBmb3IgZXJyb3JzLlxuICAgKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWF0ZWQgc2hhZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMubG9hZFNoYWRlciA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJTb3VyY2UsIHNoYWRlclR5cGUsIGVycm9yKSB7XG4gICAgdmFyIGNvbXBpbGVkLFxuICAgICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG5cbiAgICAvLyBMb2FkIHRoZSBzaGFkZXIgc291cmNlXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHNoYWRlclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgIC8vIENoZWNrIHRoZSBjb21waWxlIHN0YXR1c1xuICAgIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3Jvbmc6XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgICdFcnJvciBjb21waWxpbmcgc2hhZGVyIFwiJyArIHNoYWRlciArICdcIjonICtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvZ3JhbSwgYXR0YWNoZXMgc2hhZGVycywgYmluZHMgYXR0cmliIGxvY2F0aW9ucywgbGlua3MgdGhlXG4gICAqIHByb2dyYW0gYW5kIGNhbGxzIHVzZVByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5LjxXZWJHTFNoYWRlcj59ICAgIHNoYWRlcnMgICBUaGUgc2hhZGVycyB0byBhdHRhY2guXG4gICAqIEBwYXJhbSAge0FycmF5LjxzdHJpbmc+fSAgICAgICAgIGF0dHJpYnMgICBUaGUgYXR0cmlicyBuYW1lcy5cbiAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59ICAgICAgICAgbG9jYXRpb25zIFRoZSBsb2NhdGlvbnMgZm9yIHRoZSBhdHRyaWJzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBlcnJvciAgICAgQ2FsbGJhY2sgZm9yIGVycm9ycy5cbiAgICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSAgICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIHByb2dyYW0uXG4gICAqL1xuICBzaWdtYS51dGlscy5sb2FkUHJvZ3JhbSA9IGZ1bmN0aW9uKGdsLCBzaGFkZXJzLCBhdHRyaWJzLCBsb2MsIGVycm9yKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxpbmtlZCxcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzaGFkZXJzLmxlbmd0aDsgKytpKVxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuXG4gICAgaWYgKGF0dHJpYnMpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7ICsraSlcbiAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKFxuICAgICAgICAgIHByb2dyYW0sXG4gICAgICAgICAgbG9jYXRpb25zID8gbG9jYXRpb25zW2ldIDogaSxcbiAgICAgICAgICBvcHRfYXR0cmlic1tpXVxuICAgICAgICApO1xuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAvLyBDaGVjayB0aGUgbGluayBzdGF0dXNcbiAgICBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgaWYgKGVycm9yKVxuICAgICAgICBlcnJvcignRXJyb3IgaW4gcHJvZ3JhbSBsaW5raW5nOiAnICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuXG4gICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqICoqKioqKioqKlxuICAgKiBNQVRSSUNFUzpcbiAgICogKioqKioqKioqXG4gICAqIFRoZSBmb2xsb3dpbmcgdXRpbHMgYXJlIGp1c3QgaGVyZSB0byBoZWxwIGdlbmVyYXRpbmcgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAqIG1hdHJpY2VzIGZvciB0aGUgV2ViR0wgcmVuZGVyZXJzLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscy5tYXRyaWNlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyB0cmFuc2xhdGlvbiBtYXRyaXguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHggVGhlIFggdHJhbnNsYXRpb24uXG4gICAqIEBwYXJhbSAge251bWJlcn0gZHkgVGhlIFkgdHJhbnNsYXRpb24uXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24gPSBmdW5jdGlvbihkeCwgZHkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICBkeCwgZHksIDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgcmV0dXJucyBhIDN4MyBvciAyeDIgcm90YXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBhbmdsZSBUaGUgcm90YXRpb24gYW5nbGUuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IG0yICAgIElmIHRydWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIDJ4MiBtYXRyaXguXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgIFJldHVybnMgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNpZ21hLnV0aWxzLm1hdHJpY2VzLnJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUsIG0yKSB7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgcmV0dXJuIG0yID8gW1xuICAgICAgY29zLCAtc2luLFxuICAgICAgc2luLCBjb3NcbiAgICBdIDogW1xuICAgICAgY29zLCAtc2luLCAwLFxuICAgICAgc2luLCBjb3MsIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByYXRpbyBUaGUgc2NhbGluZyByYXRpby5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgICAgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgMngyIG1hdHJpeC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMuc2NhbGUgPSBmdW5jdGlvbihyYXRpbywgbTIpIHtcbiAgICByZXR1cm4gbTIgPyBbXG4gICAgICByYXRpbywgMCxcbiAgICAgIDAsIHJhdGlvXG4gICAgXSA6IFtcbiAgICAgIHJhdGlvLCAwLCAwLFxuICAgICAgMCwgcmF0aW8sIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIHJldHVybnMgYSAzeDMgb3IgMngyIGhvbW90aGV0aWMgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBhICBUaGUgZmlyc3QgbWF0cml4LlxuICAgKiBAcGFyYW0gIHthcnJheX0gICBiICBUaGUgc2Vjb25kIG1hdHJpeC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gbTIgSWYgdHJ1ZSwgdGhlIGZ1bmN0aW9uIHdpbGwgYXNzdW1lIGJvdGggbWF0cmljZXMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIDJ4Mi5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgUmV0dXJucyB0aGUgbWF0cml4LlxuICAgKi9cbiAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkgPSBmdW5jdGlvbihhLCBiLCBtMikge1xuICAgIHZhciBsID0gbTIgPyAyIDogMyxcbiAgICAgICAgYTAwID0gYVswICogbCArIDBdLFxuICAgICAgICBhMDEgPSBhWzAgKiBsICsgMV0sXG4gICAgICAgIGEwMiA9IGFbMCAqIGwgKyAyXSxcbiAgICAgICAgYTEwID0gYVsxICogbCArIDBdLFxuICAgICAgICBhMTEgPSBhWzEgKiBsICsgMV0sXG4gICAgICAgIGExMiA9IGFbMSAqIGwgKyAyXSxcbiAgICAgICAgYTIwID0gYVsyICogbCArIDBdLFxuICAgICAgICBhMjEgPSBhWzIgKiBsICsgMV0sXG4gICAgICAgIGEyMiA9IGFbMiAqIGwgKyAyXSxcbiAgICAgICAgYjAwID0gYlswICogbCArIDBdLFxuICAgICAgICBiMDEgPSBiWzAgKiBsICsgMV0sXG4gICAgICAgIGIwMiA9IGJbMCAqIGwgKyAyXSxcbiAgICAgICAgYjEwID0gYlsxICogbCArIDBdLFxuICAgICAgICBiMTEgPSBiWzEgKiBsICsgMV0sXG4gICAgICAgIGIxMiA9IGJbMSAqIGwgKyAyXSxcbiAgICAgICAgYjIwID0gYlsyICogbCArIDBdLFxuICAgICAgICBiMjEgPSBiWzIgKiBsICsgMV0sXG4gICAgICAgIGIyMiA9IGJbMiAqIGwgKyAyXTtcblxuICAgIHJldHVybiBtMiA/IFtcbiAgICAgIGEwMCAqIGIwMCArIGEwMSAqIGIxMCxcbiAgICAgIGEwMCAqIGIwMSArIGEwMSAqIGIxMSxcbiAgICAgIGExMCAqIGIwMCArIGExMSAqIGIxMCxcbiAgICAgIGExMCAqIGIwMSArIGExMSAqIGIxMVxuICAgIF0gOiBbXG4gICAgICBhMDAgKiBiMDAgKyBhMDEgKiBiMTAgKyBhMDIgKiBiMjAsXG4gICAgICBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjEsXG4gICAgICBhMDAgKiBiMDIgKyBhMDEgKiBiMTIgKyBhMDIgKiBiMjIsXG4gICAgICBhMTAgKiBiMDAgKyBhMTEgKiBiMTAgKyBhMTIgKiBiMjAsXG4gICAgICBhMTAgKiBiMDEgKyBhMTEgKiBiMTEgKyBhMTIgKiBiMjEsXG4gICAgICBhMTAgKiBiMDIgKyBhMTEgKiBiMTIgKyBhMTIgKiBiMjIsXG4gICAgICBhMjAgKiBiMDAgKyBhMjEgKiBiMTAgKyBhMjIgKiBiMjAsXG4gICAgICBhMjAgKiBiMDEgKyBhMjEgKiBiMTEgKyBhMjIgKiBiMjEsXG4gICAgICBhMjAgKiBiMDIgKyBhMjEgKiBiMTIgKyBhMjIgKiBiMjJcbiAgICBdO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBodHRwOi8vbXkub3BlcmEuY29tL2Vtb2xsZXIvYmxvZy8yMDExLzEyLzIwL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtZXItYW5pbWF0aW5nXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuXG4gICAqIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbiAgICogTUlUIGxpY2Vuc2VcbiAgICovXG4gIHZhciB4LFxuICAgICAgbGFzdFRpbWUgPSAwLFxuICAgICAgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5cbiAgZm9yICh4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyB4KyspIHtcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cbiAgICAgIGdsb2JhbFt2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gICAgICBnbG9iYWxbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgfVxuXG4gIGlmICghZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSksXG4gICAgICAgICAgaWQgPSBnbG9iYWwuc2V0VGltZW91dChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRpbWVUb0NhbGxcbiAgICAgICAgICApO1xuXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gIGlmICghZ2xvYmFsLmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHBvbHlmaWxsIGZvdW5kIG9uIE1ETi5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCNDb21wYXRpYmlsaXR5XG4gICAqIFB1YmxpYyBkb21haW5cbiAgICovXG4gIGlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihvVGhpcykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAvLyBDbG9zZXN0IHRoaW5nIHBvc3NpYmxlIHRvIHRoZSBFQ01BU2NyaXB0IDUgaW50ZXJuYWwgSXNDYWxsYWJsZVxuICAgICAgICAvLyBmdW5jdGlvbjpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnXG4gICAgICAgICk7XG5cbiAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgZlRvQmluZCA9IHRoaXMsXG4gICAgICAgICAgZk5PUCxcbiAgICAgICAgICBmQm91bmQ7XG5cbiAgICAgIGZOT1AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgZkJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmVG9CaW5kLmFwcGx5KFxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBmTk9QICYmIG9UaGlzID9cbiAgICAgICAgICAgIHRoaXMgOlxuICAgICAgICAgICAgb1RoaXMsXG4gICAgICAgICAgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG5cbiAgICAgIHJldHVybiBmQm91bmQ7XG4gICAgfTtcbn0pKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gUGFja2FnZXMgaW5pdGlhbGl6YXRpb246XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc2V0dGluZ3MnKTtcblxuICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgLyoqXG4gICAgICogR1JBUEggU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzIHRvIGFkZFxuICAgIC8vICAgICAgICAgICBub2RlcyBvciBlZGdlcy5cbiAgICBjbG9uZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIG5vZGVzIFwiaWRcIiB2YWx1ZXMgYW5kIGVkZ2VzIFwiaWRcIiwgXCJzb3VyY2VcIiBhbmRcbiAgICAvLyAgICAgICAgICAgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXMgaW1tdXRhYmxlLlxuICAgIGltbXV0YWJsZTogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHNpZ21hIGNhbiBsb2cgaXRzIGVycm9ycyBhbmQgd2FybmluZ3MuXG4gICAgdmVyYm9zZTogZmFsc2UsXG5cblxuICAgIC8qKlxuICAgICAqIFJFTkRFUkVSUyBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge3N0cmluZ31cbiAgICBjbGFzc1ByZWZpeDogJ3NpZ21hJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlVHlwZTogJ2RlZicsXG4gICAgLy8ge3N0cmluZ31cbiAgICBkZWZhdWx0RWRnZVR5cGU6ICdkZWYnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdExhYmVsQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbFNpemU6IDE0LFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBlZGdlcyBjb2xvci4gQXZhaWxhYmxlIHZhbHVlczpcbiAgICAvLyAgICAgICAgICBcInNvdXJjZVwiLCBcInRhcmdldFwiLCBcImRlZmF1bHRcIlxuICAgIGVkZ2VDb2xvcjogJ3NvdXJjZScsXG4gICAgLy8ge251bWJlcn0gRGVmaW5lcyB0aGUgbWluaW1hbCBlZGdlJ3MgYXJyb3cgZGlzcGxheSBzaXplLlxuICAgIG1pbkFycm93U2l6ZTogMCxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGZvbnQ6ICdhcmlhbCcsXG4gICAgLy8ge3N0cmluZ30gRXhhbXBsZTogJ2JvbGQnXG4gICAgZm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIGNvbG9yLiBBdmFpbGFibGUgdmFsdWVzOlxuICAgIC8vICAgICAgICAgIFwibm9kZVwiLCBcImRlZmF1bHRcIlxuICAgIGxhYmVsQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgbGFiZWxzIHNpemUuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJmaXhlZFwiLCBcInByb3BvcnRpb25hbFwiXG4gICAgbGFiZWxTaXplOiAnZml4ZWQnLFxuICAgIC8vIHtzdHJpbmd9IFRoZSByYXRpbyBiZXR3ZWVuIHRoZSBmb250IHNpemUgb2YgdGhlIGxhYmVsIGFuZCB0aGUgbm9kZSBzaXplLlxuICAgIGxhYmVsU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHNpemUgYSBub2RlIG11c3QgaGF2ZSB0byBzZWUgaXRzIGxhYmVsIGRpc3BsYXllZC5cbiAgICBsYWJlbFRocmVzaG9sZDogOCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgb3ZlcnNhbXBsaW5nIGZhY3RvciB1c2VkIGluIFdlYkdMIHJlbmRlcmVyLlxuICAgIHdlYmdsT3ZlcnNhbXBsaW5nUmF0aW86IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGJvcmRlciBvZiBob3ZlcmVkIG5vZGVzLlxuICAgIGJvcmRlclNpemU6IDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGRlZmF1bHQgaG92ZXJlZCBub2RlIGJvcmRlcidzIGNvbG9yLlxuICAgIGRlZmF1bHROb2RlQm9yZGVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaG92ZXJlZCBub2RlJ3MgbGFiZWwgZm9udC4gSWYgbm90IHNwZWNpZmllZCwgd2lsbCBoZXJpdGF0ZVxuICAgIC8vICAgICAgICAgIHRoZSBcImZvbnRcIiB2YWx1ZS5cbiAgICBob3ZlckZvbnQ6ICcnLFxuICAgIC8vIHtib29sZWFufSBJZiB0cnVlLCB0aGVuIG9ubHkgb25lIG5vZGUgY2FuIGJlIGhvdmVyZWQgYXQgYSB0aW1lLlxuICAgIHNpbmdsZUhvdmVyOiB0cnVlLFxuICAgIC8vIHtzdHJpbmd9IEV4YW1wbGU6ICdib2xkJ1xuICAgIGhvdmVyRm9udFN0eWxlOiAnJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgaG92ZXJlZCBub2RlcyBzaGFkb3cgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlclNoYWRvdzogJ2RlZmF1bHQnLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgbGFiZWxIb3ZlclNoYWRvd0NvbG9yOiAnIzAwMCcsXG4gICAgLy8ge3N0cmluZ30gSW5kaWNhdGVzIGhvdyB0byBjaG9vc2UgdGhlIGhvdmVyZWQgbm9kZXMgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbm9kZUhvdmVyQ29sb3I6ICdub2RlJyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHROb2RlSG92ZXJDb2xvcjogJyMwMDAnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIG5vZGVzIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgICAgICAgQXZhaWxhYmxlIHZhbHVlczogXCJub2RlXCIsIFwiZGVmYXVsdFwiXG4gICAgbGFiZWxIb3ZlckJHQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcjogJyNmZmYnLFxuICAgIC8vIHtzdHJpbmd9IEluZGljYXRlcyBob3cgdG8gY2hvb3NlIHRoZSBob3ZlcmVkIGxhYmVscyBjb2xvci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcIm5vZGVcIiwgXCJkZWZhdWx0XCJcbiAgICBsYWJlbEhvdmVyQ29sb3I6ICdkZWZhdWx0JyxcbiAgICAvLyB7c3RyaW5nfVxuICAgIGRlZmF1bHRMYWJlbEhvdmVyQ29sb3I6ICcjMDAwJyxcbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgaG93IHRvIGNob29zZSB0aGUgZWRnZXMgaG92ZXIgY29sb3IuIEF2YWlsYWJsZSB2YWx1ZXM6XG4gICAgLy8gICAgICAgICAgXCJlZGdlXCIsIFwiZGVmYXVsdFwiXG4gICAgZWRnZUhvdmVyQ29sb3I6ICdlZGdlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgc2l6ZSBtdWx0aXBsaWNhdG9yIG9mIGhvdmVyZWQgZWRnZXMuXG4gICAgZWRnZUhvdmVyU2l6ZVJhdGlvOiAxLFxuICAgIC8vIHtzdHJpbmd9XG4gICAgZGVmYXVsdEVkZ2VIb3ZlckNvbG9yOiAnIzAwMCcsXG4gICAgLy8ge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgZWRnZSBleHRyZW1pdGllcyBtdXN0IGJlIGhvdmVyZWQgd2hlbiB0aGVcbiAgICAvLyAgICAgICAgICAgZWRnZSBpcyBob3ZlcmVkLlxuICAgIGVkZ2VIb3ZlckV4dHJlbWl0aWVzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbnN9IFRoZSBkaWZmZXJlbnQgZHJhd2luZyBtb2RlczpcbiAgICAvLyAgICAgICAgICAgZmFsc2U6IExheWVyZWQgbm90IGRpc3BsYXllZC5cbiAgICAvLyAgICAgICAgICAgdHJ1ZTogTGF5ZXJlZCBkaXNwbGF5ZWQuXG4gICAgZHJhd0VkZ2VzOiB0cnVlLFxuICAgIGRyYXdOb2RlczogdHJ1ZSxcbiAgICBkcmF3TGFiZWxzOiB0cnVlLFxuICAgIGRyYXdFZGdlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGRyYXduIGluIHNldmVyYWwgZnJhbWVzIG9yIGluXG4gICAgLy8gICAgICAgICAgIG9uZSBmcmFtZSwgYXMgdGhlIG5vZGVzIGFuZCBsYWJlbHMgYXJlIGRyYXduLlxuICAgIGJhdGNoRWRnZXNEcmF3aW5nOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBlZGdlcyBtdXN0IGJlIGhpZGRlbiBkdXJpbmcgZHJhZ2dpbmcgYW5kXG4gICAgLy8gICAgICAgICAgIGFuaW1hdGlvbnMuXG4gICAgaGlkZUVkZ2VzT25Nb3ZlOiBmYWxzZSxcbiAgICAvLyB7bnVtYmVyc30gVGhlIGRpZmZlcmVudCBiYXRjaCBzaXplcywgd2hlbiBlbGVtZW50cyBhcmUgZGlzcGxheWVkIGluXG4gICAgLy8gICAgICAgICAgIHNldmVyYWwgZnJhbWVzLlxuICAgIGNhbnZhc0VkZ2VzQmF0Y2hTaXplOiA1MDAsXG4gICAgd2ViZ2xFZGdlc0JhdGNoU2l6ZTogMTAwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFJFU0NBTEUgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7c3RyaW5nfSBJbmRpY2F0ZXMgb2YgdG8gc2NhbGUgdGhlIGdyYXBoIHJlbGF0aXZlbHkgdG8gaXRzIGNvbnRhaW5lci5cbiAgICAvLyAgICAgICAgICBBdmFpbGFibGUgdmFsdWVzOiBcImluc2lkZVwiLCBcIm91dHNpZGVcIlxuICAgIHNjYWxpbmdNb2RlOiAnaW5zaWRlJyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWFyZ2luIHRvIGtlZXAgYXJvdW5kIHRoZSBncmFwaC5cbiAgICBzaWRlTWFyZ2luOiAwLFxuICAgIC8vIHtudW1iZXJ9IERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgc21hbGxlc3QgYW5kIHRoZSBiaWdnZXN0IG5vZGUgLyBlZGdlc1xuICAgIC8vICAgICAgICAgIG9uIHRoZSBzY3JlZW4uIFRoaXMgbWFwcGluZyBtYWtlcyBlYXNpZXIgdG8gZGlzcGxheSB0aGUgZ3JhcGgsXG4gICAgLy8gICAgICAgICAgYXZvaWRpbmcgdG9vIGJpZyBub2RlcyB0aGF0IHRha2UgaGFsZiBvZiB0aGUgc2NyZWVuLCBvciB0b29cbiAgICAvLyAgICAgICAgICBzbWFsbCBvbmVzIHRoYXQgYXJlIG5vdCByZWFkYWJsZS4gSWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZVxuICAgIC8vICAgICAgICAgIGVxdWFscywgdGhlbiB0aGUgbWluaW1hbCBkaXNwbGF5IHNpemUgd2lsbCBiZSAwLiBBbmQgaWYgdGhleVxuICAgIC8vICAgICAgICAgIGFyZSBib3RoIGVxdWFsIHRvIDAsIHRoZW4gdGhlcmUgaXMgbm8gbWFwcGluZywgYW5kIHRoZSByYWRpdXNcbiAgICAvLyAgICAgICAgICBvZiB0aGUgbm9kZXMgd2lsbCBiZSB0aGVpciBzaXplLlxuICAgIG1pbkVkZ2VTaXplOiAwLjUsXG4gICAgbWF4RWRnZVNpemU6IDEsXG4gICAgbWluTm9kZVNpemU6IDEsXG4gICAgbWF4Tm9kZVNpemU6IDgsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQVBUT1JTIFNFVFRJTkdTOlxuICAgICAqICoqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59XG4gICAgdG91Y2hFbmFibGVkOiB0cnVlLFxuICAgIC8vIHtib29sZWFufVxuICAgIG1vdXNlRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBtb3VzZVdoZWVsRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7Ym9vbGVhbn1cbiAgICBkb3VibGVDbGlja0VuYWJsZWQ6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERlZmluZXMgd2hldGhlciB0aGUgY3VzdG9tIGV2ZW50cyBzdWNoIGFzIFwiY2xpY2tOb2RlXCIgY2FuIGJlXG4gICAgLy8gICAgICAgICAgIHVzZWQuXG4gICAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyB3aXRoIHRoZSBtb3VzZS13aGVlbC5cbiAgICB6b29taW5nUmF0aW86IDEuNyxcbiAgICAvLyB7bnVtYmVyfSBEZWZpbmVzIGJ5IGhvdyBtdWNoIG11bHRpcGxpY2F0aW5nIHRoZSB6b29taW5nIGxldmVsIHdoZW4gdGhlXG4gICAgLy8gICAgICAgICAgdXNlciB6b29tcyBieSBkb3VibGUgY2xpY2tpbmcuXG4gICAgZG91YmxlQ2xpY2tab29taW5nUmF0aW86IDIuMixcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWluaW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NaW46IDAuMDYyNSxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB6b29taW5nIGxldmVsLlxuICAgIHpvb21NYXg6IDIsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2Ugc2Nyb2xsaW5nLlxuICAgIG1vdXNlWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZG91YmxlIGNsaWNrLlxuICAgIGRvdWJsZUNsaWNrWm9vbUR1cmF0aW9uOiAyMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIGR1cmF0aW9uIG9mIGFuaW1hdGlvbnMgZm9sbG93aW5nIGEgbW91c2UgZHJvcHBpbmcuXG4gICAgbW91c2VJbmVydGlhRHVyYXRpb246IDIwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgaW5lcnRpYSBwb3dlciAobW91c2UgY2FwdG9yKS5cbiAgICBtb3VzZUluZXJ0aWFSYXRpbzogMyxcbiAgICAvLyB7bnVtYmVyfSBUaGUgZHVyYXRpb24gb2YgYW5pbWF0aW9ucyBmb2xsb3dpbmcgYSB0b3VjaCBkcm9wcGluZy5cbiAgICB0b3VjaEluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBpbmVydGlhIHBvd2VyICh0b3VjaCBjYXB0b3IpLlxuICAgIHRvdWNoSW5lcnRpYVJhdGlvOiAzLFxuICAgIC8vIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHRpbWUgYmV0d2VlbiB0d28gY2xpY2tzIHRvIG1ha2UgaXQgYSBkb3VibGUgY2xpY2suXG4gICAgZG91YmxlQ2xpY2tUaW1lb3V0OiAzMDAsXG4gICAgLy8ge251bWJlcn0gVGhlIG1heGltdW0gdGltZSBiZXR3ZWVuIHR3byB0YXBzIHRvIG1ha2UgaXQgYSBkb3VibGUgdGFwLlxuICAgIGRvdWJsZVRhcFRpbWVvdXQ6IDMwMCxcbiAgICAvLyB7bnVtYmVyfSBUaGUgbWF4aW11bSB0aW1lIG9mIGRyYWdnaW5nIHRvIHRyaWdnZXIgaW50ZXJ0aWEuXG4gICAgZHJhZ1RpbWVvdXQ6IDIwMCxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEdMT0JBTCBTRVRUSU5HUzpcbiAgICAgKiAqKioqKioqKioqKioqKioqXG4gICAgICovXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgaGFzIHRvIHJlZnJlc2ggaXRzZWxmXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgd2hlbiBhIFwicmVzaXplXCIgZXZlbnQgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoZVxuICAgIC8vICAgICAgICAgICB3aW5kb3cgb2JqZWN0LlxuICAgIGF1dG9SZXNpemU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IERldGVybWluZXMgd2hldGhlciB0aGUgXCJyZXNjYWxlXCIgbWlkZGxld2FyZSBoYXMgdG8gYmUgY2FsbGVkXG4gICAgLy8gICAgICAgICAgIGF1dG9tYXRpY2FsbHkgZm9yIGVhY2ggY2FtZXJhIG9uIHJlZnJlc2guXG4gICAgYXV0b1Jlc2NhbGU6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIGNhbWVyYSBtZXRob2QgXCJnb1RvXCIgd2lsbCBiYXNpY2FsbHkgZG9cbiAgICAvLyAgICAgICAgICAgbm90aGluZy5cbiAgICBlbmFibGVDYW1lcmE6IHRydWUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byBmYWxzZSwgdGhlIG5vZGVzIGNhbm5vdCBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUhvdmVyaW5nOiB0cnVlLFxuICAgIC8vIHtib29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGVkZ2VzIGNhbiBiZSBob3ZlcmVkLlxuICAgIGVuYWJsZUVkZ2VIb3ZlcmluZzogZmFsc2UsXG4gICAgLy8ge251bWJlcn0gVGhlIHNpemUgb2YgdGhlIGFyZWEgYXJvdW5kIHRoZSBlZGdlcyB0byBhY3RpdmF0ZSBob3ZlcmluZy5cbiAgICBlZGdlSG92ZXJQcmVjaXNpb246IDUsXG4gICAgLy8ge2Jvb2xlYW59IElmIHNldCB0byB0cnVlLCB0aGUgcmVzY2FsZSBtaWRkbGV3YXJlIHdpbGwgaWdub3JlIG5vZGUgc2l6ZXNcbiAgICAvLyAgICAgICAgICAgdG8gZGV0ZXJtaW5lIHRoZSBncmFwaHMgYm91bmRpbmdzLlxuICAgIHJlc2NhbGVJZ25vcmVTaXplOiBmYWxzZSxcbiAgICAvLyB7Ym9vbGVhbn0gRGV0ZXJtaW5lcyBpZiB0aGUgY29yZSBoYXMgdG8gdHJ5IHRvIGNhdGNoIGVycm9ycyBvblxuICAgIC8vICAgICAgICAgICByZW5kZXJpbmcuXG4gICAgc2tpcEVycm9yczogZmFsc2UsXG5cblxuXG5cbiAgICAvKipcbiAgICAgKiBDQU1FUkEgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKlxuICAgICAqL1xuICAgIC8vIHtudW1iZXJ9IFRoZSBwb3dlciBkZWdyZWVzIGFwcGxpZWQgdG8gdGhlIG5vZGVzL2VkZ2VzIHNpemUgcmVsYXRpdmVseSB0b1xuICAgIC8vICAgICAgICAgIHRoZSB6b29taW5nIGxldmVsLiBCYXNpY2FsbHk6XG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5SID0gTWF0aC5wb3coem9vbSwgbm9kZXNQb3dSYXRpbykgKiBSXG4gICAgLy8gICAgICAgICAgID4gb25TY3JlZW5UID0gTWF0aC5wb3coem9vbSwgZWRnZXNQb3dSYXRpbykgKiBUXG4gICAgbm9kZXNQb3dSYXRpbzogMC41LFxuICAgIGVkZ2VzUG93UmF0aW86IDAuNSxcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEFOSU1BVElPTlMgU0VUVElOR1M6XG4gICAgICogKioqKioqKioqKioqKioqKioqKipcbiAgICAgKi9cbiAgICAvLyB7bnVtYmVyfSBUaGUgZGVmYXVsdCBhbmltYXRpb24gdGltZS5cbiAgICBhbmltYXRpb25zVGltZTogMjAwXG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBwcmV2aW91c2x5IGRlc2lnbmVkIHNldHRpbmdzOlxuICBzaWdtYS5zZXR0aW5ncyA9IHNpZ21hLnV0aWxzLmV4dGVuZChzaWdtYS5zZXR0aW5ncyB8fCB7fSwgc2V0dGluZ3MpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVyIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtkaXNwYXRjaGVyfSBUaGUgbmV3IGRpc3BhdGNoZXIgaW5zdGFuY2UuXG4gICAqL1xuICB2YXIgZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2hhbmRsZXJzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFdpbGwgZXhlY3V0ZSB0aGUgaGFuZGxlciBldmVyeXRpbWUgdGhhdCB0aGUgaW5kaWNhdGVkIGV2ZW50IChvciB0aGVcbiAgICogaW5kaWNhdGVkIGV2ZW50cykgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgIGV2ZW50cyAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IChvciB0aGUgZXZlbnRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGVkIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9uKE9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gYmluZC5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBkaXNwYXRjaGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBlQXJyYXk7XG5cbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0J1xuICAgIClcbiAgICAgIGZvciAoZXZlbnRzIGluIGFyZ3VtZW50c1swXSlcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50cywgYXJndW1lbnRzWzBdW2V2ZW50c10pO1xuICAgIGVsc2UgaWYgKFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGVBcnJheS5sZW5ndGg7IGkgIT09IGw7IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcblxuICAgICAgICAvLyBDaGVjayB0aGF0IGV2ZW50IGlzIG5vdCAnJzpcbiAgICAgICAgaWYgKCFldmVudClcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50XSlcbiAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudF0gPSBbXTtcblxuICAgICAgICAvLyBVc2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseSB0aGUgaGFuZGxlciB3aWxsIG1ha2UgcG9zc2libGVcbiAgICAgICAgLy8gbGF0ZXIgdG8gYWRkIGZsYWdzXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgJ2JpbmQ6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhbmRsZXIgZnJvbSBhIHNwZWNpZmllZCBldmVudCAob3Igc3BlY2lmaWVkIGV2ZW50cykuXG4gICAqXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9ICAgICAgICAgICBldmVudHMgIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgc3BhY2VzKS4gSWYgdW5kZWZpbmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIGFsbCBoYW5kbGVycyBhcmUgcmVtb3ZlZC5cbiAgICogQHBhcmFtICB7P2Z1bmN0aW9uKG9iamVjdCl9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gdW5iaW5kLiBJZiB1bmRlZmluZWQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnQgb3IgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAqIEByZXR1cm4ge2Rpc3BhdGNoZXJ9ICAgICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIHZhciBpLFxuICAgICAgICBuLFxuICAgICAgICBqLFxuICAgICAgICBtLFxuICAgICAgICBrLFxuICAgICAgICBhLFxuICAgICAgICBldmVudCxcbiAgICAgICAgZUFycmF5ID0gdHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycgPyBldmVudHMuc3BsaXQoJyAnKSA6IGV2ZW50cztcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChrIGluIHRoaXMuX2hhbmRsZXJzKVxuICAgICAgICBkZWxldGUgdGhpcy5faGFuZGxlcnNba107XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgICBldmVudCA9IGVBcnJheVtpXTtcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKGogPSAwLCBtID0gdGhpcy5faGFuZGxlcnNbZXZlbnRdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW2V2ZW50XVtqXS5oYW5kbGVyICE9PSBoYW5kbGVyKVxuICAgICAgICAgICAgICBhLnB1c2godGhpcy5faGFuZGxlcnNbZXZlbnRdW2pdKTtcblxuICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50XSA9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuX2hhbmRsZXJzW2V2ZW50XS5sZW5ndGggPT09IDApXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBlQXJyYXkubGVuZ3RoOyBpICE9PSBuOyBpICs9IDEpXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYW5kbGVyc1tlQXJyYXlbaV1dO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGVhY2ggaGFuZGxlciBib3VuZCB0byB0aGUgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgZXZlbnRzIFRoZSBuYW1lIG9mIHRoZSBldmVudCAob3IgdGhlIGV2ZW50cyBzZXBhcmF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IHNwYWNlcykuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgIGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7ZGlzcGF0Y2hlcn0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbixcbiAgICAgICAgaixcbiAgICAgICAgbSxcbiAgICAgICAgYSxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVBcnJheSA9IHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnID8gZXZlbnRzLnNwbGl0KCcgJykgOiBldmVudHM7XG5cbiAgICBkYXRhID0gZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBkYXRhO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IGVBcnJheS5sZW5ndGg7IGkgIT09IG47IGkgKz0gMSkge1xuICAgICAgZXZlbnROYW1lID0gZUFycmF5W2ldO1xuXG4gICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xuICAgICAgICBldmVudCA9IHNlbGYuZ2V0RXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIG0gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDsgaiAhPT0gbTsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXVtqXS5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0ub25lKVxuICAgICAgICAgICAgYS5wdXNoKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1bal0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBldmVudCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIGV2ZW50cyBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IGRhdGEgICBUaGUgY29udGVudCBvZiB0aGUgZXZlbnQgKG9wdGlvbmFsKS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIGRpc3BhdGNoZXIucHJvdG90eXBlLmdldEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnQsXG4gICAgICBkYXRhOiBkYXRhIHx8IHt9LFxuICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQSB1c2VmdWwgZnVuY3Rpb24gdG8gZGVhbCB3aXRoIGluaGVyaXRhbmNlLiBJdCB3aWxsIG1ha2UgdGhlIHRhcmdldFxuICAgKiBpbmhlcml0IHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzIGRpc3BhdGNoZXIgYXMgd2VsbCBhcyBpdHMgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldC5cbiAgICovXG4gIGRpc3BhdGNoZXIuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0LCBhcmdzKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gZGlzcGF0Y2hlci5wcm90b3R5cGUpXG4gICAgICBpZiAoZGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaykpXG4gICAgICAgIHRhcmdldFtrXSA9IGRpc3BhdGNoZXIucHJvdG90eXBlW2tdO1xuXG4gICAgZGlzcGF0Y2hlci5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoZXI7XG4gICAgZXhwb3J0cy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgfSBlbHNlXG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGhpcyB1dGlscyBhaW1zIHRvIGZhY2lsaXRhdGUgdGhlIG1hbmlwdWxhdGlvbiBvZiBlYWNoIGluc3RhbmNlIHNldHRpbmcuXG4gICAqIFVzaW5nIGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBhbiBvYmplY3QgYnJpbmdzIHR3byBtYWluIGFkdmFudGFnZXM6IEZpcnN0LFxuICAgKiBpdCB3aWxsIGJlIGVhc2llciBpbiB0aGUgZnV0dXJlIHRvIGNhdGNoIHNldHRpbmdzIHVwZGF0ZXMgdGhyb3VnaCBhXG4gICAqIGZ1bmN0aW9uIHRoYW4gYW4gb2JqZWN0LiBTZWNvbmQsIGdpdmluZyBpdCBhIGZ1bGwgb2JqZWN0IHdpbGwgXCJtZXJnZVwiIGl0XG4gICAqIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgcHJvcGVybHksIGtlZXBpbmcgdXMgdG8gaGF2ZSB0byBhbHdheXMgYWRkIGEgbG9vcC5cbiAgICpcbiAgICogQHJldHVybiB7Y29uZmlndXJhYmxlfSBUaGUgXCJzZXR0aW5nc1wiIGZ1bmN0aW9uLlxuICAgKi9cbiAgdmFyIGNvbmZpZ3VyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBkYXRhID0ge30sXG4gICAgICAgIGRhdGFzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRob2QgdG8gdXNlIHRvIHNldCBvciBnZXQgYW55IHByb3BlcnR5IG9mIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fSAgICBhMSBJZiBpdCBpcyBhIHN0cmluZyBhbmQgaWYgYTIgaXMgdW5kZWZpbmVkLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS4gSWYgaXQgaXMgYSBzdHJpbmcgYW5kIGlmIGEyIGlzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0LCB0aGVuIGl0IHdpbGwgc2V0IGEyIGFzIHRoZSBwcm9wZXJ0eVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcgdG8gYTEsIGFuZCByZXR1cm4gdGhpcy4gSWZcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBpcyBhbiBvYmplY3QsIHRoZW4gZWFjaCBwYWlyIHN0cmluZyArXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0KG9yIGFueSBvdGhlciB0eXBlKSB3aWxsIGJlIHNldCBhcyBhXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkuXG4gICAgICogQHBhcmFtICB7Kj99ICAgICAgICAgICAgICAgYTIgVGhlIG5ldyBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIGExIGlmIGExXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7Knxjb25maWd1cmFibGV9ICAgICAgUmV0dXJucyBpdHNlbGYgb3IgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFBvbHltb3JwaGlzbTpcbiAgICAgKiAqKioqKioqKioqKioqXG4gICAgICogSGVyZSBhcmUgc29tZSBiYXNpYyB1c2UgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgPiBzZXR0aW5ncyA9IG5ldyBjb25maWd1cmFibGUoKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgNDIpO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDJcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJywgMTIzKTtcbiAgICAgKiAgPiBzZXR0aW5ncygnbXlTZXR0aW5nJyk7IC8vIExvZ3M6IDEyM1xuICAgICAqICA+IHNldHRpbmdzKHtteVNldHRpbmc6IDQ1Nn0pO1xuICAgICAqICA+IHNldHRpbmdzKCdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICpcbiAgICAgKiBBbHNvLCBpdCBpcyBwb3NzaWJsZSB0byB1c2UgdGhlIGZ1bmN0aW9uIGFzIGEgZmFsbGJhY2s6XG4gICAgICogID4gc2V0dGluZ3Moe215U2V0dGluZzogJ2FiYyd9LCAnbXlTZXR0aW5nJyk7ICAvLyBMb2dzOiAnYWJjJ1xuICAgICAqICA+IHNldHRpbmdzKHtoaXNTZXR0aW5nOiAnYWJjJ30sICdteVNldHRpbmcnKTsgLy8gTG9nczogNDU2XG4gICAgICovXG4gICAgdmFyIHNldHRpbmdzID0gZnVuY3Rpb24oYTEsIGEyKSB7XG4gICAgICB2YXIgbyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgaztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGExID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZGF0YVthMV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gZGF0YVthMV07XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBkYXRhcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaWYgKGRhdGFzW2ldW2ExXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFzW2ldW2ExXTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGExID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAoYTEgfHwge30pW2EyXSAhPT0gdW5kZWZpbmVkID8gYTFbYTJdIDogc2V0dGluZ3MoYTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbyA9ICh0eXBlb2YgYTEgPT09ICdvYmplY3QnICYmIGEyID09PSB1bmRlZmluZWQpID8gYTEgOiB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJylcbiAgICAgICAgICBvW2ExXSA9IGEyO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGsgPSBPYmplY3Qua2V5cyhvKSwgbCA9IGsubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGRhdGFba1tpXV0gPSBvW2tbaV1dO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGNvbmZpZ3VyYWJsZSBmdW5jdGlvbiwgd2l0aCBuZXcgb2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0Kn0gIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB0byBzZWFyY2ggaW4uXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb259IFJldHVybnMgdGhlIGZ1bmN0aW9uLiBDaGVjayBpdHMgZG9jdW1lbnRhdGlvbiB0byBrbm93XG4gICAgICogICAgICAgICAgICAgICAgICAgIG1vcmUgYWJvdXQgaG93IGl0IHdvcmtzLlxuICAgICAqL1xuICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBkYXRhcy5jb25jYXQoXG4gICAgICAgIGRhdGFcbiAgICAgICkuY29uY2F0KFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGNvbmZpZ3VyYWJsZS5hcHBseSh7fSwgYXJncyk7XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemVcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIHNldHRpbmdzKGFyZ3VtZW50c1tpXSk7XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuY29uZmlndXJhYmxlID0gY29uZmlndXJhYmxlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZ3VyYWJsZTtcbiAgICBleHBvcnRzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgfSBlbHNlXG4gICAgdGhpcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9tZXRob2RzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbmRleGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9pbml0QmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgX21ldGhvZEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIF9tZXRob2RCZWZvcmVCaW5kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBfZGVmYXVsdFNldHRpbmdzID0ge1xuICAgICAgICBpbW11dGFibGU6IHRydWUsXG4gICAgICAgIGNsb25lOiB0cnVlXG4gICAgICB9LFxuICAgICAgX2RlZmF1bHRTZXR0aW5nc0Z1bmN0aW9uID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdFNldHRpbmdzW2tleV07XG4gICAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZ3JhcGggY29uc3RydWN0b3IuIEl0IGluaXRpYWxpemVzIHRoZSBkYXRhIGFuZCB0aGUgaW5kZXhlcywgYW5kIGJpbmRzXG4gICAqIHRoZSBjdXN0b20gaW5kZXhlcyBhbmQgbWV0aG9kcyB0byBpdHMgb3duIHNjb3BlLlxuICAgKlxuICAgKiBSZWNvZ25pemVkIHBhcmFtZXRlcnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlcnMgaW4gdGhlIHNldHRpbmdzXG4gICAqIG9iamVjdDpcbiAgICpcbiAgICogICB7Ym9vbGVhbn0gY2xvbmUgICAgIEluZGljYXRlcyBpZiB0aGUgZGF0YSBoYXZlIHRvIGJlIGNsb25lZCBpbiBtZXRob2RzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICB0byBhZGQgbm9kZXMgb3IgZWRnZXMuXG4gICAqICAge2Jvb2xlYW59IGltbXV0YWJsZSBJbmRpY2F0ZXMgaWYgbm9kZXMgXCJpZFwiIHZhbHVlcyBhbmQgZWRnZXMgXCJpZFwiLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiBhbmQgXCJ0YXJnZXRcIiB2YWx1ZXMgbXVzdCBiZSBzZXQgYXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P2NvbmZpZ3VyYWJsZX0gc2V0dGluZ3MgRXZlbnR1YWxseSBhIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtncmFwaH0gICAgICAgICAgICAgICAgICBUaGUgbmV3IGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgdmFyIGdyYXBoID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICB2YXIgayxcbiAgICAgICAgZm4sXG4gICAgICAgIGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBEQVRBOlxuICAgICAqICoqKioqXG4gICAgICogRXZlcnkgZGF0YSB0aGF0IGlzIGNhbGxhYmxlIGZyb20gZ3JhcGggbWV0aG9kcyBhcmUgc3RvcmVkIGluIHRoaXMgXCJkYXRhXCJcbiAgICAgKiBvYmplY3QuIFRoaXMgb2JqZWN0IHdpbGwgYmUgc2VydmVkIGFzIGNvbnRleHQgZm9yIGFsbCB0aGVzZSBtZXRob2RzLFxuICAgICAqIGFuZCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgb3RoZXIgdHlwZSBvZiBkYXRhIGluIGl0LlxuICAgICAqL1xuICAgIGRhdGEgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFNFVFRJTkdTIEZVTkNUSU9OOlxuICAgICAgICogKioqKioqKioqKioqKioqKioqXG4gICAgICAgKi9cbiAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyB8fCBfZGVmYXVsdFNldHRpbmdzRnVuY3Rpb24sXG5cbiAgICAgIC8qKlxuICAgICAgICogTUFJTiBEQVRBOlxuICAgICAgICogKioqKioqKioqKlxuICAgICAgICovXG4gICAgICBub2Rlc0FycmF5OiBbXSxcbiAgICAgIGVkZ2VzQXJyYXk6IFtdLFxuXG4gICAgICAvKipcbiAgICAgICAqIEdMT0JBTCBJTkRFWEVTOlxuICAgICAgICogKioqKioqKioqKioqKioqXG4gICAgICAgKiBUaGVzZSBpbmRleGVzIGp1c3QgaW5kZXggZGF0YSBieSBpZHMuXG4gICAgICAgKi9cbiAgICAgIG5vZGVzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBlZGdlc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgICAvKipcbiAgICAgICAqIExPQ0FMIElOREVYRVM6XG4gICAgICAgKiAqKioqKioqKioqKioqKlxuICAgICAgICogVGhlc2UgaW5kZXhlcyByZWZlciBmcm9tIG5vZGUgdG8gbm9kZXMuIEVhY2gga2V5IGlzIGFuIGlkLCBhbmQgZWFjaFxuICAgICAgICogdmFsdWUgaXMgdGhlIGFycmF5IG9mIHRoZSBpZHMgb2YgcmVsYXRlZCBub2Rlcy5cbiAgICAgICAqL1xuICAgICAgaW5OZWlnaGJvcnNJbmRleDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG91dE5laWdoYm9yc0luZGV4OiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgYWxsTmVpZ2hib3JzSW5kZXg6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgICAgIGluTmVpZ2hib3JzQ291bnQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBvdXROZWlnaGJvcnNDb3VudDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGFsbE5laWdoYm9yc0NvdW50OiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcblxuICAgIC8vIEV4ZWN1dGUgYmluZGluZ3M6XG4gICAgZm9yIChrIGluIF9pbml0QmluZGluZ3MpXG4gICAgICBfaW5pdEJpbmRpbmdzW2tdLmNhbGwoZGF0YSk7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBib3RoIHRoZSBzY29wZSBhbmQgdGhlIGRhdGEgb2JqZWN0czpcbiAgICBmb3IgKGsgaW4gX21ldGhvZHMpIHtcbiAgICAgIGZuID0gX19iaW5kR3JhcGhNZXRob2QoaywgZGF0YSwgX21ldGhvZHNba10pO1xuICAgICAgdGhpc1trXSA9IGZuO1xuICAgICAgZGF0YVtrXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogQSBjdXN0b20gdG9vbCB0byBiaW5kIG1ldGhvZHMgc3VjaCB0aGF0IGZ1bmN0aW9uIHRoYXQgYXJlIGJvdW5kIHRvIGl0IHdpbGxcbiAgICogYmUgZXhlY3V0ZWQgYW55dGltZSB0aGUgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBiaW5kLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgc2NvcGUgICAgICBUaGUgc2NvcGUgd2hlcmUgdGhlIG1ldGhvZCBtdXN0IGJlIGV4ZWN1dGVkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gZm4gICAgICAgICBUaGUgbWV0aG9kIGl0c2VsZi5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICAgVGhlIG5ldyBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBfX2JpbmRHcmFwaE1ldGhvZChtZXRob2ROYW1lLCBzY29wZSwgZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgayxcbiAgICAgICAgICByZXM7XG5cbiAgICAgIC8vIEV4ZWN1dGUgXCJiZWZvcmVcIiBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIEFwcGx5IHRoZSBtZXRob2Q6XG4gICAgICByZXMgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgLy8gRXhlY3V0ZSBib3VuZCBmdW5jdGlvbnM6XG4gICAgICBmb3IgKGsgaW4gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICBfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV1ba10uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIFJldHVybiByZXM6XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgY3VzdG9tIHRvb2wgZnVuY3Rpb24gcmVtb3ZlcyBldmVyeSBwYWlyIGtleS92YWx1ZSBmcm9tIGFuIGhhc2guIFRoZVxuICAgKiBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aGlsZSBzb21lIG90aGVyIHJlZmVyZW5jZXMgYXJlXG4gICAqIHN0aWxsIGhhbmdpbmcgaW4gc29tZSBzY29wZXMuLi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBlbXB0eS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgVGhlIGVtcHR5IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIF9fZW1wdHlPYmplY3Qob2JqKSB7XG4gICAgdmFyIGs7XG5cbiAgICBmb3IgKGsgaW4gb2JqKVxuICAgICAgaWYgKCEoJ2hhc093blByb3BlcnR5JyBpbiBvYmopIHx8IG9iai5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgZGVsZXRlIG9ialtrXTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuXG5cblxuICAvKipcbiAgICogVGhpcyBnbG9iYWwgbWV0aG9kIGFkZHMgYSBtZXRob2QgdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoZSBmdXR1cmx5IGNyZWF0ZWRcbiAgICogZ3JhcGggaW5zdGFuY2VzLlxuICAgKlxuICAgKiBTaW5jZSB0aGVzZSBtZXRob2RzIHdpbGwgYmUgYm91bmQgdG8gdGhlaXIgc2NvcGUgd2hlbiB0aGUgaW5zdGFuY2VzIGFyZVxuICAgKiBjcmVhdGVkLCBpdCBkb2VzIG5vdCB1c2UgdGhlIHByb3RvdHlwZS4gQmVjYXVzZSBvZiB0aGF0LCBtZXRob2RzIGhhdmUgdG9cbiAgICogYmUgYWRkZWQgYmVmb3JlIGluc3RhbmNlcyBhcmUgY3JlYXRlZCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGU6XG4gICAqXG4gICAqICA+IGdyYXBoLmFkZE1ldGhvZCgnZ2V0Tm9kZXNDb3VudCcsIGZ1bmN0aW9uKCkge1xuICAgKiAgPiAgIHJldHVybiB0aGlzLm5vZGVzQXJyYXkubGVuZ3RoO1xuICAgKiAgPiB9KTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIG1ldGhvZCBpdHNlbGYuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBmbikge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtZXRob2ROYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoICE9PSAyXG4gICAgKVxuICAgICAgdGhyb3cgJ2FkZE1ldGhvZDogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoX21ldGhvZHNbbWV0aG9kTmFtZV0gfHwgZ3JhcGhbbWV0aG9kTmFtZV0pXG4gICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICBfbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZuO1xuICAgIF9tZXRob2RCaW5kaW5nc1ttZXRob2ROYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGdsb2JhbCBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBtZXRob2QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCwgYW5kXG4gICAqIGZhbHNlIGVsc2UuXG4gICAqXG4gICAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXM6XG4gICAqXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgnYWRkTm9kZScpOyAvLyByZXR1cm5zIHRydWVcbiAgICogID4gZ3JhcGguaGFzTWV0aG9kKCdoYXNNZXRob2QnKTsgLy8gcmV0dXJucyB0cnVlXG4gICAqICA+IGdyYXBoLmhhc01ldGhvZCgndW5leGlzdGluZ01ldGhvZCcpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICBUaGUgcmVzdWx0LlxuICAgKi9cbiAgZ3JhcGguaGFzTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHJldHVybiAhIShfbWV0aG9kc1ttZXRob2ROYW1lXSB8fCBncmFwaFttZXRob2ROYW1lXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZ2xvYmFsIG1ldGhvZHMgYXR0YWNoZXMgYSBmdW5jdGlvbiB0byBhIG1ldGhvZC4gQW55dGltZSB0aGUgc3BlY2lmaWVkXG4gICAqIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIsIHdpdGggdGhlXG4gICAqIHNhbWUgYXJndW1lbnRzIGFuZCBpbiB0aGUgc2FtZSBzY29wZS4gVGhlIGF0dGFjaGVkIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICAgKiByaWdodCBiZWZvcmUgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgdHJ1ZSwgdW5sZXNzIHRoZSBtZXRob2QgaXMgdGhlIGdyYXBoXG4gICAqIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBUbyBhdHRhY2ggYSBmdW5jdGlvbiB0byB0aGUgZ3JhcGggY29uc3RydWN0b3IsIHVzZSAnY29uc3RydWN0b3InIGFzIHRoZVxuICAgKiBtZXRob2QgbmFtZSAoZmlyc3QgYXJndW1lbnQpLlxuICAgKlxuICAgKiBUaGUgbWFpbiBpZGVhIGlzIHRvIGhhdmUgYSBjbGVhbiB3YXkgdG8ga2VlcCBjdXN0b20gaW5kZXhlcyB1cCB0byBkYXRlLFxuICAgKiBmb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICA+IHZhciB0aW1lc0FkZE5vZGVDYWxsZWQgPSAwO1xuICAgKiAgPiBncmFwaC5hdHRhY2goJ2FkZE5vZGUnLCAndGltZXNBZGROb2RlQ2FsbGVkSW5jJywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgdGltZXNBZGROb2RlQ2FsbGVkKys7XG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiB2YXIgbXlHcmFwaCA9IG5ldyBncmFwaCgpO1xuICAgKiAgPiBjb25zb2xlLmxvZyh0aW1lc0FkZE5vZGVDYWxsZWQpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2codGltZXNBZGROb2RlQ2FsbGVkKTsgLy8gb3V0cHV0cyAyXG4gICAqXG4gICAqIFRoZSBpZGVhIGZvciBjYWxsaW5nIGEgZnVuY3Rpb24gYmVmb3JlIGlzIHRvIHByb3ZpZGUgcHJlLXByb2Nlc3NvcnMsIGZvclxuICAgKiBpbnN0YW5jZTpcbiAgICpcbiAgICogID4gdmFyIGNvbG9yUGFsZXR0ZSA9IHsgUGVyc29uOiAnI0MzQ0JFMScsIFBsYWNlOiAnIzlCREVCRCcgfTtcbiAgICogID4gZ3JhcGguYXR0YWNoKCdhZGROb2RlJywgJ2FwcGx5Tm9kZUNvbG9yUGFsZXR0ZScsIGZ1bmN0aW9uKG4pIHtcbiAgICogID4gICBuLmNvbG9yID0gY29sb3JQYWxldHRlW24uY2F0ZWdvcnldO1xuICAgKiAgPiB9LCB0cnVlKTtcbiAgICogID5cbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICduMCcsIGNhdGVnb3J5OiAnUGVyc29uJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5ub2RlcygnbjAnKS5jb2xvcik7IC8vIG91dHB1dHMgJyNDM0NCRTEnXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSByZWxhdGVkIG1ldGhvZCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnN0cnVjdG9yXCIuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBrZXkgICAgICAgIFRoZSBrZXkgdG8gaWRlbnRpZnkgdGhlIGZ1bmN0aW9uIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGZuICAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59ICBiZWZvcmUgICAgIElmIHRydWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByaWdodCBiZWZvcmUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgIFRoZSBnbG9iYWwgZ3JhcGggY29uc3RydWN0b3IuXG4gICAqL1xuICBncmFwaC5hdHRhY2ggPSBmdW5jdGlvbihtZXRob2ROYW1lLCBrZXksIGZuLCBiZWZvcmUpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2YgbWV0aG9kTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAzIHx8XG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gNFxuICAgIClcbiAgICAgIHRocm93ICdhdHRhY2g6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgdmFyIGJpbmRpbmdzO1xuXG4gICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjb25zdHJ1Y3RvcicpXG4gICAgICBiaW5kaW5ncyA9IF9pbml0QmluZGluZ3M7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmICghX21ldGhvZEJlZm9yZUJpbmRpbmdzW21ldGhvZE5hbWVdKVxuICAgICAgICB0aHJvdyAnVGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICAgICAgYmluZGluZ3MgPSBfbWV0aG9kQmVmb3JlQmluZGluZ3NbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFfbWV0aG9kQmluZGluZ3NbbWV0aG9kTmFtZV0pXG4gICAgICAgICAgdGhyb3cgJ1RoZSBtZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiBkb2VzIG5vdCBleGlzdC4nO1xuXG4gICAgICAgIGJpbmRpbmdzID0gX21ldGhvZEJpbmRpbmdzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiaW5kaW5nc1trZXldKVxuICAgICAgdGhyb3cgJ0EgZnVuY3Rpb24gXCInICsga2V5ICsgJ1wiIGlzIGFscmVhZHkgYXR0YWNoZWQgJyArXG4gICAgICAgICAgICAndG8gdGhlIG1ldGhvZCBcIicgKyBtZXRob2ROYW1lICsgJ1wiLic7XG5cbiAgICBiaW5kaW5nc1trZXldID0gZm47XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWxpYXMgb2YgYXR0YWNoKG1ldGhvZE5hbWUsIGtleSwgZm4sIHRydWUpLlxuICAgKi9cbiAgZ3JhcGguYXR0YWNoQmVmb3JlID0gZnVuY3Rpb24obWV0aG9kTmFtZSwga2V5LCBmbikge1xuICAgIHJldHVybiB0aGlzLmF0dGFjaChtZXRob2ROYW1lLCBrZXksIGZuLCB0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIGlzIGp1c3QgYW4gaGVscGVyIHRvIGRlYWwgd2l0aCBjdXN0b20gaW5kZXhlcy4gSXQgdGFrZXMgYXNcbiAgICogYXJndW1lbnRzIHRoZSBuYW1lIG9mIHRoZSBpbmRleCBhbmQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICogZnVuY3Rpb25zIHRvIGJpbmQgdG8gdGhlIG1ldGhvZHMuXG4gICAqXG4gICAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLCB0aGF0IGNyZWF0ZXMgYW4gaW5kZXggdG8ga2VlcCB0aGUgbnVtYmVyIG9mIG5vZGVzXG4gICAqIGluIHRoZSBjdXJyZW50IGdyYXBoLiBJdCBhbHNvIGFkZHMgYSBtZXRob2QgdG8gcHJvdmlkZSBhIGdldHRlciBvbiB0aGF0XG4gICAqIG5ldyBpbmRleDpcbiAgICpcbiAgICogID4gc2lnbWEuY2xhc3Nlcy5ncmFwaC5hZGRJbmRleCgnbm9kZXNDb3VudCcsIHtcbiAgICogID4gICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQgPSAwO1xuICAgKiAgPiAgIH0sXG4gICAqICA+ICAgYWRkTm9kZTogZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgICB0aGlzLm5vZGVzQ291bnQrKztcbiAgICogID4gICB9LFxuICAgKiAgPiAgIGRyb3BOb2RlOiBmdW5jdGlvbigpIHtcbiAgICogID4gICAgIHRoaXMubm9kZXNDb3VudC0tO1xuICAgKiAgPiAgIH1cbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHNpZ21hLmNsYXNzZXMuZ3JhcGguYWRkTWV0aG9kKCdnZXROb2Rlc0NvdW50JywgZnVuY3Rpb24oKSB7XG4gICAqICA+ICAgcmV0dXJuIHRoaXMubm9kZXNDb3VudDtcbiAgICogID4gfSk7XG4gICAqICA+XG4gICAqICA+IHZhciBteUdyYXBoID0gbmV3IHNpZ21hLmNsYXNzZXMuZ3JhcGgoKTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDBcbiAgICogID5cbiAgICogID4gbXlHcmFwaC5hZGROb2RlKHsgaWQ6ICcxJyB9KS5hZGROb2RlKHsgaWQ6ICcyJyB9KTtcbiAgICogID4gY29uc29sZS5sb2cobXlHcmFwaC5nZXROb2Rlc0NvdW50KCkpOyAvLyBvdXRwdXRzIDJcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgaW5kZXguXG4gICAqIEBwYXJhbSAge29iamVjdH0gYmluZGluZ3MgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBmdW5jdGlvbnMgdG8gYmluZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZ2xvYmFsIGdyYXBoIGNvbnN0cnVjdG9yLlxuICAgKi9cbiAgZ3JhcGguYWRkSW5kZXggPSBmdW5jdGlvbihuYW1lLCBiaW5kaW5ncykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgT2JqZWN0KGJpbmRpbmdzKSAhPT0gYmluZGluZ3MgfHxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDJcbiAgICApXG4gICAgICB0aHJvdyAnYWRkSW5kZXg6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKF9pbmRleGVzW25hbWVdKVxuICAgICAgdGhyb3cgJ1RoZSBpbmRleCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgaztcblxuICAgIC8vIFN0b3JlIHRoZSBiaW5kaW5nczpcbiAgICBfaW5kZXhlc1tuYW1lXSA9IGJpbmRpbmdzO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBiaW5kaW5nczpcbiAgICBmb3IgKGsgaW4gYmluZGluZ3MpXG4gICAgICBpZiAodHlwZW9mIGJpbmRpbmdzW2tdICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnVGhlIGJpbmRpbmdzIG11c3QgYmUgZnVuY3Rpb25zLic7XG4gICAgICBlbHNlXG4gICAgICAgIGdyYXBoLmF0dGFjaChrLCBuYW1lLCBiaW5kaW5nc1trXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIG5vZGUgdG8gdGhlIGdyYXBoLiBUaGUgbm9kZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIi4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0byBhZGQgYW55XG4gICAqIG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIG5vZGUgd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCB3aWxsIGJlIGRlZmluZWQgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG5vZGUgVGhlIG5vZGUgdG8gYWRkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdhZGROb2RlJywgZnVuY3Rpb24obm9kZSkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIG5vZGUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYW4gaWQ6XG4gICAgaWYgKE9iamVjdChub2RlKSAhPT0gbm9kZSB8fCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgJ2FkZE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlLmlkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygbm9kZS5pZCAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyAnVGhlIG5vZGUgbXVzdCBoYXZlIGEgc3RyaW5nIG9yIG51bWJlciBpZC4nO1xuXG4gICAgaWYgKHRoaXMubm9kZXNJbmRleFtub2RlLmlkXSlcbiAgICAgIHRocm93ICdUaGUgbm9kZSBcIicgKyBub2RlLmlkICsgJ1wiIGFscmVhZHkgZXhpc3RzLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaWQgPSBub2RlLmlkLFxuICAgICAgICB2YWxpZE5vZGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiY2xvbmVcIiBvcHRpb246XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MoJ2Nsb25lJykpIHtcbiAgICAgIGZvciAoayBpbiBub2RlKVxuICAgICAgICBpZiAoayAhPT0gJ2lkJylcbiAgICAgICAgICB2YWxpZE5vZGVba10gPSBub2RlW2tdO1xuICAgIH0gZWxzZVxuICAgICAgdmFsaWROb2RlID0gbm9kZTtcblxuICAgIC8vIENoZWNrIHRoZSBcImltbXV0YWJsZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnaW1tdXRhYmxlJykpXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWROb2RlLCAnaWQnLCB7XG4gICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdmFsaWROb2RlLmlkID0gaWQ7XG5cbiAgICAvLyBBZGQgZW1wdHkgY29udGFpbmVycyBmb3IgZWRnZXMgaW5kZXhlczpcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXSA9IDA7XG4gICAgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF0gPSAwO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdID0gMDtcblxuICAgIC8vIEFkZCB0aGUgbm9kZSB0byBpbmRleGVzOlxuICAgIHRoaXMubm9kZXNBcnJheS5wdXNoKHZhbGlkTm9kZSk7XG4gICAgdGhpcy5ub2Rlc0luZGV4W3ZhbGlkTm9kZS5pZF0gPSB2YWxpZE5vZGU7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaW5zdGFuY2U6XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBhZGRzIGFuIGVkZ2UgdG8gdGhlIGdyYXBoLiBUaGUgZWRnZSBtdXN0IGJlIGFuIG9iamVjdCwgd2l0aCBhXG4gICAqIHN0cmluZyB1bmRlciB0aGUga2V5IFwiaWRcIiwgYW5kIHN0cmluZ3MgdW5kZXIgdGhlIGtleXMgXCJzb3VyY2VcIiBhbmRcbiAgICogXCJ0YXJnZXRcIiB0aGF0IGRlc2lnbiBleGlzdGluZyBub2Rlcy4gRXhjZXB0IGZvciB0aGlzLCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgKiBhZGQgYW55IG90aGVyIGF0dHJpYnV0ZSwgdGhhdCB3aWxsIGJlIHByZXNlcnZlZCBhbGwgYWxvbmcgdGhlXG4gICAqIG1hbmlwdWxhdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBncmFwaCBvcHRpb24gXCJjbG9uZVwiIGhhcyBhIHRydXRoeSB2YWx1ZSwgdGhlIGVkZ2Ugd2lsbCBiZSBjbG9uZWRcbiAgICogd2hlbiBhZGRlZCB0byB0aGUgZ3JhcGguIEFsc28sIGlmIHRoZSBncmFwaCBvcHRpb24gXCJpbW11dGFibGVcIiBoYXMgYVxuICAgKiB0cnV0aHkgdmFsdWUsIGl0cyBpZCwgc291cmNlIGFuZCB0YXJnZXQgd2lsbCBiZSBkZWZpbmVkIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlZGdlIFRoZSBlZGdlIHRvIGFkZC5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnYWRkRWRnZScsIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAvLyBDaGVjayB0aGF0IHRoZSBlZGdlIGlzIGFuIG9iamVjdCBhbmQgaGFzIGFuIGlkOlxuICAgIGlmIChPYmplY3QoZWRnZSkgIT09IGVkZ2UgfHwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdhZGRFZGdlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmICh0eXBlb2YgZWRnZS5pZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGVkZ2UuaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ1RoZSBlZGdlIG11c3QgaGF2ZSBhIHN0cmluZyBvciBudW1iZXIgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2Uuc291cmNlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS5zb3VyY2UgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2Uuc291cmNlXSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSBzb3VyY2UgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICgodHlwZW9mIGVkZ2UudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZWRnZS50YXJnZXQgIT09ICdudW1iZXInKSB8fFxuICAgICAgICAhdGhpcy5ub2Rlc0luZGV4W2VkZ2UudGFyZ2V0XSlcbiAgICAgIHRocm93ICdUaGUgZWRnZSB0YXJnZXQgbXVzdCBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgaWQuJztcblxuICAgIGlmICh0aGlzLmVkZ2VzSW5kZXhbZWRnZS5pZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgZWRnZS5pZCArICdcIiBhbHJlYWR5IGV4aXN0cy4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIHZhbGlkRWRnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBDaGVjayB0aGUgXCJjbG9uZVwiIG9wdGlvbjpcbiAgICBpZiAodGhpcy5zZXR0aW5ncygnY2xvbmUnKSkge1xuICAgICAgZm9yIChrIGluIGVkZ2UpXG4gICAgICAgIGlmIChrICE9PSAnaWQnICYmIGsgIT09ICdzb3VyY2UnICYmIGsgIT09ICd0YXJnZXQnKVxuICAgICAgICAgIHZhbGlkRWRnZVtrXSA9IGVkZ2Vba107XG4gICAgfSBlbHNlXG4gICAgICB2YWxpZEVkZ2UgPSBlZGdlO1xuXG4gICAgLy8gQ2hlY2sgdGhlIFwiaW1tdXRhYmxlXCIgb3B0aW9uOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKCdpbW11dGFibGUnKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkRWRnZSwgJ2lkJywge1xuICAgICAgICB2YWx1ZTogZWRnZS5pZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICdzb3VyY2UnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnNvdXJjZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZEVkZ2UsICd0YXJnZXQnLCB7XG4gICAgICAgIHZhbHVlOiBlZGdlLnRhcmdldCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkRWRnZS5pZCA9IGVkZ2UuaWQ7XG4gICAgICB2YWxpZEVkZ2Uuc291cmNlID0gZWRnZS5zb3VyY2U7XG4gICAgICB2YWxpZEVkZ2UudGFyZ2V0ID0gZWRnZS50YXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBlZGdlIHRvIGluZGV4ZXM6XG4gICAgdGhpcy5lZGdlc0FycmF5LnB1c2godmFsaWRFZGdlKTtcbiAgICB0aGlzLmVkZ2VzSW5kZXhbdmFsaWRFZGdlLmlkXSA9IHZhbGlkRWRnZTtcblxuICAgIGlmICghdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdKVxuICAgICAgdGhpcy5pbk5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmluTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLmlkXSA9XG4gICAgICB2YWxpZEVkZ2U7XG5cbiAgICBpZiAoIXRoaXMub3V0TmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnNvdXJjZV1bdmFsaWRFZGdlLnRhcmdldF0pXG4gICAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdID1cbiAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLm91dE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgdmFsaWRFZGdlO1xuXG4gICAgaWYgKCF0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS50YXJnZXRdKVxuICAgICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XSA9XG4gICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFt2YWxpZEVkZ2Uuc291cmNlXVt2YWxpZEVkZ2UudGFyZ2V0XVt2YWxpZEVkZ2UuaWRdID1cbiAgICAgIHZhbGlkRWRnZTtcblxuICAgIGlmICh2YWxpZEVkZ2UudGFyZ2V0ICE9PSB2YWxpZEVkZ2Uuc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0pXG4gICAgICAgIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbdmFsaWRFZGdlLnRhcmdldF1bdmFsaWRFZGdlLnNvdXJjZV0gPVxuICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmFsbE5laWdoYm9yc0luZGV4W3ZhbGlkRWRnZS50YXJnZXRdW3ZhbGlkRWRnZS5zb3VyY2VdW3ZhbGlkRWRnZS5pZF0gPVxuICAgICAgICB2YWxpZEVkZ2U7XG4gICAgfVxuXG4gICAgLy8gS2VlcCBjb3VudHMgdXAgdG8gZGF0ZTpcbiAgICB0aGlzLmluTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnRhcmdldF0rKztcbiAgICB0aGlzLm91dE5laWdoYm9yc0NvdW50W3ZhbGlkRWRnZS5zb3VyY2VdKys7XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFt2YWxpZEVkZ2UudGFyZ2V0XSsrO1xuICAgIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbdmFsaWRFZGdlLnNvdXJjZV0rKztcblxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgZHJvcHMgYSBub2RlIGZyb20gdGhlIGdyYXBoLiBJdCBhbHNvIHJlbW92ZXMgZWFjaCBlZGdlIHRoYXQgaXNcbiAgICogYm91bmQgdG8gaXQsIHRocm91Z2ggdGhlIGRyb3BFZGdlIG1ldGhvZC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBub2RlXG4gICAqIGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIFRoZSBub2RlIGlkLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIFRoZSBncmFwaCBpbnN0YW5jZS5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZHJvcE5vZGUnLCBmdW5jdGlvbihpZCkge1xuICAgIC8vIENoZWNrIHRoYXQgdGhlIGFyZ3VtZW50cyBhcmUgdmFsaWQ6XG4gICAgaWYgKCh0eXBlb2YgaWQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHx8XG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyAnZHJvcE5vZGU6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCF0aGlzLm5vZGVzSW5kZXhbaWRdKVxuICAgICAgdGhyb3cgJ1RoZSBub2RlIFwiJyArIGlkICsgJ1wiIGRvZXMgbm90IGV4aXN0Lic7XG5cbiAgICB2YXIgaSwgaywgbDtcblxuICAgIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIGluZGV4ZXM6XG4gICAgZGVsZXRlIHRoaXMubm9kZXNJbmRleFtpZF07XG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMubm9kZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAodGhpcy5ub2Rlc0FycmF5W2ldLmlkID09PSBpZCkge1xuICAgICAgICB0aGlzLm5vZGVzQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIFJlbW92ZSByZWxhdGVkIGVkZ2VzOlxuICAgIGZvciAoaSA9IHRoaXMuZWRnZXNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uc291cmNlID09PSBpZCB8fCB0aGlzLmVkZ2VzQXJyYXlbaV0udGFyZ2V0ID09PSBpZClcbiAgICAgICAgdGhpcy5kcm9wRWRnZSh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQpO1xuXG4gICAgLy8gUmVtb3ZlIHJlbGF0ZWQgZWRnZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbaWRdO1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtpZF07XG5cbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0NvdW50W2lkXTtcbiAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNDb3VudFtpZF07XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnRbaWRdO1xuXG4gICAgZm9yIChrIGluIHRoaXMubm9kZXNJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5vdXROZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtrXVtpZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkcm9wcyBhbiBlZGdlIGZyb20gdGhlIGdyYXBoLiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGVkZ2VcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgVGhlIGVkZ2UgaWQuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgVGhlIGdyYXBoIGluc3RhbmNlLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdkcm9wRWRnZScsIGZ1bmN0aW9uKGlkKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSB2YWxpZDpcbiAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykgfHxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93ICdkcm9wRWRnZTogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIXRoaXMuZWRnZXNJbmRleFtpZF0pXG4gICAgICB0aHJvdyAnVGhlIGVkZ2UgXCInICsgaWQgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcblxuICAgIHZhciBpLCBsLCBlZGdlO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kZXhlczpcbiAgICBlZGdlID0gdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBkZWxldGUgdGhpcy5lZGdlc0luZGV4W2lkXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZGdlc0FycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmICh0aGlzLmVkZ2VzQXJyYXlbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuZWRnZXNBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuaW5OZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5pbk5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXTtcblxuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF1bZWRnZS5pZF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF0pLmxlbmd0aClcbiAgICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4W2VkZ2Uuc291cmNlXVtlZGdlLnRhcmdldF07XG5cbiAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdW2VkZ2UuaWRdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdKS5sZW5ndGgpXG4gICAgICBkZWxldGUgdGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnNvdXJjZV1bZWRnZS50YXJnZXRdO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9PSBlZGdlLnNvdXJjZSkge1xuICAgICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzSW5kZXhbZWRnZS50YXJnZXRdW2VkZ2Uuc291cmNlXVtlZGdlLmlkXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5hbGxOZWlnaGJvcnNJbmRleFtlZGdlLnRhcmdldF1bZWRnZS5zb3VyY2VdKS5sZW5ndGgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4W2VkZ2UudGFyZ2V0XVtlZGdlLnNvdXJjZV07XG4gICAgfVxuXG4gICAgdGhpcy5pbk5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuICAgIHRoaXMub3V0TmVpZ2hib3JzQ291bnRbZWRnZS5zb3VyY2VdLS07XG4gICAgdGhpcy5hbGxOZWlnaGJvcnNDb3VudFtlZGdlLnNvdXJjZV0tLTtcbiAgICB0aGlzLmFsbE5laWdoYm9yc0NvdW50W2VkZ2UudGFyZ2V0XS0tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBkZXN0cm95cyB0aGUgY3VycmVudCBpbnN0YW5jZS4gSXQgYmFzaWNhbGx5IGVtcHRpZXMgZWFjaCBpbmRleFxuICAgKiBhbmQgbWV0aG9kcyBhdHRhY2hlZCB0byB0aGUgZ3JhcGguXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2tpbGwnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBEZWxldGUgYXJyYXlzOlxuICAgIHRoaXMubm9kZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZWRnZXNBcnJheS5sZW5ndGggPSAwO1xuICAgIGRlbGV0ZSB0aGlzLm5vZGVzQXJyYXk7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNBcnJheTtcblxuICAgIC8vIERlbGV0ZSBpbmRleGVzOlxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzSW5kZXg7XG4gICAgZGVsZXRlIHRoaXMuZWRnZXNJbmRleDtcbiAgICBkZWxldGUgdGhpcy5pbk5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLm91dE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmFsbE5laWdoYm9yc0luZGV4O1xuICAgIGRlbGV0ZSB0aGlzLmluTmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMub3V0TmVpZ2hib3JzQ291bnQ7XG4gICAgZGVsZXRlIHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBlbXB0aWVzIHRoZSBub2RlcyBhbmQgZWRnZXMgYXJyYXlzLCBhcyB3ZWxsIGFzIHRoZSBkaWZmZXJlbnRcbiAgICogaW5kZXhlcy5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ2NsZWFyJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub2Rlc0FycmF5Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lZGdlc0FycmF5Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBEdWUgdG8gR0MgaXNzdWVzLCBJIHByZWZlciBub3QgdG8gY3JlYXRlIG5ldyBvYmplY3QuIFRoZXNlIG9iamVjdHMgYXJlXG4gICAgLy8gb25seSBhdmFpbGFibGUgZnJvbSB0aGUgbWV0aG9kcyBhbmQgYXR0YWNoZWQgZnVuY3Rpb25zLCBidXQgc3RpbGwsIGl0IGlzXG4gICAgLy8gYmV0dGVyIHRvIHByZXZlbnQgZ2hvc3QgcmVmZXJlbmNlcyB0byB1bnJlbGV2YW50IGRhdGEuLi5cbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMubm9kZXNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLmVkZ2VzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5ub2Rlc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuaW5OZWlnaGJvcnNJbmRleCk7XG4gICAgX19lbXB0eU9iamVjdCh0aGlzLm91dE5laWdoYm9yc0luZGV4KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMuYWxsTmVpZ2hib3JzSW5kZXgpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5pbk5laWdoYm9yc0NvdW50KTtcbiAgICBfX2VtcHR5T2JqZWN0KHRoaXMub3V0TmVpZ2hib3JzQ291bnQpO1xuICAgIF9fZW1wdHlPYmplY3QodGhpcy5hbGxOZWlnaGJvcnNDb3VudCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlYWRzIGFuIG9iamVjdCBhbmQgYWRkcyB0aGUgbm9kZXMgYW5kIGVkZ2VzLCB0aHJvdWdoIHRoZVxuICAgKiBwcm9wZXIgbWV0aG9kcyBcImFkZE5vZGVcIiBhbmQgXCJhZGRFZGdlXCIuXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZTpcbiAgICpcbiAgICogID4gdmFyIG15R3JhcGggPSBuZXcgZ3JhcGgoKTtcbiAgICogID4gbXlHcmFwaC5yZWFkKHtcbiAgICogID4gICBub2RlczogW1xuICAgKiAgPiAgICAgeyBpZDogJ24wJyB9LFxuICAgKiAgPiAgICAgeyBpZDogJ24xJyB9XG4gICAqICA+ICAgXSxcbiAgICogID4gICBlZGdlczogW1xuICAgKiAgPiAgICAge1xuICAgKiAgPiAgICAgICBpZDogJ2UwJyxcbiAgICogID4gICAgICAgc291cmNlOiAnbjAnLFxuICAgKiAgPiAgICAgICB0YXJnZXQ6ICduMSdcbiAgICogID4gICAgIH1cbiAgICogID4gICBdXG4gICAqICA+IH0pO1xuICAgKiAgPlxuICAgKiAgPiBjb25zb2xlLmxvZyhcbiAgICogID4gICBteUdyYXBoLm5vZGVzKCkubGVuZ3RoLFxuICAgKiAgPiAgIG15R3JhcGguZWRnZXMoKS5sZW5ndGhcbiAgICogID4gKTsgLy8gb3V0cHV0cyAyIDFcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBnIFRoZSBncmFwaCBvYmplY3QuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgZ3JhcGggaW5zdGFuY2UuXG4gICAqL1xuICBncmFwaC5hZGRNZXRob2QoJ3JlYWQnLCBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGEsXG4gICAgICAgIGw7XG5cbiAgICBhID0gZy5ub2RlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZE5vZGUoYVtpXSk7XG5cbiAgICBhID0gZy5lZGdlcyB8fCBbXTtcbiAgICBmb3IgKGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICB0aGlzLmFkZEVkZ2UoYVtpXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIG9uZSBvciBzZXZlcmFsIG5vZGVzLCBkZXBlbmRpbmcgb24gaG93IGl0IGlzIGNhbGxlZC5cbiAgICpcbiAgICogVG8gZ2V0IHRoZSBhcnJheSBvZiBub2RlcywgY2FsbCBcIm5vZGVzXCIgd2l0aG91dCBhcmd1bWVudC4gVG8gZ2V0IGFcbiAgICogc3BlY2lmaWMgbm9kZSwgY2FsbCBpdCB3aXRoIHRoZSBpZCBvZiB0aGUgbm9kZS4gVGhlIGdldCBtdWx0aXBsZSBub2RlLFxuICAgKiBjYWxsIGl0IHdpdGggYW4gYXJyYXkgb2YgaWRzLCBhbmQgaXQgd2lsbCByZXR1cm4gdGhlIGFycmF5IG9mIG5vZGVzLCBpblxuICAgKiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtICB7PyhzdHJpbmd8YXJyYXkpfSB2IEV2ZW50dWFsbHkgb25lIGlkLCBhbiBhcnJheSBvZiBpZHMuXG4gICAqIEByZXR1cm4ge29iamVjdHxhcnJheX0gICAgICBUaGUgcmVsYXRlZCBub2RlIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgKi9cbiAgZ3JhcGguYWRkTWV0aG9kKCdub2RlcycsIGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgb2Ygbm9kZXMgYW5kIHJldHVybiBpdDpcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc0FycmF5LnNsaWNlKDApO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZWxhdGVkIG5vZGU6XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgKHR5cGVvZiB2ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpKVxuICAgICAgcmV0dXJuIHRoaXMubm9kZXNJbmRleFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgbCxcbiAgICAgICAgICBhID0gW107XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2Lmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgICAgaWYgKHR5cGVvZiB2W2ldID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdltpXSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgYS5wdXNoKHRoaXMubm9kZXNJbmRleFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB0aHJvdyAnbm9kZXM6IFdyb25nIGFyZ3VtZW50cy4nO1xuICB9KTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHJldHVybnMgdGhlIGRlZ3JlZSBvZiBvbmUgb3Igc2V2ZXJhbCBub2RlcywgZGVwZW5kaW5nIG9uIGhvd1xuICAgKiBpdCBpcyBjYWxsZWQuIEl0IGlzIGFsc28gcG9zc2libGUgdG8gZ2V0IGluY29taW5nIG9yIG91dGNvbWluZyBkZWdyZWVzXG4gICAqIGluc3RlYWQgYnkgc3BlY2lmeWluZyAnaW4nIG9yICdvdXQnIGFzIGEgc2Vjb25kIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl9IHYgICAgIE9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSAgICAgIHdoaWNoIFdoaWNoIGRlZ3JlZSBpcyByZXF1aXJlZC4gVmFsdWVzIGFyZSAnaW4nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdXQnLCBhbmQgYnkgZGVmYXVsdCB0aGUgbm9ybWFsIGRlZ3JlZS5cbiAgICogQHJldHVybiB7bnVtYmVyfGFycmF5fSAgICAgICBUaGUgcmVsYXRlZCBkZWdyZWUgb3IgYXJyYXkgb2YgZGVncmVlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZGVncmVlJywgZnVuY3Rpb24odiwgd2hpY2gpIHtcbiAgICAvLyBDaGVjayB3aGljaCBkZWdyZWUgaXMgcmVxdWlyZWQ6XG4gICAgd2hpY2ggPSB7XG4gICAgICAnaW4nOiB0aGlzLmluTmVpZ2hib3JzQ291bnQsXG4gICAgICAnb3V0JzogdGhpcy5vdXROZWlnaGJvcnNDb3VudFxuICAgIH1bd2hpY2ggfHwgJyddIHx8IHRoaXMuYWxsTmVpZ2hib3JzQ291bnQ7XG5cbiAgICAvLyBSZXR1cm4gdGhlIHJlbGF0ZWQgbm9kZTpcbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJylcbiAgICAgIHJldHVybiB3aGljaFt2XTtcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiB0aGUgcmVsYXRlZCBub2RlOlxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh3aGljaFt2W2ldXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnZGVncmVlOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2RlZ3JlZTogV3JvbmcgYXJndW1lbnRzLic7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZHMgcmV0dXJucyBvbmUgb3Igc2V2ZXJhbCBlZGdlcywgZGVwZW5kaW5nIG9uIGhvdyBpdCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIFRvIGdldCB0aGUgYXJyYXkgb2YgZWRnZXMsIGNhbGwgXCJlZGdlc1wiIHdpdGhvdXQgYXJndW1lbnQuIFRvIGdldCBhXG4gICAqIHNwZWNpZmljIGVkZ2UsIGNhbGwgaXQgd2l0aCB0aGUgaWQgb2YgdGhlIGVkZ2UuIFRoZSBnZXQgbXVsdGlwbGUgZWRnZSxcbiAgICogY2FsbCBpdCB3aXRoIGFuIGFycmF5IG9mIGlkcywgYW5kIGl0IHdpbGwgcmV0dXJuIHRoZSBhcnJheSBvZiBlZGdlcywgaW5cbiAgICogdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSAgez8oc3RyaW5nfGFycmF5KX0gdiBFdmVudHVhbGx5IG9uZSBpZCwgYW4gYXJyYXkgb2YgaWRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8YXJyYXl9ICAgICAgVGhlIHJlbGF0ZWQgZWRnZSBvciBhcnJheSBvZiBlZGdlcy5cbiAgICovXG4gIGdyYXBoLmFkZE1ldGhvZCgnZWRnZXMnLCBmdW5jdGlvbih2KSB7XG4gICAgLy8gQ2xvbmUgdGhlIGFycmF5IG9mIGVkZ2VzIGFuZCByZXR1cm4gaXQ6XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuZWRnZXNBcnJheS5zbGljZSgwKTtcblxuICAgIC8vIFJldHVybiB0aGUgcmVsYXRlZCBlZGdlOlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInKSlcbiAgICAgIHJldHVybiB0aGlzLmVkZ2VzSW5kZXhbdl07XG5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHJlbGF0ZWQgZWRnZTpcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICApIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gdi5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICh0eXBlb2YgdltpXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZbaV0gPT09ICdudW1iZXInKVxuICAgICAgICAgIGEucHVzaCh0aGlzLmVkZ2VzSW5kZXhbdltpXV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdGhyb3cgJ2VkZ2VzOiBXcm9uZyBhcmd1bWVudHMuJztcbiAgfSk7XG5cblxuICAvKipcbiAgICogRVhQT1JUOlxuICAgKiAqKioqKioqXG4gICAqL1xuICBpZiAodHlwZW9mIHNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNpZ21hLmNsYXNzZXMgPSBzaWdtYS5jbGFzc2VzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2lnbWEuY2xhc3Nlcy5ncmFwaCA9IGdyYXBoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdyYXBoO1xuICAgIGV4cG9ydHMuZ3JhcGggPSBncmFwaDtcbiAgfSBlbHNlXG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2xhc3NlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY2FtZXJhIGNvbnN0cnVjdG9yLiBJdCBqdXN0IGluaXRpYWxpemVzIGl0cyBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIGlkICAgICAgIFRoZSBpZC5cbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gIGdyYXBoICAgIFRoZSBncmFwaC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgb3B0aW9ucyAgRXZlbnR1YWxseSBzb21lIG92ZXJyaWRpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Y2FtZXJhfSAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBmcmVzaCBuZXcgY2FtZXJhIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEgPSBmdW5jdGlvbihpZCwgZ3JhcGgsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZ3JhcGgnLCB7XG4gICAgICB2YWx1ZTogZ3JhcGhcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgdmFsdWU6IGlkXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkUHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdyZWFkX2NhbScgKyBpZCArICc6J1xuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJlZml4Jywge1xuICAgICAgdmFsdWU6ICdjYW0nICsgaWQgKyAnOidcbiAgICB9KTtcblxuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLnJhdGlvID0gMTtcbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLmlzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHRpbmdzID0gKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zKSA/XG4gICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdChvcHRpb25zKSA6XG4gICAgICBzZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY2FtZXJhIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvb3JkaW5hdGVzIFRoZSBuZXcgY29vcmRpbmF0ZXMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICAgICAgIFJldHVybnMgdGhlIGNhbWVyYS5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nb1RvID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MoJ2VuYWJsZUNhbWVyYScpKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYyA9IGNvb3JkaW5hdGVzIHx8IHt9LFxuICAgICAgICBrZXlzID0gWyd4JywgJ3knLCAncmF0aW8nLCAnYW5nbGUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGlmIChjW2tleXNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjW2tleXNbaV1dID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oY1trZXlzW2ldXSkpXG4gICAgICAgICAgdGhpc1trZXlzW2ldXSA9IGNba2V5c1tpXV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyAnVmFsdWUgZm9yIFwiJyArIGtleXNbaV0gKyAnXCIgaXMgbm90IGEgbnVtYmVyLic7XG4gICAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2Nvb3JkaW5hdGVzVXBkYXRlZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhIGdyYXBoIGFuZCBjb21wdXRlcyBmb3IgZWFjaCBub2RlIGFuZCBlZGdlcyBpdHNcbiAgICogY29vcmRpbmF0ZXMgcmVsYXRpdmVseSB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW1lcmEuIEJhc2ljYWxseSwgaXQgd2lsbFxuICAgKiBjb21wdXRlIHRoZSBjb29yZGluYXRlcyB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgZ3JhcGhpYyByZW5kZXJlcnMuXG4gICAqXG4gICAqIFNpbmNlIGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgZGlmZmVyZW50IGNhbWVyYXMgYW5kIGRpZmZlcmVudFxuICAgKiByZW5kZXJlcnMsIGl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYSBwcmVmaXggdG8gcHV0IGJlZm9yZSB0aGUgbmV3XG4gICAqIGNvb3JkaW5hdGVzICh0byBnZXQgc29tZXRoaW5nIGxpa2UgXCJub2RlLmNhbWVyYTFfeFwiKVxuICAgKlxuICAgKiBAcGFyYW0gIHs/c3RyaW5nfSByZWFkICAgIFRoZSBwcmVmaXggb2YgdGhlIGNvb3JkaW5hdGVzIHRvIHJlYWQuXG4gICAqIEBwYXJhbSAgez9zdHJpbmd9IHdyaXRlICAgVGhlIHByZWZpeCBvZiB0aGUgY29vcmRpbmF0ZXMgdG8gd3JpdGUuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy4gVGhvc2UgY2FuIGJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSByZXN0cmljdGVkIGVkZ2VzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQSB3aWR0aC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAtIEEgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHtjYW1lcmF9ICAgICAgICBSZXR1cm5zIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuYXBwbHlWaWV3ID0gZnVuY3Rpb24ocmVhZCwgd3JpdGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB3cml0ZSA9IHdyaXRlICE9PSB1bmRlZmluZWQgPyB3cml0ZSA6IHRoaXMucHJlZml4O1xuICAgIHJlYWQgPSByZWFkICE9PSB1bmRlZmluZWQgPyByZWFkIDogdGhpcy5yZWFkUHJlZml4O1xuXG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5ub2RlcyB8fCB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGVkZ2VzID0gb3B0aW9ucy5lZGdlcyB8fCB0aGlzLmdyYXBoLmVkZ2VzKCk7XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcmVsQ29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLyB0aGlzLnJhdGlvLFxuICAgICAgICByZWxTaW4gPSBNYXRoLnNpbih0aGlzLmFuZ2xlKSAvIHRoaXMucmF0aW8sXG4gICAgICAgIG5vZGVSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ25vZGVzUG93UmF0aW8nKSksXG4gICAgICAgIGVkZ2VSYXRpbyA9IE1hdGgucG93KHRoaXMucmF0aW8sIHRoaXMuc2V0dGluZ3MoJ2VkZ2VzUG93UmF0aW8nKSksXG4gICAgICAgIHhPZmZzZXQgPSAob3B0aW9ucy53aWR0aCB8fCAwKSAvIDIgLSB0aGlzLnggKiByZWxDb3MgLSB0aGlzLnkgKiByZWxTaW4sXG4gICAgICAgIHlPZmZzZXQgPSAob3B0aW9ucy5oZWlnaHQgfHwgMCkgLyAyIC0gdGhpcy55ICogcmVsQ29zICsgdGhpcy54ICogcmVsU2luO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZVt3cml0ZSArICd4J10gPVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbENvcyArXG4gICAgICAgIChub2RlW3JlYWQgKyAneSddIHx8IDApICogcmVsU2luICtcbiAgICAgICAgeE9mZnNldDtcbiAgICAgIG5vZGVbd3JpdGUgKyAneSddID1cbiAgICAgICAgKG5vZGVbcmVhZCArICd5J10gfHwgMCkgKiByZWxDb3MgLVxuICAgICAgICAobm9kZVtyZWFkICsgJ3gnXSB8fCAwKSAqIHJlbFNpbiArXG4gICAgICAgIHlPZmZzZXQ7XG4gICAgICBub2RlW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChub2RlW3JlYWQgKyAnc2l6ZSddIHx8IDApIC9cbiAgICAgICAgbm9kZVJhdGlvO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGwgPSBlZGdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGVkZ2VzW2ldW3dyaXRlICsgJ3NpemUnXSA9XG4gICAgICAgIChlZGdlc1tpXVtyZWFkICsgJ3NpemUnXSB8fCAwKSAvXG4gICAgICAgIGVkZ2VSYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogY2FtZXJhIHRvIHRoZSBmcmFtZSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCBpbiB0aGUgZnJhbWUgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICBjYW1lcmEuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBncmFwaC5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5ncmFwaFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgdmVjdG9yKSB7XG4gICAgdmFyIFggPSAwLFxuICAgICAgICBZID0gMCxcbiAgICAgICAgY29zID0gTWF0aC5jb3ModGhpcy5hbmdsZSksXG4gICAgICAgIHNpbiA9IE1hdGguc2luKHRoaXMuYW5nbGUpO1xuXG4gICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW4gZGlmZmVyZW50aWFsIHZlY3RvcjpcbiAgICBpZiAoIXZlY3Rvcikge1xuICAgICAgWCA9IC0gKHRoaXMueCAqIGNvcyArIHRoaXMueSAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgICAgWSA9IC0gKHRoaXMueSAqIGNvcyAtIHRoaXMueCAqIHNpbikgLyB0aGlzLnJhdGlvO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiAoeCAqIGNvcyArIHkgKiBzaW4pIC8gdGhpcy5yYXRpbyArIFgsXG4gICAgICB5OiAoeSAqIGNvcyAtIHggKiBzaW4pIC8gdGhpcy5yYXRpbyArIFlcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiBncmFwaCB0byB0aGUgZnJhbWUgb2YgdGhlIGNhbWVyYS5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IGluIHRoZSBmcmFtZSBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgaW4gdGhlIGZyYW1lIG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgZ3JhcGguXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgcG9pbnQgY29vcmRpbmF0ZXMgaW4gdGhlIGZyYW1lIG9mIHRoZSBjYW1lcmEuXG4gICAqL1xuICBzaWdtYS5jbGFzc2VzLmNhbWVyYS5wcm90b3R5cGUuY2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB2ZWN0b3IpIHtcbiAgICB2YXIgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgc2luID0gTWF0aC5zaW4odGhpcy5hbmdsZSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9yaWdpbiBkaWZmZXJlbnRpYWwgdmVjdG9yOlxuICAgIGlmICghdmVjdG9yKSB7XG4gICAgICBYID0gLSAodGhpcy54ICogY29zICsgdGhpcy55ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgICBZID0gLSAodGhpcy55ICogY29zIC0gdGhpcy54ICogc2luKSAvIHRoaXMucmF0aW87XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICgoeCAtIFgpICogY29zIC0gKHkgLSBZKSAqIHNpbikgKiB0aGlzLnJhdGlvLFxuICAgICAgeTogKCh5IC0gWSkgKiBjb3MgKyAoeCAtIFgpICogc2luKSAqIHRoaXMucmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIGNhbWVyYS4gVGhpcyBpc1xuICAgKiBlc3BlY2lhbGx5IHVzZWZ1bCB0byBhcHBseSB0aGUgY2FtZXJhIHZpZXcgZGlyZWN0bHkgaW4gc2hhZGVycywgaW4gY2FzZSBvZlxuICAgKiBXZWJHTCByZW5kZXJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgKi9cbiAgc2lnbWEuY2xhc3Nlcy5jYW1lcmEucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLnNjYWxlKDEgLyB0aGlzLnJhdGlvKSxcbiAgICAgICAgcm90YXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbih0aGlzLmFuZ2xlKSxcbiAgICAgICAgdHJhbnNsYXRpb24gPSBzaWdtYS51dGlscy5tYXRyaWNlcy50cmFuc2xhdGlvbigtdGhpcy54LCAtdGhpcy55KSxcbiAgICAgICAgbWF0cml4ID0gc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgdHJhbnNsYXRpb24sXG4gICAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMubXVsdGlwbHkoXG4gICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgIHNjYWxlXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfTtcblxuICAvKipcbiAgICogVGFraW5nIGEgd2lkdGggYW5kIGEgaGVpZ2h0IGFzIHBhcmFtZXRlcnMsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlXG4gICAqIGNvb3JkaW5hdGVzIG9mIHRoZSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoZSBjYW1lcmEgb24gc2NyZWVuLCBpbiB0aGVcbiAgICogZ3JhcGgncyByZWZlcmVudGllbC5cbiAgICpcbiAgICogVG8ga2VlcCBkaXNwbGF5aW5nIGxhYmVscyBvZiBub2RlcyBnb2luZyBvdXQgb2YgdGhlIHNjcmVlbiwgdGhlIG1ldGhvZFxuICAgKiBrZWVwcyBhIG1hcmdpbiBhcm91bmQgdGhlIHNjcmVlbiBpbiB0aGUgcmV0dXJuZWQgcmVjdGFuZ2xlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHNjcmVlbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgcmVjdGFuZ2xlIGFzIHgxLCB5MSwgeDIgYW5kIHkyLCByZXByZXNlbnRpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdHdvIG9wcG9zaXRlIHBvaW50cy5cbiAgICovXG4gIHNpZ21hLmNsYXNzZXMuY2FtZXJhLnByb3RvdHlwZS5nZXRSZWN0YW5nbGUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoVmVjdCA9IHRoaXMuY2FtZXJhUG9zaXRpb24od2lkdGgsIDAsIHRydWUpLFxuICAgICAgICBoZWlnaHRWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbigwLCBoZWlnaHQsIHRydWUpLFxuICAgICAgICBjZW50ZXJWZWN0ID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHRydWUpLFxuICAgICAgICBtYXJnaW5YID0gdGhpcy5jYW1lcmFQb3NpdGlvbih3aWR0aCAvIDQsIDAsIHRydWUpLngsXG4gICAgICAgIG1hcmdpblkgPSB0aGlzLmNhbWVyYVBvc2l0aW9uKDAsIGhlaWdodCAvIDQsIHRydWUpLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHRoaXMueCAtIGNlbnRlclZlY3QueCAtIG1hcmdpblgsXG4gICAgICB5MTogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSxcbiAgICAgIHgyOiB0aGlzLnggLSBjZW50ZXJWZWN0LnggKyBtYXJnaW5YICsgd2lkdGhWZWN0LngsXG4gICAgICB5MjogdGhpcy55IC0gY2VudGVyVmVjdC55IC0gbWFyZ2luWSArIHdpZHRoVmVjdC55LFxuICAgICAgaGVpZ2h0OiBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGhlaWdodFZlY3QueCwgMikgK1xuICAgICAgICBNYXRoLnBvdyhoZWlnaHRWZWN0LnkgKyAyICogbWFyZ2luWSwgMilcbiAgICAgIClcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBTaWdtYSBRdWFkdHJlZSBNb2R1bGVcbiAgICogPT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgcmVjdGFuZ2xlIGlzIGF4aXMtYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqL1xuICAgIGlzQXhpc0FsaWduZWQ6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiByLngxID09PSByLngyIHx8IHIueTEgPT09IHIueTI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdG9wIHBvaW50cyBvZiBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlLiBUaGlzIGlzIHVzZWZ1bCBpblxuICAgICAqIGNhc2VzIHdoZW4gdGhlIHJlY3RhbmdsZSBoYXMgYmVlbiByb3RhdGVkIChsZWZ0LCByaWdodCBvciBib3R0b20gdXApIGFuZFxuICAgICAqIGxhdGVyIG9wZXJhdGlvbnMgbmVlZCB0byBrbm93IHRoZSB0b3AgcG9pbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50c1xuICAgICAqICAgICAgICAgICAgICAgICAgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHJlY3RhbmdsZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBheGlzQWxpZ25lZFRvcFBvaW50czogZnVuY3Rpb24ocikge1xuXG4gICAgICAvLyBCYXNpY1xuICAgICAgaWYgKHIueTEgPT09IHIueTIgJiYgci54MSA8IHIueDIpXG4gICAgICAgIHJldHVybiByO1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIHJpZ2h0XG4gICAgICBpZiAoci54MSA9PT0gci54MiAmJiByLnkyID4gci55MSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogci54MSAtIHIuaGVpZ2h0LCB5MTogci55MSxcbiAgICAgICAgICB4Mjogci54MSwgeTI6IHIueTEsXG4gICAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAvLyBSb3RhdGVkIHRvIGxlZnRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPCByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxLCB5MTogci55MixcbiAgICAgICAgICB4Mjogci54MiArIHIuaGVpZ2h0LCB5Mjogci55MixcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIEJvdHRvbSdzIHVwXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogci54MiwgeTE6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgeDI6IHIueDEsIHkyOiByLnkxIC0gci5oZWlnaHQsXG4gICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb29yZGluYXRlcyBvZiBhIHJlY3RhbmdsZSdzIGxvd2VyIGxlZnQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlckxlZnRDb29yOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgd2lkdGggPSAoXG4gICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhyLngyIC0gci54MSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHIueTIgLSByLnkxLCAyKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByLngxIC0gKHIueTIgLSByLnkxKSAqIHIuaGVpZ2h0IC8gd2lkdGgsXG4gICAgICAgIHk6IHIueTEgKyAoci54MiAtIHIueDEpICogci5oZWlnaHQgLyB3aWR0aFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgcmlnaHQgY29ybmVyIGZyb20gaXRzIHRvcCBwb2ludHNcbiAgICAgKiBhbmQgaXRzIGxvd2VyIGxlZnQgY29ybmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSBjb3JuZXIncyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgY29ybmVyICh4LCB5KS5cbiAgICAgKi9cbiAgICBsb3dlclJpZ2h0Q29vcjogZnVuY3Rpb24ociwgbGxjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbGMueCAtIHIueDEgKyByLngyLFxuICAgICAgICB5OiBsbGMueSAtIHIueTEgKyByLnkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvb3JkaW5hdGVzIG9mIGFsbCB0aGUgY29ybmVycyBvZiBhIHJlY3RhbmdsZSBmcm9tIGl0cyB0b3AgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiB0aGUgZm91ciBjb3JuZXJzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29ybmVyczogZnVuY3Rpb24ocikge1xuICAgICAgdmFyIGxsYyA9IHRoaXMubG93ZXJMZWZ0Q29vcihyKSxcbiAgICAgICAgICBscmMgPSB0aGlzLmxvd2VyUmlnaHRDb29yKHIsIGxsYyk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt4OiByLngxLCB5OiByLnkxfSxcbiAgICAgICAge3g6IHIueDIsIHk6IHIueTJ9LFxuICAgICAgICB7eDogbGxjLngsIHk6IGxsYy55fSxcbiAgICAgICAge3g6IGxyYy54LCB5OiBscmMueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IGEgc3F1YXJlIGRlZmluZWQgYnkgaXRzIGJvdW5kYXJpZXMgaW50byBmb3VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBCb3VuZGFyaWVzIG9mIHRoZSBzcXVhcmUgKHgsIHksIHdpZHRoLCBoZWlnaHQpLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm91ciBuZXcgc3F1YXJlcywgdGhlbXNlbHZlc1xuICAgICAqICAgICAgICAgICAgICAgICAgZGVmaW5lZCBieSBhbiBhcnJheSBvZiB0aGVpciBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqL1xuICAgIHNwbGl0U3F1YXJlOiBmdW5jdGlvbihiKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueX0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn1cbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLngsIHk6IGIueSArIGIuaGVpZ2h0fSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnkgKyBiLmhlaWdodH1cbiAgICAgICAgXVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgZm91ciBheGlzIGJldHdlZW4gY29ybmVycyBvZiByZWN0YW5nbGUgQSBhbmQgY29ybmVycyBvZlxuICAgICAqIHJlY3RhbmdsZSBCLiBUaGlzIGlzIG5lZWRlZCBsYXRlciB0byBjaGVjayBhbiBldmVudHVhbCBjb2xsaXNpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gQW4gYXJyYXkgb2YgcmVjdGFuZ2xlIEEncyBmb3VyIGNvcm5lcnMgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQidzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIGZvdXIgYXhpcyBkZWZpbmVkIGJ5IHRoZWlyIGNvb3JkaW5hdGVzICh4LHkpLlxuICAgICAqL1xuICAgIGF4aXM6IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVswXS54LCB5OiBjMVsxXS55IC0gYzFbMF0ueX0sXG4gICAgICAgIHt4OiBjMVsxXS54IC0gYzFbM10ueCwgeTogYzFbMV0ueSAtIGMxWzNdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzJdLngsIHk6IGMyWzBdLnkgLSBjMlsyXS55fSxcbiAgICAgICAge3g6IGMyWzBdLnggLSBjMlsxXS54LCB5OiBjMlswXS55IC0gYzJbMV0ueX1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3QgYSByZWN0YW5nbGUncyBjb3JuZXIgb24gYW4gYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBjb3JuZXIgKHgsIHkpLlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYW4gYXhpcyAoeCwgeSkuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvamVjdGlvbiBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbihjLCBhKSB7XG4gICAgICB2YXIgbCA9IChcbiAgICAgICAgKGMueCAqIGEueCArIGMueSAqIGEueSkgL1xuICAgICAgICAoTWF0aC5wb3coYS54LCAyKSArIE1hdGgucG93KGEueSwgMikpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsICogYS54LFxuICAgICAgICB5OiBsICogYS55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGNvbGxpZGUgb24gb25lIHBhcnRpY3VsYXIgYXhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICBBbiBheGlzJyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBBJ3MgY29ybmVycy5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEIncyBjb3JuZXJzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGNvbGxpZGUgb24gdGhlIGF4aXMuXG4gICAgICovXG4gICAgYXhpc0NvbGxpc2lvbjogZnVuY3Rpb24oYSwgYzEsIGMyKSB7XG4gICAgICB2YXIgc2MxID0gW10sXG4gICAgICAgICAgc2MyID0gW107XG5cbiAgICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCA0OyBjaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvamVjdGlvbihjMVtjaV0sIGEpLFxuICAgICAgICAgICAgcDIgPSB0aGlzLnByb2plY3Rpb24oYzJbY2ldLCBhKTtcblxuICAgICAgICBzYzEucHVzaChwMS54ICogYS54ICsgcDEueSAqIGEueSk7XG4gICAgICAgIHNjMi5wdXNoKHAyLnggKiBhLnggKyBwMi55ICogYS55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heGMxID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MxKSxcbiAgICAgICAgICBtYXhjMiA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjMiksXG4gICAgICAgICAgbWluYzEgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1pbmMyID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgc2MyKTtcblxuICAgICAgcmV0dXJuIChtaW5jMiA8PSBtYXhjMSAmJiBtYXhjMiA+PSBtaW5jMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBlYWNoIG9uZSBvZiB0aGVpciBmb3VyIGF4aXMuIElmXG4gICAgICogYWxsIGF4aXMgY29sbGlkZSwgdGhlbiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gY29sbGlkZSBvbiB0aGUgcGxhbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZS5cbiAgICAgKi9cbiAgICBjb2xsaXNpb246IGZ1bmN0aW9uKGMxLCBjMikge1xuICAgICAgdmFyIGF4aXMgPSB0aGlzLmF4aXMoYzEsIGMyKSxcbiAgICAgICAgICBjb2wgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICAgICAgY29sID0gY29sICYmIHRoaXMuYXhpc0NvbGxpc2lvbihheGlzW2ldLCBjMSwgYzIpO1xuXG4gICAgICByZXR1cm4gY29sO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBRdWFkIEZ1bmN0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS1cbiAgICpcbiAgICogVGhlIFF1YWR0cmVlIGZ1bmN0aW9ucyB0aGVtc2VsdmVzLlxuICAgKiBGb3IgZWFjaCBvZiB0aG9zZSBmdW5jdGlvbnMsIHdlIGNvbnNpZGVyIHRoYXQgaW4gYSBzcGxpdHRlZCBxdWFkLCB0aGVcbiAgICogaW5kZXggb2YgZWFjaCBub2RlIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAqIDA6IHRvcCBsZWZ0XG4gICAqIDE6IHRvcCByaWdodFxuICAgKiAyOiBib3R0b20gbGVmdFxuICAgKiAzOiBib3R0b20gcmlnaHRcbiAgICpcbiAgICogTW9yZW92ZXIsIHRoZSBoZXJlYWZ0ZXIgcXVhZCdzIHBoaWxvc29waHkgaXMgdG8gY29uc2lkZXIgdGhhdCBpZiBhbiBlbGVtZW50XG4gICAqIGNvbGxpZGVzIHdpdGggbW9yZSB0aGFuIG9uZSBub2RlcywgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gZWFjaCBvZiB0aGVcbiAgICogbm9kZXMgaXQgY29sbGlkZXMgd2l0aCB3aGVyZSBvdGhlciB3b3VsZCBsZXQgaXQgbGllIG9uIGEgaGlnaGVyIG5vZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIHBvaW50IGluIHRoZSBxdWFkXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50ICAgICAgQSBwb2ludCBkZWZpbmVkIGJ5IGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZEJvdW5kcyBCb3VuZGFyaWVzIG9mIHRoZSBxdWFkICh4LCB5LCB3aWR0aCwgaGVpZ3RoKS5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4KHBvaW50LCBxdWFkQm91bmRzKSB7XG4gICAgdmFyIHhtcCA9IHF1YWRCb3VuZHMueCArIHF1YWRCb3VuZHMud2lkdGggLyAyLFxuICAgICAgICB5bXAgPSBxdWFkQm91bmRzLnkgKyBxdWFkQm91bmRzLmhlaWdodCAvIDIsXG4gICAgICAgIHRvcCA9IChwb2ludC55IDwgeW1wKSxcbiAgICAgICAgbGVmdCA9IChwb2ludC54IDwgeG1wKTtcblxuICAgIGlmICh0b3ApIHtcbiAgICAgIGlmIChsZWZ0KVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAyO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbmRleGVzIG9mIG5vZGVzIGNvbnRhaW5pbmcgYW4gYXhpcy1hbGlnbmVkIHJlY3RhbmdsZVxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICByZWN0YW5nbGUgICBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byBwb2ludHMgKHgxLCB5MSksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIHF1YWRDb3JuZXJzIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZEluZGV4ZXMocmVjdGFuZ2xlLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKChyZWN0YW5nbGUueDIgPj0gcXVhZENvcm5lcnNbaV1bMF0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLngxIDw9IHF1YWRDb3JuZXJzW2ldWzFdLngpICYmXG4gICAgICAgICAgKHJlY3RhbmdsZS55MSArIHJlY3RhbmdsZS5oZWlnaHQgPj0gcXVhZENvcm5lcnNbaV1bMF0ueSkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxIDw9IHF1YWRDb3JuZXJzW2ldWzJdLnkpKVxuICAgICAgICBpbmRleGVzLnB1c2goaSk7XG5cbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhIG5vbi1heGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgY29ybmVycyAgICAgIEFuIGFycmF5IGNvbnRhaW5pbmcgZWFjaCBjb3JuZXIgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IGl0cyBjb29yZGluYXRlcyAoeCwgeSkuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgcXVhZENvcm5lcnMgIEFuIGFycmF5IG9mIHRoZSBxdWFkIG5vZGVzJyBjb3JuZXJzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICBBbiBhcnJheSBvZiBpbmRleGVzIGNvbnRhaW5pbmcgb25lIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdXIgaW50ZWdlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZENvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVycykge1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICAvLyBJdGVyYXRpbmcgdGhyb3VnaCBxdWFkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgaWYgKF9nZW9tLmNvbGxpc2lvbihjb3JuZXJzLCBxdWFkQ29ybmVyc1tpXSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YmRpdmlkZSBhIHF1YWQgYnkgY3JlYXRpbmcgYSBub2RlIGF0IGEgcHJlY2lzZSBpbmRleC4gVGhlIGZ1bmN0aW9uIGRvZXNcbiAgICogbm90IGdlbmVyYXRlIGFsbCBmb3VyIG5vZGVzIG5vdCB0byBwb3RlbnRpYWxseSBjcmVhdGUgdW51c2VkIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIHF1YWQgIFRoZSBxdWFkIG9iamVjdCB0byBzdWJkaXZpZGUuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBBIG5ldyBxdWFkIHJlcHJlc2VudGluZyB0aGUgbm9kZSBjcmVhdGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRTdWJkaXZpZGUoaW5kZXgsIHF1YWQpIHtcbiAgICB2YXIgbmV4dCA9IHF1YWQubGV2ZWwgKyAxLFxuICAgICAgICBzdWJ3ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy53aWR0aCAvIDIpLFxuICAgICAgICBzdWJoID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy5oZWlnaHQgLyAyKSxcbiAgICAgICAgcXggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLngpLFxuICAgICAgICBxeSA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueSksXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggPSBxeDtcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgeCA9IHF4ICsgc3VidztcbiAgICAgICAgeSA9IHF5ICsgc3ViaDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWFkVHJlZShcbiAgICAgIHt4OiB4LCB5OiB5LCB3aWR0aDogc3VidywgaGVpZ2h0OiBzdWJofSxcbiAgICAgIG5leHQsXG4gICAgICBxdWFkLm1heEVsZW1lbnRzLFxuICAgICAgcXVhZC5tYXhMZXZlbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgaW5zZXJ0IGFuIGVsZW1lbnQgaW50byB0aGUgcXVhZHRyZWUuIE9ubHkgcG9pbnRzXG4gICAqIHdpdGggc2l6ZSwgaS5lLiBheGlzLWFsaWduZWQgc3F1YXJlcywgbWF5IGJlIGluc2VydGVkIHdpdGggdGhpc1xuICAgKiBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGVsICAgICAgICAgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGluIHRoZSBxdWFkdHJlZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgc2l6ZWRQb2ludCBBIHNpemVkIHBvaW50IGRlZmluZWQgYnkgdHdvIHRvcCBwb2ludHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcXVhZCAgICAgICBUaGUgcXVhZCBpbiB3aGljaCB0byBpbnNlcnQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgVGhlIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhbnl0aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG5cbiAgICAgIC8vIFNlYXJjaGluZyBhcHByb3ByaWF0ZSBxdWFkc1xuICAgICAgdmFyIGluZGV4ZXMgPSBfcXVhZEluZGV4ZXMoc2l6ZWRQb2ludCwgcXVhZC5jb3JuZXJzKTtcblxuICAgICAgLy8gSXRlcmF0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gU3ViZGl2aWRpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSA9IF9xdWFkU3ViZGl2aWRlKGluZGV4ZXNbaV0sIHF1YWQpO1xuXG4gICAgICAgIC8vIFJlY3Vyc2lvblxuICAgICAgICBfcXVhZEluc2VydChlbCwgc2l6ZWRQb2ludCwgcXVhZC5ub2Rlc1tpbmRleGVzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAvLyBQdXNoaW5nIHRoZSBlbGVtZW50IGluIGEgbGVhZiBub2RlXG4gICAgICBxdWFkLmVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSByZXRyaWV2ZSBldmVyeSBlbGVtZW50cyBoZWxkIGJ5IHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlXG4gICAqIHNlYXJjaGVkIHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBwb2ludCBUaGUgc2VhcmNoZWQgcG9pbnQgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSByZWxldmFudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZVBvaW50KHBvaW50LCBxdWFkKSB7XG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXggPSBfcXVhZEluZGV4KHBvaW50LCBxdWFkLmJvdW5kcyk7XG5cbiAgICAgIC8vIElmIG5vZGUgZG9lcyBub3QgZXhpc3Qgd2UgcmV0dXJuIGFuIGVtcHR5IGxpc3RcbiAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQubm9kZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHF1YWQuZWxlbWVudHM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGNvbnRhaW5lZCB3aXRoaW4gYW4gcmVjdGFuZ3VsYXIgYXJlYVxuICAgKiB0aGF0IG1heSBvciBtYXkgbm90IGJlIGF4aXMtYWxpZ25lZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fGFycmF5fSByZWN0RGF0YSAgICAgICBUaGUgc2VhcmNoZWQgYXJlYSBkZWZpbmVkIGVpdGhlciBieVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGFycmF5IG9mIGZvdXIgY29ybmVycyAoeCwgeSkgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FzZSBvZiBhIG5vbi1heGlzLWFsaWduZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0YW5nbGUgb3IgYW4gb2JqZWN0IHdpdGggdHdvIHRvcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICBxdWFkICAgICAgICAgICBUaGUgc2VhcmNoZWQgcXVhZC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICBjb2xsaXNpb25GdW5jICBUaGUgY29sbGlzaW9uIGZ1bmN0aW9uIHVzZWQgdG8gc2VhcmNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG5vZGUgaW5kZXhlcy5cbiAgICogQHBhcmFtICB7YXJyYXk/fSAgICAgICBlbHMgICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRSZXRyaWV2ZUFyZWEocmVjdERhdGEsIHF1YWQsIGNvbGxpc2lvbkZ1bmMsIGVscykge1xuICAgIGVscyA9IGVscyB8fCB7fTtcblxuICAgIGlmIChxdWFkLmxldmVsIDwgcXVhZC5tYXhMZXZlbCkge1xuICAgICAgdmFyIGluZGV4ZXMgPSBjb2xsaXNpb25GdW5jKHJlY3REYXRhLCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAocXVhZC5ub2Rlc1tpbmRleGVzW2ldXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICAgICAgcmVjdERhdGEsXG4gICAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dLFxuICAgICAgICAgICAgY29sbGlzaW9uRnVuYyxcbiAgICAgICAgICAgIGVsc1xuICAgICAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHF1YWQuZWxlbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKVxuICAgICAgICBpZiAoZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgZWxzW3F1YWQuZWxlbWVudHNbal0uaWRdID0gcXVhZC5lbGVtZW50c1tqXTtcblxuICAgIHJldHVybiBlbHM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgcXVhZHRyZWUgb2JqZWN0IGl0c2VsZi5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgIGJvdW5kcyAgICAgICBUaGUgYm91bmRhcmllcyBvZiB0aGUgcXVhZCBkZWZpbmVkIGJ5IGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luICh4LCB5KSwgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIGxldmVsICAgICAgICBUaGUgbGV2ZWwgb2YgdGhlIHF1YWQgaW4gdGhlIHRyZWUuXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBtYXhFbGVtZW50cyAgVGhlIG1heCBudW1iZXIgb2YgZWxlbWVudCBpbiBhIGxlYWYgbm9kZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heExldmVsICAgICBUaGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRUcmVlKGJvdW5kcywgbGV2ZWwsIG1heEVsZW1lbnRzLCBtYXhMZXZlbCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogbGV2ZWwgfHwgMCxcbiAgICAgIGJvdW5kczogYm91bmRzLFxuICAgICAgY29ybmVyczogX2dlb20uc3BsaXRTcXVhcmUoYm91bmRzKSxcbiAgICAgIG1heEVsZW1lbnRzOiBtYXhFbGVtZW50cyB8fCAyMCxcbiAgICAgIG1heExldmVsOiBtYXhMZXZlbCB8fCA0LFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgbm9kZXM6IFtdXG4gICAgfTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ21hIFF1YWQgQ29uc3RydWN0b3JcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBxdWFkIGNvcmUgdGhhdCB3aWxsIGJlY29tZSB0aGUgc2lnbWEgaW50ZXJmYWNlIHdpdGggdGhlIHF1YWR0cmVlLlxuICAgKlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfdHJlZSAgUHJvcGVydHkgaG9sZGluZyB0aGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfZ2VvbSAgRXhwb3NpdGlvbiBvZiB0aGUgX2dlb20gbmFtZXNwYWNlIGZvciB0ZXN0aW5nLlxuICAgKiBwcm9wZXJ0eSB7b2JqZWN0fSBfY2FjaGUgQ2FjaGUgZm9yIHRoZSBhcmVhIG1ldGhvZC5cbiAgICovXG4gIHZhciBxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBub2RlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBub2RlcyAgIEFuIGFycmF5IG9mIG5vZGVzIHRvIGluZGV4LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgQW4gb2JqZWN0IG9mIHBhcmFtZXRlcnMgd2l0aCBhdCBsZWFzdCB0aGUgcXVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgVGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICpcbiAgICogUGFyYW1ldGVyczpcbiAgICogLS0tLS0tLS0tLVxuICAgKiBib3VuZHM6ICAgICAge29iamVjdH0gICBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgaXRzIG9yaWdpbiAoeCwgeSlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggYW5kIGhlaWd0aC5cbiAgICogcHJlZml4OiAgICAgIHtzdHJpbmc/fSAgYSBwcmVmaXggZm9yIG5vZGUgZ2VvbWV0cmljIGF0dHJpYnV0ZXMuXG4gICAqIG1heEVsZW1lbnRzOiB7aW50ZWdlcj99IHRoZSBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIGEgbGVhZiBub2RlLlxuICAgKiBtYXhMZXZlbDogICAge2ludGVnZXI/fSB0aGUgbWF4IHJlY3Vyc2lvbiBsZXZlbCBvZiB0aGUgdHJlZS5cbiAgICovXG4gIHF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24obm9kZXMsIHBhcmFtcykge1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5xdWFkLmluZGV4OiBib3VuZHMgaW5mb3JtYXRpb24gbm90IGdpdmVuLic7XG5cbiAgICAvLyBQcmVmaXhcbiAgICB2YXIgcHJlZml4ID0gcGFyYW1zLnByZWZpeCB8fCAnJztcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIC8vIEluc2VydGluZyBncmFwaCBub2RlcyBpbnRvIHRoZSB0cmVlXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgLy8gSW5zZXJ0aW5nIG5vZGVcbiAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICBub2Rlc1tpXSxcbiAgICAgICAgX2dlb20ucG9pbnRUb1NxdWFyZSh7XG4gICAgICAgICAgeDogbm9kZXNbaV1bcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5OiBub2Rlc1tpXVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHNpemU6IG5vZGVzW2ldW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgfSksXG4gICAgICAgIHRoaXMuX3RyZWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBub2RlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBxdWFkLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZSA/XG4gICAgICBfcXVhZFJldHJpZXZlUG9pbnQoe3g6IHgsIHk6IHl9LCB0aGlzLl90cmVlKSB8fCBbXSA6XG4gICAgICBbXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggbm9kZXMgd2l0aGluIGEgcmVjdGFuZ3VsYXIgYXJlYS4gVGhlIG1ldGhvZHMga2VlcCB0aGVcbiAgICogbGFzdCBhcmVhIHF1ZXJpZWQgaW4gY2FjaGUgZm9yIG9wdGltaXphdGlvbiByZWFzb24gYW5kIHdpbGwgYWN0IGRpZmZlcmVudGx5XG4gICAqIGZvciB0aGUgc2FtZSByZWFzb24gaWYgdGhlIGFyZWEgaXMgYXhpcy1hbGlnbmVkIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBBIHJlY3RhbmdsZSBkZWZpbmVkIGJ5IHR3byB0b3AgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKVxuICAgKiAgICAgICAgICAgICAgICAgIGFuZCBoZWlnaHQuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgQW4gYXJyYXkgb2Ygbm9kZXMgcmV0cmlldmVkLlxuICAgKi9cbiAgcXVhZC5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHJlY3QpLFxuICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICByZWN0RGF0YTtcblxuICAgIC8vIFJldHVybmluZyBjYWNoZT9cbiAgICBpZiAodGhpcy5fY2FjaGUucXVlcnkgPT09IHNlcmlhbGl6ZWQpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGUucmVzdWx0O1xuXG4gICAgLy8gQXhpcyBhbGlnbmVkID9cbiAgICBpZiAoX2dlb20uaXNBeGlzQWxpZ25lZChyZWN0KSkge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkSW5kZXhlcztcbiAgICAgIHJlY3REYXRhID0gX2dlb20uYXhpc0FsaWduZWRUb3BQb2ludHMocmVjdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29sbGlzaW9uRnVuYyA9IF9xdWFkQ29sbGlzaW9uO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5yZWN0YW5nbGVDb3JuZXJzKHJlY3QpO1xuICAgIH1cblxuICAgIC8vIFJldHJpZXZpbmcgbm9kZXNcbiAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmVlID9cbiAgICAgIF9xdWFkUmV0cmlldmVBcmVhKFxuICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgdGhpcy5fdHJlZSxcbiAgICAgICAgY29sbGlzaW9uRnVuY1xuICAgICAgKSA6XG4gICAgICBbXTtcblxuICAgIC8vIE9iamVjdCB0byBhcnJheVxuICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBub2RlcylcbiAgICAgIG5vZGVzQXJyYXkucHVzaChub2Rlc1tpXSk7XG5cbiAgICAvLyBDYWNoaW5nXG4gICAgdGhpcy5fY2FjaGUucXVlcnkgPSBzZXJpYWxpemVkO1xuICAgIHRoaXMuX2NhY2hlLnJlc3VsdCA9IG5vZGVzQXJyYXk7XG5cbiAgICByZXR1cm4gbm9kZXNBcnJheTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFWFBPUlQ6XG4gICAqICoqKioqKipcbiAgICovXG4gIGlmICh0eXBlb2YgdGhpcy5zaWdtYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMgPSB0aGlzLnNpZ21hLmNsYXNzZXMgfHwge307XG4gICAgdGhpcy5zaWdtYS5jbGFzc2VzLnF1YWQgPSBxdWFkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHF1YWQ7XG4gICAgZXhwb3J0cy5xdWFkID0gcXVhZDtcbiAgfSBlbHNlXG4gICAgdGhpcy5xdWFkID0gcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogU2lnbWEgUXVhZHRyZWUgTW9kdWxlIGZvciBlZGdlc1xuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogU8OpYmFzdGllbiBIZXltYW5uLFxuICAgKiAgIGZyb20gdGhlIHF1YWQgb2YgR3VpbGxhdW1lIFBsaXF1ZSAoWW9tZ3VpdGhlcmVhbClcbiAgICogVmVyc2lvbjogMC4yXG4gICAqL1xuXG5cblxuICAvKipcbiAgICogUXVhZCBHZW9tZXRyaWMgT3BlcmF0aW9uc1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIEEgdXNlZnVsIGJhdGNoIG9mIGdlb21ldHJpYyBvcGVyYXRpb25zIHVzZWQgYnkgdGhlIHF1YWR0cmVlLlxuICAgKi9cblxuICB2YXIgX2dlb20gPSB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggbm9kZSB3aXRoIHgsIHkgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggbm9kZSB3aXRoIGF0IGxlYXN0IGEgcG9pbnQgKHgsIHkpIGFuZCBhIHNpemUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBwb2ludFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogbi54IC0gbi5zaXplLFxuICAgICAgICB5MTogbi55IC0gbi5zaXplLFxuICAgICAgICB4Mjogbi54ICsgbi5zaXplLFxuICAgICAgICB5Mjogbi55IC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG4uc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIHdpdGggeDEsIHkxLCB4MiwgeTIgYW5kIHNpemUgaW50byBhblxuICAgICAqIGF4aXMtYWxpZ25lZCBzcXVhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgZ3JhcGggZWRnZSB3aXRoIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gQSBzcXVhcmU6IHR3byBwb2ludHMgKHgxLCB5MSksICh4MiwgeTIpIGFuZCBoZWlnaHQuXG4gICAgICovXG4gICAgbGluZVRvU3F1YXJlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS55MSA8IGUueTIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIHRvcFxuICAgICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gbGVmdFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIHkxOiBlLnkxIC0gZS5zaXplLFxuICAgICAgICAgICAgeDI6IGUueDIgKyBlLnNpemUsXG4gICAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICAgIGhlaWdodDogZS55MiAtIGUueTEgKyBlLnNpemUgKiAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoZS54MSwgZS55MSkgb24gcmlnaHRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MSArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MSAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTIgLSBlLnkxICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAoZS54MiwgZS55Mikgb24gdG9wXG4gICAgICBpZiAoZS54MSA8IGUueDIpIHtcbiAgICAgICAgLy8gKGUueDEsIGUueTEpIG9uIGxlZnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogZS54MSAtIGUuc2l6ZSxcbiAgICAgICAgICB5MTogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICB4MjogZS54MiArIGUuc2l6ZSxcbiAgICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IGUueTEgLSBlLnkyICsgZS5zaXplICogMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gKGUueDIsIGUueTIpIG9uIHJpZ2h0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogZS54MiAtIGUuc2l6ZSxcbiAgICAgICAgeTE6IGUueTIgLSBlLnNpemUsXG4gICAgICAgIHgyOiBlLngxICsgZS5zaXplLFxuICAgICAgICB5MjogZS55MiAtIGUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBlLnkxIC0gZS55MiArIGUuc2l6ZSAqIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBncmFwaCBlZGdlIG9mIHR5cGUgJ2N1cnZlJyB3aXRoIHgxLCB5MSwgeDIsIHkyLFxuICAgICAqIGNvbnRyb2wgcG9pbnQgYW5kIHNpemUgaW50byBhbiBheGlzLWFsaWduZWQgc3F1YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBlICBBIGdyYXBoIGVkZ2Ugd2l0aCBhdCBsZWFzdCB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGEgc2l6ZS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGNwIEEgY29udHJvbCBwb2ludCAoeCx5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgIEEgc3F1YXJlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIHF1YWRyYXRpY0N1cnZlVG9TcXVhcmU6IGZ1bmN0aW9uKGUsIGNwKSB7XG4gICAgICB2YXIgcHQgPSBzaWdtYS51dGlscy5nZXRQb2ludE9uUXVhZHJhdGljQ3VydmUoXG4gICAgICAgIDAuNSxcbiAgICAgICAgZS54MSxcbiAgICAgICAgZS55MSxcbiAgICAgICAgZS54MixcbiAgICAgICAgZS55MixcbiAgICAgICAgY3AueCxcbiAgICAgICAgY3AueVxuICAgICAgKTtcblxuICAgICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSB0d28gcG9pbnRzIGFuZCB0aGUgcG9pbnQgYXQgdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAgIC8vIGN1cnZlOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihlLngxLCBlLngyLCBwdC54KSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoZS54MSwgZS54MiwgcHQueCksXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKGUueTEsIGUueTIsIHB0LnkpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChlLnkxLCBlLnkyLCBwdC55KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IG1pblggLSBlLnNpemUsXG4gICAgICAgIHkxOiBtaW5ZIC0gZS5zaXplLFxuICAgICAgICB4MjogbWF4WCArIGUuc2l6ZSxcbiAgICAgICAgeTI6IG1pblkgLSBlLnNpemUsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBlLnNpemUgKiAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGEgZ3JhcGggc2VsZiBsb29wIGludG8gYW4gYXhpcy1hbGlnbmVkIHNxdWFyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gbiBBIGdyYXBoIG5vZGUgd2l0aCBhIHBvaW50ICh4LCB5KSBhbmQgYSBzaXplLlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gICBBIHNxdWFyZTogdHdvIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBzZWxmTG9vcFRvU3F1YXJlOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBGaXR0aW5nIHRvIHRoZSBjdXJ2ZSBpcyB0b28gY29zdGx5LCB3ZSBjb21wdXRlIGEgbGFyZ2VyIGJvdW5kaW5nIGJveFxuICAgICAgLy8gdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIGNwID0gc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKG4ueCwgbi55LCBuLnNpemUpO1xuXG4gICAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHBvaW50IGFuZCB0aGUgdHdvIGNvbnRyb2wgcG9pbnRzOlxuICAgICAgdmFyIG1pblggPSBNYXRoLm1pbihuLngsIGNwLngxLCBjcC54MiksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG4ueCwgY3AueDEsIGNwLngyKSxcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obi55LCBjcC55MSwgY3AueTIpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChuLnksIGNwLnkxLCBjcC55Mik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBtaW5YIC0gbi5zaXplLFxuICAgICAgICB5MTogbWluWSAtIG4uc2l6ZSxcbiAgICAgICAgeDI6IG1heFggKyBuLnNpemUsXG4gICAgICAgIHkyOiBtaW5ZIC0gbi5zaXplLFxuICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZICsgbi5zaXplICogMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWN0YW5nbGUgaXMgYXhpcy1hbGlnbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAgKHgxLCB5MSkgYW5kICh4MiwgeTIpLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBheGlzLWFsaWduZWQuXG4gICAgICovXG4gICAgaXNBeGlzQWxpZ25lZDogZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHIueDEgPT09IHIueDIgfHwgci55MSA9PT0gci55MjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0b3AgcG9pbnRzIG9mIGFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogY2FzZXMgd2hlbiB0aGUgcmVjdGFuZ2xlIGhhcyBiZWVuIHJvdGF0ZWQgKGxlZnQsIHJpZ2h0IG9yIGJvdHRvbSB1cCkgYW5kXG4gICAgICogbGF0ZXIgb3BlcmF0aW9ucyBuZWVkIHRvIGtub3cgdGhlIHRvcCBwb2ludHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEFuIGF4aXMtYWxpZ25lZCByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzXG4gICAgICogICAgICAgICAgICAgICAgICAoeDEsIHkxKSwgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgcmVjdGFuZ2xlOiB0d28gcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgICAqL1xuICAgIGF4aXNBbGlnbmVkVG9wUG9pbnRzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgIC8vIEJhc2ljXG4gICAgICBpZiAoci55MSA9PT0gci55MiAmJiByLngxIDwgci54MilcbiAgICAgICAgcmV0dXJuIHI7XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gcmlnaHRcbiAgICAgIGlmIChyLngxID09PSByLngyICYmIHIueTIgPiByLnkxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiByLngxIC0gci5oZWlnaHQsIHkxOiByLnkxLFxuICAgICAgICAgIHgyOiByLngxLCB5Mjogci55MSxcbiAgICAgICAgICBoZWlnaHQ6IHIuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgIC8vIFJvdGF0ZWQgdG8gbGVmdFxuICAgICAgaWYgKHIueDEgPT09IHIueDIgJiYgci55MiA8IHIueTEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IHIueDEsIHkxOiByLnkyLFxuICAgICAgICAgIHgyOiByLngyICsgci5oZWlnaHQsIHkyOiByLnkyLFxuICAgICAgICAgIGhlaWdodDogci5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgLy8gQm90dG9tJ3MgdXBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiByLngyLCB5MTogci55MSAtIHIuaGVpZ2h0LFxuICAgICAgICB4Mjogci54MSwgeTI6IHIueTEgLSByLmhlaWdodCxcbiAgICAgICAgaGVpZ2h0OiByLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvb3JkaW5hdGVzIG9mIGEgcmVjdGFuZ2xlJ3MgbG93ZXIgbGVmdCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyTGVmdENvb3I6IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciB3aWR0aCA9IChcbiAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHIueDIgLSByLngxLCAyKSArXG4gICAgICAgICAgTWF0aC5wb3coci55MiAtIHIueTEsIDIpXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHIueDEgLSAoci55MiAtIHIueTEpICogci5oZWlnaHQgLyB3aWR0aCxcbiAgICAgICAgeTogci55MSArIChyLngyIC0gci54MSkgKiByLmhlaWdodCAvIHdpZHRoXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY29vcmRpbmF0ZXMgb2YgYSByZWN0YW5nbGUncyBsb3dlciByaWdodCBjb3JuZXIgZnJvbSBpdHMgdG9wIHBvaW50c1xuICAgICAqIGFuZCBpdHMgbG93ZXIgbGVmdCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBBIGNvcm5lcidzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXIgKHgsIHkpLlxuICAgICAqL1xuICAgIGxvd2VyUmlnaHRDb29yOiBmdW5jdGlvbihyLCBsbGMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGxsYy54IC0gci54MSArIHIueDIsXG4gICAgICAgIHk6IGxsYy55IC0gci55MSArIHIueTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY29vcmRpbmF0ZXMgb2YgYWxsIHRoZSBjb3JuZXJzIG9mIGEgcmVjdGFuZ2xlIGZyb20gaXRzIHRvcCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIHRoZSBmb3VyIGNvcm5lcnMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb3JuZXJzOiBmdW5jdGlvbihyKSB7XG4gICAgICB2YXIgbGxjID0gdGhpcy5sb3dlckxlZnRDb29yKHIpLFxuICAgICAgICAgIGxyYyA9IHRoaXMubG93ZXJSaWdodENvb3IociwgbGxjKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHIueDEsIHk6IHIueTF9LFxuICAgICAgICB7eDogci54MiwgeTogci55Mn0sXG4gICAgICAgIHt4OiBsbGMueCwgeTogbGxjLnl9LFxuICAgICAgICB7eDogbHJjLngsIHk6IGxyYy55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBzcXVhcmUgZGVmaW5lZCBieSBpdHMgYm91bmRhcmllcyBpbnRvIGZvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IEJvdW5kYXJpZXMgb2YgdGhlIHNxdWFyZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkuXG4gICAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmb3VyIG5ldyBzcXVhcmVzLCB0aGVtc2VsdmVzXG4gICAgICogICAgICAgICAgICAgICAgICBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHRoZWlyIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICovXG4gICAgc3BsaXRTcXVhcmU6IGZ1bmN0aW9uKGIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55fSxcbiAgICAgICAgICB7eDogYi54LCB5OiBiLnkgKyBiLmhlaWdodCAvIDJ9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoLCB5OiBiLnl9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfVxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCwgeTogYi55ICsgYi5oZWlnaHR9LFxuICAgICAgICAgIHt4OiBiLnggKyBiLndpZHRoIC8gMiwgeTogYi55ICsgYi5oZWlnaHR9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7eDogYi54ICsgYi53aWR0aCAvIDIsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGggLyAyLCB5OiBiLnkgKyBiLmhlaWdodH0sXG4gICAgICAgICAge3g6IGIueCArIGIud2lkdGgsIHk6IGIueSArIGIuaGVpZ2h0fVxuICAgICAgICBdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBmb3VyIGF4aXMgYmV0d2VlbiBjb3JuZXJzIG9mIHJlY3RhbmdsZSBBIGFuZCBjb3JuZXJzIG9mXG4gICAgICogcmVjdGFuZ2xlIEIuIFRoaXMgaXMgbmVlZGVkIGxhdGVyIHRvIGNoZWNrIGFuIGV2ZW50dWFsIGNvbGxpc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSBBbiBhcnJheSBvZiByZWN0YW5nbGUgQSdzIGZvdXIgY29ybmVycyAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7YXJyYXl9IEFuIGFycmF5IG9mIHJlY3RhbmdsZSBCJ3MgZm91ciBjb3JuZXJzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgZm91ciBheGlzIGRlZmluZWQgYnkgdGhlaXIgY29vcmRpbmF0ZXMgKHgseSkuXG4gICAgICovXG4gICAgYXhpczogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7eDogYzFbMV0ueCAtIGMxWzBdLngsIHk6IGMxWzFdLnkgLSBjMVswXS55fSxcbiAgICAgICAge3g6IGMxWzFdLnggLSBjMVszXS54LCB5OiBjMVsxXS55IC0gYzFbM10ueX0sXG4gICAgICAgIHt4OiBjMlswXS54IC0gYzJbMl0ueCwgeTogYzJbMF0ueSAtIGMyWzJdLnl9LFxuICAgICAgICB7eDogYzJbMF0ueCAtIGMyWzFdLngsIHk6IGMyWzBdLnkgLSBjMlsxXS55fVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBhIHJlY3RhbmdsZSdzIGNvcm5lciBvbiBhbiBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIGNvcm5lciAoeCwgeSkuXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBDb29yZGluYXRlcyBvZiBhbiBheGlzICh4LCB5KS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9qZWN0aW9uIGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgICAqL1xuICAgIHByb2plY3Rpb246IGZ1bmN0aW9uKGMsIGEpIHtcbiAgICAgIHZhciBsID0gKFxuICAgICAgICAoYy54ICogYS54ICsgYy55ICogYS55KSAvXG4gICAgICAgIChNYXRoLnBvdyhhLngsIDIpICsgTWF0aC5wb3coYS55LCAyKSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGwgKiBhLngsXG4gICAgICAgIHk6IGwgKiBhLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdHdvIHJlY3RhbmdsZXMgY29sbGlkZSBvbiBvbmUgcGFydGljdWxhciBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgIEFuIGF4aXMnIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICAgKiBAcGFyYW0gIHthcnJheX0gICAgUmVjdGFuZ2xlIEEncyBjb3JuZXJzLlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQidzIGNvcm5lcnMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgY29sbGlkZSBvbiB0aGUgYXhpcy5cbiAgICAgKi9cbiAgICBheGlzQ29sbGlzaW9uOiBmdW5jdGlvbihhLCBjMSwgYzIpIHtcbiAgICAgIHZhciBzYzEgPSBbXSxcbiAgICAgICAgICBzYzIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IDQ7IGNpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9qZWN0aW9uKGMxW2NpXSwgYSksXG4gICAgICAgICAgICBwMiA9IHRoaXMucHJvamVjdGlvbihjMltjaV0sIGEpO1xuXG4gICAgICAgIHNjMS5wdXNoKHAxLnggKiBhLnggKyBwMS55ICogYS55KTtcbiAgICAgICAgc2MyLnB1c2gocDIueCAqIGEueCArIHAyLnkgKiBhLnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4YzEgPSBNYXRoLm1heC5hcHBseShNYXRoLCBzYzEpLFxuICAgICAgICAgIG1heGMyID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgc2MyKSxcbiAgICAgICAgICBtaW5jMSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHNjMSksXG4gICAgICAgICAgbWluYzIgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBzYzIpO1xuXG4gICAgICByZXR1cm4gKG1pbmMyIDw9IG1heGMxICYmIG1heGMyID49IG1pbmMxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0d28gcmVjdGFuZ2xlcyBjb2xsaWRlIG9uIGVhY2ggb25lIG9mIHRoZWlyIGZvdXIgYXhpcy4gSWZcbiAgICAgKiBhbGwgYXhpcyBjb2xsaWRlLCB0aGVuIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBjb2xsaWRlIG9uIHRoZSBwbGFuZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2FycmF5fSAgICBSZWN0YW5nbGUgQSdzIGNvcm5lcnMuXG4gICAgICogQHBhcmFtICB7YXJyYXl9ICAgIFJlY3RhbmdsZSBCJ3MgY29ybmVycy5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlcyBjb2xsaWRlLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbjogZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgICB2YXIgYXhpcyA9IHRoaXMuYXhpcyhjMSwgYzIpLFxuICAgICAgICAgIGNvbCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBjb2wgPSBjb2wgJiYgdGhpcy5heGlzQ29sbGlzaW9uKGF4aXNbaV0sIGMxLCBjMik7XG5cbiAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFF1YWQgRnVuY3Rpb25zXG4gICAqIC0tLS0tLS0tLS0tLVxuICAgKlxuICAgKiBUaGUgUXVhZHRyZWUgZnVuY3Rpb25zIHRoZW1zZWx2ZXMuXG4gICAqIEZvciBlYWNoIG9mIHRob3NlIGZ1bmN0aW9ucywgd2UgY29uc2lkZXIgdGhhdCBpbiBhIHNwbGl0dGVkIHF1YWQsIHRoZVxuICAgKiBpbmRleCBvZiBlYWNoIG5vZGUgaXMgdGhlIGZvbGxvd2luZzpcbiAgICogMDogdG9wIGxlZnRcbiAgICogMTogdG9wIHJpZ2h0XG4gICAqIDI6IGJvdHRvbSBsZWZ0XG4gICAqIDM6IGJvdHRvbSByaWdodFxuICAgKlxuICAgKiBNb3Jlb3ZlciwgdGhlIGhlcmVhZnRlciBxdWFkJ3MgcGhpbG9zb3BoeSBpcyB0byBjb25zaWRlciB0aGF0IGlmIGFuIGVsZW1lbnRcbiAgICogY29sbGlkZXMgd2l0aCBtb3JlIHRoYW4gb25lIG5vZGVzLCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byBlYWNoIG9mIHRoZVxuICAgKiBub2RlcyBpdCBjb2xsaWRlcyB3aXRoIHdoZXJlIG90aGVyIHdvdWxkIGxldCBpdCBsaWUgb24gYSBoaWdoZXIgbm9kZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgcG9pbnQgaW4gdGhlIHF1YWRcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgcG9pbnQgICAgICBBIHBvaW50IGRlZmluZWQgYnkgY29vcmRpbmF0ZXMgKHgsIHkpLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkQm91bmRzIEJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgKHgsIHksIHdpZHRoLCBoZWlndGgpLlxuICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSAgICAgICAgICAgIFRoZSBpbmRleCBvZiB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXgocG9pbnQsIHF1YWRCb3VuZHMpIHtcbiAgICB2YXIgeG1wID0gcXVhZEJvdW5kcy54ICsgcXVhZEJvdW5kcy53aWR0aCAvIDIsXG4gICAgICAgIHltcCA9IHF1YWRCb3VuZHMueSArIHF1YWRCb3VuZHMuaGVpZ2h0IC8gMixcbiAgICAgICAgdG9wID0gKHBvaW50LnkgPCB5bXApLFxuICAgICAgICBsZWZ0ID0gKHBvaW50LnggPCB4bXApO1xuXG4gICAgaWYgKHRvcCkge1xuICAgICAgaWYgKGxlZnQpXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobGVmdClcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGluZGV4ZXMgb2Ygbm9kZXMgY29udGFpbmluZyBhbiBheGlzLWFsaWduZWQgcmVjdGFuZ2xlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHJlY3RhbmdsZSAgIEEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdHdvIHBvaW50cyAoeDEsIHkxKSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHgyLCB5MikgYW5kIGhlaWdodC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgcXVhZENvcm5lcnMgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkSW5kZXhlcyhyZWN0YW5nbGUsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoKHJlY3RhbmdsZS54MiA+PSBxdWFkQ29ybmVyc1tpXVswXS54KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueDEgPD0gcXVhZENvcm5lcnNbaV1bMV0ueCkgJiZcbiAgICAgICAgICAocmVjdGFuZ2xlLnkxICsgcmVjdGFuZ2xlLmhlaWdodCA+PSBxdWFkQ29ybmVyc1tpXVswXS55KSAmJlxuICAgICAgICAgIChyZWN0YW5nbGUueTEgPD0gcXVhZENvcm5lcnNbaV1bMl0ueSkpXG4gICAgICAgIGluZGV4ZXMucHVzaChpKTtcblxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW5kZXhlcyBvZiBub2RlcyBjb250YWluaW5nIGEgbm9uLWF4aXMtYWxpZ25lZCByZWN0YW5nbGVcbiAgICpcbiAgICogQHBhcmFtICB7YXJyYXl9ICBjb3JuZXJzICAgICAgQW4gYXJyYXkgY29udGFpbmluZyBlYWNoIGNvcm5lciBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlIGRlZmluZWQgYnkgaXRzIGNvb3JkaW5hdGVzICh4LCB5KS5cbiAgICogQHBhcmFtICB7YXJyYXl9ICBxdWFkQ29ybmVycyAgQW4gYXJyYXkgb2YgdGhlIHF1YWQgbm9kZXMnIGNvcm5lcnMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgIEFuIGFycmF5IG9mIGluZGV4ZXMgY29udGFpbmluZyBvbmUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91ciBpbnRlZ2Vycy5cbiAgICovXG4gIGZ1bmN0aW9uIF9xdWFkQ29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGluZyB0aHJvdWdoIHF1YWRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBpZiAoX2dlb20uY29sbGlzaW9uKGNvcm5lcnMsIHF1YWRDb3JuZXJzW2ldKSlcbiAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuXG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogU3ViZGl2aWRlIGEgcXVhZCBieSBjcmVhdGluZyBhIG5vZGUgYXQgYSBwcmVjaXNlIGluZGV4LiBUaGUgZnVuY3Rpb24gZG9lc1xuICAgKiBub3QgZ2VuZXJhdGUgYWxsIGZvdXIgbm9kZXMgbm90IHRvIHBvdGVudGlhbGx5IGNyZWF0ZSB1bnVzZWQgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2ludGVnZXJ9ICBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gY3JlYXRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgcXVhZCAgVGhlIHF1YWQgb2JqZWN0IHRvIHN1YmRpdmlkZS5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgIEEgbmV3IHF1YWQgcmVwcmVzZW50aW5nIHRoZSBub2RlIGNyZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFN1YmRpdmlkZShpbmRleCwgcXVhZCkge1xuICAgIHZhciBuZXh0ID0gcXVhZC5sZXZlbCArIDEsXG4gICAgICAgIHN1YncgPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLndpZHRoIC8gMiksXG4gICAgICAgIHN1YmggPSBNYXRoLnJvdW5kKHF1YWQuYm91bmRzLmhlaWdodCAvIDIpLFxuICAgICAgICBxeCA9IE1hdGgucm91bmQocXVhZC5ib3VuZHMueCksXG4gICAgICAgIHF5ID0gTWF0aC5yb3VuZChxdWFkLmJvdW5kcy55KSxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IHF4O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4ID0gcXg7XG4gICAgICAgIHkgPSBxeSArIHN1Ymg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB4ID0gcXggKyBzdWJ3O1xuICAgICAgICB5ID0gcXkgKyBzdWJoO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1YWRUcmVlKFxuICAgICAge3g6IHgsIHk6IHksIHdpZHRoOiBzdWJ3LCBoZWlnaHQ6IHN1Ymh9LFxuICAgICAgbmV4dCxcbiAgICAgIHF1YWQubWF4RWxlbWVudHMsXG4gICAgICBxdWFkLm1heExldmVsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBpbnNlcnQgYW4gZWxlbWVudCBpbnRvIHRoZSBxdWFkdHJlZS4gT25seSBwb2ludHNcbiAgICogd2l0aCBzaXplLCBpLmUuIGF4aXMtYWxpZ25lZCBzcXVhcmVzLCBtYXkgYmUgaW5zZXJ0ZWQgd2l0aCB0aGlzXG4gICAqIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgZWwgICAgICAgICBUaGUgZWxlbWVudCB0byBpbnNlcnQgaW4gdGhlIHF1YWR0cmVlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBzaXplZFBvaW50IEEgc2l6ZWQgcG9pbnQgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50c1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBxdWFkICAgICAgIFRoZSBxdWFkIGluIHdoaWNoIHRvIGluc2VydCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICBUaGUgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gX3F1YWRJbnNlcnQoZWwsIHNpemVkUG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcblxuICAgICAgLy8gU2VhcmNoaW5nIGFwcHJvcHJpYXRlIHF1YWRzXG4gICAgICB2YXIgaW5kZXhlcyA9IF9xdWFkSW5kZXhlcyhzaXplZFBvaW50LCBxdWFkLmNvcm5lcnMpO1xuXG4gICAgICAvLyBJdGVyYXRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAvLyBTdWJkaXZpZGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhlc1tpXV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dID0gX3F1YWRTdWJkaXZpZGUoaW5kZXhlc1tpXSwgcXVhZCk7XG5cbiAgICAgICAgLy8gUmVjdXJzaW9uXG4gICAgICAgIF9xdWFkSW5zZXJ0KGVsLCBzaXplZFBvaW50LCBxdWFkLm5vZGVzW2luZGV4ZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgIC8vIFB1c2hpbmcgdGhlIGVsZW1lbnQgaW4gYSBsZWFmIG5vZGVcbiAgICAgIHF1YWQuZWxlbWVudHMucHVzaChlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHJldHJpZXZlIGV2ZXJ5IGVsZW1lbnRzIGhlbGQgYnkgdGhlIG5vZGUgY29udGFpbmluZyB0aGVcbiAgICogc2VhcmNoZWQgcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHBvaW50IFRoZSBzZWFyY2hlZCBwb2ludCAoeCwgeSkuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHF1YWQgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAgICBBbiBhcnJheSBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIHJlbGV2YW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlUG9pbnQocG9pbnQsIHF1YWQpIHtcbiAgICBpZiAocXVhZC5sZXZlbCA8IHF1YWQubWF4TGV2ZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IF9xdWFkSW5kZXgocG9pbnQsIHF1YWQuYm91bmRzKTtcblxuICAgICAgLy8gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB3ZSByZXR1cm4gYW4gZW1wdHkgbGlzdFxuICAgICAgaWYgKHF1YWQubm9kZXNbaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWFkUmV0cmlldmVQb2ludChwb2ludCwgcXVhZC5ub2Rlc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcXVhZC5lbGVtZW50cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgcmV0cmlldmUgZXZlcnkgZWxlbWVudHMgY29udGFpbmVkIHdpdGhpbiBhbiByZWN0YW5ndWxhciBhcmVhXG4gICAqIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYXhpcy1hbGlnbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R8YXJyYXl9IHJlY3REYXRhICAgICAgIFRoZSBzZWFyY2hlZCBhcmVhIGRlZmluZWQgZWl0aGVyIGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gYXJyYXkgb2YgZm91ciBjb3JuZXJzICh4LCB5KSBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjYXNlIG9mIGEgbm9uLWF4aXMtYWxpZ25lZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3RhbmdsZSBvciBhbiBvYmplY3Qgd2l0aCB0d28gdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzICh4MSwgeTEpLCAoeDIsIHkyKSBhbmQgaGVpZ2h0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgIHF1YWQgICAgICAgICAgIFRoZSBzZWFyY2hlZCBxdWFkLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgIGNvbGxpc2lvbkZ1bmMgIFRoZSBjb2xsaXNpb24gZnVuY3Rpb24gdXNlZCB0byBzZWFyY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Igbm9kZSBpbmRleGVzLlxuICAgKiBAcGFyYW0gIHthcnJheT99ICAgICAgIGVscyAgICAgICAgICAgIFRoZSByZXRyaWV2ZWQgZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgQW4gYXJyYXkgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZWEuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFJldHJpZXZlQXJlYShyZWN0RGF0YSwgcXVhZCwgY29sbGlzaW9uRnVuYywgZWxzKSB7XG4gICAgZWxzID0gZWxzIHx8IHt9O1xuXG4gICAgaWYgKHF1YWQubGV2ZWwgPCBxdWFkLm1heExldmVsKSB7XG4gICAgICB2YXIgaW5kZXhlcyA9IGNvbGxpc2lvbkZ1bmMocmVjdERhdGEsIHF1YWQuY29ybmVycyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmIChxdWFkLm5vZGVzW2luZGV4ZXNbaV1dICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgICAgICByZWN0RGF0YSxcbiAgICAgICAgICAgIHF1YWQubm9kZXNbaW5kZXhlc1tpXV0sXG4gICAgICAgICAgICBjb2xsaXNpb25GdW5jLFxuICAgICAgICAgICAgZWxzXG4gICAgICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcXVhZC5lbGVtZW50cy5sZW5ndGg7IGogPCBtOyBqKyspXG4gICAgICAgIGlmIChlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBlbHNbcXVhZC5lbGVtZW50c1tqXS5pZF0gPSBxdWFkLmVsZW1lbnRzW2pdO1xuXG4gICAgcmV0dXJuIGVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBxdWFkdHJlZSBvYmplY3QgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgYm91bmRzICAgICAgIFRoZSBib3VuZGFyaWVzIG9mIHRoZSBxdWFkIGRlZmluZWQgYnkgYW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gKHgsIHkpLCB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbGV2ZWwgICAgICAgIFRoZSBsZXZlbCBvZiB0aGUgcXVhZCBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtICB7aW50ZWdlcn0gIG1heEVsZW1lbnRzICBUaGUgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIGEgbGVhZiBub2RlLlxuICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSAgbWF4TGV2ZWwgICAgIFRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgICAgIFRoZSBxdWFkdHJlZSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBfcXVhZFRyZWUoYm91bmRzLCBsZXZlbCwgbWF4RWxlbWVudHMsIG1heExldmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiBsZXZlbCB8fCAwLFxuICAgICAgYm91bmRzOiBib3VuZHMsXG4gICAgICBjb3JuZXJzOiBfZ2VvbS5zcGxpdFNxdWFyZShib3VuZHMpLFxuICAgICAgbWF4RWxlbWVudHM6IG1heEVsZW1lbnRzIHx8IDQwLFxuICAgICAgbWF4TGV2ZWw6IG1heExldmVsIHx8IDgsXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBub2RlczogW11cbiAgICB9O1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbWEgUXVhZCBDb25zdHJ1Y3RvclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqIFRoZSBlZGdlcXVhZCBBUEkgYXMgZXhwb3NlZCB0byBzaWdtYS5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBlZGdlcXVhZCBjb3JlIHRoYXQgd2lsbCBiZWNvbWUgdGhlIHNpZ21hIGludGVyZmFjZSB3aXRoIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogcHJvcGVydHkge29iamVjdH0gX3RyZWUgICAgIFByb3BlcnR5IGhvbGRpbmcgdGhlIHF1YWR0cmVlIG9iamVjdC5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2dlb20gICAgIEV4cG9zaXRpb24gb2YgdGhlIF9nZW9tIG5hbWVzcGFjZSBmb3IgdGVzdGluZy5cbiAgICogcHJvcGVydHkge29iamVjdH0gX2NhY2hlICAgIENhY2hlIGZvciB0aGUgYXJlYSBtZXRob2QuXG4gICAqIHByb3BlcnR5IHtib29sZWFufSBfZW5hYmxlZCBDYW4gaW5kZXggYW5kIHJldHJlaXZlIGVsZW1lbnRzLlxuICAgKi9cbiAgdmFyIGVkZ2VxdWFkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2VvbSA9IF9nZW9tO1xuICAgIHRoaXMuX3RyZWUgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgcXVlcnk6IGZhbHNlLFxuICAgICAgcmVzdWx0OiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGV4IGEgZ3JhcGggYnkgaW5zZXJ0aW5nIGl0cyBlZGdlcyBpbnRvIHRoZSBxdWFkdHJlZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBncmFwaCAgIEEgZ3JhcGggaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zICBBbiBvYmplY3Qgb2YgcGFyYW1ldGVycyB3aXRoIGF0IGxlYXN0IHRoZSBxdWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBUaGUgcXVhZHRyZWUgb2JqZWN0LlxuICAgKlxuICAgKiBQYXJhbWV0ZXJzOlxuICAgKiAtLS0tLS0tLS0tXG4gICAqIGJvdW5kczogICAgICB7b2JqZWN0fSAgIGJvdW5kYXJpZXMgb2YgdGhlIHF1YWQgZGVmaW5lZCBieSBpdHMgb3JpZ2luICh4LCB5KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCBhbmQgaGVpZ3RoLlxuICAgKiBwcmVmaXg6ICAgICAge3N0cmluZz99ICBhIHByZWZpeCBmb3IgZWRnZSBnZW9tZXRyaWMgYXR0cmlidXRlcy5cbiAgICogbWF4RWxlbWVudHM6IHtpbnRlZ2VyP30gdGhlIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSBsZWFmIG5vZGUuXG4gICAqIG1heExldmVsOiAgICB7aW50ZWdlcj99IHRoZSBtYXggcmVjdXJzaW9uIGxldmVsIG9mIHRoZSB0cmVlLlxuICAgKi9cbiAgZWRnZXF1YWQucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZ3JhcGgsIHBhcmFtcykge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuXG4gICAgLy8gRW5mb3JjaW5nIHByZXNlbmNlIG9mIGJvdW5kYXJpZXNcbiAgICBpZiAoIXBhcmFtcy5ib3VuZHMpXG4gICAgICB0aHJvdyAnc2lnbWEuY2xhc3Nlcy5lZGdlcXVhZC5pbmRleDogYm91bmRzIGluZm9ybWF0aW9uIG5vdCBnaXZlbi4nO1xuXG4gICAgLy8gUHJlZml4XG4gICAgdmFyIHByZWZpeCA9IHBhcmFtcy5wcmVmaXggfHwgJycsXG4gICAgICAgIGNwLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgbixcbiAgICAgICAgZTtcblxuICAgIC8vIEJ1aWxkaW5nIHRoZSB0cmVlXG4gICAgdGhpcy5fdHJlZSA9IF9xdWFkVHJlZShcbiAgICAgIHBhcmFtcy5ib3VuZHMsXG4gICAgICAwLFxuICAgICAgcGFyYW1zLm1heEVsZW1lbnRzLFxuICAgICAgcGFyYW1zLm1heExldmVsXG4gICAgKTtcblxuICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG5cbiAgICAvLyBJbnNlcnRpbmcgZ3JhcGggZWRnZXMgaW50byB0aGUgdHJlZVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBncmFwaC5ub2RlcyhlZGdlc1tpXS5zb3VyY2UpO1xuICAgICAgdGFyZ2V0ID0gZ3JhcGgubm9kZXMoZWRnZXNbaV0udGFyZ2V0KTtcbiAgICAgIGUgPSB7XG4gICAgICAgIHgxOiBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgeTE6IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB4MjogdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHkyOiB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZTogZWRnZXNbaV1bcHJlZml4ICsgJ3NpemUnXSB8fCAwXG4gICAgICB9O1xuXG4gICAgICAvLyBJbnNlcnRpbmcgZWRnZVxuICAgICAgaWYgKGVkZ2VzW2ldLnR5cGUgPT09ICdjdXJ2ZScgfHwgZWRnZXNbaV0udHlwZSA9PT0gJ2N1cnZlZEFycm93Jykge1xuICAgICAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICBuID0ge1xuICAgICAgICAgICAgeDogc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICB5OiBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgIHNpemU6IHNvdXJjZVtwcmVmaXggKyAnc2l6ZSddIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIF9xdWFkSW5zZXJ0KFxuICAgICAgICAgICAgZWRnZXNbaV0sXG4gICAgICAgICAgICBfZ2VvbS5zZWxmTG9vcFRvU3F1YXJlKG4pLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRRdWFkcmF0aWNDb250cm9sUG9pbnQoZS54MSwgZS55MSwgZS54MiwgZS55Mik7XG4gICAgICAgICAgX3F1YWRJbnNlcnQoXG4gICAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICAgIF9nZW9tLnF1YWRyYXRpY0N1cnZlVG9TcXVhcmUoZSwgY3ApLFxuICAgICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfcXVhZEluc2VydChcbiAgICAgICAgICBlZGdlc1tpXSxcbiAgICAgICAgICBfZ2VvbS5saW5lVG9TcXVhcmUoZSksXG4gICAgICAgICAgdGhpcy5fdHJlZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgY2FjaGU6XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBxdWVyeTogZmFsc2UsXG4gICAgICByZXN1bHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIHJlbW92ZT9cbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgZXZlcnkgZ3JhcGggZWRnZXMgaGVsZCBieSB0aGUgcXVhZHRyZWUgbm9kZSBjb250YWluaW5nIHRoZVxuICAgKiBzZWFyY2hlZCBwb2ludC5cbiAgICpcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4IG9mIHRoZSBwb2ludC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSB5IG9mIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7YXJyYXl9ICBBbiBhcnJheSBvZiBlZGdlcyByZXRyaWV2ZWQuXG4gICAqL1xuICBlZGdlcXVhZC5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZVBvaW50KHt4OiB4LCB5OiB5fSwgdGhpcy5fdHJlZSkgfHwgW10gOlxuICAgICAgW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGV2ZXJ5IGdyYXBoIGVkZ2VzIHdpdGhpbiBhIHJlY3Rhbmd1bGFyIGFyZWEuIFRoZSBtZXRob2RzIGtlZXAgdGhlXG4gICAqIGxhc3QgYXJlYSBxdWVyaWVkIGluIGNhY2hlIGZvciBvcHRpbWl6YXRpb24gcmVhc29uIGFuZCB3aWxsIGFjdCBkaWZmZXJlbnRseVxuICAgKiBmb3IgdGhlIHNhbWUgcmVhc29uIGlmIHRoZSBhcmVhIGlzIGF4aXMtYWxpZ25lZCBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gQSByZWN0YW5nbGUgZGVmaW5lZCBieSB0d28gdG9wIHBvaW50cyAoeDEsIHkxKSwgKHgyLCB5MilcbiAgICogICAgICAgICAgICAgICAgICBhbmQgaGVpZ2h0LlxuICAgKiBAcmV0dXJuIHthcnJheX0gIEFuIGFycmF5IG9mIGVkZ2VzIHJldHJpZXZlZC5cbiAgICovXG4gIGVkZ2VxdWFkLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocmVjdCksXG4gICAgICAgIGNvbGxpc2lvbkZ1bmMsXG4gICAgICAgIHJlY3REYXRhO1xuXG4gICAgLy8gUmV0dXJuaW5nIGNhY2hlP1xuICAgIGlmICh0aGlzLl9jYWNoZS5xdWVyeSA9PT0gc2VyaWFsaXplZClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5yZXN1bHQ7XG5cbiAgICAvLyBBeGlzIGFsaWduZWQgP1xuICAgIGlmIChfZ2VvbS5pc0F4aXNBbGlnbmVkKHJlY3QpKSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRJbmRleGVzO1xuICAgICAgcmVjdERhdGEgPSBfZ2VvbS5heGlzQWxpZ25lZFRvcFBvaW50cyhyZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb2xsaXNpb25GdW5jID0gX3F1YWRDb2xsaXNpb247XG4gICAgICByZWN0RGF0YSA9IF9nZW9tLnJlY3RhbmdsZUNvcm5lcnMocmVjdCk7XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmluZyBlZGdlc1xuICAgIHZhciBlZGdlcyA9IHRoaXMuX3RyZWUgP1xuICAgICAgX3F1YWRSZXRyaWV2ZUFyZWEoXG4gICAgICAgIHJlY3REYXRhLFxuICAgICAgICB0aGlzLl90cmVlLFxuICAgICAgICBjb2xsaXNpb25GdW5jXG4gICAgICApIDpcbiAgICAgIFtdO1xuXG4gICAgLy8gT2JqZWN0IHRvIGFycmF5XG4gICAgdmFyIGVkZ2VzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGVkZ2VzKVxuICAgICAgZWRnZXNBcnJheS5wdXNoKGVkZ2VzW2ldKTtcblxuICAgIC8vIENhY2hpbmdcbiAgICB0aGlzLl9jYWNoZS5xdWVyeSA9IHNlcmlhbGl6ZWQ7XG4gICAgdGhpcy5fY2FjaGUucmVzdWx0ID0gZWRnZXNBcnJheTtcblxuICAgIHJldHVybiBlZGdlc0FycmF5O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVYUE9SVDpcbiAgICogKioqKioqKlxuICAgKi9cbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ21hICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2lnbWEuY2xhc3NlcyA9IHRoaXMuc2lnbWEuY2xhc3NlcyB8fCB7fTtcbiAgICB0aGlzLnNpZ21hLmNsYXNzZXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBlZGdlcXVhZDtcbiAgICBleHBvcnRzLmVkZ2VxdWFkID0gZWRnZXF1YWQ7XG4gIH0gZWxzZVxuICAgIHRoaXMuZWRnZXF1YWQgPSBlZGdlcXVhZDtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLm1vdXNlID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcblxuICAgICAgICAvLyBUaGUgbGF0ZXN0IHN0YWdlIHBvc2l0aW9uOlxuICAgICAgICBfbGFzdENhbWVyYVgsXG4gICAgICAgIF9sYXN0Q2FtZXJhWSxcbiAgICAgICAgX2xhc3RDYW1lcmFBbmdsZSxcbiAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyxcblxuICAgICAgICAvLyBNT1VTRSBNQU5BR0VNRU5UOlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgbW91c2UgcG9zaXRpb24gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmc6XG4gICAgICAgIF9zdGFydE1vdXNlWCxcbiAgICAgICAgX3N0YXJ0TW91c2VZLFxuXG4gICAgICAgIF9pc01vdXNlRG93bixcbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfaGFzRHJhZ2dlZCxcbiAgICAgICAgX2Rvd25TdGFydFRpbWUsXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQ7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgc2lnbWEudXRpbHMuZG91YmxlQ2xpY2soX3RhcmdldCwgJ2NsaWNrJywgX2RvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIF93aGVlbEhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBfd2hlZWxIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIF9kb3duSGFuZGxlciwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfY2xpY2tIYW5kbGVyLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF91cEhhbmRsZXIsIGZhbHNlKTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVuYmluZHMgZXZlcnkgaGFuZGxlcnMgdGhhdCBtYWtlcyB0aGUgY2FwdG9yIHdvcmsuXG4gICAgICovXG4gICAgdGhpcy5raWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICBzaWdtYS51dGlscy51bmJpbmREb3VibGVDbGljayhfdGFyZ2V0LCAnY2xpY2snKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBfd2hlZWxIYW5kbGVyKTtcbiAgICAgIF90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIF93aGVlbEhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfbW92ZUhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBfZG93bkhhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF9jbGlja0hhbmRsZXIpO1xuICAgICAgX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIF9vdXRIYW5kbGVyKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdXBIYW5kbGVyKTtcbiAgICB9O1xuXG5cblxuXG4gICAgLy8gTU9VU0UgRVZFTlRTOlxuICAgIC8vICoqKioqKioqKioqKipcblxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ21vdmUnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5XG4gICAgICogZHJhZyB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX21vdmVIYW5kbGVyKGUpIHtcbiAgICAgIHZhciB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcG9zO1xuXG4gICAgICAvLyBEaXNwYXRjaCBldmVudDpcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpKSB7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlbW92ZScsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSkpO1xuXG4gICAgICAgIGlmIChfaXNNb3VzZURvd24pIHtcbiAgICAgICAgICBfaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIF9oYXNEcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgICAgX21vdmluZ1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcblxuICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICBzaWdtYS51dGlscy5nZXRYKGUpIC0gX3N0YXJ0TW91c2VYLFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIF9zdGFydE1vdXNlWSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IF9zdGFydENhbWVyYVggLSBwb3MueDtcbiAgICAgICAgICB5ID0gX3N0YXJ0Q2FtZXJhWSAtIHBvcy55O1xuXG4gICAgICAgICAgaWYgKHggIT09IF9jYW1lcmEueCB8fCB5ICE9PSBfY2FtZXJhLnkpIHtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd1cCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgc3RvcCBkcmFnZ2luZyB0aGVcbiAgICAgKiBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfdXBIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9pc01vdXNlRG93bikge1xuICAgICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSBmYWxzZTtcblxuICAgICAgICB2YXIgeCA9IHNpZ21hLnV0aWxzLmdldFgoZSksXG4gICAgICAgICAgICB5ID0gc2lnbWEudXRpbHMuZ2V0WShlKTtcblxuICAgICAgICBpZiAoX2lzTW92aW5nKSB7XG4gICAgICAgICAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbChfY2FtZXJhKTtcbiAgICAgICAgICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEoXG4gICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBfY2FtZXJhLnggK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICB5OiBfY2FtZXJhLnkgK1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncygnbW91c2VJbmVydGlhUmF0aW8nKSAqIChfY2FtZXJhLnkgLSBfbGFzdENhbWVyYVkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdtb3VzZUluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBfc3RhcnRNb3VzZVggIT09IHggfHxcbiAgICAgICAgICBfc3RhcnRNb3VzZVkgIT09IHlcbiAgICAgICAgKVxuICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICB4OiBfY2FtZXJhLngsXG4gICAgICAgICAgICB5OiBfY2FtZXJhLnlcbiAgICAgICAgICB9KTtcblxuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZXVwJyxcbiAgICAgICAgICBzaWdtYS51dGlscy5tb3VzZUNvb3JkcyhlKSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIF9pc01vdmluZyBmbGFnOlxuICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdkb3duJyBtb3VzZSBldmVudC4gSXQgd2lsbCBzdGFydCBvYnNlcnZpbmdcbiAgICAgKiB0aGUgbW91c2UgcG9zaXRpb24gZm9yIGRyYWdnaW5nIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZG93bkhhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgX3N0YXJ0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgIF9sYXN0Q2FtZXJhWSA9IF9jYW1lcmEueTtcblxuICAgICAgICBfc3RhcnRNb3VzZVggPSBzaWdtYS51dGlscy5nZXRYKGUpO1xuICAgICAgICBfc3RhcnRNb3VzZVkgPSBzaWdtYS51dGlscy5nZXRZKGUpO1xuXG4gICAgICAgIF9oYXNEcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIF9kb3duU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICBzd2l0Y2ggKGUud2hpY2gpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBNaWRkbGUgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAvLyBSaWdodCBtb3VzZSBidXR0b24gcHJlc3NlZFxuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRjbGljaycsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIExlZnQgbW91c2UgYnV0dG9uIHByZXNzZWRcbiAgICAgICAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdvdXQnIG1vdXNlIGV2ZW50LiBJdCB3aWxsIGp1c3QgcmVkaXNwYXRjaFxuICAgICAqIHRoZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfb3V0SGFuZGxlcihlKSB7XG4gICAgICBpZiAoX3NldHRpbmdzKCdtb3VzZUVuYWJsZWQnKSlcbiAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnbW91c2VvdXQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICdjbGljaycgbW91c2UgZXZlbnQuIEl0IHdpbGwgcmVkaXNwYXRjaCB0aGVcbiAgICAgKiBjbGljayBldmVudCwgYnV0IHdpdGggbm9ybWFsaXplZCBYIGFuZCBZIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtldmVudH0gZSBBIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSk7XG4gICAgICAgIGV2ZW50LmlzRHJhZ2dpbmcgPVxuICAgICAgICAgICgoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIF9kb3duU3RhcnRUaW1lKSA+IDEwMCkgJiYgX2hhc0RyYWdnZWQ7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWxzZVxuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSBkb3VibGUgY2xpY2sgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZUNsaWNrSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbjtcblxuICAgICAgaWYgKF9zZXR0aW5ncygnbW91c2VFbmFibGVkJykpIHtcbiAgICAgICAgcmF0aW8gPSAxIC8gX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZWNsaWNrJyxcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIF9zdGFydE1vdXNlWCwgX3N0YXJ0TW91c2VZKSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WShlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBhbmltYXRpb24gPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCdkb3VibGVDbGlja1pvb21EdXJhdGlvbicpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNpZ21hLnV0aWxzLnpvb21UbyhfY2FtZXJhLCBwb3MueCwgcG9zLnksIHJhdGlvLCBhbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd3aGVlbCcgbW91c2UgZXZlbnQuIEl0IHdpbGwgYmFzaWNhbGx5IHpvb21cbiAgICAgKiBpbiBvciBub3QgaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3doZWVsSGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICB3aGVlbERlbHRhID0gc2lnbWEudXRpbHMuZ2V0RGVsdGEoZSk7XG5cbiAgICAgIGlmIChfc2V0dGluZ3MoJ21vdXNlRW5hYmxlZCcpICYmIF9zZXR0aW5ncygnbW91c2VXaGVlbEVuYWJsZWQnKSAmJiB3aGVlbERlbHRhICE9PSAwKSB7XG4gICAgICAgIHJhdGlvID0gd2hlZWxEZWx0YSA+IDAgP1xuICAgICAgICAgIDEgLyBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpIDpcbiAgICAgICAgICBfc2V0dGluZ3MoJ3pvb21pbmdSYXRpbycpO1xuXG4gICAgICAgIHBvcyA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgc2lnbWEudXRpbHMuZ2V0WChlKSAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgIHNpZ21hLnV0aWxzLmdldFkoZSkgLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG5cbiAgICAgICAgYW5pbWF0aW9uID0ge1xuICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ21vdXNlWm9vbUR1cmF0aW9uJylcbiAgICAgICAgfTtcblxuICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcblxuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhcHRvcnMnKTtcblxuICAvKipcbiAgICogVGhlIHVzZXIgaW5wdXRzIGRlZmF1bHQgY2FwdG9yLiBJdCBkZWFscyB3aXRoIG1vdXNlIGV2ZW50cywga2V5Ym9hcmRzXG4gICAqIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgIHRhcmdldCAgIFRoZSBET00gZWxlbWVudCB3aGVyZSB0aGUgbGlzdGVuZXJzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZC5cbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgICAgICBjYW1lcmEgICBUaGUgY2FtZXJhIHJlbGF0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge3NpZ21hLmNhcHRvcn0gICAgICAgICAgVGhlIGZyZXNoIG5ldyBjYXB0b3IgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5jYXB0b3JzLnRvdWNoID0gZnVuY3Rpb24odGFyZ2V0LCBjYW1lcmEsIHNldHRpbmdzKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcyxcbiAgICAgICAgX3RhcmdldCA9IHRhcmdldCxcbiAgICAgICAgX2NhbWVyYSA9IGNhbWVyYSxcbiAgICAgICAgX3NldHRpbmdzID0gc2V0dGluZ3MsXG5cbiAgICAgICAgLy8gQ0FNRVJBIE1BTkFHRU1FTlQ6XG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBUaGUgY2FtZXJhIHBvc2l0aW9uIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nOlxuICAgICAgICBfc3RhcnRDYW1lcmFYLFxuICAgICAgICBfc3RhcnRDYW1lcmFZLFxuICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSxcbiAgICAgICAgX3N0YXJ0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVGhlIGxhdGVzdCBzdGFnZSBwb3NpdGlvbjpcbiAgICAgICAgX2xhc3RDYW1lcmFYLFxuICAgICAgICBfbGFzdENhbWVyYVksXG4gICAgICAgIF9sYXN0Q2FtZXJhQW5nbGUsXG4gICAgICAgIF9sYXN0Q2FtZXJhUmF0aW8sXG5cbiAgICAgICAgLy8gVE9VQ0ggTUFOQUdFTUVOVDpcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gVG91Y2hlcyB0aGF0IGFyZSBkb3duOlxuICAgICAgICBfZG93blRvdWNoZXMgPSBbXSxcblxuICAgICAgICBfc3RhcnRUb3VjaFgwLFxuICAgICAgICBfc3RhcnRUb3VjaFkwLFxuICAgICAgICBfc3RhcnRUb3VjaFgxLFxuICAgICAgICBfc3RhcnRUb3VjaFkxLFxuICAgICAgICBfc3RhcnRUb3VjaEFuZ2xlLFxuICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlLFxuXG4gICAgICAgIF90b3VjaE1vZGUsXG5cbiAgICAgICAgX2lzTW92aW5nLFxuICAgICAgICBfZG91YmxlVGFwLFxuICAgICAgICBfbW92aW5nVGltZW91dElkO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIHNpZ21hLnV0aWxzLmRvdWJsZUNsaWNrKF90YXJnZXQsICd0b3VjaHN0YXJ0JywgX2RvdWJsZVRhcEhhbmRsZXIpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCwgZmFsc2UpO1xuICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gcG9zaXRpb24oZSkge1xuICAgICAgdmFyIG9mZnNldCA9IHNpZ21hLnV0aWxzLmdldE9mZnNldChfdGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0LFxuICAgICAgICB5OiBlLnBhZ2VZIC0gb2Zmc2V0LnRvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1bmJpbmRzIGV2ZXJ5IGhhbmRsZXJzIHRoYXQgbWFrZXMgdGhlIGNhcHRvciB3b3JrLlxuICAgICAqL1xuICAgIHRoaXMua2lsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEudXRpbHMudW5iaW5kRG91YmxlQ2xpY2soX3RhcmdldCwgJ3RvdWNoc3RhcnQnKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydCk7XG4gICAgICBfdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfaGFuZGxlTGVhdmUpO1xuICAgICAgX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGxlYXZlJywgX2hhbmRsZUxlYXZlKTtcbiAgICAgIF90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX2hhbmRsZU1vdmUpO1xuICAgIH07XG5cbiAgICAvLyBUT1VDSCBFVkVOVFM6XG4gICAgLy8gKioqKioqKioqKioqKlxuICAgIC8qKlxuICAgICAqIFRoZSBoYW5kbGVyIGxpc3RlbmluZyB0byB0aGUgJ3RvdWNoc3RhcnQnIGV2ZW50LiBJdCB3aWxsIHNldCB0aGUgdG91Y2hcbiAgICAgKiBtb2RlIChcIl90b3VjaE1vZGVcIikgYW5kIHN0YXJ0IG9ic2VydmluZyB0aGUgdXNlciB0b3VjaCBtb3Zlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlU3RhcnQoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczE7XG5cbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuXG4gICAgICAgIHN3aXRjaCAoX2Rvd25Ub3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDE7XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfbGFzdENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfbGFzdENhbWVyYVkgPSBfY2FtZXJhLnk7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMCA9IHBvczAueDtcbiAgICAgICAgICAgIF9zdGFydFRvdWNoWTAgPSBwb3MwLnk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9jYW1lcmEuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgX3RvdWNoTW9kZSA9IDI7XG5cbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgcG9zMSA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1sxXSk7XG4gICAgICAgICAgICB4MCA9IHBvczAueDtcbiAgICAgICAgICAgIHkwID0gcG9zMC55O1xuICAgICAgICAgICAgeDEgPSBwb3MxLng7XG4gICAgICAgICAgICB5MSA9IHBvczEueTtcblxuICAgICAgICAgICAgX2xhc3RDYW1lcmFYID0gX2NhbWVyYS54O1xuICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFBbmdsZSA9IF9jYW1lcmEuYW5nbGU7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgIF9zdGFydENhbWVyYVggPSBfY2FtZXJhLng7XG4gICAgICAgICAgICBfc3RhcnRDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgwID0geDA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkwID0geTA7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFgxID0geDE7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaFkxID0geTE7XG5cbiAgICAgICAgICAgIF9zdGFydFRvdWNoQW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgICBfc3RhcnRUb3VjaFkxIC0gX3N0YXJ0VG91Y2hZMCxcbiAgICAgICAgICAgICAgX3N0YXJ0VG91Y2hYMSAtIF9zdGFydFRvdWNoWDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBfc3RhcnRUb3VjaERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICpcbiAgICAgICAgICAgICAgICAoX3N0YXJ0VG91Y2hZMSAtIF9zdGFydFRvdWNoWTApICtcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKSAqXG4gICAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWDEgLSBfc3RhcnRUb3VjaFgwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoZSAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIGFuZCAndG91Y2hsZWF2ZSdcbiAgICAgKiBldmVudC4gSXQgd2lsbCB1cGRhdGUgdGhlIHRvdWNoIG1vZGUgaWYgdGhlcmUgYXJlIHN0aWxsIGF0IGxlYXN0IG9uZVxuICAgICAqIGZpbmdlciwgYW5kIHN0b3AgZHJhZ2dpbmcgZWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGUgQSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlTGVhdmUoZSkge1xuICAgICAgaWYgKF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgX2Rvd25Ub3VjaGVzID0gZS50b3VjaGVzO1xuICAgICAgICB2YXIgaW5lcnRpYVJhdGlvID0gX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFSYXRpbycpO1xuXG4gICAgICAgIGlmIChfbW92aW5nVGltZW91dElkKSB7XG4gICAgICAgICAgX2lzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChfdG91Y2hNb2RlKSB7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgX2hhbmRsZVN0YXJ0KGUpO1xuXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2NhbWVyYS5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnc3RvcERyYWcnKTtcblxuICAgICAgICAgICAgaWYgKF9pc01vdmluZykge1xuICAgICAgICAgICAgICBfZG91YmxlVGFwID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLmNhbWVyYShcbiAgICAgICAgICAgICAgICBfY2FtZXJhLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHg6IF9jYW1lcmEueCArXG4gICAgICAgICAgICAgICAgICAgIGluZXJ0aWFSYXRpbyAqIChfY2FtZXJhLnggLSBfbGFzdENhbWVyYVgpLFxuICAgICAgICAgICAgICAgICAgeTogX2NhbWVyYS55ICtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRpYVJhdGlvICogKF9jYW1lcmEueSAtIF9sYXN0Q2FtZXJhWSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCcsXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogX3NldHRpbmdzKCd0b3VjaEluZXJ0aWFEdXJhdGlvbicpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90b3VjaE1vZGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlICd0b3VjaG1vdmUnIGV2ZW50LiBJdCB3aWxsIGVmZmVjdGl2ZWx5IGRyYWdcbiAgICAgKiB0aGUgZ3JhcGgsIGFuZCBldmVudHVhbGx5IHpvb21zIGFuZCB0dXJuIGl0IGlmIHRoZSB1c2VyIGlzIHVzaW5nIHR3b1xuICAgICAqIGZpbmdlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZU1vdmUoZSkge1xuICAgICAgaWYgKCFfZG91YmxlVGFwICYmIF9zZXR0aW5ncygndG91Y2hFbmFibGVkJykpIHtcbiAgICAgICAgdmFyIHgwLFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MCxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY29zLFxuICAgICAgICAgICAgc2luLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgcG9zMCxcbiAgICAgICAgICAgIHBvczEsXG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBkQW5nbGUsXG4gICAgICAgICAgICBkUmF0aW8sXG4gICAgICAgICAgICBuZXdTdGFnZVgsXG4gICAgICAgICAgICBuZXdTdGFnZVksXG4gICAgICAgICAgICBuZXdTdGFnZVJhdGlvLFxuICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZTtcblxuICAgICAgICBfZG93blRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgICAgIF9pc01vdmluZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKF9tb3ZpbmdUaW1lb3V0SWQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF9tb3ZpbmdUaW1lb3V0SWQpO1xuXG4gICAgICAgIF9tb3ZpbmdUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF9pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB9LCBfc2V0dGluZ3MoJ2RyYWdUaW1lb3V0JykpO1xuXG4gICAgICAgIHN3aXRjaCAoX3RvdWNoTW9kZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBvczAgPSBwb3NpdGlvbihfZG93blRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgeDAgPSBwb3MwLng7XG4gICAgICAgICAgICB5MCA9IHBvczAueTtcblxuICAgICAgICAgICAgZGlmZiA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIHgwIC0gX3N0YXJ0VG91Y2hYMCxcbiAgICAgICAgICAgICAgeTAgLSBfc3RhcnRUb3VjaFkwLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBuZXdTdGFnZVggPSBfc3RhcnRDYW1lcmFYIC0gZGlmZi54O1xuICAgICAgICAgICAgbmV3U3RhZ2VZID0gX3N0YXJ0Q2FtZXJhWSAtIGRpZmYueTtcblxuICAgICAgICAgICAgaWYgKG5ld1N0YWdlWCAhPT0gX2NhbWVyYS54IHx8IG5ld1N0YWdlWSAhPT0gX2NhbWVyYS55KSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuXG4gICAgICAgICAgICAgIF9jYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgICAgICAgeDogbmV3U3RhZ2VYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1N0YWdlWVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLm1vdXNlQ29vcmRzKGUsIHBvczAueCwgcG9zMC55KSk7XG5cbiAgICAgICAgICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zMCA9IHBvc2l0aW9uKF9kb3duVG91Y2hlc1swXSk7XG4gICAgICAgICAgICBwb3MxID0gcG9zaXRpb24oX2Rvd25Ub3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHgwID0gcG9zMC54O1xuICAgICAgICAgICAgeTAgPSBwb3MwLnk7XG4gICAgICAgICAgICB4MSA9IHBvczEueDtcbiAgICAgICAgICAgIHkxID0gcG9zMS55O1xuXG4gICAgICAgICAgICBzdGFydCA9IF9jYW1lcmEuY2FtZXJhUG9zaXRpb24oXG4gICAgICAgICAgICAgIChfc3RhcnRUb3VjaFgwICsgX3N0YXJ0VG91Y2hYMSkgLyAyIC1cbiAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgICAgKF9zdGFydFRvdWNoWTAgKyBfc3RhcnRUb3VjaFkxKSAvIDIgLVxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS55LFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZW5kID0gX2NhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgICAgKHgwICsgeDEpIC8gMiAtIHNpZ21hLnV0aWxzLmdldENlbnRlcihlKS54LFxuICAgICAgICAgICAgICAoeTAgKyB5MSkgLyAyIC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGRBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCkgLSBfc3RhcnRUb3VjaEFuZ2xlO1xuICAgICAgICAgICAgZFJhdGlvID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAoeTEgLSB5MCkgKiAoeTEgLSB5MCkgKyAoeDEgLSB4MCkgKiAoeDEgLSB4MClcbiAgICAgICAgICAgICkgLyBfc3RhcnRUb3VjaERpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2xhdGlvbjpcbiAgICAgICAgICAgIHgwID0gc3RhcnQueDtcbiAgICAgICAgICAgIHkwID0gc3RhcnQueTtcblxuICAgICAgICAgICAgLy8gSG9tb3RoZXRpYyB0cmFuc2Zvcm1hdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gPSBfc3RhcnRDYW1lcmFSYXRpbyAvIGRSYXRpbztcbiAgICAgICAgICAgIHgwID0geDAgKiBkUmF0aW87XG4gICAgICAgICAgICB5MCA9IHkwICogZFJhdGlvO1xuXG4gICAgICAgICAgICAvLyBSb3RhdGlvbjpcbiAgICAgICAgICAgIG5ld1N0YWdlQW5nbGUgPSBfc3RhcnRDYW1lcmFBbmdsZSAtIGRBbmdsZTtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1kQW5nbGUpO1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4oLWRBbmdsZSk7XG4gICAgICAgICAgICB4MSA9IHgwICogY29zICsgeTAgKiBzaW47XG4gICAgICAgICAgICB5MSA9IHkwICogY29zIC0geDAgKiBzaW47XG4gICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgeTAgPSB5MTtcblxuICAgICAgICAgICAgLy8gRmluYWxpemU6XG4gICAgICAgICAgICBuZXdTdGFnZVggPSB4MCAtIGVuZC54ICsgX3N0YXJ0Q2FtZXJhWDtcbiAgICAgICAgICAgIG5ld1N0YWdlWSA9IHkwIC0gZW5kLnkgKyBfc3RhcnRDYW1lcmFZO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5ld1N0YWdlUmF0aW8gIT09IF9jYW1lcmEucmF0aW8gfHxcbiAgICAgICAgICAgICAgbmV3U3RhZ2VBbmdsZSAhPT0gX2NhbWVyYS5hbmdsZSB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVggIT09IF9jYW1lcmEueCB8fFxuICAgICAgICAgICAgICBuZXdTdGFnZVkgIT09IF9jYW1lcmEueVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIF9sYXN0Q2FtZXJhWCA9IF9jYW1lcmEueDtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFZID0gX2NhbWVyYS55O1xuICAgICAgICAgICAgICBfbGFzdENhbWVyYUFuZ2xlID0gX2NhbWVyYS5hbmdsZTtcbiAgICAgICAgICAgICAgX2xhc3RDYW1lcmFSYXRpbyA9IF9jYW1lcmEucmF0aW87XG5cbiAgICAgICAgICAgICAgX2NhbWVyYS5nb1RvKHtcbiAgICAgICAgICAgICAgICB4OiBuZXdTdGFnZVgsXG4gICAgICAgICAgICAgICAgeTogbmV3U3RhZ2VZLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBuZXdTdGFnZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHJhdGlvOiBuZXdTdGFnZVJhdGlvXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2RyYWcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBsaXN0ZW5pbmcgdG8gdGhlIGRvdWJsZSB0YXAgY3VzdG9tIGV2ZW50LiBJdCB3aWxsXG4gICAgICogYmFzaWNhbGx5IHpvb20gaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlIEEgdG91Y2ggZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RvdWJsZVRhcEhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBhbmltYXRpb247XG5cbiAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBfc2V0dGluZ3MoJ3RvdWNoRW5hYmxlZCcpKSB7XG4gICAgICAgIF9kb3VibGVUYXAgPSB0cnVlO1xuXG4gICAgICAgIHJhdGlvID0gMSAvIF9zZXR0aW5ncygnZG91YmxlQ2xpY2tab29taW5nUmF0aW8nKTtcblxuICAgICAgICBwb3MgPSBwb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkb3VibGVjbGljaycsXG4gICAgICAgICAgc2lnbWEudXRpbHMubW91c2VDb29yZHMoZSwgcG9zLngsIHBvcy55KSk7XG5cbiAgICAgICAgaWYgKF9zZXR0aW5ncygnZG91YmxlQ2xpY2tFbmFibGVkJykpIHtcbiAgICAgICAgICBwb3MgPSBfY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgcG9zLnggLSBzaWdtYS51dGlscy5nZXRDZW50ZXIoZSkueCxcbiAgICAgICAgICAgIHBvcy55IC0gc2lnbWEudXRpbHMuZ2V0Q2VudGVyKGUpLnksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFuaW1hdGlvbiA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBfc2V0dGluZ3MoJ2RvdWJsZUNsaWNrWm9vbUR1cmF0aW9uJyksXG4gICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgX2RvdWJsZVRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzaWdtYS51dGlscy56b29tVG8oX2NhbWVyYSwgcG9zLngsIHBvcy55LCByYXRpbywgYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KVxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIGlmICh0eXBlb2YgY29ucmFkID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnY29ucmFkIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgPSBmdW5jdGlvbihncmFwaCwgY2FtZXJhLCBzZXR0aW5ncywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyAnc2lnbWEucmVuZGVyZXJzLmNhbnZhczogV3JvbmcgYXJndW1lbnRzLic7XG5cbiAgICBpZiAoIShvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICAgIHRocm93ICdDb250YWluZXIgbm90IGZvdW5kLic7XG5cbiAgICB2YXIgayxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZm4sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZCh0aGlzKTtcblxuICAgIC8vIEluaXRpYWxpemUgbWFpbiBhdHRyaWJ1dGVzOlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmNvbnRleHRzID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIHRoaXMuc2V0dGluZ3MgPSAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnNldHRpbmdzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBvcHRpb25zLnNldHRpbmdzXG4gICAgICApID9cbiAgICAgICAgc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMuc2V0dGluZ3MpIDpcbiAgICAgICAgc2V0dGluZ3M7XG5cbiAgICAvLyBOb2RlIGluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBDb25yYWQgcmVsYXRlZCBhdHRyaWJ1dGVzOlxuICAgIHRoaXMuam9icyA9IHt9O1xuXG4gICAgLy8gRmluZCB0aGUgcHJlZml4OlxuICAgIHRoaXMub3B0aW9ucy5wcmVmaXggPSAncmVuZGVyZXInICsgdGhpcy5jb25yYWRJZCArICc6JztcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIERPTSBlbGVtZW50czpcbiAgICBpZiAoXG4gICAgICAhdGhpcy5zZXR0aW5ncygnYmF0Y2hFZGdlc0RyYXdpbmcnKVxuICAgICkge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnKTtcbiAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdERPTSgnY2FudmFzJywgJ2VkZ2VzJyk7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdzY2VuZScpO1xuICAgICAgdGhpcy5jb250ZXh0cy5ub2RlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgIHNpZ21hLm1pc2MuZHJhd0hvdmVycy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuXG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZW5kZXJzIHRoZSBncmFwaCBvbiB0aGUgY2FudmFzZXMuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLmNhbnZhc30gICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgaWQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgam9iLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZWRnZXMsXG4gICAgICAgIHJlbmRlcmVycyxcbiAgICAgICAgcmVuZGVyZXJUeXBlLFxuICAgICAgICBiYXRjaFNpemUsXG4gICAgICAgIHRlbXBHQ08sXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGRyYXdFZGdlTGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0VkZ2VMYWJlbHMnKSxcbiAgICAgICAgZW1iZWRTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MuZW1iZWRPYmplY3RzKG9wdGlvbnMsIHtcbiAgICAgICAgICBwcmVmaXg6IHRoaXMub3B0aW9ucy5wcmVmaXhcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNhbWVyYSdzIHZpZXc6XG4gICAgdGhpcy5jYW1lcmEuYXBwbHlWaWV3KFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdGhpcy5vcHRpb25zLnByZWZpeCxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIC8vIEZpbmQgd2hpY2ggbm9kZXMgYXJlIG9uIHNjcmVlbjpcbiAgICB0aGlzLmVkZ2VzT25TY3JlZW4gPSBbXTtcbiAgICB0aGlzLm5vZGVzT25TY3JlZW4gPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgdGhpcy5jYW1lcmEuZ2V0UmVjdGFuZ2xlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICk7XG5cbiAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpbmRleFthW2ldLmlkXSA9IGFbaV07XG5cbiAgICAvLyBEcmF3IGVkZ2VzOlxuICAgIC8vIC0gSWYgc2V0dGluZ3MoJ2JhdGNoRWRnZXNEcmF3aW5nJykgaXMgdHJ1ZSwgdGhlIGVkZ2VzIGFyZSBkaXNwbGF5ZWQgcGVyXG4gICAgLy8gICBiYXRjaGVzLiBJZiBub3QsIHRoZXkgYXJlIGRyYXduIGluIG9uZSBmcmFtZS5cbiAgICBpZiAoZHJhd0VkZ2VzKSB7XG4gICAgICAvLyBGaXJzdCwgbGV0J3MgaWRlbnRpZnkgd2hpY2ggZWRnZXMgdG8gZHJhdy4gVG8gZG8gdGhpcywgd2UganVzdCBrZWVwXG4gICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAvLyB0aGUgcXVhZHRyZWUgYW5kIHRoZSBcImhpZGRlblwiIGF0dHJpYnV0ZS4gV2UgYWxzbyBkbyBub3Qga2VlcCBoaWRkZW5cbiAgICAgIC8vIGVkZ2VzLlxuICAgICAgZm9yIChhID0gZ3JhcGguZWRnZXMoKSwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChpbmRleFtvLnNvdXJjZV0gfHwgaW5kZXhbby50YXJnZXRdKSAmJlxuICAgICAgICAgICghby5oaWRkZW4gJiYgIW5vZGVzKG8uc291cmNlKS5oaWRkZW4gJiYgIW5vZGVzKG8udGFyZ2V0KS5oaWRkZW4pXG4gICAgICAgIClcbiAgICAgICAgICB0aGlzLmVkZ2VzT25TY3JlZW4ucHVzaChvKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFwiYmF0Y2hFZGdlc0RyYXdpbmdcIiBzZXR0aW5ncyBpcyB0cnVlLCBlZGdlcyBhcmUgYmF0Y2hlZDpcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICAgIGlkID0gJ2VkZ2VzXycgKyB0aGlzLmNvbnJhZElkO1xuICAgICAgICBiYXRjaFNpemUgPSBlbWJlZFNldHRpbmdzKCdjYW52YXNFZGdlc0JhdGNoU2l6ZScpO1xuXG4gICAgICAgIGVkZ2VzID0gdGhpcy5lZGdlc09uU2NyZWVuO1xuICAgICAgICBsID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZWRnZXMubGVuZ3RoLCBzdGFydCArIGJhdGNoU2l6ZSk7XG5cbiAgICAgICAgam9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGVtcEdDTyA9IHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuXG4gICAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICAgIG8udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgZ3JhcGgubm9kZXMoby5zb3VyY2UpLFxuICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRHJhdyBlZGdlIGxhYmVsczpcbiAgICAgICAgICBpZiAoZHJhd0VkZ2VMYWJlbHMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgIG8gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKCFvLmhpZGRlbilcbiAgICAgICAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLmxhYmVscyxcbiAgICAgICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOlxuICAgICAgICAgIHRoaXMuY29udGV4dHMuZWRnZXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGVtcEdDTztcblxuICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICBpZiAoZW5kID09PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0ID0gZW5kICsgMTtcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbihlZGdlcy5sZW5ndGgsIHN0YXJ0ICsgYmF0Y2hTaXplKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICBjb25yYWQuYWRkSm9iKGlkLCBqb2IuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIElmIG5vdCwgdGhleSBhcmUgZHJhd24gaW4gb25lIGZyYW1lOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLmVkZ2VzO1xuICAgICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBvID0gYVtpXTtcbiAgICAgICAgICAocmVuZGVyZXJzW1xuICAgICAgICAgICAgby50eXBlIHx8IHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2RlZmF1bHRFZGdlVHlwZScpXG4gICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgIG8sXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnNvdXJjZSksXG4gICAgICAgICAgICBncmFwaC5ub2RlcyhvLnRhcmdldCksXG4gICAgICAgICAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLFxuICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEcmF3IGVkZ2UgbGFiZWxzOlxuICAgICAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgICAgIGlmIChkcmF3RWRnZUxhYmVscykge1xuICAgICAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5lZGdlcy5sYWJlbHM7XG4gICAgICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmhpZGRlbilcbiAgICAgICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdEVkZ2VUeXBlJylcbiAgICAgICAgICAgICAgXSB8fCByZW5kZXJlcnMuZGVmKShcbiAgICAgICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgICAgIGdyYXBoLm5vZGVzKGFbaV0uc291cmNlKSxcbiAgICAgICAgICAgICAgICBncmFwaC5ub2RlcyhhW2ldLnRhcmdldCksXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJhdyBub2RlczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdOb2Rlcykge1xuICAgICAgcmVuZGVyZXJzID0gc2lnbWEuY2FudmFzLm5vZGVzO1xuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChyZW5kZXJlcnNbXG4gICAgICAgICAgICBhW2ldLnR5cGUgfHwgdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJylcbiAgICAgICAgICBdIHx8IHJlbmRlcmVycy5kZWYpKFxuICAgICAgICAgICAgYVtpXSxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMubm9kZXMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IGxhYmVsczpcbiAgICAvLyAtIE5vIGJhdGNoaW5nXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIHJlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5sYWJlbHM7XG4gICAgICBmb3IgKGEgPSB0aGlzLm5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4pXG4gICAgICAgICAgKHJlbmRlcmVyc1tcbiAgICAgICAgICAgIGFbaV0udHlwZSB8fCB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgIF0gfHwgcmVuZGVyZXJzLmRlZikoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0cy5sYWJlbHMsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JlbmRlcicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBET00gZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHN3aXRjaGVzIGl0c1xuICAgKiBwb3NpdGlvbiB0byBcImFic29sdXRlXCIsIHJlZmVyZW5jZXMgaXQgdG8gdGhlIGRvbUVsZW1lbnRzIGF0dHJpYnV0ZSwgYW5kXG4gICAqIGZpbmFsbHkgYXBwZW5kcyBpdCB0byB0aGUgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgKHRvIHN0b3JlIGl0IGluIFwiZG9tRWxlbWVudHNcIikuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCkge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJylcbiAgICAgIHRoaXMuY29udGV4dHNbaWRdID0gZG9tLmdldENvbnRleHQoJzJkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLmNhbnZhcy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKHcgKiBwaXhlbFJhdGlvKSArICdweCcpO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoaCAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHNba10uc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuY2FudmFzfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuY2FudmFzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5jb250ZXh0cykge1xuICAgICAgdGhpcy5jb250ZXh0c1trXS5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBraWxscyBjb250ZXh0cyBhbmQgb3RoZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5jYW52YXMucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWxzLCBub2RlcyBhbmQgZWRnZXMgcmVuZGVyZXJzIGFyZSBzdG9yZWQgaW4gdGhlIHRocmVlIGZvbGxvd2luZ1xuICAgKiBvYmplY3RzLiBXaGVuIGFuIGVsZW1lbnQgaXMgZHJhd24sIGl0cyB0eXBlIHdpbGwgYmUgY2hlY2tlZCBhbmQgaWYgYVxuICAgKiByZW5kZXJlciB3aXRoIHRoZSBzYW1lIG5hbWUgZXhpc3RzLCBpdCB3aWxsIGJlIHVzZWQuIElmIG5vdCBmb3VuZCwgdGhlXG4gICAqIGRlZmF1bHQgcmVuZGVyZXIgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFRoZXkgYXJlIHN0b3JlZCBpbiBkaWZmZXJlbnQgZmlsZXMsIGluIHRoZSBcIi4vY2FudmFzXCIgZm9sZGVyLlxuICAgKi9cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubm9kZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5yZW5kZXJlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGNhbnZhcyBzaWdtYSdzIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmdyYXBofSAgICAgICAgICAgIGdyYXBoICAgIFRoZSBncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSAge3NpZ21hLmNsYXNzZXMuY2FtZXJhfSAgICAgICAgICAgY2FtZXJhICAgVGhlIGNhbWVyYS5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNpZ21hIGluc3RhbmNlIHNldHRpbmdzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICBvYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy5jYW52YXN9ICAgICAgICAgIFRoZSByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbCA9IGZ1bmN0aW9uKGdyYXBoLCBjYW1lcmEsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93ICdzaWdtYS5yZW5kZXJlcnMud2ViZ2w6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGssXG4gICAgICAgIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBfc2VsZiA9IHRoaXM7XG5cbiAgICBzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXIuZXh0ZW5kKHRoaXMpO1xuXG4gICAgLy8gQ29ucmFkIHJlbGF0ZWQgYXR0cmlidXRlczpcbiAgICB0aGlzLmpvYnMgPSB7fTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29ucmFkSWQnLCB7XG4gICAgICB2YWx1ZTogc2lnbWEudXRpbHMuaWQoKVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYWluIGF0dHJpYnV0ZXM6XG4gICAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLmRvbUVsZW1lbnRzID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2V0dGluZ3MgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9wdGlvbnMuc2V0dGluZ3NcbiAgICAgICkgP1xuICAgICAgICBzZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucy5zZXR0aW5ncykgOlxuICAgICAgICBzZXR0aW5ncztcblxuICAgIC8vIEZpbmQgdGhlIHByZWZpeDpcbiAgICB0aGlzLm9wdGlvbnMucHJlZml4ID0gdGhpcy5jYW1lcmEucmVhZFByZWZpeDtcblxuICAgIC8vIEluaXRpYWxpemUgcHJvZ3JhbXMgaGFzaFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbm9kZVByb2dyYW1zJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlUHJvZ3JhbXMnLCB7XG4gICAgICB2YWx1ZToge31cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25vZGVGbG9hdEFycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZWRnZUZsb2F0QXJyYXlzJywge1xuICAgICAgdmFsdWU6IHt9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlZGdlSW5kaWNlc0FycmF5cycsIHtcbiAgICAgIHZhbHVlOiB7fVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzOlxuICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKSB7XG4gICAgICB0aGlzLmluaXRET00oJ2NhbnZhcycsICdlZGdlcycsIHRydWUpO1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbm9kZXMnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnc2NlbmUnLCB0cnVlKTtcbiAgICAgIHRoaXMuY29udGV4dHMubm9kZXMgPSB0aGlzLmNvbnRleHRzLnNjZW5lO1xuICAgICAgdGhpcy5jb250ZXh0cy5lZGdlcyA9IHRoaXMuY29udGV4dHMuc2NlbmU7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbGFiZWxzJyk7XG4gICAgdGhpcy5pbml0RE9NKCdjYW52YXMnLCAnbW91c2UnKTtcbiAgICB0aGlzLmNvbnRleHRzLmhvdmVyID0gdGhpcy5jb250ZXh0cy5tb3VzZTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLm1vdXNlLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggc2lnbWEgZXZlbnRzOlxuICAgIHNpZ21hLm1pc2MuYmluZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuY2FtZXJhLnByZWZpeCk7XG4gICAgc2lnbWEubWlzYy5kcmF3SG92ZXJzLmNhbGwodGhpcywgdGhpcy5jYW1lcmEucHJlZml4KTtcblxuICAgIHRoaXMucmVzaXplKCk7XG4gIH07XG5cblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgZ2VuZXJhdGUgdGhlIG5vZGVzIGFuZCBlZGdlcyBmbG9hdCBhcnJheXMuIFRoaXMgc3RlcCBpc1xuICAgKiBzZXBhcmF0ZWQgZnJvbSB0aGUgXCJyZW5kZXJcIiBtZXRob2QsIGJlY2F1c2UgdG8ga2VlcCBXZWJHTCBlZmZpY2llbnQsIHNpbmNlXG4gICAqIGFsbCB0aGUgY2FtZXJhIGFuZCBtaWRkbGV3YXJlcyBhcmUgbW9kZWxpc2VkIGFzIG1hdHJpY2VzIGFuZCB0aGV5IGRvIG5vdFxuICAgKiByZXF1aXJlIHRoZSBmbG9hdCBhcnJheXMgdG8gYmUgcmVnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEJhc2ljYWxseSwgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgY2FtZXJhIG9yIGFwcGxpZXMgc29tZSBzcGVjaWZpYyBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb25zLCB0aGlzIHByb2Nlc3Mgc3RlcCB3aWxsIGJlIHNraXBwZWQsIGFuZCB0aGUgXCJyZW5kZXJcIlxuICAgKiBtZXRob2Qgd2lsbCBlZmZpY2llbnRseSByZWZyZXNoIHRoZSByZW5kZXJpbmcuXG4gICAqXG4gICAqIEFuZCB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIHRoZSBncmFwaCBjb2xvcnMgb3IgcG9zaXRpb25zIChhcHBseWluZyBhIG5ld1xuICAgKiBsYXlvdXQgb3IgZmlsdGVyaW5nIHRoZSBjb2xvcnMsIGZvciBpbnN0YW5jZSksIHRoaXMgXCJwcm9jZXNzXCIgc3RlcCB3aWxsIGJlXG4gICAqIHJlcXVpcmVkIHRvIHJlZ2VuZXJhdGUgdGhlIGZsb2F0IGFycmF5cy5cbiAgICpcbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgb3B0aW9ucyA9IHNpZ21hLnV0aWxzLmV4dGVuZChvcHRpb25zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkZWZhdWx0RWRnZVR5cGUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0RWRnZVR5cGUnKSxcbiAgICAgICAgZGVmYXVsdE5vZGVUeXBlID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZGVmYXVsdE5vZGVUeXBlJyk7XG5cbiAgICAvLyBFbXB0eSBmbG9hdCBhcnJheXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUZsb2F0QXJyYXlzKVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdO1xuXG4gICAgZm9yIChrIGluIHRoaXMuZWRnZUluZGljZXNBcnJheXMpXG4gICAgICBkZWxldGUgdGhpcy5lZGdlSW5kaWNlc0FycmF5c1trXTtcblxuICAgIC8vIFNvcnQgZWRnZXMgYW5kIG5vZGVzIHBlciB0eXBlczpcbiAgICBmb3IgKGEgPSBncmFwaC5lZGdlcygpLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0eXBlID0gYVtpXS50eXBlIHx8IGRlZmF1bHRFZGdlVHlwZTtcbiAgICAgIGsgPSAodHlwZSAmJiBzaWdtYS53ZWJnbC5lZGdlc1t0eXBlXSkgPyB0eXBlIDogJ2RlZic7XG5cbiAgICAgIGlmICghdGhpcy5lZGdlRmxvYXRBcnJheXNba10pXG4gICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdID0ge1xuICAgICAgICAgIGVkZ2VzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5lZGdlcy5wdXNoKGFbaV0pO1xuICAgIH1cblxuICAgIGZvciAoYSA9IGdyYXBoLm5vZGVzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHR5cGUgPSBhW2ldLnR5cGUgfHwgZGVmYXVsdE5vZGVUeXBlO1xuICAgICAgayA9ICh0eXBlICYmIHNpZ21hLndlYmdsLm5vZGVzW3R5cGVdKSA/IHR5cGUgOiAnZGVmJztcblxuICAgICAgaWYgKCF0aGlzLm5vZGVGbG9hdEFycmF5c1trXSlcbiAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10gPSB7XG4gICAgICAgICAgbm9kZXM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzLnB1c2goYVtpXSk7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBlZGdlczpcbiAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgIHJlbmRlcmVyID0gc2lnbWEud2ViZ2wuZWRnZXNba107XG4gICAgICBhID0gdGhpcy5lZGdlRmxvYXRBcnJheXNba10uZWRnZXM7XG5cbiAgICAgIC8vIENyZWF0aW5nIHRoZSBuZWNlc3NhcnkgYXJyYXlzXG4gICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlbiAmJlxuICAgICAgICAgICFncmFwaC5ub2RlcyhhW2ldLnNvdXJjZSkuaGlkZGVuICYmXG4gICAgICAgICAgIWdyYXBoLm5vZGVzKGFbaV0udGFyZ2V0KS5oaWRkZW5cbiAgICAgICAgKVxuICAgICAgICAgIHJlbmRlcmVyLmFkZEVkZ2UoXG4gICAgICAgICAgICBhW2ldLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS5zb3VyY2UpLFxuICAgICAgICAgICAgZ3JhcGgubm9kZXMoYVtpXS50YXJnZXQpLFxuICAgICAgICAgICAgdGhpcy5lZGdlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICBpICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFUyxcbiAgICAgICAgICAgIG9wdGlvbnMucHJlZml4LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1xuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuY29tcHV0ZUluZGljZXMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRoaXMuZWRnZUluZGljZXNBcnJheXNba10gPSByZW5kZXJlci5jb21wdXRlSW5kaWNlcyhcbiAgICAgICAgICB0aGlzLmVkZ2VGbG9hdEFycmF5c1trXS5hcnJheVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFB1c2ggbm9kZXM6XG4gICAgZm9yIChrIGluIHRoaXMubm9kZUZsb2F0QXJyYXlzKSB7XG4gICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLm5vZGVzW2tdO1xuICAgICAgYSA9IHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLm5vZGVzO1xuXG4gICAgICAvLyBDcmVhdGluZyB0aGUgbmVjZXNzYXJ5IGFycmF5c1xuICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICBhLmxlbmd0aCAqIHJlbmRlcmVyLlBPSU5UUyAqIHJlbmRlcmVyLkFUVFJJQlVURVNcbiAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5KVxuICAgICAgICAgIHRoaXMubm9kZUZsb2F0QXJyYXlzW2tdLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgIGEubGVuZ3RoICogcmVuZGVyZXIuUE9JTlRTICogcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICk7XG5cbiAgICAgICAgLy8gSnVzdCBjaGVjayB0aGF0IHRoZSBlZGdlIGFuZCBib3RoIGl0cyBleHRyZW1pdGllcyBhcmUgdmlzaWJsZTpcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFhW2ldLmhpZGRlblxuICAgICAgICApXG4gICAgICAgICAgcmVuZGVyZXIuYWRkTm9kZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICB0aGlzLm5vZGVGbG9hdEFycmF5c1trXS5hcnJheSxcbiAgICAgICAgICAgIGkgKiByZW5kZXJlci5QT0lOVFMgKiByZW5kZXJlci5BVFRSSUJVVEVTLFxuICAgICAgICAgICAgb3B0aW9ucy5wcmVmaXgsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVuZGVycyB0aGUgZ3JhcGguIEl0IGJhc2ljYWxseSBjYWxscyBlYWNoIHByb2dyYW0gKGFuZFxuICAgKiBnZW5lcmF0ZSB0aGVtIGlmIHRoZXkgZG8gbm90IGV4aXN0IHlldCkgdG8gcmVuZGVyIG5vZGVzIGFuZCBlZGdlcywgYmF0Y2hlZFxuICAgKiBwZXIgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGluIHRoZSBjYW52YXMgcmVuZGVyZXIsIGl0IGlzIHBvc3NpYmxlIHRvIGRpc3BsYXkgZWRnZXMsIG5vZGVzIGFuZCAvIG9yXG4gICAqIGxhYmVscyBpbiBiYXRjaGVzLCB0byBtYWtlIHRoZSB3aG9sZSB0aGluZyB3YXkgbW9yZSBzY2FsYWJsZS5cbiAgICpcbiAgICogQHBhcmFtICB7P29iamVjdH0gICAgICAgICAgICAgICBwYXJhbXMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLndlYmdsfSAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgbCxcbiAgICAgICAgayxcbiAgICAgICAgbyxcbiAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBncmFwaCA9IHRoaXMuZ3JhcGgsXG4gICAgICAgIG5vZGVzR2wgPSB0aGlzLmNvbnRleHRzLm5vZGVzLFxuICAgICAgICBlZGdlc0dsID0gdGhpcy5jb250ZXh0cy5lZGdlcyxcbiAgICAgICAgbWF0cml4ID0gdGhpcy5jYW1lcmEuZ2V0TWF0cml4KCksXG4gICAgICAgIG9wdGlvbnMgPSBzaWdtYS51dGlscy5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBkcmF3TGFiZWxzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd0xhYmVscycpLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyk7XG5cbiAgICAvLyBDYWxsIHRoZSByZXNpemUgZnVuY3Rpb246XG4gICAgdGhpcy5yZXNpemUoZmFsc2UpO1xuXG4gICAgLy8gQ2hlY2sgdGhlICdoaWRlRWRnZXNPbk1vdmUnIHNldHRpbmc6XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mob3B0aW9ucywgJ2hpZGVFZGdlc09uTW92ZScpKVxuICAgICAgaWYgKHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQgfHwgdGhpcy5jYW1lcmEuaXNNb3ZpbmcpXG4gICAgICAgIGRyYXdFZGdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQ2xlYXIgY2FudmFzZXM6XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgLy8gVHJhbnNsYXRlIG1hdHJpeCB0byBbd2lkdGgvMiwgaGVpZ2h0LzJdOlxuICAgIG1hdHJpeCA9IHNpZ21hLnV0aWxzLm1hdHJpY2VzLm11bHRpcGx5KFxuICAgICAgbWF0cml4LFxuICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMudHJhbnNsYXRpb24odGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMilcbiAgICApO1xuXG4gICAgLy8gS2lsbCBydW5uaW5nIGpvYnM6XG4gICAgZm9yIChrIGluIHRoaXMuam9icylcbiAgICAgIGlmIChjb25yYWQuaGFzSm9iKGspKVxuICAgICAgICBjb25yYWQua2lsbEpvYihrKTtcblxuICAgIGlmIChkcmF3RWRnZXMpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdiYXRjaEVkZ2VzRHJhd2luZycpKVxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBqb2IsXG4gICAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgaW5kaWNlcyxcbiAgICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgICAgICAgY3VycmVudFByb2dyYW07XG5cbiAgICAgICAgICBpZCA9ICdlZGdlc18nICsgdGhpcy5jb25yYWRJZDtcbiAgICAgICAgICBiYXRjaFNpemUgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbEVkZ2VzQmF0Y2hTaXplJyk7XG4gICAgICAgICAgYSA9IE9iamVjdC5rZXlzKHRoaXMuZWRnZUZsb2F0QXJyYXlzKTtcblxuICAgICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICBpbmRpY2VzID0gdGhpcy5lZGdlSW5kaWNlc0FycmF5c1thW2ldXTtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgZW5kID0gTWF0aC5taW4oXG4gICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGpvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pXG4gICAgICAgICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2FbaV1dID0gcmVuZGVyZXIuaW5pdFByb2dyYW0oZWRnZXNHbCk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgICBlZGdlc0dsLnVzZVByb2dyYW0odGhpcy5lZGdlUHJvZ3JhbXNbYVtpXV0pO1xuICAgICAgICAgICAgICByZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1thW2ldXSxcbiAgICAgICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgICAgIHNjYWxpbmdSYXRpbzogdGhpcy5zZXR0aW5ncyhcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgJ3dlYmdsT3ZlcnNhbXBsaW5nUmF0aW8nXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgY291bnQ6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IGluZGljZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhdGNoIGpvYidzIGVuZDpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZW5kID49IGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTICYmXG4gICAgICAgICAgICAgIGkgPT09IGEubGVuZ3RoIC0gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmpvYnNbaWRdO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmQgPj0gYXJyLmxlbmd0aCAvIHJlbmRlcmVyLkFUVFJJQlVURVMpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICBhcnIgPSB0aGlzLmVkZ2VGbG9hdEFycmF5c1thW2ldXS5hcnJheTtcbiAgICAgICAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5lZGdlc1thW2ldXTtcbiAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICBlbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICBzdGFydCArIGJhdGNoU2l6ZSAqIHJlbmRlcmVyLlBPSU5UUyxcbiAgICAgICAgICAgICAgICBhcnIubGVuZ3RoIC8gcmVuZGVyZXIuQVRUUklCVVRFU1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgIHN0YXJ0ICsgYmF0Y2hTaXplICogcmVuZGVyZXIuUE9JTlRTLFxuICAgICAgICAgICAgICAgIGFyci5sZW5ndGggLyByZW5kZXJlci5BVFRSSUJVVEVTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLmpvYnNbaWRdID0gam9iO1xuICAgICAgICAgIGNvbnJhZC5hZGRKb2IoaWQsIGpvYi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy5lZGdlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgICByZW5kZXJlciA9IHNpZ21hLndlYmdsLmVkZ2VzW2tdO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgcHJvZ3JhbTpcbiAgICAgICAgICBpZiAoIXRoaXMuZWRnZVByb2dyYW1zW2tdKVxuICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10gPSByZW5kZXJlci5pbml0UHJvZ3JhbShlZGdlc0dsKTtcblxuICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgIGlmICh0aGlzLmVkZ2VGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgICAgZWRnZXNHbC51c2VQcm9ncmFtKHRoaXMuZWRnZVByb2dyYW1zW2tdKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgICAgZWRnZXNHbCxcbiAgICAgICAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba10sXG4gICAgICAgICAgICAgIHRoaXMuZWRnZUZsb2F0QXJyYXlzW2tdLmFycmF5LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgICAgICByYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJyksXG4gICAgICAgICAgICAgICAgaW5kaWNlc0RhdGE6IHRoaXMuZWRnZUluZGljZXNBcnJheXNba11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhd05vZGVzKSB7XG4gICAgICAvLyBFbmFibGUgYmxlbmRpbmc6XG4gICAgICBub2Rlc0dsLmJsZW5kRnVuYyhub2Rlc0dsLlNSQ19BTFBIQSwgbm9kZXNHbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcbiAgICAgIG5vZGVzR2wuZW5hYmxlKG5vZGVzR2wuQkxFTkQpO1xuXG4gICAgICBmb3IgKGsgaW4gdGhpcy5ub2RlRmxvYXRBcnJheXMpIHtcbiAgICAgICAgcmVuZGVyZXIgPSBzaWdtYS53ZWJnbC5ub2Rlc1trXTtcblxuICAgICAgICAvLyBDaGVjayBwcm9ncmFtOlxuICAgICAgICBpZiAoIXRoaXMubm9kZVByb2dyYW1zW2tdKVxuICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdID0gcmVuZGVyZXIuaW5pdFByb2dyYW0obm9kZXNHbCk7XG5cbiAgICAgICAgLy8gUmVuZGVyXG4gICAgICAgIGlmICh0aGlzLm5vZGVGbG9hdEFycmF5c1trXSkge1xuICAgICAgICAgIG5vZGVzR2wudXNlUHJvZ3JhbSh0aGlzLm5vZGVQcm9ncmFtc1trXSk7XG4gICAgICAgICAgcmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgbm9kZXNHbCxcbiAgICAgICAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tdLFxuICAgICAgICAgICAgdGhpcy5ub2RlRmxvYXRBcnJheXNba10uYXJyYXksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLFxuICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICAgIHJhdGlvOiB0aGlzLmNhbWVyYS5yYXRpbyxcbiAgICAgICAgICAgICAgc2NhbGluZ1JhdGlvOiB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICd3ZWJnbE92ZXJzYW1wbGluZ1JhdGlvJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRyYXdMYWJlbHMpIHtcbiAgICAgIGEgPSB0aGlzLmNhbWVyYS5xdWFkdHJlZS5hcmVhKFxuICAgICAgICB0aGlzLmNhbWVyYS5nZXRSZWN0YW5nbGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICApO1xuXG4gICAgICAvLyBBcHBseSBjYW1lcmEgdmlldyB0byB0aGVzZSBub2RlczpcbiAgICAgIHRoaXMuY2FtZXJhLmFwcGx5VmlldyhcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBub2RlczogYSxcbiAgICAgICAgICBlZGdlczogW10sXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBvID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNldHRpbmdzKHtcbiAgICAgICAgICBwcmVmaXg6IHNlbGYuY2FtZXJhLnByZWZpeFxuICAgICAgICB9LCBrZXkpO1xuICAgICAgfTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0uaGlkZGVuKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5sYWJlbHNbXG4gICAgICAgICAgICAgIGFbaV0udHlwZSB8fFxuICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkZWZhdWx0Tm9kZVR5cGUnKVxuICAgICAgICAgICAgXSB8fCBzaWdtYS5jYW52YXMubGFiZWxzLmRlZlxuICAgICAgICAgICkoYVtpXSwgdGhpcy5jb250ZXh0cy5sYWJlbHMsIG8pO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgncmVuZGVyJyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG5cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIERPTSBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSwgc3dpdGNoZXMgaXRzXG4gICAqIHBvc2l0aW9uIHRvIFwiYWJzb2x1dGVcIiwgcmVmZXJlbmNlcyBpdCB0byB0aGUgZG9tRWxlbWVudHMgYXR0cmlidXRlLCBhbmRcbiAgICogZmluYWxseSBhcHBlbmRzIGl0IHRvIHRoZSBjb250YWluZXIuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICB0YWcgICBUaGUgbGFiZWwgdGFnLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWQgICAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkb21FbGVtZW50c1wiKS5cbiAgICogQHBhcmFtICB7P2Jvb2xlYW59IHdlYmdsIFdpbGwgaW5pdCB0aGUgV2ViR0wgY29udGV4dCBpZiB0cnVlLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLndlYmdsLnByb3RvdHlwZS5pbml0RE9NID0gZnVuY3Rpb24odGFnLCBpZCwgd2ViZ2wpIHtcbiAgICB2YXIgZ2wsXG4gICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3NpZ21hLScgKyBpZCk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnRzW2lkXSA9IGRvbTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChkb20pO1xuXG4gICAgaWYgKHRhZy50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgdGhpcy5jb250ZXh0c1tpZF0gPSBkb20uZ2V0Q29udGV4dCh3ZWJnbCA/ICdleHBlcmltZW50YWwtd2ViZ2wnIDogJzJkJywge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGRpbmcgd2ViZ2wgY29udGV4dCBsb3NzIGxpc3RlbmVyc1xuICAgICAgaWYgKHdlYmdsKSB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXNpemVzIGVhY2ggRE9NIGVsZW1lbnRzIGluIHRoZSBjb250YWluZXIgYW5kIHN0b3JlcyB0aGUgbmV3XG4gICAqIGRpbWVuc2lvbnMuIFRoZW4sIGl0IHJlbmRlcnMgdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/bnVtYmVyfSAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgaGVpZ2h0IFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3NpZ21hLnJlbmRlcmVycy53ZWJnbH0gICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBrLFxuICAgICAgICBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gc2lnbWEudXRpbHMuZ2V0UGl4ZWxSYXRpbygpO1xuXG4gICAgaWYgKHcgIT09IHVuZGVmaW5lZCAmJiBoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcblxuICAgICAgdyA9IHRoaXMud2lkdGg7XG4gICAgICBoID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZFdpZHRoICE9PSB0aGlzLndpZHRoIHx8IG9sZEhlaWdodCAhPT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgIGZvciAoayBpbiB0aGlzLmRvbUVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHNba10uc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcblxuICAgICAgICBpZiAodGhpcy5kb21FbGVtZW50c1trXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgLy8gSWYgc2ltcGxlIDJEIGNhbnZhczpcbiAgICAgICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAodyAqIHBpeGVsUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSArICdweCcpO1xuXG4gICAgICAgICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSlcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0c1trXS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb21FbGVtZW50c1trXS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICh3ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzW2tdLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgIChoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpKSArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2NhbGU6XG4gICAgZm9yIChrIGluIHRoaXMuY29udGV4dHMpXG4gICAgICBpZiAodGhpcy5jb250ZXh0c1trXSAmJiB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KVxuICAgICAgICB0aGlzLmNvbnRleHRzW2tdLnZpZXdwb3J0KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpLFxuICAgICAgICAgIHRoaXMuaGVpZ2h0ICogdGhpcy5zZXR0aW5ncygnd2ViZ2xPdmVyc2FtcGxpbmdSYXRpbycpXG4gICAgICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2xlYXJzIGVhY2ggY2FudmFzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMud2ViZ2x9IFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy53ZWJnbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dHMubm9kZXMuY2xlYXIodGhpcy5jb250ZXh0cy5ub2Rlcy5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB0aGlzLmNvbnRleHRzLmVkZ2VzLmNsZWFyKHRoaXMuY29udGV4dHMuZWRnZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2Qga2lsbHMgY29udGV4dHMgYW5kIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgayxcbiAgICAgICAgY2FwdG9yO1xuXG4gICAgLy8gS2lsbCBjYXB0b3JzOlxuICAgIHdoaWxlICgoY2FwdG9yID0gdGhpcy5jYXB0b3JzLnBvcCgpKSlcbiAgICAgIGNhcHRvci5raWxsKCk7XG4gICAgZGVsZXRlIHRoaXMuY2FwdG9ycztcblxuICAgIC8vIEtpbGwgY29udGV4dHM6XG4gICAgZm9yIChrIGluIHRoaXMuZG9tRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuZG9tRWxlbWVudHNba10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2tdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzW2tdO1xuICAgICAgZGVsZXRlIHRoaXMuY29udGV4dHNba107XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbUVsZW1lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLmNvbnRleHRzO1xuICB9O1xuXG5cblxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IFwic2lnbWEud2ViZ2wubm9kZXNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50IFdlYkdMIG5vZGVcbiAgICogcmVuZGVyZXJzLiBUaGUgZGVmYXVsdCBvbmUgZHJhdyBub2RlcyBhcyBkaXNjcy4gSGVyZSBhcmUgdGhlIGF0dHJpYnV0ZXNcbiAgICogYW55IG5vZGUgcmVuZGVyZXIgbXVzdCBoYXZlOlxuICAgKlxuICAgKiB7bnVtYmVyfSAgIFBPSU5UUyAgICAgIFRoZSBudW1iZXIgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGRyYXcgYSBub2RlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkTm9kZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYSBub2RlIHRvIHRoZSBkYXRhIHN0YWNrIHRoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIGdpdmVuIHRvIHRoZSBidWZmZXIuIEhlcmUgaXMgdGhlIGFyZ3VtZW50czpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtudW1iZXJ9ICAgICAgIGluZGV4ICAgVGhlIG5vZGUgaW5kZXggaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzIGFycmF5LlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgbm9kZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wubm9kZXMuZGVmIG9yIHNpZ21hLndlYmdsLm5vZGVzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLndlYmdsLmVkZ2VzXCIgY29udGFpbnMgdGhlIGRpZmZlcmVudCBXZWJHTCBlZGdlXG4gICAqIHJlbmRlcmVycy4gVGhlIGRlZmF1bHQgb25lIGRyYXcgZWRnZXMgYXMgZGlyZWN0IGxpbmVzLiBIZXJlIGFyZSB0aGVcbiAgICogYXR0cmlidXRlcyBhbnkgZWRnZSByZW5kZXJlciBtdXN0IGhhdmU6XG4gICAqXG4gICAqIHtudW1iZXJ9ICAgUE9JTlRTICAgICAgVGhlIG51bWJlciBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZHJhdyBhbiBlZGdlLlxuICAgKiB7bnVtYmVyfSAgIEFUVFJJQlVURVMgIFRoZSBudW1iZXIgb2YgYXR0cmlidXRlcyBuZWVkZWQgdG8gZHJhdyBvbmUgcG9pbnQuXG4gICAqIHtmdW5jdGlvbn0gYWRkRWRnZSAgICAgQSBmdW5jdGlvbiB0aGF0IGFkZHMgYW4gZWRnZSB0byB0aGUgZGF0YSBzdGFjayB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBnaXZlbiB0byB0aGUgYnVmZmVyLiBIZXJlIGlzIHRoZSBhcmd1bWVudHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBlZGdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICA+IHtvYmplY3R9ICAgICAgIHRhcmdldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2suXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7b2JqZWN0fSAgICAgICBvcHRpb25zIFNvbWUgb3B0aW9ucy5cbiAgICoge2Z1bmN0aW9ufSByZW5kZXIgICAgICBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGVmZmVjdGl2ZWx5IHJlbmRlciB0aGUgZWRnZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpbnRvIHRoZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgPiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge1dlYkdMUHJvZ3JhbX0gICAgICAgICAgcHJvZ3JhbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge0Zsb2F0MzJBcnJheX0gZGF0YSAgICBUaGUgc3RhY2sgdG8gZ2l2ZSB0byB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgID4ge29iamVjdH0gICAgICAgcGFyYW1zICBBbiBvYmplY3QgY29udGFpbmluZyBzb21lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsIGxpa2Ugd2lkdGgsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCwgdGhlIGNhbWVyYSByYXRpby5cbiAgICoge2Z1bmN0aW9ufSBpbml0UHJvZ3JhbSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGluaXRpYXRlIHRoZSBwcm9ncmFtLCB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHJlbGV2YW50IHNoYWRlcnMgYW5kIHBhcmFtZXRlcnMuIEl0IG11c3QgcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG5ld2x5IGNyZWF0ZWQgcHJvZ3JhbS5cbiAgICpcbiAgICogQ2hlY2sgc2lnbWEud2ViZ2wuZWRnZXMuZGVmIG9yIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgdG8gc2VlIGhvdyBpdFxuICAgKiB3b3JrcyBtb3JlIHByZWNpc2VseS5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wuZWRnZXMnKTtcblxuXG5cblxuICAvKipcbiAgICogVGhlIG9iamVjdCBcInNpZ21hLmNhbnZhcy5sYWJlbHNcIiBjb250YWlucyB0aGUgZGlmZmVyZW50XG4gICAqIGxhYmVsIHJlbmRlcmVycyBmb3IgdGhlIFdlYkdMIHJlbmRlcmVyLiBTaW5jZSBkaXNwbGF5aW5nIHRleHRzIGluIFdlYkdMIGlzXG4gICAqIGRlZmluaXRlbHkgcGFpbmZ1bCBhbmQgc2luY2UgdGhlcmUgYSB3YXkgbGVzcyBsYWJlbHMgdG8gZGlzcGxheSB0aGFuIG5vZGVzXG4gICAqIG9yIGVkZ2VzLCB0aGUgZGVmYXVsdCByZW5kZXJlciBzaW1wbHkgcmVuZGVycyB0aGVtIGluIGEgY2FudmFzLlxuICAgKlxuICAgKiBBIGxhYmVscyByZW5kZXJlciBpcyBhIHNpbXBsZSBmdW5jdGlvbiwgdGFraW5nIGFzIGFyZ3VtZW50cyB0aGUgcmVsYXRlZFxuICAgKiBub2RlLCB0aGUgcmVuZGVyZXIgYW5kIGEgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5sYWJlbHMnKTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICBpZiAodHlwZW9mIGNvbnJhZCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ2NvbnJhZCBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBzdmcgc2lnbWEncyByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWEuY2xhc3Nlcy5ncmFwaH0gICAgICAgICAgICBncmFwaCAgICBUaGUgZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gIHtzaWdtYS5jbGFzc2VzLmNhbWVyYX0gICAgICAgICAgIGNhbWVyYSAgIFRoZSBjYW1lcmEuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgIHNldHRpbmdzIFRoZSBzaWdtYSBpbnN0YW5jZSBzZXR0aW5nc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgb2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgICBUaGUgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnID0gZnVuY3Rpb24oZ3JhcGgsIGNhbWVyYSwgc2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgICAgdGhyb3cgJ3NpZ21hLnJlbmRlcmVycy5zdmc6IFdyb25nIGFyZ3VtZW50cy4nO1xuXG4gICAgaWYgKCEob3B0aW9ucy5jb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpXG4gICAgICB0aHJvdyAnQ29udGFpbmVyIG5vdCBmb3VuZC4nO1xuXG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGZuLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIG1haW4gYXR0cmlidXRlczpcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IHtcbiAgICAgIGdyYXBoOiBudWxsLFxuICAgICAgZ3JvdXBzOiB7fSxcbiAgICAgIG5vZGVzOiB7fSxcbiAgICAgIGVkZ2VzOiB7fSxcbiAgICAgIGxhYmVsczoge30sXG4gICAgICBob3ZlcnM6IHt9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVtZW50Q2FudmFzID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmNvbnRhaW5lcjtcbiAgICB0aGlzLnNldHRpbmdzID0gKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zZXR0aW5ncyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICAgKSA/XG4gICAgICAgIHNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLnNldHRpbmdzKSA6XG4gICAgICAgIHNldHRpbmdzO1xuXG4gICAgLy8gSXMgdGhlIHJlbmRlcmVyIG1lYW50IHRvIGJlIGZyZWVzdHlsZT9cbiAgICB0aGlzLnNldHRpbmdzKCdmcmVlU3R5bGUnLCAhIXRoaXMub3B0aW9ucy5mcmVlU3R5bGUpO1xuXG4gICAgLy8gU1ZHIHhtbG5zXG4gICAgdGhpcy5zZXR0aW5ncygneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcblxuICAgIC8vIEluZGV4ZXM6XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG5cbiAgICAvLyBGaW5kIHRoZSBwcmVmaXg6XG4gICAgdGhpcy5vcHRpb25zLnByZWZpeCA9ICdyZW5kZXJlcicgKyBzaWdtYS51dGlscy5pZCgpICsgJzonO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5pbml0RE9NKCdzdmcnKTtcblxuICAgIC8vIEluaXRpYWxpemUgY2FwdG9yczpcbiAgICB0aGlzLmNhcHRvcnMgPSBbXTtcbiAgICBhID0gdGhpcy5vcHRpb25zLmNhcHRvcnMgfHwgW3NpZ21hLmNhcHRvcnMubW91c2UsIHNpZ21hLmNhcHRvcnMudG91Y2hdO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4gPSB0eXBlb2YgYVtpXSA9PT0gJ2Z1bmN0aW9uJyA/IGFbaV0gOiBzaWdtYS5jYXB0b3JzW2FbaV1dO1xuICAgICAgdGhpcy5jYXB0b3JzLnB1c2goXG4gICAgICAgIG5ldyBmbihcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLFxuICAgICAgICAgIHRoaXMuY2FtZXJhLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIHJlc2l6ZTpcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gRGVhbCB3aXRoIHNpZ21hIGV2ZW50czpcbiAgICAvLyBUT0RPOiBrZWVwIGFuIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgRE9NIGV2ZW50cz9cbiAgICBzaWdtYS5taXNjLmJpbmRET01FdmVudHMuY2FsbCh0aGlzLCB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoKTtcbiAgICB0aGlzLmJpbmRIb3ZlcnModGhpcy5vcHRpb25zLnByZWZpeCk7XG5cbiAgICAvLyBSZXNpemVcbiAgICB0aGlzLnJlc2l6ZShmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgdGhlIGdyYXBoIG9uIHRoZSBzdmcgc2NlbmUuXG4gICAqXG4gICAqIEBwYXJhbSAgez9vYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICBSZXR1cm5zIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICBzaWdtYS5yZW5kZXJlcnMuc3ZnLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgYSxcbiAgICAgICAgaSxcbiAgICAgICAgayxcbiAgICAgICAgZSxcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgcmVuZGVyZXJzLFxuICAgICAgICBzdWJyZW5kZXJlcnMsXG4gICAgICAgIGluZGV4ID0ge30sXG4gICAgICAgIGdyYXBoID0gdGhpcy5ncmFwaCxcbiAgICAgICAgbm9kZXMgPSB0aGlzLmdyYXBoLm5vZGVzLFxuICAgICAgICBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4IHx8ICcnLFxuICAgICAgICBkcmF3RWRnZXMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3RWRnZXMnKSxcbiAgICAgICAgZHJhd05vZGVzID0gdGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnZHJhd05vZGVzJyksXG4gICAgICAgIGRyYXdMYWJlbHMgPSB0aGlzLnNldHRpbmdzKG9wdGlvbnMsICdkcmF3TGFiZWxzJyksXG4gICAgICAgIGVtYmVkU2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLmVtYmVkT2JqZWN0cyhvcHRpb25zLCB7XG4gICAgICAgICAgcHJlZml4OiB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAgICAgIGZvcmNlTGFiZWxzOiB0aGlzLm9wdGlvbnMuZm9yY2VMYWJlbHNcbiAgICAgICAgfSk7XG5cbiAgICAvLyBDaGVjayB0aGUgJ2hpZGVFZGdlc09uTW92ZScgc2V0dGluZzpcbiAgICBpZiAodGhpcy5zZXR0aW5ncyhvcHRpb25zLCAnaGlkZUVkZ2VzT25Nb3ZlJykpXG4gICAgICBpZiAodGhpcy5jYW1lcmEuaXNBbmltYXRlZCB8fCB0aGlzLmNhbWVyYS5pc01vdmluZylcbiAgICAgICAgZHJhd0VkZ2VzID0gZmFsc2U7XG5cbiAgICAvLyBBcHBseSB0aGUgY2FtZXJhJ3MgdmlldzpcbiAgICB0aGlzLmNhbWVyYS5hcHBseVZpZXcoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbnMucHJlZml4LFxuICAgICAge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBIaWRpbmcgZXZlcnl0aGluZ1xuICAgIC8vIFRPRE86IGZpbmQgYSBtb3JlIHNlbnNpYmxlIHdheSB0byBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uXG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5ub2Rlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5lZGdlcyk7XG4gICAgdGhpcy5oaWRlRE9NRWxlbWVudHModGhpcy5kb21FbGVtZW50cy5sYWJlbHMpO1xuXG4gICAgLy8gRmluZCB3aGljaCBub2RlcyBhcmUgb24gc2NyZWVuXG4gICAgdGhpcy5lZGdlc09uU2NyZWVuID0gW107XG4gICAgdGhpcy5ub2Rlc09uU2NyZWVuID0gdGhpcy5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgIHRoaXMuY2FtZXJhLmdldFJlY3RhbmdsZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICApO1xuXG4gICAgLy8gTm9kZSBpbmRleFxuICAgIGZvciAoYSA9IHRoaXMubm9kZXNPblNjcmVlbiwgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGluZGV4W2FbaV0uaWRdID0gYVtpXTtcblxuICAgIC8vIEZpbmQgd2hpY2ggZWRnZXMgYXJlIG9uIHNjcmVlblxuICAgIGZvciAoYSA9IGdyYXBoLmVkZ2VzKCksIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG8gPSBhW2ldO1xuICAgICAgaWYgKFxuICAgICAgICAoaW5kZXhbby5zb3VyY2VdIHx8IGluZGV4W28udGFyZ2V0XSkgJiZcbiAgICAgICAgKCFvLmhpZGRlbiAmJiAhbm9kZXMoby5zb3VyY2UpLmhpZGRlbiAmJiAhbm9kZXMoby50YXJnZXQpLmhpZGRlbilcbiAgICAgIClcbiAgICAgICAgdGhpcy5lZGdlc09uU2NyZWVuLnB1c2gobyk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheSBub2Rlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVuZGVyZXJzID0gc2lnbWEuc3ZnLm5vZGVzO1xuICAgIHN1YnJlbmRlcmVycyA9IHNpZ21hLnN2Zy5sYWJlbHM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgbm9kZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghYVtpXS5oaWRkZW4gJiYgIXRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0pIHtcblxuICAgICAgICAgIC8vIE5vZGVcbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLm5vZGVzLmFwcGVuZENoaWxkKGUpO1xuXG4gICAgICAgICAgLy8gTGFiZWxcbiAgICAgICAgICBlID0gKHN1YnJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHN1YnJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubGFiZWxzW2FbaV0uaWRdID0gZTtcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyb3Vwcy5sYWJlbHMuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vLS0gU2Vjb25kIHdlIHVwZGF0ZSB0aGUgbm9kZXNcbiAgICBpZiAoZHJhd05vZGVzKVxuICAgICAgZm9yIChhID0gdGhpcy5ub2Rlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFbaV0uaGlkZGVuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIE5vZGVcbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMubm9kZXNbYVtpXS5pZF0sXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuXG4gICAgICAgIC8vIExhYmVsXG4gICAgICAgIChzdWJyZW5kZXJlcnNbYVtpXS50eXBlXSB8fCBzdWJyZW5kZXJlcnMuZGVmKS51cGRhdGUoXG4gICAgICAgICAgYVtpXSxcbiAgICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmxhYmVsc1thW2ldLmlkXSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAvLyBEaXNwbGF5IGVkZ2VzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS1cbiAgICByZW5kZXJlcnMgPSBzaWdtYS5zdmcuZWRnZXM7XG5cbiAgICAvLy0tIEZpcnN0IHdlIGNyZWF0ZSB0aGUgZWRnZXMgd2hpY2ggYXJlIG5vdCBhbHJlYWR5IGNyZWF0ZWRcbiAgICBpZiAoZHJhd0VkZ2VzKVxuICAgICAgZm9yIChhID0gdGhpcy5lZGdlc09uU2NyZWVuLCBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb21FbGVtZW50cy5lZGdlc1thW2ldLmlkXSkge1xuICAgICAgICAgIHNvdXJjZSA9IG5vZGVzKGFbaV0uc291cmNlKTtcbiAgICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgICBlID0gKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgICAgIGFbaV0sXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0gPSBlO1xuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JvdXBzLmVkZ2VzLmFwcGVuZENoaWxkKGUpO1xuICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgLy8tLSBTZWNvbmQgd2UgdXBkYXRlIHRoZSBlZGdlc1xuICAgIGlmIChkcmF3RWRnZXMpXG4gICAgICBmb3IgKGEgPSB0aGlzLmVkZ2VzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc291cmNlID0gbm9kZXMoYVtpXS5zb3VyY2UpO1xuICAgICAgICB0YXJnZXQgPSBub2RlcyhhW2ldLnRhcmdldCk7XG5cbiAgICAgICAgKHJlbmRlcmVyc1thW2ldLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLnVwZGF0ZShcbiAgICAgICAgICBhW2ldLFxuICAgICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZWRnZXNbYVtpXS5pZF0sXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICk7XG4gICAgICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZW5kZXInKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBzd2l0Y2hlcyBpdHNcbiAgICogcG9zaXRpb24gdG8gXCJhYnNvbHV0ZVwiLCByZWZlcmVuY2VzIGl0IHRvIHRoZSBkb21FbGVtZW50cyBhdHRyaWJ1dGUsIGFuZFxuICAgKiBmaW5hbGx5IGFwcGVuZHMgaXQgdG8gdGhlIGNvbnRhaW5lci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGhlIGxhYmVsIHRhZy5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAgVGhlIGlkIG9mIHRoZSBlbGVtZW50ICh0byBzdG9yZSBpdCBpbiBcImRvbUVsZW1lbnRzXCIpLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuaW5pdERPTSA9IGZ1bmN0aW9uKHRhZykge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgdGFnKSxcbiAgICAgICAgYyA9IHRoaXMuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JyksXG4gICAgICAgIGcsXG4gICAgICAgIGwsXG4gICAgICAgIGk7XG5cbiAgICBkb20uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYyArICctc3ZnJyk7XG5cbiAgICAvLyBTZXR0aW5nIFNWRyBuYW1lc3BhY2VcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4bWxucycsIHRoaXMuc2V0dGluZ3MoJ3htbG5zJykpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgJzEuMScpO1xuXG4gICAgLy8gQ3JlYXRpbmcgdGhlIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGMgKyAnLW1lYXN1cmVtZW50LWNhbnZhcycpO1xuXG4gICAgLy8gQXBwZW5kaW5nIGVsZW1lbnRzXG4gICAgdGhpcy5kb21FbGVtZW50cy5ncmFwaCA9IHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGRvbSk7XG5cbiAgICAvLyBDcmVhdGluZyBncm91cHNcbiAgICB2YXIgZ3JvdXBzID0gWydlZGdlcycsICdub2RlcycsICdsYWJlbHMnLCAnaG92ZXJzJ107XG4gICAgZm9yIChpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zZXR0aW5ncygneG1sbnMnKSwgJ2cnKTtcblxuICAgICAgZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaWQnLCBjICsgJy1ncm91cC0nICsgZ3JvdXBzW2ldKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgYyArICctZ3JvdXAnKTtcblxuICAgICAgdGhpcy5kb21FbGVtZW50cy5ncm91cHNbZ3JvdXBzW2ldXSA9XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguYXBwZW5kQ2hpbGQoZyk7XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kaW5nIG1lYXN1cmVtZW50IGNhbnZhc1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgdGhpcy5tZWFzdXJlbWVudENhbnZhcyA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBoaWRlcyBhIGJhdGNoIG9mIFNWRyBET00gZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FycmF5fSAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICBBbiBhcnJheSBvZiBlbGVtZW50cyB0byBoaWRlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICByZW5kZXJlciAgVGhlIHJlbmRlcmVyIHRvIHVzZS5cbiAgICogQHJldHVybiB7c2lnbWEucmVuZGVyZXJzLnN2Z30gICAgICAgICAgICAgIFJldHVybnMgdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHNpZ21hLnJlbmRlcmVycy5zdmcucHJvdG90eXBlLmhpZGVET01FbGVtZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIG8sXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgaW4gZWxlbWVudHMpIHtcbiAgICAgIG8gPSBlbGVtZW50c1tpXTtcbiAgICAgIHNpZ21hLnN2Zy51dGlscy5oaWRlKG8pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgaG92ZXIgZXZlbnRzIHRvIHRoZSByZW5kZXJlci5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcmVmaXggVGhlIHJlbmRlcmVyIHByZWZpeC5cbiAgICovXG4gIC8vIFRPRE86IGFkZCBvcHRpb24gYWJvdXQgd2hldGhlciB0byBkaXNwbGF5IGhvdmVycyBvciBub3RcbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUuYmluZEhvdmVycyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciByZW5kZXJlcnMgPSBzaWdtYS5zdmcuaG92ZXJzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaG92ZXJlZE5vZGU7XG5cbiAgICBmdW5jdGlvbiBvdmVyTm9kZShlKSB7XG4gICAgICB2YXIgbm9kZSA9IGUuZGF0YS5ub2RlLFxuICAgICAgICAgIGVtYmVkU2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzLmVtYmVkT2JqZWN0cyh7XG4gICAgICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVtYmVkU2V0dGluZ3MoJ2VuYWJsZUhvdmVyaW5nJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIGhvdmVyID0gKHJlbmRlcmVyc1tub2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ub2Rlc1tub2RlLmlkXSxcbiAgICAgICAgc2VsZi5tZWFzdXJlbWVudENhbnZhcyxcbiAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgKTtcblxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgICAgaG92ZXJlZE5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91dE5vZGUoZSkge1xuICAgICAgdmFyIG5vZGUgPSBlLmRhdGEubm9kZSxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgaWYgKCFlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnRcbiAgICAgIHNlbGYuZG9tRWxlbWVudHMuZ3JvdXBzLmhvdmVycy5yZW1vdmVDaGlsZChcbiAgICAgICAgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbbm9kZS5pZF07XG5cbiAgICAgIC8vIFJlaW5zdGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMubm9kZXMuYXBwZW5kQ2hpbGQoXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbbm9kZS5pZF1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gT1BUSU1JWkU6IHBlcmZvcm0gYSByZWFsIHVwZGF0ZSByYXRoZXIgdGhhbiBhIGRlbGV0aW9uXG4gICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgaWYgKCFob3ZlcmVkTm9kZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZW1iZWRTZXR0aW5ncyA9IHNlbGYuc2V0dGluZ3MuZW1iZWRPYmplY3RzKHtcbiAgICAgICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICAgICAgfSk7XG5cbiAgICAgIC8vIERlbGV0aW5nIGVsZW1lbnQgYmVmb3JlIHVwZGF0ZVxuICAgICAgc2VsZi5kb21FbGVtZW50cy5ncm91cHMuaG92ZXJzLnJlbW92ZUNoaWxkKFxuICAgICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF1cbiAgICAgICk7XG4gICAgICBkZWxldGUgc2VsZi5kb21FbGVtZW50cy5ob3ZlcnNbaG92ZXJlZE5vZGUuaWRdO1xuXG4gICAgICB2YXIgaG92ZXIgPSAocmVuZGVyZXJzW2hvdmVyZWROb2RlLnR5cGVdIHx8IHJlbmRlcmVycy5kZWYpLmNyZWF0ZShcbiAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgIHNlbGYuZG9tRWxlbWVudHMubm9kZXNbaG92ZXJlZE5vZGUuaWRdLFxuICAgICAgICBzZWxmLm1lYXN1cmVtZW50Q2FudmFzLFxuICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICApO1xuXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmhvdmVyc1tob3ZlcmVkTm9kZS5pZF0gPSBob3ZlcjtcblxuICAgICAgLy8gSW5zZXJ0aW5nIHRoZSBob3ZlciBpbiB0aGUgZG9tXG4gICAgICBzZWxmLmRvbUVsZW1lbnRzLmdyb3Vwcy5ob3ZlcnMuYXBwZW5kQ2hpbGQoaG92ZXIpO1xuICAgIH1cblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgdGhpcy5iaW5kKCdvdmVyTm9kZScsIG92ZXJOb2RlKTtcbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBvdXROb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBvbiByZW5kZXJcbiAgICB0aGlzLmJpbmQoJ3JlbmRlcicsIHVwZGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgZWFjaCBET00gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lciBhbmQgc3RvcmVzIHRoZSBuZXdcbiAgICogZGltZW5zaW9ucy4gVGhlbiwgaXQgcmVuZGVycyB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIHdpZHRoICBUaGUgbmV3IHdpZHRoIG9mIHRoZSBjb250YWluZXIuXG4gICAqIEBwYXJhbSAgez9udW1iZXJ9ICAgICAgICAgICAgICAgIGhlaWdodCBUaGUgbmV3IGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzaWdtYS5yZW5kZXJlcnMuc3ZnfSAgICAgICAgICAgUmV0dXJucyB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgc2lnbWEucmVuZGVyZXJzLnN2Zy5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odywgaCkge1xuICAgIHZhciBvbGRXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIG9sZEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gMTtcblxuICAgIGlmICh3ICE9PSB1bmRlZmluZWQgJiYgaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChvbGRXaWR0aCAhPT0gdGhpcy53aWR0aCB8fCBvbGRIZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuXG4gICAgICBpZiAodGhpcy5kb21FbGVtZW50cy5ncmFwaC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudHMuZ3JhcGguc2V0QXR0cmlidXRlKCd3aWR0aCcsICh3ICogcGl4ZWxSYXRpbykpO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLmdyYXBoLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKGggKiBwaXhlbFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogVGhlIGxhYmVscywgbm9kZXMgYW5kIGVkZ2VzIHJlbmRlcmVycyBhcmUgc3RvcmVkIGluIHRoZSB0aHJlZSBmb2xsb3dpbmdcbiAgICogb2JqZWN0cy4gV2hlbiBhbiBlbGVtZW50IGlzIGRyYXduLCBpdHMgdHlwZSB3aWxsIGJlIGNoZWNrZWQgYW5kIGlmIGFcbiAgICogcmVuZGVyZXIgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0cywgaXQgd2lsbCBiZSB1c2VkLiBJZiBub3QgZm91bmQsIHRoZVxuICAgKiBkZWZhdWx0IHJlbmRlcmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGV5IGFyZSBzdG9yZWQgaW4gZGlmZmVyZW50IGZpbGVzLCBpbiB0aGUgXCIuL3N2Z1wiIGZvbGRlci5cbiAgICovXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLm5vZGVzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmVkZ2VzJyk7XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmxhYmVscycpO1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucmVuZGVyZXJzJyk7XG5cbiAgLy8gQ2hlY2sgaWYgV2ViR0wgaXMgZW5hYmxlZDpcbiAgdmFyIGNhbnZhcyxcbiAgICAgIHdlYmdsID0gISFnbG9iYWwuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICBpZiAod2ViZ2wpIHtcbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0cnkge1xuICAgICAgd2ViZ2wgPSAhIShcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdlYmdsID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29weSB0aGUgZ29vZCByZW5kZXJlcjpcbiAgc2lnbWEucmVuZGVyZXJzLmRlZiA9IHdlYmdsID9cbiAgICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgOlxuICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXM7XG59KSh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEud2ViZ2wubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBub2RlIHJlbmRlcmVyIHdpbGwgZGlzcGxheSBub2RlcyBhcyBkaXNjcywgc2hhcGVkIGluIHRyaWFuZ2xlcyB3aXRoXG4gICAqIHRoZSBnbC5UUklBTkdMRVMgZGlzcGxheSBtb2RlLiBTbywgdG8gYmUgbW9yZSBwcmVjaXNlLCB0byBkcmF3IG9uZSBub2RlLFxuICAgKiBpdCB3aWxsIHN0b3JlIHRocmVlIHRpbWVzIHRoZSBjZW50ZXIgb2Ygbm9kZSwgd2l0aCB0aGUgY29sb3IgYW5kIHRoZSBzaXplLFxuICAgKiBhbmQgYW4gYW5nbGUgaW5kaWNhdGluZyB3aGljaCBcImNvcm5lclwiIG9mIHRoZSB0cmlhbmdsZSB0byBkcmF3LlxuICAgKlxuICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGRvZXMgbm90IGRlYWwgd2l0aCBhbnRpLWFsaWFzaW5nLCBzbyBtYWtlIHN1cmUgdGhhdFxuICAgKiB5b3UgZGVhbCB3aXRoIGl0IHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIChieSBkZWZhdWx0LCB0aGUgV2ViR0xcbiAgICogcmVuZGVyZXIgd2lsbCBvdmVyc2FtcGxlIHRoZSByZW5kZXJpbmcgdGhyb3VnaCB0aGUgd2ViZ2xPdmVyc2FtcGxpbmdSYXRpb1xuICAgKiB2YWx1ZSkuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5kZWYgPSB7XG4gICAgUE9JTlRTOiAzLFxuICAgIEFUVFJJQlVURVM6IDUsXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihcbiAgICAgICAgbm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpXG4gICAgICApO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDA7XG5cbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuICAgICAgZGF0YVtpKytdID0gMiAqIE1hdGguUEkgLyAzO1xuXG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd4J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICd5J107XG4gICAgICBkYXRhW2krK10gPSBub2RlW3ByZWZpeCArICdzaXplJ107XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICAgIGRhdGFbaSsrXSA9IDQgKiBNYXRoLlBJIC8gMztcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIGFuZ2xlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfYW5nbGUnKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBzY2FsZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9zY2FsZScpO1xuXG4gICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLkRZTkFNSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIDEgLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnbm9kZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihzY2FsZUxvY2F0aW9uLCBwYXJhbXMuc2NhbGluZ1JhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaXplTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhbmdsZUxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgYW5nbGVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDE2XG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5UUklBTkdMRVMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMiBjZW50ZXI7JyxcbiAgICAgICAgICAndmFyeWluZyBmbG9hdCByYWRpdXM7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IHRoZSBwb2ludCBzaXplIHR3aWNlOlxuICAgICAgICAgICAgJ3JhZGl1cyA9IGFfc2l6ZSAqIHVfcmF0aW87JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICd2ZWMyIHBvc2l0aW9uID0gKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHk7JyxcbiAgICAgICAgICAgIC8vICdjZW50ZXIgPSAocG9zaXRpb24gLyB1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSk7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSBwb3NpdGlvbiAqIHVfc2NhbGU7JyxcbiAgICAgICAgICAgICdjZW50ZXIgPSB2ZWMyKGNlbnRlci54LCB1X3NjYWxlICogdV9yZXNvbHV0aW9uLnkgLSBjZW50ZXIueSk7JyxcblxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gcG9zaXRpb24gKycsXG4gICAgICAgICAgICAgICcyLjAgKiByYWRpdXMgKiB2ZWMyKGNvcyhhX2FuZ2xlKSwgc2luKGFfYW5nbGUpKTsnLFxuICAgICAgICAgICAgJ3Bvc2l0aW9uID0gKHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uICogMi4wIC0gMS4wKSAqIHZlYzIoMSwgLTEpOycsXG5cbiAgICAgICAgICAgICdyYWRpdXMgPSByYWRpdXMgKiB1X3NjYWxlOycsXG5cbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgY2VudGVyOycsXG4gICAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ3ZlYzQgY29sb3IwID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApOycsXG5cbiAgICAgICAgICAgICd2ZWMyIG0gPSBnbF9GcmFnQ29vcmQueHkgLSBjZW50ZXI7JyxcbiAgICAgICAgICAgICdmbG9hdCBkaWZmID0gcmFkaXVzIC0gc3FydChtLnggKiBtLnggKyBtLnkgKiBtLnkpOycsXG5cbiAgICAgICAgICAgIC8vIEhlcmUgaXMgaG93IHdlIGRyYXcgYSBkaXNjIGluc3RlYWQgb2YgYSBzcXVhcmU6XG4gICAgICAgICAgICAnaWYgKGRpZmYgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgICAnZWxzZScsXG4gICAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLm5vZGVzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbm9kZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgbm9kZXMgaW4gdGhlIGZhc3Rlc3Qgd2F5OiBOb2RlcyBhcmUgYmFzaWNcbiAgICogc3F1YXJlcywgZHJhd24gdGhyb3VnaCB0aGUgZ2wuUE9JTlRTIGRyYXdpbmcgbWV0aG9kLiBUaGUgc2l6ZSBvZiB0aGUgbm9kZXNcbiAgICogYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIFwiZ2xfUG9pbnRTaXplXCIgdmFsdWUgaW4gdGhlIHZlcnRleCBzaGFkZXIuXG4gICAqXG4gICAqIEl0IGlzIHRoZSBmYXN0ZXN0IG5vZGUgcmVuZGVyZXIgaGVyZSBzaW5jZSB0aGUgYnVmZmVyIGp1c3QgdGFrZXMgb25lIGxpbmVcbiAgICogdG8gZHJhdyBlYWNoIG5vZGUgKHdpdGggYXR0cmlidXRlcyBcInhcIiwgXCJ5XCIsIFwic2l6ZVwiIGFuZCBcImNvbG9yXCIpLlxuICAgKlxuICAgKiBOZXZlcnRoZWxlc3MsIHRoaXMgbWV0aG9kIGhhcyBzb21lIHByb2JsZW1zLCBlc3BlY2lhbGx5IGR1ZSB0byBzb21lIGlzc3Vlc1xuICAgKiB3aXRoIHRoZSBnbC5QT0lOVFM6XG4gICAqICAtIEZpcnN0LCBpZiB0aGUgY2VudGVyIG9mIGEgbm9kZSBpcyBvdXRzaWRlIHRoZSBzY2VuZSwgdGhlIHBvaW50IHdpbGwgbm90XG4gICAqICAgIGJlIGRyYXduLCBldmVuIGlmIGl0IHNob3VsZCBiZSBwYXJ0bHkgb24gc2NyZWVuLlxuICAgKiAgLSBJIHRyaWVkIGFwcGx5aW5nIGEgZnJhZ21lbnQgc2hhZGVyIHNpbWlsYXIgdG8gdGhlIG9uZSBpbiB0aGUgZGVmYXVsdFxuICAgKiAgICBub2RlIHJlbmRlcmVyIHRvIGRpc3BsYXkgdGhlbSBhcyBkaXNjcywgYnV0IGl0IGRpZCBub3Qgd29yayBmaW5lIG9uXG4gICAqICAgIHNvbWUgY29tcHV0ZXJzIHNldHRpbmdzLCBmaWxsaW5nIHRoZSBkaXNjcyB3aXRoIHdlaXJkIGdyYWRpZW50cyBub3RcbiAgICogICAgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgY29sb3IuXG4gICAqL1xuICBzaWdtYS53ZWJnbC5ub2Rlcy5mYXN0ID0ge1xuICAgIFBPSU5UUzogMSxcbiAgICBBVFRSSUJVVEVTOiA0LFxuICAgIGFkZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3gnXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3knXTtcbiAgICAgIGRhdGFbaSsrXSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcbiAgICAgIGRhdGFbaSsrXSA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoXG4gICAgICAgIG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpLFxuICAgICAgICAgIHNpemVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9zaXplJyksXG4gICAgICAgICAgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHJlc29sdXRpb25Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpLFxuICAgICAgICAgIG1hdHJpeExvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXgnKSxcbiAgICAgICAgICByYXRpb0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yYXRpbycpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgcmF0aW9Mb2NhdGlvbixcbiAgICAgICAgMSAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNpemVMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgcG9zaXRpb25Mb2NhdGlvbixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICBzaXplTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA4XG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDEyXG4gICAgICApO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKFxuICAgICAgICBnbC5QT0lOVFMsXG4gICAgICAgIHBhcmFtcy5zdGFydCB8fCAwLFxuICAgICAgICBwYXJhbXMuY291bnQgfHwgKGRhdGEubGVuZ3RoIC8gdGhpcy5BVFRSSUJVVEVTKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGluaXRQcm9ncmFtOiBmdW5jdGlvbihnbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlcixcbiAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICBwcm9ncmFtO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3NpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfc2NhbGU7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XG4gICAgICAgICAgICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcbiAgICAgICAgICAgIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxuICAgICAgICAgICAgJ2dsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIHVfcmF0aW8gKiB1X3NjYWxlICogMi4wOycsXG5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbG9yOlxuICAgICAgICAgICAgJ2Zsb2F0IGMgPSBhX2NvbG9yOycsXG4gICAgICAgICAgICAnY29sb3IuYiA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuZyA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOycsXG4gICAgICAgICAgICAnY29sb3IuciA9IG1vZChjLCAyNTYuMCk7IGMgPSBmbG9vcihjIC8gMjU2LjApOyBjb2xvciAvPSAyNTUuMDsnLFxuICAgICAgICAgICAgJ2NvbG9yLmEgPSAxLjA7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuVkVSVEVYX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBzaWdtYS51dGlscy5sb2FkU2hhZGVyKFxuICAgICAgICBnbCxcbiAgICAgICAgW1xuICAgICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjNCBjb2xvcjsnLFxuXG4gICAgICAgICAgJ3ZvaWQgbWFpbih2b2lkKSB7JyxcbiAgICAgICAgICAgICdmbG9hdCBib3JkZXIgPSAwLjAxOycsXG4gICAgICAgICAgICAnZmxvYXQgcmFkaXVzID0gMC41OycsXG5cbiAgICAgICAgICAgICd2ZWM0IGNvbG9yMCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsnLFxuICAgICAgICAgICAgJ3ZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTsnLFxuICAgICAgICAgICAgJ2Zsb2F0IGRpc3QgPSByYWRpdXMgLSBzcXJ0KG0ueCAqIG0ueCArIG0ueSAqIG0ueSk7JyxcblxuICAgICAgICAgICAgJ2Zsb2F0IHQgPSAwLjA7JyxcbiAgICAgICAgICAgICdpZiAoZGlzdCA+IGJvcmRlciknLFxuICAgICAgICAgICAgICAndCA9IDEuMDsnLFxuICAgICAgICAgICAgJ2Vsc2UgaWYgKGRpc3QgPiAwLjApJyxcbiAgICAgICAgICAgICAgJ3QgPSBkaXN0IC8gYm9yZGVyOycsXG5cbiAgICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvciwgdCk7JyxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgICAgZ2wuRlJBR01FTlRfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBwcm9ncmFtID0gc2lnbWEudXRpbHMubG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLndlYmdsLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgbGluZXMgZ29pbmcgZnJvbSB0aGUgc291cmNlIG5vZGVcbiAgICogdG8gdGhlIHRhcmdldCBub2RlLiBUbyBkZWFsIHdpdGggZWRnZSB0aGlja25lc3NlcywgdGhlIGxpbmVzIGFyZSBtYWRlIG9mXG4gICAqIHR3byB0cmlhbmdsZXMgZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZyBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA2IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgNyBhdHRyaWJ1dGVzIChzb3VyY2UgcG9zaXRpb24sIHRhcmdldCBwb3NpdGlvbiwgdGhpY2tuZXNzLCBjb2xvclxuICAgKiBhbmQgYSBmbGFnIGluZGljYXRpbmcgd2hpY2ggdmVydGljZSBvZiB0aGUgcmVjdGFuZ2xlIGl0IGlzKS5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmRlZiA9IHtcbiAgICBQT0lOVFM6IDYsXG4gICAgQVRUUklCVVRFUzogNyxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIGNvbG9yID0gZWRnZS5jb2xvcjtcblxuICAgICAgaWYgKCFjb2xvcilcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncygnZWRnZUNvbG9yJykpIHtcbiAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHRFZGdlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb2xvcjpcbiAgICAgIGNvbG9yID0gc2lnbWEudXRpbHMuZmxvYXRDb2xvcihjb2xvcik7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMSA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbjInKSxcbiAgICAgICAgICB0aGlja25lc3NMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV90aGlja25lc3MnKSxcbiAgICAgICAgICBtaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX21pbnVzJyksXG4gICAgICAgICAgcmVzb2x1dGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9yZXNvbHV0aW9uJyksXG4gICAgICAgICAgbWF0cml4TG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGknKSxcbiAgICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV9tYXRyaXhIYWxmUGlNaW51cycpLFxuICAgICAgICAgIHJhdGlvTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3JhdGlvJyksXG4gICAgICAgICAgc2NhbGVMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfc2NhbGUnKTtcblxuICAgICAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCk7XG4gICAgICBnbC51bmlmb3JtMWYoXG4gICAgICAgIHJhdGlvTG9jYXRpb24sXG4gICAgICAgIHBhcmFtcy5yYXRpbyAvIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdlZGdlc1Bvd1JhdGlvJykpXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMSk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlja25lc3NMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShtaW51c0xvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMSxcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24yLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpY2tuZXNzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAxNlxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobWludXNMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihjb2xvckxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLlRSSUFOR0xFUyxcbiAgICAgICAgcGFyYW1zLnN0YXJ0IHx8IDAsXG4gICAgICAgIHBhcmFtcy5jb3VudCB8fCAoZGF0YS5sZW5ndGggLyB0aGlzLkFUVFJJQlVURVMpXG4gICAgICApO1xuICAgIH0sXG4gICAgaW5pdFByb2dyYW06IGZ1bmN0aW9uKGdsKSB7XG4gICAgICB2YXIgdmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHByb2dyYW07XG5cbiAgICAgIHZlcnRleFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24xOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb24yOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSBmbG9hdCBhX3RoaWNrbmVzczsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9taW51czsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3JhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9zY2FsZTsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgdV9tYXRyaXg7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MiB1X21hdHJpeEhhbGZQaU1pbnVzOycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBnb29kIHBvaW50OlxuICAgICAgICAgICAgJ3ZlYzIgcG9zaXRpb24gPSBhX3RoaWNrbmVzcyAqIHVfcmF0aW8gKicsXG4gICAgICAgICAgICAgICdub3JtYWxpemUoYV9wb3NpdGlvbjIgLSBhX3Bvc2l0aW9uMSk7JyxcblxuICAgICAgICAgICAgJ21hdDIgbWF0cml4ID0gYV9taW51cyAqIHVfbWF0cml4SGFsZlBpTWludXMgKycsXG4gICAgICAgICAgICAgICcoMS4wIC0gYV9taW51cykgKiB1X21hdHJpeEhhbGZQaTsnLFxuXG4gICAgICAgICAgICAncG9zaXRpb24gPSBtYXRyaXggKiBwb3NpdGlvbiArIGFfcG9zaXRpb24xOycsXG5cbiAgICAgICAgICAgIC8vIFNjYWxlIGZyb20gW1stMSAxXSBbLTEgMV1dIHRvIHRoZSBjb250YWluZXI6XG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KCcsXG4gICAgICAgICAgICAgICcoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGxpbmVzIHdpdGggdGhlIGdsLkxJTkVTIGRpc3BsYXlcbiAgICogbW9kZS4gU2luY2UgdGhpcyBtb2RlIGRvZXMgbm90IHN1cHBvcnQgd2VsbCB0aGlja25lc3MsIGVkZ2VzIGFyZSBhbGwgZHJhd25cbiAgICogd2l0aCB0aGUgc2FtZSB0aGlja25lc3MgKDNweCksIGluZGVwZW5kYW50bHkgb2YgdGhlIGVkZ2UgYXR0cmlidXRlcyBvciB0aGVcbiAgICogem9vbWluZyByYXRpby5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmZhc3QgPSB7XG4gICAgUE9JTlRTOiAyLFxuICAgIEFUVFJJQlVURVM6IDMsXG4gICAgYWRkRWRnZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGRhdGEsIGksIHByZWZpeCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciB3ID0gKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSAvIDIsXG4gICAgICAgICAgeDEgPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHgyID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgICAgeTIgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGRhdGEsIHBhcmFtcykge1xuICAgICAgdmFyIGJ1ZmZlcjtcblxuICAgICAgLy8gRGVmaW5lIGF0dHJpYnV0ZXM6XG4gICAgICB2YXIgY29sb3JMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9jb2xvcicpLFxuICAgICAgICAgIHBvc2l0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfcG9zaXRpb24nKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4Jyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAgICAgZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgcGFyYW1zLndpZHRoLCBwYXJhbXMuaGVpZ2h0KTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobWF0cml4TG9jYXRpb24sIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShjb2xvckxvY2F0aW9uKTtcblxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAyLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY29sb3JMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG5cbiAgICAgIGdsLmxpbmVXaWR0aCgzKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoXG4gICAgICAgIGdsLkxJTkVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9jb2xvcjsnLFxuXG4gICAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNCgnLFxuICAgICAgICAgICAgICAnKCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS53ZWJnbC5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGVkZ2UgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IGVkZ2VzIGFzIGFycm93cyBnb2luZyBmcm9tIHRoZSBzb3VyY2Ugbm9kZVxuICAgKiB0byB0aGUgdGFyZ2V0IG5vZGUuIFRvIGRlYWwgd2l0aCBlZGdlIHRoaWNrbmVzc2VzLCB0aGUgbGluZXMgYXJlIG1hZGUgb2ZcbiAgICogdGhyZWUgdHJpYW5nbGVzOiB0d28gZm9ybWluZyByZWN0YW5nbGVzLCB3aXRoIHRoZSBnbC5UUklBTkdMRVMgZHJhd2luZ1xuICAgKiBtb2RlLlxuICAgKlxuICAgKiBJdCBpcyBleHBlbnNpdmUsIHNpbmNlIGRyYXdpbmcgYSBzaW5nbGUgZWRnZSByZXF1aXJlcyA5IHBvaW50cywgZWFjaFxuICAgKiBoYXZpbmcgYSBsb3Qgb2YgYXR0cmlidXRlcy5cbiAgICovXG4gIHNpZ21hLndlYmdsLmVkZ2VzLmFycm93ID0ge1xuICAgIFBPSU5UUzogOSxcbiAgICBBVFRSSUJVVEVTOiAxMSxcbiAgICBhZGRFZGdlOiBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgZGF0YSwgaSwgcHJlZml4LCBzZXR0aW5ncykge1xuICAgICAgdmFyIHcgPSAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpIC8gMixcbiAgICAgICAgICB4MSA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgIHkxID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgICAgeDIgPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICB5MiA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICAgIHRhcmdldFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBjb2xvciA9IGVkZ2UuY29sb3I7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoc2V0dGluZ3MoJ2VkZ2VDb2xvcicpKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWxpemUgY29sb3I6XG4gICAgICBjb2xvciA9IHNpZ21hLnV0aWxzLmZsb2F0Q29sb3IoY29sb3IpO1xuXG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB4MTtcbiAgICAgIGRhdGFbaSsrXSA9IHkxO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG5cbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0gdztcbiAgICAgIGRhdGFbaSsrXSA9IHRhcmdldFNpemU7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAxLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSAwLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHgyO1xuICAgICAgZGF0YVtpKytdID0geTI7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICAvLyBBcnJvdyBoZWFkOlxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IC0xLjA7XG4gICAgICBkYXRhW2krK10gPSBjb2xvcjtcblxuICAgICAgZGF0YVtpKytdID0geDI7XG4gICAgICBkYXRhW2krK10gPSB5MjtcbiAgICAgIGRhdGFbaSsrXSA9IHgxO1xuICAgICAgZGF0YVtpKytdID0geTE7XG4gICAgICBkYXRhW2krK10gPSB3O1xuICAgICAgZGF0YVtpKytdID0gdGFyZ2V0U2l6ZTtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDEuMDtcbiAgICAgIGRhdGFbaSsrXSA9IDAuMDtcbiAgICAgIGRhdGFbaSsrXSA9IGNvbG9yO1xuXG4gICAgICBkYXRhW2krK10gPSB4MjtcbiAgICAgIGRhdGFbaSsrXSA9IHkyO1xuICAgICAgZGF0YVtpKytdID0geDE7XG4gICAgICBkYXRhW2krK10gPSB5MTtcbiAgICAgIGRhdGFbaSsrXSA9IHc7XG4gICAgICBkYXRhW2krK10gPSB0YXJnZXRTaXplO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMC4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gMS4wO1xuICAgICAgZGF0YVtpKytdID0gY29sb3I7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBkYXRhLCBwYXJhbXMpIHtcbiAgICAgIHZhciBidWZmZXI7XG5cbiAgICAgIC8vIERlZmluZSBhdHRyaWJ1dGVzOlxuICAgICAgdmFyIHBvc2l0aW9uTG9jYXRpb24xID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3BvczEnKSxcbiAgICAgICAgICBwb3NpdGlvbkxvY2F0aW9uMiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3MyJyksXG4gICAgICAgICAgdGhpY2tuZXNzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfdGhpY2tuZXNzJyksXG4gICAgICAgICAgdGFyZ2V0U2l6ZUxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RTaXplJyksXG4gICAgICAgICAgZGVsYXlMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9kZWxheScpLFxuICAgICAgICAgIG1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfbWludXMnKSxcbiAgICAgICAgICBoZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfaGVhZCcpLFxuICAgICAgICAgIGhlYWRQb3NpdGlvbkxvY2F0aW9uID1cbiAgICAgICAgICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX2hlYWRQb3NpdGlvbicpLFxuICAgICAgICAgIGNvbG9yTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FfY29sb3InKSxcbiAgICAgICAgICByZXNvbHV0aW9uTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3Jlc29sdXRpb24nKSxcbiAgICAgICAgICBtYXRyaXhMb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfbWF0cml4JyksXG4gICAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaScpLFxuICAgICAgICAgIG1hdHJpeEhhbGZQaU1pbnVzTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeEhhbGZQaU1pbnVzJyksXG4gICAgICAgICAgcmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmF0aW8nKSxcbiAgICAgICAgICBub2RlUmF0aW9Mb2NhdGlvbiA9XG4gICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vfbm9kZVJhdGlvJyksXG4gICAgICAgICAgYXJyb3dIZWFkTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X2Fycm93SGVhZCcpLFxuICAgICAgICAgIHNjYWxlTG9jYXRpb24gPVxuICAgICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X3NjYWxlJyk7XG5cbiAgICAgIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICBnbC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCBwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQpO1xuICAgICAgZ2wudW5pZm9ybTFmKFxuICAgICAgICByYXRpb0xvY2F0aW9uLFxuICAgICAgICBwYXJhbXMucmF0aW8gLyBNYXRoLnBvdyhwYXJhbXMucmF0aW8sIHBhcmFtcy5zZXR0aW5ncygnZWRnZXNQb3dSYXRpbycpKVxuICAgICAgKTtcbiAgICAgIGdsLnVuaWZvcm0xZihcbiAgICAgICAgbm9kZVJhdGlvTG9jYXRpb24sXG4gICAgICAgIE1hdGgucG93KHBhcmFtcy5yYXRpbywgcGFyYW1zLnNldHRpbmdzKCdub2Rlc1Bvd1JhdGlvJykpIC9cbiAgICAgICAgcGFyYW1zLnJhdGlvXG4gICAgICApO1xuICAgICAgZ2wudW5pZm9ybTFmKGFycm93SGVhZExvY2F0aW9uLCA1LjApO1xuICAgICAgZ2wudW5pZm9ybTFmKHNjYWxlTG9jYXRpb24sIHBhcmFtcy5zY2FsaW5nUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihtYXRyaXhMb2NhdGlvbiwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihcbiAgICAgICAgbWF0cml4SGFsZlBpTG9jYXRpb24sXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBzaWdtYS51dGlscy5tYXRyaWNlcy5yb3RhdGlvbihNYXRoLlBJIC8gMiwgdHJ1ZSlcbiAgICAgICk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4MmZ2KFxuICAgICAgICBtYXRyaXhIYWxmUGlNaW51c0xvY2F0aW9uLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgc2lnbWEudXRpbHMubWF0cmljZXMucm90YXRpb24oLU1hdGguUEkgLyAyLCB0cnVlKVxuICAgICAgKTtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjEpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbjIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpY2tuZXNzTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGFyZ2V0U2l6ZUxvY2F0aW9uKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbGF5TG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobWludXNMb2NhdGlvbik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShoZWFkTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaGVhZFBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoY29sb3JMb2NhdGlvbik7XG5cbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbjEsXG4gICAgICAgIDIsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uMixcbiAgICAgICAgMixcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDhcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaWNrbmVzc0xvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMTZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRhcmdldFNpemVMb2NhdGlvbixcbiAgICAgICAgMSxcbiAgICAgICAgZ2wuRkxPQVQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLkFUVFJJQlVURVMgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgIDIwXG4gICAgICApO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihkZWxheUxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMjRcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKG1pbnVzTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICAyOFxuICAgICAgKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaGVhZExvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzJcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGhlYWRQb3NpdGlvbkxvY2F0aW9uLFxuICAgICAgICAxLFxuICAgICAgICBnbC5GTE9BVCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuQVRUUklCVVRFUyAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgMzZcbiAgICAgICk7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGNvbG9yTG9jYXRpb24sXG4gICAgICAgIDEsXG4gICAgICAgIGdsLkZMT0FULFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICA0MFxuICAgICAgKTtcblxuICAgICAgZ2wuZHJhd0FycmF5cyhcbiAgICAgICAgZ2wuVFJJQU5HTEVTLFxuICAgICAgICBwYXJhbXMuc3RhcnQgfHwgMCxcbiAgICAgICAgcGFyYW1zLmNvdW50IHx8IChkYXRhLmxlbmd0aCAvIHRoaXMuQVRUUklCVVRFUylcbiAgICAgICk7XG4gICAgfSxcbiAgICBpbml0UHJvZ3JhbTogZnVuY3Rpb24oZ2wpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgcHJvZ3JhbTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gc2lnbWEudXRpbHMubG9hZFNoYWRlcihcbiAgICAgICAgZ2wsXG4gICAgICAgIFtcbiAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3MxOycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zMjsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfdFNpemU7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfZGVsYXk7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfbWludXM7JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfaGVhZDsnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYV9oZWFkUG9zaXRpb247JyxcbiAgICAgICAgICAnYXR0cmlidXRlIGZsb2F0IGFfY29sb3I7JyxcblxuICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9yYXRpbzsnLFxuICAgICAgICAgICd1bmlmb3JtIGZsb2F0IHVfbm9kZVJhdGlvOycsXG4gICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdV9hcnJvd0hlYWQ7JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCB1X3NjYWxlOycsXG4gICAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDIgdV9tYXRyaXhIYWxmUGk7JyxcbiAgICAgICAgICAndW5pZm9ybSBtYXQyIHVfbWF0cml4SGFsZlBpTWludXM7JyxcblxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgY29sb3I7JyxcblxuICAgICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGdvb2QgcG9pbnQ6XG4gICAgICAgICAgICAndmVjMiBwb3MgPSBub3JtYWxpemUoYV9wb3MyIC0gYV9wb3MxKTsnLFxuXG4gICAgICAgICAgICAnbWF0MiBtYXRyaXggPSAoMS4wIC0gYV9oZWFkKSAqJyxcbiAgICAgICAgICAgICAgJygnLFxuICAgICAgICAgICAgICAgICdhX21pbnVzICogdV9tYXRyaXhIYWxmUGlNaW51cyArJyxcbiAgICAgICAgICAgICAgICAnKDEuMCAtIGFfbWludXMpICogdV9tYXRyaXhIYWxmUGknLFxuICAgICAgICAgICAgICAnKSArIGFfaGVhZCAqICgnLFxuICAgICAgICAgICAgICAgICdhX2hlYWRQb3NpdGlvbiAqIHVfbWF0cml4SGFsZlBpTWludXMgKiAwLjYgKycsXG4gICAgICAgICAgICAgICAgJyhhX2hlYWRQb3NpdGlvbiAqIGFfaGVhZFBvc2l0aW9uIC0gMS4wKSAqIG1hdDIoMS4wKScsXG4gICAgICAgICAgICAgICcpOycsXG5cbiAgICAgICAgICAgICdwb3MgPSBhX3BvczEgKyAoJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGJvZHk6XG4gICAgICAgICAgICAgICcoMS4wIC0gYV9oZWFkKSAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGhlYWQ6XG4gICAgICAgICAgICAgICdhX2hlYWQgKiB1X2Fycm93SGVhZCAqIGFfdGhpY2tuZXNzICogdV9yYXRpbyAqIG1hdHJpeCAqIHBvcyArJyxcbiAgICAgICAgICAgICAgLy8gRGVhbCB3aXRoIGRlbGF5OlxuICAgICAgICAgICAgICAnYV9kZWxheSAqIHBvcyAqICgnLFxuICAgICAgICAgICAgICAgICdhX3RTaXplIC8gdV9ub2RlUmF0aW8gKycsXG4gICAgICAgICAgICAgICAgJ3VfYXJyb3dIZWFkICogYV90aGlja25lc3MgKiB1X3JhdGlvJyxcbiAgICAgICAgICAgICAgJyknLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gU2NhbGUgZnJvbSBbWy0xIDFdIFstMSAxXV0gdG8gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoJyxcbiAgICAgICAgICAgICAgJygodV9tYXRyaXggKiB2ZWMzKHBvcywgMSkpLnh5IC8nLFxuICAgICAgICAgICAgICAgICd1X3Jlc29sdXRpb24gKiAyLjAgLSAxLjApICogdmVjMigxLCAtMSksJyxcbiAgICAgICAgICAgICAgJzAsJyxcbiAgICAgICAgICAgICAgJzEnLFxuICAgICAgICAgICAgJyk7JyxcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29sb3I6XG4gICAgICAgICAgICAnZmxvYXQgYyA9IGFfY29sb3I7JyxcbiAgICAgICAgICAgICdjb2xvci5iID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5nID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7JyxcbiAgICAgICAgICAgICdjb2xvci5yID0gbW9kKGMsIDI1Ni4wKTsgYyA9IGZsb29yKGMgLyAyNTYuMCk7IGNvbG9yIC89IDI1NS4wOycsXG4gICAgICAgICAgICAnY29sb3IuYSA9IDEuMDsnLFxuICAgICAgICAgICd9J1xuICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICBnbC5WRVJURVhfU0hBREVSXG4gICAgICApO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNpZ21hLnV0aWxzLmxvYWRTaGFkZXIoXG4gICAgICAgIGdsLFxuICAgICAgICBbXG4gICAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG5cbiAgICAgICAgICAndmFyeWluZyB2ZWM0IGNvbG9yOycsXG5cbiAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yOycsXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgIGdsLkZSQUdNRU5UX1NIQURFUlxuICAgICAgKTtcblxuICAgICAgcHJvZ3JhbSA9IHNpZ21hLnV0aWxzLmxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMubGFiZWxzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgbGFiZWwgcmVuZGVyZXIgd2lsbCBqdXN0IGRpc3BsYXkgdGhlIGxhYmVsIG9uIHRoZSByaWdodCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5sYWJlbHMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgZm9udFNpemUsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgIGlmIChzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAoIW5vZGUubGFiZWwgfHwgdHlwZW9mIG5vZGUubGFiZWwgIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuO1xuXG4gICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgIHNldHRpbmdzKCdsYWJlbFNpemVSYXRpbycpICogc2l6ZTtcblxuICAgIGNvbnRleHQuZm9udCA9IChzZXR0aW5ncygnZm9udFN0eWxlJykgPyBzZXR0aW5ncygnZm9udFN0eWxlJykgKyAnICcgOiAnJykgK1xuICAgICAgZm9udFNpemUgKyAncHggJyArIHNldHRpbmdzKCdmb250Jyk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAobm9kZS5jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdE5vZGVDb2xvcicpKSA6XG4gICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsQ29sb3InKTtcblxuICAgIGNvbnRleHQuZmlsbFRleHQoXG4gICAgICBub2RlLmxhYmVsLFxuICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd4J10gKyBzaXplICsgMyksXG4gICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMylcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgYmFzaWNhbGx5IGRpc3BsYXkgdGhlIGxhYmVsIHdpdGggYSBiYWNrZ3JvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWYgPSBmdW5jdGlvbihub2RlLCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciB4LFxuICAgICAgICB5LFxuICAgICAgICB3LFxuICAgICAgICBoLFxuICAgICAgICBlLFxuICAgICAgICBmb250U3R5bGUgPSBzZXR0aW5ncygnaG92ZXJGb250U3R5bGUnKSB8fCBzZXR0aW5ncygnZm9udFN0eWxlJyksXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbFNpemUnKSA6XG4gICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgLy8gTGFiZWwgYmFja2dyb3VuZDpcbiAgICBjb250ZXh0LmZvbnQgPSAoZm9udFN0eWxlID8gZm9udFN0eWxlICsgJyAnIDogJycpICtcbiAgICAgIGZvbnRTaXplICsgJ3B4ICcgKyAoc2V0dGluZ3MoJ2hvdmVyRm9udCcpIHx8IHNldHRpbmdzKCdmb250JykpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzKCdsYWJlbEhvdmVyQkdDb2xvcicpID09PSAnbm9kZScgP1xuICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRIb3ZlckxhYmVsQkdDb2xvcicpO1xuXG4gICAgaWYgKG5vZGUubGFiZWwgJiYgc2V0dGluZ3MoJ2xhYmVsSG92ZXJTaGFkb3cnKSkge1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSA4O1xuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IHNldHRpbmdzKCdsYWJlbEhvdmVyU2hhZG93Q29sb3InKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5sYWJlbCAmJiB0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHggPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgeSA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgY29udGV4dC5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArIGZvbnRTaXplIC8gMiArIHNpemUgKyA3XG4gICAgICApO1xuICAgICAgaCA9IE1hdGgucm91bmQoZm9udFNpemUgKyA0KTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGZvbnRTaXplIC8gMiArIDIpO1xuXG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5ICsgZSk7XG4gICAgICBjb250ZXh0LmFyY1RvKHgsIHksIHggKyBlLCB5LCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5KTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3LCB5ICsgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgZSwgeSArIGgpO1xuICAgICAgY29udGV4dC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSBlLCBlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkgKyBlKTtcblxuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG4gICAgfVxuXG4gICAgLy8gTm9kZSBib3JkZXI6XG4gICAgaWYgKHNldHRpbmdzKCdib3JkZXJTaXplJykgPiAwKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncygnbm9kZUJvcmRlckNvbG9yJykgPT09ICdub2RlJyA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQm9yZGVyQ29sb3InKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBub2RlW3ByZWZpeCArICd4J10sXG4gICAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgc2l6ZSArIHNldHRpbmdzKCdib3JkZXJTaXplJyksXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGguUEkgKiAyLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cblxuICAgIC8vIE5vZGU6XG4gICAgdmFyIG5vZGVSZW5kZXJlciA9IHNpZ21hLmNhbnZhcy5ub2Rlc1tub2RlLnR5cGVdIHx8IHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWY7XG4gICAgbm9kZVJlbmRlcmVyKG5vZGUsIGNvbnRleHQsIHNldHRpbmdzKTtcblxuICAgIC8vIERpc3BsYXkgdGhlIGxhYmVsOlxuICAgIGlmIChub2RlLmxhYmVsICYmIHR5cGVvZiBub2RlLmxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAoc2V0dGluZ3MoJ2xhYmVsSG92ZXJDb2xvcicpID09PSAnbm9kZScpID9cbiAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsSG92ZXJDb2xvcicpO1xuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KFxuICAgICAgICBub2RlLmxhYmVsLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSxcbiAgICAgICAgTWF0aC5yb3VuZChub2RlW3ByZWZpeCArICd5J10gKyBmb250U2l6ZSAvIDMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5ub2RlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBub2RlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBub2RlIGFzIGEgc2ltcGxlIGRpc2MuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMubm9kZXMuZGVmID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3gnXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3knXSxcbiAgICAgIG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgIDAsXG4gICAgICBNYXRoLlBJICogMixcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlZGdlIHJlbmRlcmVyLiBJdCByZW5kZXJzIHRoZSBlZGdlIGFzIGEgc2ltcGxlIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5kZWYgPSBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2VzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZWRnZSByZW5kZXJlciB3aWxsIGRpc3BsYXkgZWRnZXMgYXMgYXJyb3dzIGdvaW5nIGZyb20gdGhlIHNvdXJjZSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlcy5hcnJvdyA9IGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIHNpemUgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSxcbiAgICAgICAgdFNpemUgPSB0YXJnZXRbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgc1ggPSBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgc1kgPSBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgdFggPSB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgdFkgPSB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgYVNpemUgPSBNYXRoLm1heChzaXplICogMi41LCBzZXR0aW5ncygnbWluQXJyb3dTaXplJykpLFxuICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpLFxuICAgICAgICBhWCA9IHNYICsgKHRYIC0gc1gpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQsXG4gICAgICAgIGFZID0gc1kgKyAodFkgLSBzWSkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgdlggPSAodFggLSBzWCkgKiBhU2l6ZSAvIGQsXG4gICAgICAgIHZZID0gKHRZIC0gc1kpICogYVNpemUgLyBkO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhzWCwgc1kpO1xuICAgIGNvbnRleHQubGluZVRvKFxuICAgICAgYVgsXG4gICAgICBhWVxuICAgICk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZZICogMC42LCBhWSAtIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCAtIHZZICogMC42LCBhWSArIHZYICogMC42KTtcbiAgICBjb250ZXh0LmxpbmVUbyhhWCArIHZYLCBhWSArIHZZKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpO1xuXG4gICAgaWYgKCFjb2xvcilcbiAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgY29sb3IgPSBzb3VyY2UuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICBjb2xvciA9IHRhcmdldC5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbG9yID0gZGVmYXVsdEVkZ2VDb2xvcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGlmIChzZXR0aW5ncygnZWRnZUhvdmVyQ29sb3InKSA9PT0gJ2VkZ2UnKSB7XG4gICAgICBjb2xvciA9IGVkZ2UuaG92ZXJfY29sb3IgfHwgY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBzZXR0aW5ncygnZGVmYXVsdEVkZ2VIb3ZlckNvbG9yJykgfHwgY29sb3I7XG4gICAgfVxuICAgIHNpemUgKj0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gc2l6ZTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKFxuICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXVxuICAgICk7XG4gICAgY29udGV4dC5saW5lVG8oXG4gICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgIHRhcmdldFtwcmVmaXggKyAneSddXG4gICAgKTtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9O1xufSkoKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMnKTtcblxuICAvKipcbiAgICogVGhpcyBob3ZlciByZW5kZXJlciB3aWxsIGRpc3BsYXkgdGhlIGVkZ2Ugd2l0aCBhIGRpZmZlcmVudCBjb2xvciBvciBzaXplLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgICBUaGUgZWRnZSBvYmplY3QuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgc291cmNlIG5vZGUgIFRoZSBlZGdlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCBub2RlICBUaGUgZWRnZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0ICAgICAgVGhlIGNhbnZhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgICBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAqL1xuICBzaWdtYS5jYW52YXMuZWRnZWhvdmVycy5jdXJ2ZSA9XG4gICAgZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIGNvbnRleHQsIHNldHRpbmdzKSB7XG4gICAgdmFyIGNvbG9yID0gZWRnZS5jb2xvcixcbiAgICAgICAgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnLFxuICAgICAgICBzaXplID0gc2V0dGluZ3MoJ2VkZ2VIb3ZlclNpemVSYXRpbycpICogKGVkZ2VbcHJlZml4ICsgJ3NpemUnXSB8fCAxKSxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNTaXplID0gc291cmNlW3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgc1NpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MSwgY3AueTEsIGNwLngyLCBjcC55MiwgdFgsIHRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIHRYLCB0WSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5jYW52YXMuZWRnZWhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGhvdmVyIHJlbmRlcmVyIHdpbGwgZGlzcGxheSB0aGUgZWRnZSB3aXRoIGEgZGlmZmVyZW50IGNvbG9yIG9yIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5lZGdlaG92ZXJzLmFycm93ID1cbiAgICBmdW5jdGlvbihlZGdlLCBzb3VyY2UsIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3MpIHtcbiAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgIGVkZ2VDb2xvciA9IHNldHRpbmdzKCdlZGdlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgIGRlZmF1bHRFZGdlQ29sb3IgPSBzZXR0aW5ncygnZGVmYXVsdEVkZ2VDb2xvcicpLFxuICAgICAgICBzaXplID0gZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEsXG4gICAgICAgIHRTaXplID0gdGFyZ2V0W3ByZWZpeCArICdzaXplJ10sXG4gICAgICAgIHNYID0gc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgIHNZID0gc291cmNlW3ByZWZpeCArICd5J10sXG4gICAgICAgIHRYID0gdGFyZ2V0W3ByZWZpeCArICd4J10sXG4gICAgICAgIHRZID0gdGFyZ2V0W3ByZWZpeCArICd5J107XG5cbiAgICBzaXplID0gKGVkZ2UuaG92ZXIpID9cbiAgICAgIHNldHRpbmdzKCdlZGdlSG92ZXJTaXplUmF0aW8nKSAqIHNpemUgOiBzaXplO1xuICAgIHZhciBhU2l6ZSA9IHNpemUgKiAyLjUsXG4gICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSksXG4gICAgICAgIGFYID0gc1ggKyAodFggLSBzWCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZCxcbiAgICAgICAgYVkgPSBzWSArICh0WSAtIHNZKSAqIChkIC0gYVNpemUgLSB0U2l6ZSkgLyBkLFxuICAgICAgICB2WCA9ICh0WCAtIHNYKSAqIGFTaXplIC8gZCxcbiAgICAgICAgdlkgPSAodFkgLSBzWSkgKiBhU2l6ZSAvIGQ7XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBjb250ZXh0LmxpbmVUbyhcbiAgICAgIGFYLFxuICAgICAgYVlcbiAgICApO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5lZGdlaG92ZXJzJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaG92ZXIgcmVuZGVyZXIgd2lsbCBkaXNwbGF5IHRoZSBlZGdlIHdpdGggYSBkaWZmZXJlbnQgY29sb3Igb3Igc2l6ZS5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSBub2RlICBUaGUgZWRnZSBzb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICB0YXJnZXQgbm9kZSAgVGhlIGVkZ2UgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAgICAgIFRoZSBjYW52YXMgY29udGV4dC5cbiAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyAgICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2lnbWEuY2FudmFzLmVkZ2Vob3ZlcnMuY3VydmVkQXJyb3cgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIHZhciBjb2xvciA9IGVkZ2UuY29sb3IsXG4gICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgZWRnZUNvbG9yID0gc2V0dGluZ3MoJ2VkZ2VDb2xvcicpLFxuICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yID0gc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSxcbiAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyksXG4gICAgICAgIGNwID0ge30sXG4gICAgICAgIHNpemUgPSBzZXR0aW5ncygnZWRnZUhvdmVyU2l6ZVJhdGlvJykgKiAoZWRnZVtwcmVmaXggKyAnc2l6ZSddIHx8IDEpLFxuICAgICAgICB0U2l6ZSA9IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddLFxuICAgICAgICBzWCA9IHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICBzWSA9IHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICB0WCA9IHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICB0WSA9IHRhcmdldFtwcmVmaXggKyAneSddLFxuICAgICAgICBkLFxuICAgICAgICBhU2l6ZSxcbiAgICAgICAgYVgsXG4gICAgICAgIGFZLFxuICAgICAgICB2WCxcbiAgICAgICAgdlk7XG5cbiAgICBjcCA9IChzb3VyY2UuaWQgPT09IHRhcmdldC5pZCkgP1xuICAgICAgc2lnbWEudXRpbHMuZ2V0U2VsZkxvb3BDb250cm9sUG9pbnRzKHNYLCBzWSwgdFNpemUpIDpcbiAgICAgIHNpZ21hLnV0aWxzLmdldFF1YWRyYXRpY0NvbnRyb2xQb2ludChzWCwgc1ksIHRYLCB0WSk7XG5cbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54MSwgMikgKyBNYXRoLnBvdyh0WSAtIGNwLnkxLCAyKSk7XG4gICAgICBhU2l6ZSA9IHNpemUgKiAyLjU7XG4gICAgICBhWCA9IGNwLngxICsgKHRYIC0gY3AueDEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICBhWSA9IGNwLnkxICsgKHRZIC0gY3AueTEpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngxKSAqIGFTaXplIC8gZDtcbiAgICAgIHZZID0gKHRZIC0gY3AueTEpICogYVNpemUgLyBkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBjcC54LCAyKSArIE1hdGgucG93KHRZIC0gY3AueSwgMikpO1xuICAgICAgYVNpemUgPSBzaXplICogMi41O1xuICAgICAgYVggPSBjcC54ICsgKHRYIC0gY3AueCkgKiAoZCAtIGFTaXplIC0gdFNpemUpIC8gZDtcbiAgICAgIGFZID0gY3AueSArICh0WSAtIGNwLnkpICogKGQgLSBhU2l6ZSAtIHRTaXplKSAvIGQ7XG4gICAgICB2WCA9ICh0WCAtIGNwLngpICogYVNpemUgLyBkO1xuICAgICAgdlkgPSAodFkgLSBjcC55KSAqIGFTaXplIC8gZDtcbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKVxuICAgICAgc3dpdGNoIChlZGdlQ29sb3IpIHtcbiAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICBjb2xvciA9IHNvdXJjZS5jb2xvciB8fCBkZWZhdWx0Tm9kZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgIGNvbG9yID0gdGFyZ2V0LmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sb3IgPSBkZWZhdWx0RWRnZUNvbG9yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKCdlZGdlSG92ZXJDb2xvcicpID09PSAnZWRnZScpIHtcbiAgICAgIGNvbG9yID0gZWRnZS5ob3Zlcl9jb2xvciB8fCBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSBlZGdlLmhvdmVyX2NvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0RWRnZUhvdmVyQ29sb3InKSB8fCBjb2xvcjtcbiAgICB9XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzaXplO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oc1gsIHNZKTtcbiAgICBpZiAoc291cmNlLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjcC54MiwgY3AueTIsIGNwLngxLCBjcC55MSwgYVgsIGFZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNwLngsIGNwLnksIGFYLCBhWSk7XG4gICAgfVxuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WSAqIDAuNiwgYVkgLSB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggLSB2WSAqIDAuNiwgYVkgKyB2WCAqIDAuNik7XG4gICAgY29udGV4dC5saW5lVG8oYVggKyB2WCwgYVkgKyB2WSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLmNhbnZhcy5leHRyZW1pdGllcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCByZW5kZXJlciBmb3IgaG92ZXJlZCBlZGdlIGV4dHJlbWl0aWVzLiBJdCByZW5kZXJzIHRoZSBlZGdlXG4gICAqIGV4dHJlbWl0aWVzIGFzIGhvdmVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgZWRnZSAgICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBzb3VyY2Ugbm9kZSAgVGhlIGVkZ2Ugc291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgdGFyZ2V0IG5vZGUgIFRoZSBlZGdlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgICAgICBUaGUgY2FudmFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICovXG4gIHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcy5kZWYgPVxuICAgIGZ1bmN0aW9uKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBjb250ZXh0LCBzZXR0aW5ncykge1xuICAgIC8vIFNvdXJjZSBOb2RlOlxuICAgIChcbiAgICAgIHNpZ21hLmNhbnZhcy5ob3ZlcnNbc291cmNlLnR5cGVdIHx8XG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzLmRlZlxuICAgICkgKFxuICAgICAgc291cmNlLCBjb250ZXh0LCBzZXR0aW5nc1xuICAgICk7XG5cbiAgICAvLyBUYXJnZXQgTm9kZTpcbiAgICAoXG4gICAgICBzaWdtYS5jYW52YXMuaG92ZXJzW3RhcmdldC50eXBlXSB8fFxuICAgICAgc2lnbWEuY2FudmFzLmhvdmVycy5kZWZcbiAgICApIChcbiAgICAgIHRhcmdldCwgY29udGV4dCwgc2V0dGluZ3NcbiAgICApO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLnV0aWxzJyk7XG5cbiAgLyoqXG4gICAqIFNvbWUgdXNlZnVsIGZ1bmN0aW9ucyB1c2VkIGJ5IHNpZ21hJ3MgU1ZHIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEuc3ZnLnV0aWxzID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgc2hvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgZWxlbWVudCAgIFRoZSBET00gZWxlbWVudCB0byBzaG93LlxuICAgICAqL1xuICAgIHNob3c6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGhpZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGVsZW1lbnQgICBUaGUgRE9NIGVsZW1lbnQgdG8gaGlkZS5cbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcubm9kZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbm9kZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBkaXNjLlxuICAgKi9cbiAgc2lnbWEuc3ZnLm5vZGVzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICBUaGUgbm9kZSBvYmplY3QuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgICAgICAgICBzZXR0aW5ncyBUaGUgc2V0dGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdjaXJjbGUnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgdGhlIG5vZGUncyBjaXJjbGVcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhcbiAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBSZXR1cm5pbmcgdGhlIERPTSBFbGVtZW50XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIG5vZGUgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICAgICAgICAgIGNpcmNsZSAgIFRoZSBub2RlIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgY2lyY2xlLCBzZXR0aW5ncykge1xuICAgICAgdmFyIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJztcblxuICAgICAgLy8gQXBwbHlpbmcgY2hhbmdlc1xuICAgICAgLy8gVE9ETzogb3B0aW1pemUgLSBjaGVjayBpZiBuZWNlc3NhcnlcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnY3gnLCBub2RlW3ByZWZpeCArICd4J10pO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3InLCBub2RlW3ByZWZpeCArICdzaXplJ10pO1xuXG4gICAgICAvLyBVcGRhdGluZyBvbmx5IGlmIG5vdCBmcmVlc3R5bGVcbiAgICAgIGlmICghc2V0dGluZ3MoJ2ZyZWVTdHlsZScpKVxuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgbnVsbCwgJ2ZpbGwnLCBub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KSgpO1xuXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5zdmcuZWRnZXMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIHNpbXBsZSBsaW5lLlxuICAgKi9cbiAgc2lnbWEuc3ZnLmVkZ2VzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2xpbmUnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgbGluZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd4MScsIHNvdXJjZVtwcmVmaXggKyAneCddKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3kxJywgc291cmNlW3ByZWZpeCArICd5J10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneDInLCB0YXJnZXRbcHJlZml4ICsgJ3gnXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5MicsIHRhcmdldFtwcmVmaXggKyAneSddKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgbGluZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5lZGdlcycpO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VydmUgZWRnZSByZW5kZXJlci4gSXQgcmVuZGVycyB0aGUgbm9kZSBhcyBhIGJlemllciBjdXJ2ZS5cbiAgICovXG4gIHNpZ21hLnN2Zy5lZGdlcy5jdXJ2ZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBlZGdlICAgICAgIFRoZSBlZGdlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oZWRnZSwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLmNvbG9yLFxuICAgICAgICAgIHByZWZpeCA9IHNldHRpbmdzKCdwcmVmaXgnKSB8fCAnJyxcbiAgICAgICAgICBlZGdlQ29sb3IgPSBzZXR0aW5ncygnZWRnZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdE5vZGVDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJyksXG4gICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvciA9IHNldHRpbmdzKCdkZWZhdWx0RWRnZUNvbG9yJyk7XG5cbiAgICAgIGlmICghY29sb3IpXG4gICAgICAgIHN3aXRjaCAoZWRnZUNvbG9yKSB7XG4gICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgIGNvbG9yID0gc291cmNlLmNvbG9yIHx8IGRlZmF1bHROb2RlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgY29sb3IgPSB0YXJnZXQuY29sb3IgfHwgZGVmYXVsdE5vZGVDb2xvcjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb2xvciA9IGRlZmF1bHRFZGdlQ29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3BhdGgnKTtcblxuICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1lZGdlLWlkJywgZWRnZS5pZCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1lZGdlJyk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2UnLCBjb2xvcik7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTVkcgRWxlbWVudCB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIGVkZ2UgICAgICAgVGhlIGVkZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgbGluZSAgICAgICBUaGUgbGluZSBET00gRWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHNvdXJjZSAgICAgVGhlIHNvdXJjZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgIHRhcmdldCAgICAgVGhlIHRhcmdldCBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oZWRnZSwgcGF0aCwgc291cmNlLCB0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJlZml4ID0gc2V0dGluZ3MoJ3ByZWZpeCcpIHx8ICcnO1xuXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdzdHJva2Utd2lkdGgnLCBlZGdlW3ByZWZpeCArICdzaXplJ10gfHwgMSk7XG5cbiAgICAgIC8vIENvbnRyb2wgcG9pbnRcbiAgICAgIHZhciBjeCA9IChzb3VyY2VbcHJlZml4ICsgJ3gnXSArIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDIgK1xuICAgICAgICAodGFyZ2V0W3ByZWZpeCArICd5J10gLSBzb3VyY2VbcHJlZml4ICsgJ3knXSkgLyA0LFxuICAgICAgICAgIGN5ID0gKHNvdXJjZVtwcmVmaXggKyAneSddICsgdGFyZ2V0W3ByZWZpeCArICd5J10pIC8gMiArXG4gICAgICAgIChzb3VyY2VbcHJlZml4ICsgJ3gnXSAtIHRhcmdldFtwcmVmaXggKyAneCddKSAvIDQ7XG5cbiAgICAgIC8vIFBhdGhcbiAgICAgIHZhciBwID0gJ00nICsgc291cmNlW3ByZWZpeCArICd4J10gKyAnLCcgKyBzb3VyY2VbcHJlZml4ICsgJ3knXSArICcgJyArXG4gICAgICAgICAgICAgICdRJyArIGN4ICsgJywnICsgY3kgKyAnICcgK1xuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSArICcsJyArIHRhcmdldFtwcmVmaXggKyAneSddO1xuXG4gICAgICAvLyBVcGRhdGluZyBhdHRyaWJ1dGVzXG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdkJywgcCk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsICdmaWxsJywgJ25vbmUnKTtcblxuICAgICAgLy8gU2hvd2luZ1xuICAgICAgcGF0aC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLnN2Zy5sYWJlbHMnKTtcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbGFiZWwgcmVuZGVyZXIuIEl0IHJlbmRlcnMgdGhlIGxhYmVsIGFzIGEgc2ltcGxlIHRleHQuXG4gICAqL1xuICBzaWdtYS5zdmcubGFiZWxzLmRlZiA9IHtcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICBub2RlICAgICAgIFRoZSBub2RlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtjb25maWd1cmFibGV9ICAgICAgICAgICAgIHNldHRpbmdzICAgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obm9kZSwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAndGV4dCcpO1xuXG4gICAgICB2YXIgZm9udFNpemUgPSAoc2V0dGluZ3MoJ2xhYmVsU2l6ZScpID09PSAnZml4ZWQnKSA/XG4gICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICBzZXR0aW5ncygnbGFiZWxTaXplUmF0aW8nKSAqIHNpemU7XG5cbiAgICAgIHZhciBmb250Q29sb3IgPSAoc2V0dGluZ3MoJ2xhYmVsQ29sb3InKSA9PT0gJ25vZGUnKSA/XG4gICAgICAgIChub2RlLmNvbG9yIHx8IHNldHRpbmdzKCdkZWZhdWx0Tm9kZUNvbG9yJykpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbENvbG9yJyk7XG5cbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2RhdGEtbGFiZWwtdGFyZ2V0Jywgbm9kZS5pZCk7XG4gICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdjbGFzcycsIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1sYWJlbCcpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1zaXplJywgZm9udFNpemUpO1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZm9udC1mYW1pbHknLCBzZXR0aW5ncygnZm9udCcpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuXG4gICAgICB0ZXh0LmlubmVySFRNTCA9IG5vZGUubGFiZWw7XG4gICAgICB0ZXh0LnRleHRDb250ZW50ID0gbm9kZS5sYWJlbDtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNWRyBFbGVtZW50IHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgICAgbm9kZSAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9ICAgICAgICAgICAgICAgdGV4dCAgICAgVGhlIGxhYmVsIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2NvbmZpZ3VyYWJsZX0gICAgICAgICAgICAgc2V0dGluZ3MgVGhlIHNldHRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24obm9kZSwgdGV4dCwgc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgdmFyIGZvbnRTaXplID0gKHNldHRpbmdzKCdsYWJlbFNpemUnKSA9PT0gJ2ZpeGVkJykgP1xuICAgICAgICBzZXR0aW5ncygnZGVmYXVsdExhYmVsU2l6ZScpIDpcbiAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplO1xuXG4gICAgICAvLyBDYXNlIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBkaXNwbGF5IHRoZSBsYWJlbFxuICAgICAgaWYgKCFzZXR0aW5ncygnZm9yY2VMYWJlbHMnKSAmJiBzaXplIDwgc2V0dGluZ3MoJ2xhYmVsVGhyZXNob2xkJykpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBVcGRhdGluZ1xuICAgICAgdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsXG4gICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddICsgc2l6ZSArIDMpKTtcbiAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSArIGZvbnRTaXplIC8gMykpO1xuXG4gICAgICAvLyBTaG93aW5nXG4gICAgICB0ZXh0LnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEuc3ZnLmhvdmVycycpO1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBob3ZlciByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLnN2Zy5ob3ZlcnMuZGVmID0ge1xuXG4gICAgLyoqXG4gICAgICogU1ZHIEVsZW1lbnQgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICBub2RlICAgICAgICAgICAgICAgVGhlIG5vZGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge0NhbnZhc0VsZW1lbnR9ICAgIG1lYXN1cmVtZW50Q2FudmFzICBBIGZha2UgY2FudmFzIGhhbmRsZWQgYnlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3ZnIHRvIHBlcmZvcm0gc29tZSBtZWFzdXJlbWVudHMgYW5kXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSAgICAgICBub2RlQ2lyY2xlICAgICAgICAgVGhlIG5vZGUgRE9NIEVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7Y29uZmlndXJhYmxlfSAgICAgc2V0dGluZ3MgICAgICAgICAgIFRoZSBzZXR0aW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG5vZGUsIG5vZGVDaXJjbGUsIG1lYXN1cmVtZW50Q2FudmFzLCBzZXR0aW5ncykge1xuXG4gICAgICAvLyBEZWZpbmluZyB2aXN1YWwgcHJvcGVydGllc1xuICAgICAgdmFyIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZSxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGZvbnRTdHlsZSA9IHNldHRpbmdzKCdob3ZlckZvbnRTdHlsZScpIHx8IHNldHRpbmdzKCdmb250U3R5bGUnKSxcbiAgICAgICAgICBwcmVmaXggPSBzZXR0aW5ncygncHJlZml4JykgfHwgJycsXG4gICAgICAgICAgc2l6ZSA9IG5vZGVbcHJlZml4ICsgJ3NpemUnXSxcbiAgICAgICAgICBmb250U2l6ZSA9IChzZXR0aW5ncygnbGFiZWxTaXplJykgPT09ICdmaXhlZCcpID9cbiAgICAgICAgICAgIHNldHRpbmdzKCdkZWZhdWx0TGFiZWxTaXplJykgOlxuICAgICAgICAgICAgc2V0dGluZ3MoJ2xhYmVsU2l6ZVJhdGlvJykgKiBzaXplLFxuICAgICAgICAgIGZvbnRDb2xvciA9IChzZXR0aW5ncygnbGFiZWxIb3ZlckNvbG9yJykgPT09ICdub2RlJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuY29sb3IgfHwgc2V0dGluZ3MoJ2RlZmF1bHROb2RlQ29sb3InKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MoJ2RlZmF1bHRMYWJlbEhvdmVyQ29sb3InKTtcblxuICAgICAgLy8gQ3JlYXRpbmcgZWxlbWVudHNcbiAgICAgIHZhciBncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ2cnKSxcbiAgICAgICAgICByZWN0YW5nbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc2V0dGluZ3MoJ3htbG5zJyksICdyZWN0JyksXG4gICAgICAgICAgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHNldHRpbmdzKCd4bWxucycpLCAnY2lyY2xlJyksXG4gICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzZXR0aW5ncygneG1sbnMnKSwgJ3RleHQnKTtcblxuICAgICAgLy8gRGVmaW5pbmcgcHJvcGVydGllc1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2NsYXNzJywgc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLWhvdmVyJyk7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZGF0YS1ub2RlLWlkJywgbm9kZS5pZCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5sYWJlbCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIHRleHQuaW5uZXJIVE1MID0gbm9kZS5sYWJlbDtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IG5vZGUubGFiZWw7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1sYWJlbCcpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZvbnQtZmFtaWx5Jywgc2V0dGluZ3MoJ2ZvbnQnKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCBmb250Q29sb3IpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd4JyxcbiAgICAgICAgICBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3gnXSArIHNpemUgKyAzKSk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3knLFxuICAgICAgICAgIE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneSddICsgZm9udFNpemUgLyAzKSk7XG5cbiAgICAgICAgLy8gTWVhc3VyZXNcbiAgICAgICAgLy8gT1BUSU1JWkU6IEZpbmQgYSBiZXR0ZXIgd2F5IHRoYW4gYSBtZWFzdXJlbWVudCBjYW52YXNcbiAgICAgICAgeCA9IE1hdGgucm91bmQobm9kZVtwcmVmaXggKyAneCddIC0gZm9udFNpemUgLyAyIC0gMik7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKG5vZGVbcHJlZml4ICsgJ3knXSAtIGZvbnRTaXplIC8gMiAtIDIpO1xuICAgICAgICB3ID0gTWF0aC5yb3VuZChcbiAgICAgICAgICBtZWFzdXJlbWVudENhbnZhcy5tZWFzdXJlVGV4dChub2RlLmxhYmVsKS53aWR0aCArXG4gICAgICAgICAgICBmb250U2l6ZSAvIDIgKyBzaXplICsgOVxuICAgICAgICApO1xuICAgICAgICBoID0gTWF0aC5yb3VuZChmb250U2l6ZSArIDQpO1xuICAgICAgICBlID0gTWF0aC5yb3VuZChmb250U2l6ZSAvIDIgKyAyKTtcblxuICAgICAgICAvLyBDaXJjbGVcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICdjbGFzcycsXG4gICAgICAgICAgICBzZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXItYXJlYScpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2ZpbGwnLCAnI2ZmZicpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlTlMobnVsbCwgJ2N4Jywgbm9kZVtwcmVmaXggKyAneCddKTtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdjeScsIG5vZGVbcHJlZml4ICsgJ3knXSk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncicsIGUpO1xuXG4gICAgICAgIC8vIFJlY3RhbmdsZVxuICAgICAgICByZWN0YW5nbGUuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJyxcbiAgICAgICAgICAgIHNldHRpbmdzKCdjbGFzc1ByZWZpeCcpICsgJy1ob3Zlci1hcmVhJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjZmZmJyk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIG5vZGVbcHJlZml4ICsgJ3gnXSArIGUgLyA0KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICd5Jywgbm9kZVtwcmVmaXggKyAneSddIC0gZSk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnd2lkdGgnLCB3KTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldEF0dHJpYnV0ZU5TKG51bGwsICdoZWlnaHQnLCBoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwZW5kaW5nIGNoaWxkc1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHJlY3RhbmdsZSk7XG4gICAgICBncm91cC5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgIGdyb3VwLmFwcGVuZENoaWxkKG5vZGVDaXJjbGUpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS51dGlscycpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG1pZGRsZXdhcmUgd2lsbCByZXNjYWxlIHRoZSBncmFwaCBzdWNoIHRoYXQgaXQgdGFrZXMgYW4gb3B0aW1hbCBzcGFjZVxuICAgKiBvbiB0aGUgcmVuZGVyZXIuXG4gICAqXG4gICAqIEFzIGVhY2ggbWlkZGxld2FyZSwgdGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIHNpZ21hXG4gICAqIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHJlYWRQcmVmaXggIFRoZSByZWFkIHByZWZpeC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSB3cml0ZVByZWZpeCBUaGUgd3JpdGUgcHJlZml4LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdGlvbnMgICAgIFRoZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgc2lnbWEubWlkZGxld2FyZXMucmVzY2FsZSA9IGZ1bmN0aW9uKHJlYWRQcmVmaXgsIHdyaXRlUHJlZml4LCBvcHRpb25zKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGQsXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBtYXJnaW4sXG4gICAgICAgIG4gPSB0aGlzLmdyYXBoLm5vZGVzKCksXG4gICAgICAgIGUgPSB0aGlzLmdyYXBoLmVkZ2VzKCksXG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5lbWJlZE9iamVjdHMob3B0aW9ucyB8fCB7fSksXG4gICAgICAgIGJvdW5kcyA9IHNldHRpbmdzKCdib3VuZHMnKSB8fCBzaWdtYS51dGlscy5nZXRCb3VuZGFyaWVzKFxuICAgICAgICAgIHRoaXMuZ3JhcGgsXG4gICAgICAgICAgcmVhZFByZWZpeCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICAgIG1pblggPSBib3VuZHMubWluWCxcbiAgICAgICAgbWluWSA9IGJvdW5kcy5taW5ZLFxuICAgICAgICBtYXhYID0gYm91bmRzLm1heFgsXG4gICAgICAgIG1heFkgPSBib3VuZHMubWF4WSxcbiAgICAgICAgc2l6ZU1heCA9IGJvdW5kcy5zaXplTWF4LFxuICAgICAgICB3ZWlnaHRNYXggPSBib3VuZHMud2VpZ2h0TWF4LFxuICAgICAgICB3ID0gc2V0dGluZ3MoJ3dpZHRoJykgfHwgMSxcbiAgICAgICAgaCA9IHNldHRpbmdzKCdoZWlnaHQnKSB8fCAxLFxuICAgICAgICByZXNjYWxlU2V0dGluZ3MgPSBzZXR0aW5ncygnYXV0b1Jlc2NhbGUnKSxcbiAgICAgICAgdmFsaWRTZXR0aW5ncyA9IHtcbiAgICAgICAgICBub2RlUG9zaXRpb246IDEsXG4gICAgICAgICAgbm9kZVNpemU6IDEsXG4gICAgICAgICAgZWRnZVNpemU6IDFcbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgZWxlbWVudHMgc2hvdWxkIHdlIHJlc2NhbGU/XG4gICAgICovXG4gICAgaWYgKCEocmVzY2FsZVNldHRpbmdzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgcmVzY2FsZVNldHRpbmdzID0gWydub2RlUG9zaXRpb24nLCAnbm9kZVNpemUnLCAnZWRnZVNpemUnXTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSByZXNjYWxlU2V0dGluZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKCF2YWxpZFNldHRpbmdzW3Jlc2NhbGVTZXR0aW5nc1tpXV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHJlc2NhbGUgc2V0dGluZyBcIicgKyByZXNjYWxlU2V0dGluZ3NbaV0gKyAnXCIgaXMgbm90IHJlY29nbml6ZWQuJ1xuICAgICAgICApO1xuXG4gICAgdmFyIG5wID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdub2RlUG9zaXRpb24nKSxcbiAgICAgICAgbnMgPSB+cmVzY2FsZVNldHRpbmdzLmluZGV4T2YoJ25vZGVTaXplJyksXG4gICAgICAgIGVzID0gfnJlc2NhbGVTZXR0aW5ncy5pbmRleE9mKCdlZGdlU2l6ZScpO1xuXG4gICAgLyoqXG4gICAgICogRmlyc3QsIHdlIGNvbXB1dGUgdGhlIHNjYWxpbmcgcmF0aW8sIHdpdGhvdXQgY29uc2lkZXJpbmcgdGhlIHNpemVzXG4gICAgICogb2YgdGhlIG5vZGVzIDogRWFjaCBub2RlIHdpbGwgaGF2ZSBpdHMgY2VudGVyIGluIHRoZSBjYW52YXMsIGJ1dCBtaWdodFxuICAgICAqIGJlIHBhcnRpYWxseSBvdXQgb2YgaXQuXG4gICAgICovXG4gICAgc2NhbGUgPSBzZXR0aW5ncygnc2NhbGluZ01vZGUnKSA9PT0gJ291dHNpZGUnID9cbiAgICAgIE1hdGgubWF4KFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApIDpcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB3IC8gTWF0aC5tYXgobWF4WCAtIG1pblgsIDEpLFxuICAgICAgICBoIC8gTWF0aC5tYXgobWF4WSAtIG1pblksIDEpXG4gICAgICApO1xuXG4gICAgLyoqXG4gICAgICogVGhlbiwgd2UgY29ycmVjdCB0aGF0IHNjYWxpbmcgcmF0aW8gY29uc2lkZXJpbmcgYSBtYXJnaW4sIHdoaWNoIGlzXG4gICAgICogYmFzaWNhbGx5IHRoZSBzaXplIG9mIHRoZSBiaWdnZXN0IG5vZGUuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgZG9uZSBhcyBhIGNvcnJlY3Rpb24gc2luY2UgdG8gY29tcGFyZSB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgKiBiaWdnZXN0IG5vZGUgdG8gdGhlIFggYW5kIFkgdmFsdWVzLCB3ZSBoYXZlIHRvIGZpcnN0IGdldCBhblxuICAgICAqIGFwcHJveGltYXRpb24gb2YgdGhlIHNjYWxpbmcgcmF0aW8uXG4gICAgICoqL1xuICAgIG1hcmdpbiA9XG4gICAgICAoXG4gICAgICAgIHNldHRpbmdzKCdyZXNjYWxlSWdub3JlU2l6ZScpID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICAoc2V0dGluZ3MoJ21heE5vZGVTaXplJykgfHwgc2l6ZU1heCkgLyBzY2FsZVxuICAgICAgKSArXG4gICAgICAoc2V0dGluZ3MoJ3NpZGVNYXJnaW4nKSB8fCAwKTtcbiAgICBtYXhYICs9IG1hcmdpbjtcbiAgICBtaW5YIC09IG1hcmdpbjtcbiAgICBtYXhZICs9IG1hcmdpbjtcbiAgICBtaW5ZIC09IG1hcmdpbjtcblxuICAgIC8vIEZpeCB0aGUgc2NhbGluZyB3aXRoIHRoZSBuZXcgZXh0cmVtYTpcbiAgICBzY2FsZSA9IHNldHRpbmdzKCdzY2FsaW5nTW9kZScpID09PSAnb3V0c2lkZScgP1xuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICkgOlxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIHcgLyBNYXRoLm1heChtYXhYIC0gbWluWCwgMSksXG4gICAgICAgIGggLyBNYXRoLm1heChtYXhZIC0gbWluWSwgMSlcbiAgICAgICk7XG5cbiAgICAvLyBTaXplIGhvbW90aGV0aWMgcGFyYW1ldGVyczpcbiAgICBpZiAoIXNldHRpbmdzKCdtYXhOb2RlU2l6ZScpICYmICFzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDE7XG4gICAgICBiID0gMDtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpID09PSBzZXR0aW5ncygnbWluTm9kZVNpemUnKSkge1xuICAgICAgYSA9IDA7XG4gICAgICBiID0gK3NldHRpbmdzKCdtYXhOb2RlU2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gKHNldHRpbmdzKCdtYXhOb2RlU2l6ZScpIC0gc2V0dGluZ3MoJ21pbk5vZGVTaXplJykpIC8gc2l6ZU1heDtcbiAgICAgIGIgPSArc2V0dGluZ3MoJ21pbk5vZGVTaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAmJiAhc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAxO1xuICAgICAgZCA9IDA7XG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSA9PT0gc2V0dGluZ3MoJ21pbkVkZ2VTaXplJykpIHtcbiAgICAgIGMgPSAwO1xuICAgICAgZCA9ICtzZXR0aW5ncygnbWluRWRnZVNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IChzZXR0aW5ncygnbWF4RWRnZVNpemUnKSAtIHNldHRpbmdzKCdtaW5FZGdlU2l6ZScpKSAvIHdlaWdodE1heDtcbiAgICAgIGQgPSArc2V0dGluZ3MoJ21pbkVkZ2VTaXplJyk7XG4gICAgfVxuXG4gICAgLy8gUmVzY2FsZSB0aGUgbm9kZXMgYW5kIGVkZ2VzOlxuICAgIGZvciAoaSA9IDAsIGwgPSBlLmxlbmd0aDsgaSA8IGw7IGkrKylcbiAgICAgIGVbaV1bd3JpdGVQcmVmaXggKyAnc2l6ZSddID1cbiAgICAgICAgZVtpXVtyZWFkUHJlZml4ICsgJ3NpemUnXSAqIChlcyA/IGMgOiAxKSArIChlcyA/IGQgOiAwKTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPVxuICAgICAgICBuW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddICogKG5zID8gYSA6IDEpICsgKG5zID8gYiA6IDApO1xuICAgICAgbltpXVt3cml0ZVByZWZpeCArICd4J10gPVxuICAgICAgICAobltpXVtyZWFkUHJlZml4ICsgJ3gnXSAtIChtYXhYICsgbWluWCkgLyAyKSAqIChucCA/IHNjYWxlIDogMSk7XG4gICAgICBuW2ldW3dyaXRlUHJlZml4ICsgJ3knXSA9XG4gICAgICAgIChuW2ldW3JlYWRQcmVmaXggKyAneSddIC0gKG1heFkgKyBtaW5ZKSAvIDIpICogKG5wID8gc2NhbGUgOiAxKTtcbiAgICB9XG4gIH07XG5cbiAgc2lnbWEudXRpbHMuZ2V0Qm91bmRhcmllcyA9IGZ1bmN0aW9uKGdyYXBoLCBwcmVmaXgsIGRvRWRnZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgZSA9IGdyYXBoLmVkZ2VzKCksXG4gICAgICAgIG4gPSBncmFwaC5ub2RlcygpLFxuICAgICAgICB3ZWlnaHRNYXggPSAtSW5maW5pdHksXG4gICAgICAgIHNpemVNYXggPSAtSW5maW5pdHksXG4gICAgICAgIG1pblggPSBJbmZpbml0eSxcbiAgICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgaWYgKGRvRWRnZXMpXG4gICAgICBmb3IgKGkgPSAwLCBsID0gZS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgIHdlaWdodE1heCA9IE1hdGgubWF4KGVbaV1bcHJlZml4ICsgJ3NpemUnXSwgd2VpZ2h0TWF4KTtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2l6ZU1heCA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3NpemUnXSwgc2l6ZU1heCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobltpXVtwcmVmaXggKyAneCddLCBtYXhYKTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihuW2ldW3ByZWZpeCArICd4J10sIG1pblgpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG5baV1bcHJlZml4ICsgJ3knXSwgbWF4WSk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obltpXVtwcmVmaXggKyAneSddLCBtaW5ZKTtcbiAgICB9XG5cbiAgICB3ZWlnaHRNYXggPSB3ZWlnaHRNYXggfHwgMTtcbiAgICBzaXplTWF4ID0gc2l6ZU1heCB8fCAxO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodE1heDogd2VpZ2h0TWF4LFxuICAgICAgc2l6ZU1heDogc2l6ZU1heCxcbiAgICAgIG1pblg6IG1pblgsXG4gICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgbWF4WDogbWF4WCxcbiAgICAgIG1heFk6IG1heFlcbiAgICB9O1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlkZGxld2FyZXMnKTtcblxuICAvKipcbiAgICogVGhpcyBtaWRkbGV3YXJlIHdpbGwganVzdCBjb3B5IHRoZSBncmFwaGljIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gcmVhZFByZWZpeCAgVGhlIHJlYWQgcHJlZml4LlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHdyaXRlUHJlZml4IFRoZSB3cml0ZSBwcmVmaXguXG4gICAqL1xuICBzaWdtYS5taWRkbGV3YXJlcy5jb3B5ID0gZnVuY3Rpb24ocmVhZFByZWZpeCwgd3JpdGVQcmVmaXgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbCxcbiAgICAgICAgYTtcblxuICAgIGlmICh3cml0ZVByZWZpeCArICcnID09PSByZWFkUHJlZml4ICsgJycpXG4gICAgICByZXR1cm47XG5cbiAgICBhID0gdGhpcy5ncmFwaC5ub2RlcygpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd4J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneCddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICd5J10gPSBhW2ldW3JlYWRQcmVmaXggKyAneSddO1xuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICAgIH1cblxuICAgIGEgPSB0aGlzLmdyYXBoLmVkZ2VzKCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgYVtpXVt3cml0ZVByZWZpeCArICdzaXplJ10gPSBhW2ldW3JlYWRQcmVmaXggKyAnc2l6ZSddO1xuICB9O1xufSkuY2FsbCh0aGlzKTtcblxuOyhmdW5jdGlvbih1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIC8vIEluaXRpYWxpemUgcGFja2FnZXM6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZycpO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmV3IElELlxuICAgKi9cbiAgdmFyIF9nZXRJRCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnJyArICgrK2lkKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFuaW1hdGVzIGEgY2FtZXJhLiBJdCBoYXMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGNhbWVyYSB0b1xuICAgKiBhbmltYXRlLCB0aGUgdmFsdWVzIG9mIHRoZSBjb29yZGluYXRlcyB0byByZWFjaCBhbmQgZXZlbnR1YWxseSBzb21lXG4gICAqIG9wdGlvbnMuIEl0IHJldHVybnMgYSBudW1iZXIgaWQsIHRoYXQgeW91IGNhbiB1c2UgdG8ga2lsbCB0aGUgYW5pbWF0aW9uLFxuICAgKiB3aXRoIHRoZSBtZXRob2Qgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbChpZCkuXG4gICAqXG4gICAqIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgez9udW1iZXJ9ICAgICAgICAgICAgZHVyYXRpb24gICBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICogICB7P2Z1bmN0aW9ufSAgICAgICAgICBvbk5ld0ZyYW1lIEEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyIGEgbmV3IGZyYW1lLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgQSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgY29tcGxldGVkIG9yIGtpbGxlZC5cbiAgICogICB7PyhzdHJpbmd8ZnVuY3Rpb24pfSBlYXNpbmcgICAgIFRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gZnJvbSB0aGUgcGFja2FnZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbWEudXRpbHMuZWFzaW5ncywgb3IgYSBjdXN0b20gZWFzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7Y2FtZXJhfSAgY2FtZXJhICBUaGUgY2FtZXJhIHRvIGFuaW1hdGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldCAgVGhlIGNvb3JkaW5hdGVzIHRvIHJlYWNoLlxuICAgKiBAcGFyYW0gIHs/b2JqZWN0fSBvcHRpb25zIEV2ZW50dWFsbHkgYW4gb2JqZWN0IHRvIHNwZWNpZnkgc29tZSBvcHRpb25zIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGZ1bmN0aW9uLiBUaGUgYXZhaWxhYmxlIG9wdGlvbnMgYXJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudGVkIGluIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgVGhlIGFuaW1hdGlvbiBpZCwgdG8gbWFrZSBpdCBlYXN5IHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdWdoIHRoZSBtZXRob2QgXCJzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsXCIuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5jYW1lcmEgPSBmdW5jdGlvbihjYW1lcmEsIHZhbCwgb3B0aW9ucykge1xuICAgIGlmIChcbiAgICAgICEoY2FtZXJhIGluc3RhbmNlb2Ygc2lnbWEuY2xhc3Nlcy5jYW1lcmEpIHx8XG4gICAgICB0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fFxuICAgICAgIXZhbFxuICAgIClcbiAgICAgIHRocm93ICdhbmltYXRpb24uY2FtZXJhOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiB2YWwueCAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwueSAhPT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiB2YWwucmF0aW8gIT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2YgdmFsLmFuZ2xlICE9PSAnbnVtYmVyJ1xuICAgIClcbiAgICAgIHRocm93ICdUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSB2YWxpZCBjb29yZGluYXRlIGluIHRoZSBnaXZlbiB2YWwuJztcblxuICAgIHZhciBmbixcbiAgICAgICAgaWQsXG4gICAgICAgIGFuaW0sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGluaXRpYWxWYWwsXG4gICAgICAgIG8gPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKTtcblxuICAgIC8vIFN0b3JlIGluaXRpYWwgdmFsdWVzOlxuICAgIGluaXRpYWxWYWwgPSB7XG4gICAgICB4OiBjYW1lcmEueCxcbiAgICAgIHk6IGNhbWVyYS55LFxuICAgICAgcmF0aW86IGNhbWVyYS5yYXRpbyxcbiAgICAgIGFuZ2xlOiBjYW1lcmEuYW5nbGVcbiAgICB9O1xuXG4gICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uO1xuICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyAhPT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBzaWdtYS51dGlscy5lYXNpbmdzW28uZWFzaW5nIHx8ICdxdWFkcmF0aWNJbk91dCddIDpcbiAgICAgIG8uZWFzaW5nO1xuXG4gICAgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb2VmLFxuICAgICAgICAgIHQgPSBvLmR1cmF0aW9uID8gKHNpZ21hLnV0aWxzLmRhdGVOb3coKSAtIHN0YXJ0KSAvIG8uZHVyYXRpb24gOiAxO1xuXG4gICAgICAvLyBJZiB0aGUgYW5pbWF0aW9uIGlzIG92ZXI6XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIGNhbWVyYS5pc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIGNhbWVyYS5nb1RvKHtcbiAgICAgICAgICB4OiB2YWwueCAhPT0gdW5kZWZpbmVkID8gdmFsLnggOiBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/IHZhbC55IDogaW5pdGlhbFZhbC55LFxuICAgICAgICAgIHJhdGlvOiB2YWwucmF0aW8gIT09IHVuZGVmaW5lZCA/IHZhbC5yYXRpbyA6IGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID8gdmFsLmFuZ2xlIDogaW5pdGlhbFZhbC5hbmdsZVxuICAgICAgICB9KTtcblxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIGRlbGV0ZSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nW2lkXTtcblxuICAgICAgICAvLyBDaGVjayBjYWxsYmFja3M6XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xuXG4gICAgICAvLyBFbHNlLCBsZXQncyBrZWVwIGdvaW5nOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29lZiA9IGVhc2luZyh0KTtcbiAgICAgICAgY2FtZXJhLmlzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICBjYW1lcmEuZ29Ubyh7XG4gICAgICAgICAgeDogdmFsLnggIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnggKyAodmFsLnggLSBpbml0aWFsVmFsLngpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLngsXG4gICAgICAgICAgeTogdmFsLnkgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBpbml0aWFsVmFsLnkgKyAodmFsLnkgLSBpbml0aWFsVmFsLnkpICogY29lZiA6XG4gICAgICAgICAgICBpbml0aWFsVmFsLnksXG4gICAgICAgICAgcmF0aW86IHZhbC5yYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8gKyAodmFsLnJhdGlvIC0gaW5pdGlhbFZhbC5yYXRpbykgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwucmF0aW8sXG4gICAgICAgICAgYW5nbGU6IHZhbC5hbmdsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGUgKyAodmFsLmFuZ2xlIC0gaW5pdGlhbFZhbC5hbmdsZSkgKiBjb2VmIDpcbiAgICAgICAgICAgIGluaXRpYWxWYWwuYW5nbGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgICBpZiAodHlwZW9mIG8ub25OZXdGcmFtZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBvLm9uTmV3RnJhbWUoKTtcblxuICAgICAgICBhbmltLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZCA9IF9nZXRJRCgpO1xuICAgIGFuaW0gPSB7XG4gICAgICBmcmFtZUlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pLFxuICAgICAgdGFyZ2V0OiBjYW1lcmEsXG4gICAgICB0eXBlOiAnY2FtZXJhJyxcbiAgICAgIG9wdGlvbnM6IG8sXG4gICAgICBmbjogZm5cbiAgICB9O1xuICAgIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdID0gYW5pbTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogS2lsbHMgYSBydW5uaW5nIGFuaW1hdGlvbi4gSXQgdHJpZ2dlcnMgdGhlIGV2ZW50dWFsIG9uQ29tcGxldGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge251bWJlcn0gaWQgIFRoZSBpZCBvZiB0aGUgYW5pbWF0aW9uIHRvIGtpbGwuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgIFJldHVybnMgdGhlIHNpZ21hLm1pc2MuYW5pbWF0aW9uIHBhY2thZ2UuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5raWxsID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSB8fCB0eXBlb2YgaWQgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgJ2FuaW1hdGlvbi5raWxsOiBXcm9uZyBhcmd1bWVudHMuJztcblxuICAgIHZhciBvID0gc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICBpZiAobykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgZGVsZXRlIHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbby5mcmFtZUlkXTtcblxuICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgIG8udGFyZ2V0LmlzQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gQ2hlY2sgY2FsbGJhY2tzOlxuICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBvLm9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBLaWxscyBldmVyeSBydW5uaW5nIGFuaW1hdGlvbnMsIG9yIG9ubHkgdGhlIG9uZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSxcbiAgICogaWYgYSBzdHJpbmcgcGFyYW1ldGVyIGlzIGdpdmVuLlxuICAgKlxuICAgKiBAcGFyYW0gIHs/KHN0cmluZ3xvYmplY3QpfSBmaWx0ZXIgQSBzdHJpbmcgdG8gZmlsdGVyIHRoZSBhbmltYXRpb25zIHRvIGtpbGxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uIHRoZWlyIHR5cGUgKGV4YW1wbGU6IFwiY2FtZXJhXCIpLCBvciBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHRvIGZpbHRlciBvbiB0aGVpciB0YXJnZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYW5pbWF0aW9ucyBraWxsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgd2F5LlxuICAgKi9cbiAgc2lnbWEubWlzYy5hbmltYXRpb24ua2lsbEFsbCA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBvLFxuICAgICAgICBpZCxcbiAgICAgICAgY291bnQgPSAwLFxuICAgICAgICB0eXBlID0gdHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycgPyBmaWx0ZXIgOiBudWxsLFxuICAgICAgICB0YXJnZXQgPSB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHJ1bm5pbmcgPSBzaWdtYS5taXNjLmFuaW1hdGlvbi5ydW5uaW5nO1xuXG4gICAgZm9yIChpZCBpbiBydW5uaW5nKVxuICAgICAgaWYgKFxuICAgICAgICAoIXR5cGUgfHwgcnVubmluZ1tpZF0udHlwZSA9PT0gdHlwZSkgJiZcbiAgICAgICAgKCF0YXJnZXQgfHwgcnVubmluZ1tpZF0udGFyZ2V0ID09PSB0YXJnZXQpXG4gICAgICApIHtcbiAgICAgICAgbyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmdbaWRdO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShvLmZyYW1lSWQpO1xuICAgICAgICBkZWxldGUgc2lnbWEubWlzYy5hbmltYXRpb24ucnVubmluZ1tpZF07XG5cbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2NhbWVyYScpXG4gICAgICAgICAgby50YXJnZXQuaXNBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyOlxuICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgIC8vIENoZWNrIGNhbGxiYWNrczpcbiAgICAgICAgaWYgKHR5cGVvZiAoby5vcHRpb25zIHx8IHt9KS5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IGFuaW1hdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBzdGlsbCBydW5uaW5nIG1hdGNoZXNcbiAgICogdGhlIGZpbHRlciBnaXZlbiB0byB0aGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ3xvYmplY3R9IGZpbHRlciBBIHN0cmluZyB0byBmaWx0ZXIgdGhlIGFuaW1hdGlvbnMgdG8ga2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb24gdGhlaXIgdHlwZSAoZXhhbXBsZTogXCJjYW1lcmFcIiksIG9yIGFuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdG8gZmlsdGVyIG9uIHRoZWlyIHRhcmdldC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBhbnkgcnVubmluZyBhbmltYXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuXG4gICAqL1xuICBzaWdtYS5taXNjLmFuaW1hdGlvbi5oYXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgaWQsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJyA/IGZpbHRlciA6IG51bGwsXG4gICAgICAgIHRhcmdldCA9IHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnID8gZmlsdGVyIDogbnVsbCxcbiAgICAgICAgcnVubmluZyA9IHNpZ21hLm1pc2MuYW5pbWF0aW9uLnJ1bm5pbmc7XG5cbiAgICBmb3IgKGlkIGluIHJ1bm5pbmcpXG4gICAgICBpZiAoXG4gICAgICAgICghdHlwZSB8fCBydW5uaW5nW2lkXS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAoIXRhcmdldCB8fCBydW5uaW5nW2lkXS50YXJnZXQgPT09IHRhcmdldClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgbm8tRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2UgY2FudmFzIG9yIFdlYkdMKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpLFxuICAgICAgICBsLFxuICAgICAgICBtWCxcbiAgICAgICAgbVksXG4gICAgICAgIGNhcHRvcixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBnZXROb2RlcyhlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBtWCA9ICd4JyBpbiBlLmRhdGEgPyBlLmRhdGEueCA6IG1YO1xuICAgICAgICBtWSA9ICd5JyBpbiBlLmRhdGEgPyBlLmRhdGEueSA6IG1ZO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgbixcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgcyxcbiAgICAgICAgICBpbnNlcnRlZCxcbiAgICAgICAgICBzZWxlY3RlZCA9IFtdLFxuICAgICAgICAgIG1vZGlmaWVkWCA9IG1YICsgc2VsZi53aWR0aCAvIDIsXG4gICAgICAgICAgbW9kaWZpZWRZID0gbVkgKyBzZWxmLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnQgPSBzZWxmLmNhbWVyYS5jYW1lcmFQb3NpdGlvbihcbiAgICAgICAgICAgIG1YLFxuICAgICAgICAgICAgbVlcbiAgICAgICAgICApLFxuICAgICAgICAgIG5vZGVzID0gc2VsZi5jYW1lcmEucXVhZHRyZWUucG9pbnQoXG4gICAgICAgICAgICBwb2ludC54LFxuICAgICAgICAgICAgcG9pbnQueVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGgpXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgeCA9IG5bcHJlZml4ICsgJ3gnXTtcbiAgICAgICAgICB5ID0gbltwcmVmaXggKyAneSddO1xuICAgICAgICAgIHMgPSBuW3ByZWZpeCArICdzaXplJ107XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbi5oaWRkZW4gJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWCA+IHggLSBzICYmXG4gICAgICAgICAgICBtb2RpZmllZFggPCB4ICsgcyAmJlxuICAgICAgICAgICAgbW9kaWZpZWRZID4geSAtIHMgJiZcbiAgICAgICAgICAgIG1vZGlmaWVkWSA8IHkgKyBzICYmXG4gICAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgIE1hdGgucG93KG1vZGlmaWVkWCAtIHgsIDIpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3cobW9kaWZpZWRZIC0geSwgMilcbiAgICAgICAgICAgICkgPCBzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGU6XG4gICAgICAgICAgICBpbnNlcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc2VsZWN0ZWQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgIGlmIChuLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuc3BsaWNlKGosIDAsIG4pO1xuICAgICAgICAgICAgICAgIGluc2VydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKG4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRFZGdlcyhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2VuYWJsZUVkZ2VIb3ZlcmluZycpKSB7XG4gICAgICAgIC8vIE5vIGV2ZW50IGlmIHRoZSBzZXR0aW5nIGlzIG9mZjpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDYW52YXMgPSAoXG4gICAgICAgIHNpZ21hLnJlbmRlcmVycy5jYW52YXMgJiYgc2VsZiBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5jYW52YXMpO1xuXG4gICAgICBpZiAoIWlzQ2FudmFzKSB7XG4gICAgICAgIC8vIEEgcXVpY2sgaGFyZGNvZGVkIHJ1bGUgdG8gcHJldmVudCBwZW9wbGUgZnJvbSB1c2luZyB0aGlzIGZlYXR1cmVcbiAgICAgICAgLy8gd2l0aCB0aGUgV2ViR0wgcmVuZGVyZXIgKHdoaWNoIGlzIG5vdCBnb29kIGVub3VnaCBhdCB0aGUgbW9tZW50KTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZWRnZSBldmVudHMgZmVhdHVyZSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBXZWJHTCByZW5kZXJlcidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgbVggPSAneCcgaW4gZS5kYXRhID8gZS5kYXRhLnggOiBtWDtcbiAgICAgICAgbVkgPSAneScgaW4gZS5kYXRhID8gZS5kYXRhLnkgOiBtWTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBsLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgZWRnZSxcbiAgICAgICAgICBzLFxuICAgICAgICAgIG1heEVwc2lsb24gPSBzZWxmLnNldHRpbmdzKCdlZGdlSG92ZXJQcmVjaXNpb24nKSxcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGNwLFxuICAgICAgICAgIG5vZGVJbmRleCA9IHt9LFxuICAgICAgICAgIGluc2VydGVkLFxuICAgICAgICAgIHNlbGVjdGVkID0gW10sXG4gICAgICAgICAgbW9kaWZpZWRYID0gbVggKyBzZWxmLndpZHRoIC8gMixcbiAgICAgICAgICBtb2RpZmllZFkgPSBtWSArIHNlbGYuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludCA9IHNlbGYuY2FtZXJhLmNhbWVyYVBvc2l0aW9uKFxuICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICBtWVxuICAgICAgICAgICksXG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgICAgaWYgKGlzQ2FudmFzKSB7XG4gICAgICAgIHZhciBub2Rlc09uU2NyZWVuID0gc2VsZi5jYW1lcmEucXVhZHRyZWUuYXJlYShcbiAgICAgICAgICBzZWxmLmNhbWVyYS5nZXRSZWN0YW5nbGUoc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQpXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoYSA9IG5vZGVzT25TY3JlZW4sIGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgbm9kZUluZGV4W2FbaV0uaWRdID0gYVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuY2FtZXJhLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVkZ2VzID0gc2VsZi5jYW1lcmEuZWRnZXF1YWR0cmVlLnBvaW50KFxuICAgICAgICAgIHBvaW50LngsXG4gICAgICAgICAgcG9pbnQueVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnNlcnRFZGdlKHNlbGVjdGVkLCBlZGdlKSB7XG4gICAgICAgIGluc2VydGVkID0gZmFsc2U7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlbGVjdGVkLmxlbmd0aDsgaisrKVxuICAgICAgICAgIGlmIChlZGdlLnNpemUgPiBzZWxlY3RlZFtqXS5zaXplKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zcGxpY2UoaiwgMCwgZWRnZSk7XG4gICAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICBzZWxlY3RlZC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZWRnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpO1xuICAgICAgICAgIHRhcmdldCA9IHNlbGYuZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpO1xuICAgICAgICAgIC8vIChIQUNLKSB3ZSBjYW4ndCBnZXQgZWRnZVtwcmVmaXggKyAnc2l6ZSddIG9uIFdlYkdMIHJlbmRlcmVyOlxuICAgICAgICAgIHMgPSBlZGdlW3ByZWZpeCArICdzaXplJ10gfHxcbiAgICAgICAgICAgICAgZWRnZVsncmVhZF8nICsgcHJlZml4ICsgJ3NpemUnXTtcblxuICAgICAgICAgIC8vIEZpcnN0LCBsZXQncyBpZGVudGlmeSB3aGljaCBlZGdlcyBhcmUgZHJhd24uIFRvIGRvIHRoaXMsIHdlIGtlZXBcbiAgICAgICAgICAvLyBldmVyeSBlZGdlcyB0aGF0IGhhdmUgYXQgbGVhc3Qgb25lIGV4dHJlbWl0eSBkaXNwbGF5ZWQgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgLy8gdGhlIHF1YWR0cmVlIGFuZCB0aGUgXCJoaWRkZW5cIiBhdHRyaWJ1dGUuIFdlIGFsc28gZG8gbm90IGtlZXAgaGlkZGVuXG4gICAgICAgICAgLy8gZWRnZXMuXG4gICAgICAgICAgLy8gVGhlbiwgbGV0J3MgY2hlY2sgaWYgdGhlIG1vdXNlIGlzIG9uIHRoZSBlZGdlICh3ZSBzdXBwb3NlIHRoYXQgaXRcbiAgICAgICAgICAvLyBpcyBhIGxpbmUgc2VnbWVudCkuXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhZWRnZS5oaWRkZW4gJiZcbiAgICAgICAgICAgICFzb3VyY2UuaGlkZGVuICYmICF0YXJnZXQuaGlkZGVuICYmXG4gICAgICAgICAgICAoIWlzQ2FudmFzIHx8XG4gICAgICAgICAgICAgIChub2RlSW5kZXhbZWRnZS5zb3VyY2VdIHx8IG5vZGVJbmRleFtlZGdlLnRhcmdldF0pKSAmJlxuICAgICAgICAgICAgc2lnbWEudXRpbHMuZ2V0RGlzdGFuY2UoXG4gICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICBtb2RpZmllZFkpID4gc291cmNlW3ByZWZpeCArICdzaXplJ10gJiZcbiAgICAgICAgICAgIHNpZ21hLnV0aWxzLmdldERpc3RhbmNlKFxuICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgIG1vZGlmaWVkWCxcbiAgICAgICAgICAgICAgbW9kaWZpZWRZKSA+IHRhcmdldFtwcmVmaXggKyAnc2l6ZSddXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS50eXBlID09ICdjdXJ2ZScgfHwgZWRnZS50eXBlID09ICdjdXJ2ZWRBcnJvdycpIHtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAgICAgY3AgPSBzaWdtYS51dGlscy5nZXRTZWxmTG9vcENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICAgIHNvdXJjZVtwcmVmaXggKyAneSddLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICdzaXplJ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPbkJlemllckN1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54MSxcbiAgICAgICAgICAgICAgICAgIGNwLnkxLFxuICAgICAgICAgICAgICAgICAgY3AueDIsXG4gICAgICAgICAgICAgICAgICBjcC55MixcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNwID0gc2lnbWEudXRpbHMuZ2V0UXVhZHJhdGljQ29udHJvbFBvaW50KFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10pO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblF1YWRyYXRpY0N1cnZlKFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgICAgbW9kaWZpZWRZLFxuICAgICAgICAgICAgICAgICAgc291cmNlW3ByZWZpeCArICd4J10sXG4gICAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldFtwcmVmaXggKyAneCddLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0W3ByZWZpeCArICd5J10sXG4gICAgICAgICAgICAgICAgICBjcC54LFxuICAgICAgICAgICAgICAgICAgY3AueSxcbiAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHMsIG1heEVwc2lsb24pXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0RWRnZShzZWxlY3RlZCwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHNpZ21hLnV0aWxzLmlzUG9pbnRPblNlZ21lbnQoXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRYLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkWSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICBzb3VyY2VbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3gnXSxcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChzLCBtYXhFcHNpbG9uKVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIGluc2VydEVkZ2Uoc2VsZWN0ZWQsIGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBiaW5kQ2FwdG9yKGNhcHRvcikge1xuICAgICAgdmFyIG5vZGVzLFxuICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgIG92ZXJOb2RlcyA9IHt9LFxuICAgICAgICAgIG92ZXJFZGdlcyA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkRvdWJsZUNsaWNrKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2snLCBlLmRhdGEpO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlcycsIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IGVkZ2VzWzBdLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tTdGFnZScsIHtjYXB0b3I6IGUuZGF0YX0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJpZ2h0Q2xpY2soZSkge1xuICAgICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrJywgZS5kYXRhKTtcblxuICAgICAgICBub2RlcyA9IGdldE5vZGVzKGUpO1xuICAgICAgICBlZGdlcyA9IGdldEVkZ2VzKGUpO1xuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3JpZ2h0Q2xpY2tOb2RlJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXNbMF0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja05vZGVzJywge1xuICAgICAgICAgICAgbm9kZTogbm9kZXMsXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja0VkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlc1swXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdyaWdodENsaWNrRWRnZXMnLCB7XG4gICAgICAgICAgICBlZGdlOiBlZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgncmlnaHRDbGlja1N0YWdlJywge2NhcHRvcjogZS5kYXRhfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBrLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBsZSxcbiAgICAgICAgICAgIG91dE5vZGVzID0gW10sXG4gICAgICAgICAgICBvdXRFZGdlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoayBpbiBvdmVyTm9kZXMpXG4gICAgICAgICAgb3V0Tm9kZXMucHVzaChvdmVyTm9kZXNba10pO1xuXG4gICAgICAgIG92ZXJOb2RlcyA9IHt9O1xuICAgICAgICAvLyBEaXNwYXRjaCBib3RoIHNpbmdsZSBhbmQgbXVsdGkgZXZlbnRzOlxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG91dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG91dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICBvdmVyRWRnZXMgPSB7fTtcbiAgICAgICAgLy8gRGlzcGF0Y2ggYm90aCBzaW5nbGUgYW5kIG11bHRpIGV2ZW50czpcbiAgICAgICAgZm9yIChpID0gMCwgbGUgPSBvdXRFZGdlcy5sZW5ndGg7IGkgPCBsZTsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG91dEVkZ2VzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dEVkZ2VzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG91dEVkZ2VzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25Nb3ZlKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIG5vZGVzID0gZ2V0Tm9kZXMoZSk7XG4gICAgICAgIGVkZ2VzID0gZ2V0RWRnZXMoZSk7XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGVkZ2UsXG4gICAgICAgICAgICBuZXdPdXROb2RlcyA9IFtdLFxuICAgICAgICAgICAgbmV3T3Zlck5vZGVzID0gW10sXG4gICAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzID0ge30sXG4gICAgICAgICAgICBsID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgbmV3T3V0RWRnZXMgPSBbXSxcbiAgICAgICAgICAgIG5ld092ZXJFZGdlcyA9IFtdLFxuICAgICAgICAgICAgY3VycmVudE92ZXJFZGdlcyA9IHt9LFxuICAgICAgICAgICAgbGUgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgbmV3bHkgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3Zlck5vZGVzW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgICBpZiAoIW92ZXJOb2Rlc1tub2RlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3Zlck5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBvdmVyTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBub2RlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJOb2RlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyTm9kZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dE5vZGVzLnB1c2gob3Zlck5vZGVzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyTm9kZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBuZXdPdmVyTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3Zlck5vZGUnLCB7XG4gICAgICAgICAgICBub2RlOiBuZXdPdmVyTm9kZXNbaV0sXG4gICAgICAgICAgICBjYXB0b3I6IGUuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gbmV3T3V0Tm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0Tm9kZScsIHtcbiAgICAgICAgICAgIG5vZGU6IG5ld091dE5vZGVzW2ldLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld092ZXJOb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZXMnLCB7XG4gICAgICAgICAgICBub2RlczogbmV3T3Zlck5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5ld091dE5vZGVzLmxlbmd0aClcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGVzJywge1xuICAgICAgICAgICAgbm9kZXM6IG5ld091dE5vZGVzLFxuICAgICAgICAgICAgY2FwdG9yOiBlLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGVjayBuZXdseSBvdmVycmVkIGVkZ2VzOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGU7IGkrKykge1xuICAgICAgICAgIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICBjdXJyZW50T3ZlckVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICBpZiAoIW92ZXJFZGdlc1tlZGdlLmlkXSkge1xuICAgICAgICAgICAgbmV3T3ZlckVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICBvdmVyRWRnZXNbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vIG1vcmUgb3ZlcnJlZCBlZGdlczpcbiAgICAgICAgZm9yIChrIGluIG92ZXJFZGdlcylcbiAgICAgICAgICBpZiAoIWN1cnJlbnRPdmVyRWRnZXNba10pIHtcbiAgICAgICAgICAgIG5ld091dEVkZ2VzLnB1c2gob3ZlckVkZ2VzW2tdKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvdmVyRWRnZXNba107XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc3BhdGNoIGJvdGggc2luZ2xlIGFuZCBtdWx0aSBldmVudHM6XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3ZlckVkZ2VzLmxlbmd0aDsgaSA8IGxlOyBpKyspXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICAgIGVkZ2U6IG5ld092ZXJFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlID0gbmV3T3V0RWRnZXMubGVuZ3RoOyBpIDwgbGU7IGkrKylcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dEVkZ2UnLCB7XG4gICAgICAgICAgICBlZGdlOiBuZXdPdXRFZGdlc1tpXSxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdmVyRWRnZXMubGVuZ3RoKVxuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3ZlckVkZ2VzJywge1xuICAgICAgICAgICAgZWRnZXM6IG5ld092ZXJFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdPdXRFZGdlcy5sZW5ndGgpXG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdXRFZGdlcycsIHtcbiAgICAgICAgICAgIGVkZ2VzOiBuZXdPdXRFZGdlcyxcbiAgICAgICAgICAgIGNhcHRvcjogZS5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJpbmQgZXZlbnRzOlxuICAgICAgY2FwdG9yLmJpbmQoJ2NsaWNrJywgb25DbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgnbW91c2Vkb3duJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZXVwJywgb25Nb3ZlKTtcbiAgICAgIGNhcHRvci5iaW5kKCdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgY2FwdG9yLmJpbmQoJ21vdXNlb3V0Jywgb25PdXQpO1xuICAgICAgY2FwdG9yLmJpbmQoJ2RvdWJsZWNsaWNrJywgb25Eb3VibGVDbGljayk7XG4gICAgICBjYXB0b3IuYmluZCgncmlnaHRjbGljaycsIG9uUmlnaHRDbGljayk7XG4gICAgICBzZWxmLmJpbmQoJ3JlbmRlcicsIG9uTW92ZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2FwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBiaW5kQ2FwdG9yKHRoaXMuY2FwdG9yc1tpXSk7XG4gIH07XG59KS5jYWxsKHRoaXMpO1xuXG47KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwYWNrYWdlczpcbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5taXNjJyk7XG5cbiAgLyoqXG4gICAqIFRoaXMgaGVscGVyIHdpbGwgYmluZCBhbnkgRE9NIHJlbmRlcmVyIChmb3IgaW5zdGFuY2Ugc3ZnKVxuICAgKiB0byBpdHMgY2FwdG9ycywgdG8gcHJvcGVybHkgZGlzcGF0Y2ggdGhlIGdvb2QgZXZlbnRzIHRvIHRoZSBzaWdtYSBpbnN0YW5jZVxuICAgKiB0byBtYW5hZ2UgY2xpY2tpbmcsIGhvdmVyaW5nIGV0Yy4uLlxuICAgKlxuICAgKiBJdCBoYXMgdG8gYmUgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgcmVsYXRlZCByZW5kZXJlci5cbiAgICovXG4gIHNpZ21hLm1pc2MuYmluZERPTUV2ZW50cyA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZ3JhcGggPSB0aGlzLmdyYXBoO1xuXG4gICAgLy8gRE9NRWxlbWVudCBhYnN0cmFjdGlvblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQoZG9tRWxlbWVudCkge1xuXG4gICAgICAvLyBIZWxwZXJzXG4gICAgICB0aGlzLmF0dHIgPSBmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBhdHRyTmFtZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQcm9wZXJ0aWVzXG4gICAgICB0aGlzLnRhZyA9IGRvbUVsZW1lbnQudGFnTmFtZTtcbiAgICAgIHRoaXMuY2xhc3MgPSB0aGlzLmF0dHIoJ2NsYXNzJyk7XG4gICAgICB0aGlzLmlkID0gdGhpcy5hdHRyKCdpZCcpO1xuXG4gICAgICAvLyBNZXRob2RzXG4gICAgICB0aGlzLmlzTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF+dGhpcy5jbGFzcy5pbmRleE9mKHNlbGYuc2V0dGluZ3MoJ2NsYXNzUHJlZml4JykgKyAnLW5vZGUnKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaXNFZGdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctZWRnZScpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5pc0hvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIX50aGlzLmNsYXNzLmluZGV4T2Yoc2VsZi5zZXR0aW5ncygnY2xhc3NQcmVmaXgnKSArICctaG92ZXInKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2xpY2tcbiAgICBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnY2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2NsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBEb3VibGUgY2xpY2tcbiAgICBmdW5jdGlvbiBkb3VibGVDbGljayhlKSB7XG4gICAgICBpZiAoIXNlbGYuc2V0dGluZ3MoJ2V2ZW50c0VuYWJsZWQnKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvLyBHZW5lcmljIGV2ZW50XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrJywgZSk7XG5cbiAgICAgIC8vIEFyZSB3ZSBvbiBhIG5vZGU/XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBFbGVtZW50KGUudGFyZ2V0KTtcblxuICAgICAgaWYgKGVsZW1lbnQuaXNOb2RlKCkpXG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZG91YmxlQ2xpY2tOb2RlJywge1xuICAgICAgICAgIG5vZGU6IGdyYXBoLm5vZGVzKGVsZW1lbnQuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2RvdWJsZUNsaWNrU3RhZ2UnKTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBPbiBvdmVyXG4gICAgZnVuY3Rpb24gb25PdmVyKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRvRWxlbWVudCB8fCBlLnRhcmdldDtcblxuICAgICAgaWYgKCFzZWxmLnNldHRpbmdzKCdldmVudHNFbmFibGVkJykgfHwgIXRhcmdldClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICBpZiAoZWwuaXNOb2RlKCkpIHtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyTm9kZScsIHtcbiAgICAgICAgICBub2RlOiBncmFwaC5ub2RlcyhlbC5hdHRyKCdkYXRhLW5vZGUtaWQnKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgZWRnZSA9IGdyYXBoLmVkZ2VzKGVsLmF0dHIoJ2RhdGEtZWRnZS1pZCcpKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdvdmVyRWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIG91dFxuICAgIGZ1bmN0aW9uIG9uT3V0KGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLmZyb21FbGVtZW50IHx8IGUub3JpZ2luYWxUYXJnZXQ7XG5cbiAgICAgIGlmICghc2VsZi5zZXR0aW5ncygnZXZlbnRzRW5hYmxlZCcpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KHRhcmdldCk7XG5cbiAgICAgIGlmIChlbC5pc05vZGUoKSkge1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ291dE5vZGUnLCB7XG4gICAgICAgICAgbm9kZTogZ3JhcGgubm9kZXMoZWwuYXR0cignZGF0YS1ub2RlLWlkJykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmFwaC5lZGdlcyhlbC5hdHRyKCdkYXRhLWVkZ2UtaWQnKSk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnb3V0RWRnZScsIHtcbiAgICAgICAgICBlZGdlOiBlZGdlLFxuICAgICAgICAgIHNvdXJjZTogZ3JhcGgubm9kZXMoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgIHRhcmdldDogZ3JhcGgubm9kZXMoZWRnZS50YXJnZXQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyaW5nIEV2ZW50czpcblxuICAgIC8vIENsaWNrXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICdjbGljaycsIGRvdWJsZUNsaWNrKTtcblxuICAgIC8vIFRvdWNoIGNvdW50ZXJwYXJ0c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2xpY2ssIGZhbHNlKTtcbiAgICBzaWdtYS51dGlscy5kb3VibGVDbGljayhjb250YWluZXIsICd0b3VjaHN0YXJ0JywgZG91YmxlQ2xpY2spO1xuXG4gICAgLy8gTW91c2VvdmVyXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uT3ZlciwgdHJ1ZSk7XG5cbiAgICAvLyBNb3VzZW91dFxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uT3V0LCB0cnVlKTtcbiAgfTtcbn0pLmNhbGwodGhpcyk7XG5cbjsoZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIHNpZ21hID09PSAndW5kZWZpbmVkJylcbiAgICB0aHJvdyAnc2lnbWEgaXMgbm90IGRlY2xhcmVkJztcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2VzOlxuICBzaWdtYS51dGlscy5wa2coJ3NpZ21hLm1pc2MnKTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbGlzdGVucyB0byBcIm92ZXJOb2RlXCIsIFwib3V0Tm9kZVwiLCBcIm92ZXJFZGdlXCIgYW5kIFwib3V0RWRnZVwiXG4gICAqIGV2ZW50cyBmcm9tIGEgcmVuZGVyZXIgYW5kIHJlbmRlcnMgdGhlIG5vZGVzIGRpZmZlcmVudGx5IG9uIHRoZSB0b3AgbGF5ZXIuXG4gICAqIFRoZSBnb2FsIGlzIHRvIG1ha2UgYW55IG5vZGUgbGFiZWwgcmVhZGFibGUgd2l0aCB0aGUgbW91c2UsIGFuZCB0b1xuICAgKiBoaWdobGlnaHQgaG92ZXJlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAqXG4gICAqIEl0IGhhcyB0byBiZSBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSByZWxhdGVkIHJlbmRlcmVyLlxuICAgKi9cbiAgc2lnbWEubWlzYy5kcmF3SG92ZXJzID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBob3ZlcmVkTm9kZXMgPSB7fSxcbiAgICAgICAgaG92ZXJlZEVkZ2VzID0ge307XG5cbiAgICB0aGlzLmJpbmQoJ292ZXJOb2RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBub2RlID0gZXZlbnQuZGF0YS5ub2RlO1xuICAgICAgaWYgKCFub2RlLmhpZGRlbikge1xuICAgICAgICBob3ZlcmVkTm9kZXNbbm9kZS5pZF0gPSBub2RlO1xuICAgICAgICBkcmF3KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmQoJ291dE5vZGUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgZGVsZXRlIGhvdmVyZWROb2Rlc1tldmVudC5kYXRhLm5vZGUuaWRdO1xuICAgICAgZHJhdygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdmVyRWRnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgZWRnZSA9IGV2ZW50LmRhdGEuZWRnZTtcbiAgICAgIGlmICghZWRnZS5oaWRkZW4pIHtcbiAgICAgICAgaG92ZXJlZEVkZ2VzW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgZHJhdygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5iaW5kKCdvdXRFZGdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRlbGV0ZSBob3ZlcmVkRWRnZXNbZXZlbnQuZGF0YS5lZGdlLmlkXTtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYmluZCgncmVuZGVyJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGRyYXcoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG5cbiAgICAgIHZhciBrLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgaG92ZXJlZE5vZGUsXG4gICAgICAgICAgaG92ZXJlZEVkZ2UsXG4gICAgICAgICAgYyA9IHNlbGYuY29udGV4dHMuaG92ZXIuY2FudmFzLFxuICAgICAgICAgIGRlZmF1bHROb2RlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHROb2RlVHlwZScpLFxuICAgICAgICAgIGRlZmF1bHRFZGdlVHlwZSA9IHNlbGYuc2V0dGluZ3MoJ2RlZmF1bHRFZGdlVHlwZScpLFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuaG92ZXJzLFxuICAgICAgICAgIGVkZ2VSZW5kZXJlcnMgPSBzaWdtYS5jYW52YXMuZWRnZWhvdmVycyxcbiAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVycyA9IHNpZ21hLmNhbnZhcy5leHRyZW1pdGllcyxcbiAgICAgICAgICBlbWJlZFNldHRpbmdzID0gc2VsZi5zZXR0aW5ncy5lbWJlZE9iamVjdHMoe1xuICAgICAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gQ2xlYXIgc2VsZi5jb250ZXh0cy5ob3ZlcjpcbiAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIuY2xlYXJSZWN0KDAsIDAsIGMud2lkdGgsIGMuaGVpZ2h0KTtcblxuICAgICAgLy8gTm9kZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVIb3ZlcmluZycpICYmXG4gICAgICAgIGVtYmVkU2V0dGluZ3MoJ3NpbmdsZUhvdmVyJykgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoaG92ZXJlZE5vZGVzKS5sZW5ndGhcbiAgICAgICkge1xuICAgICAgICBob3ZlcmVkTm9kZSA9IGhvdmVyZWROb2Rlc1tPYmplY3Qua2V5cyhob3ZlcmVkTm9kZXMpWzBdXTtcbiAgICAgICAgKFxuICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGUudHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICBub2RlUmVuZGVyZXJzLmRlZlxuICAgICAgICApKFxuICAgICAgICAgIGhvdmVyZWROb2RlLFxuICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb2RlIHJlbmRlcjogbXVsdGlwbGUgaG92ZXJcbiAgICAgIGlmIChcbiAgICAgICAgZW1iZWRTZXR0aW5ncygnZW5hYmxlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKVxuICAgICAgICBmb3IgKGsgaW4gaG92ZXJlZE5vZGVzKVxuICAgICAgICAgIChcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnNbaG92ZXJlZE5vZGVzW2tdLnR5cGVdIHx8XG4gICAgICAgICAgICBub2RlUmVuZGVyZXJzW2RlZmF1bHROb2RlVHlwZV0gfHxcbiAgICAgICAgICAgIG5vZGVSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgKShcbiAgICAgICAgICAgIGhvdmVyZWROb2Rlc1trXSxcbiAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgKTtcblxuICAgICAgLy8gRWRnZSByZW5kZXI6IHNpbmdsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICBlbWJlZFNldHRpbmdzKCdzaW5nbGVIb3ZlcicpICYmXG4gICAgICAgIE9iamVjdC5rZXlzKGhvdmVyZWRFZGdlcykubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgaG92ZXJlZEVkZ2UgPSBob3ZlcmVkRWRnZXNbT2JqZWN0LmtleXMoaG92ZXJlZEVkZ2VzKVswXV07XG4gICAgICAgIHNvdXJjZSA9IHNlbGYuZ3JhcGgubm9kZXMoaG92ZXJlZEVkZ2Uuc291cmNlKTtcbiAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgIGlmICghIGhvdmVyZWRFZGdlLmhpZGRlbikge1xuICAgICAgICAgIChcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgIGVkZ2VSZW5kZXJlcnNbZGVmYXVsdEVkZ2VUeXBlXSB8fFxuICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICApIChcbiAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGVtYmVkU2V0dGluZ3MoJ2VkZ2VIb3ZlckV4dHJlbWl0aWVzJykpIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnNbaG92ZXJlZEVkZ2UudHlwZV0gfHxcbiAgICAgICAgICAgICAgZXh0cmVtaXRpZXNSZW5kZXJlcnMuZGVmXG4gICAgICAgICAgICApKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXZvaWQgZWRnZXMgcmVuZGVyZWQgb3ZlciBub2RlczpcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXMuZGVmXG4gICAgICAgICAgICApIChcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBzZWxmLmNvbnRleHRzLmhvdmVyLFxuICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICBzaWdtYS5jYW52YXMubm9kZXNbdGFyZ2V0LnR5cGVdIHx8XG4gICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVkZ2UgcmVuZGVyOiBtdWx0aXBsZSBob3ZlclxuICAgICAgaWYgKFxuICAgICAgICBlbWJlZFNldHRpbmdzKCdlbmFibGVFZGdlSG92ZXJpbmcnKSAmJlxuICAgICAgICAhZW1iZWRTZXR0aW5ncygnc2luZ2xlSG92ZXInKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoayBpbiBob3ZlcmVkRWRnZXMpIHtcbiAgICAgICAgICBob3ZlcmVkRWRnZSA9IGhvdmVyZWRFZGdlc1trXTtcbiAgICAgICAgICBzb3VyY2UgPSBzZWxmLmdyYXBoLm5vZGVzKGhvdmVyZWRFZGdlLnNvdXJjZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gc2VsZi5ncmFwaC5ub2Rlcyhob3ZlcmVkRWRnZS50YXJnZXQpO1xuXG4gICAgICAgICAgaWYgKCFob3ZlcmVkRWRnZS5oaWRkZW4pIHtcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICBlZGdlUmVuZGVyZXJzW2RlZmF1bHRFZGdlVHlwZV0gfHxcbiAgICAgICAgICAgICAgZWRnZVJlbmRlcmVycy5kZWZcbiAgICAgICAgICAgICkgKFxuICAgICAgICAgICAgICBob3ZlcmVkRWRnZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgIGVtYmVkU2V0dGluZ3NcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChlbWJlZFNldHRpbmdzKCdlZGdlSG92ZXJFeHRyZW1pdGllcycpKSB7XG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBleHRyZW1pdGllc1JlbmRlcmVyc1tob3ZlcmVkRWRnZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIGV4dHJlbWl0aWVzUmVuZGVyZXJzLmRlZlxuICAgICAgICAgICAgICApKFxuICAgICAgICAgICAgICAgIGhvdmVyZWRFZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0cy5ob3ZlcixcbiAgICAgICAgICAgICAgICBlbWJlZFNldHRpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBlZGdlcyByZW5kZXJlZCBvdmVyIG5vZGVzOlxuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3NvdXJjZS50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgc2lnbWEuY2FudmFzLm5vZGVzW3RhcmdldC50eXBlXSB8fFxuICAgICAgICAgICAgICAgIHNpZ21hLmNhbnZhcy5ub2Rlcy5kZWZcbiAgICAgICAgICAgICAgKSAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dHMuaG92ZXIsXG4gICAgICAgICAgICAgICAgZW1iZWRTZXR0aW5nc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pLmNhbGwodGhpcyk7XG4iLCI7KGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYSBpcyBub3QgZGVjbGFyZWQnKTtcblxuICAvLyBJbml0aWFsaXplIHBhY2thZ2U6XG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEubGF5b3V0Lm5vdmVybGFwJyk7XG5cbiAgLyoqXG4gICAqIE5vdmVybGFwIExheW91dFxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqXG4gICAqIEF1dGhvcjogQGFwaXR0cyAvIEFuZHJldyBQaXR0c1xuICAgKiBBbGdvcml0aG06IEBqYWNvbXltYSAvIE1hdGhpZXUgSmFjb215IChvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIHRvIEdlcGhpIGFuZCBwb3J0ZWQgdG8gc2lnbWEuanMgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGJ5IEBhbmRwaXR0cyB3aXRoIHBlcm1pc3Npb24pXG4gICAqIEFja25vd2xlZGdlbWVudDogQHNoZXltYW4gLyBTw6liYXN0aWVuIEhleW1hbm4gKHNvbWUgaW5zcGlyYXRpb24gaGFzIGJlZW4gdGFrZW4gZnJvbSBvdGhlciBNSVQgbGljZW5zZWQgbGF5b3V0IGFsZ29yaXRobXMgYXV0aG9yZWQgYnkgQHNoZXltYW4pXG4gICAqIFZlcnNpb246IDAuMVxuICAgKi9cblxuICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgc3BlZWQ6IDMsXG4gICAgc2NhbGVOb2RlczogMS4yLFxuICAgIG5vZGVNYXJnaW46IDUuMCxcbiAgICBncmlkU2l6ZTogMjAsXG4gICAgcGVybWl0dGVkRXhwYW5zaW9uOiAxLjEsXG4gICAgcmVuZGVyZXJJbmRleDogMCxcbiAgICBtYXhJdGVyYXRpb25zOiA1MDBcbiAgfTtcblxuICB2YXIgX2luc3RhbmNlID0ge307XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZXIgT2JqZWN0XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgdmFyIF9ldmVudEVtaXR0ZXIgPSB7fTtcblxuICAgLyoqXG4gICAqIE5vdmVybGFwIE9iamVjdFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIGZ1bmN0aW9uIE5vdmVybGFwKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChzaWdJbnN0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gUHJvcGVydGllc1xuICAgICAgdGhpcy5zaWdJbnN0ID0gc2lnSW5zdDtcbiAgICAgIHRoaXMuY29uZmlnID0gc2lnbWEudXRpbHMuZXh0ZW5kKG9wdGlvbnMsIHNldHRpbmdzKTtcbiAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG4gICAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblxuICAgICAgaWYgKG9wdGlvbnMubm9kZXMpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG9wdGlvbnMubm9kZXM7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLm5vZGVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNpZ21hLnBsdWdpbnMgfHwgdHlwZW9mIHNpZ21hLnBsdWdpbnMuYW5pbWF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYS5wbHVnaW5zLmFuaW1hdGUgaXMgbm90IGRlY2xhcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXRlXG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2luZ2xlIGxheW91dCBpdGVyYXRpb24uXG4gICAgICovXG4gICAgdGhpcy5hdG9taWNHbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5ydW5uaW5nIHx8IHRoaXMuaXRlckNvdW50IDwgMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzIHx8IHRoaXMuc2lnSW5zdC5ncmFwaC5ub2RlcygpLFxuICAgICAgICAgIG5vZGVzQ291bnQgPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIG4xLFxuICAgICAgICAgIG4yLFxuICAgICAgICAgIHhtaW4gPSBJbmZpbml0eSxcbiAgICAgICAgICB4bWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgIHltaW4gPSBJbmZpbml0eSxcbiAgICAgICAgICB5bWF4ID0gLUluZmluaXR5LFxuICAgICAgICAgIHh3aWR0aCxcbiAgICAgICAgICB5aGVpZ2h0LFxuICAgICAgICAgIHhjZW50ZXIsXG4gICAgICAgICAgeWNlbnRlcixcbiAgICAgICAgICBncmlkLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjb2wsXG4gICAgICAgICAgbWluWEJveCxcbiAgICAgICAgICBtYXhYQm94LFxuICAgICAgICAgIG1pbllCb3gsXG4gICAgICAgICAgbWF4WUJveCxcbiAgICAgICAgICBhZGphY2VudE5vZGVzLFxuICAgICAgICAgIHN1YlJvdyxcbiAgICAgICAgICBzdWJDb2wsXG4gICAgICAgICAgbnhtaW4sXG4gICAgICAgICAgbnhtYXgsXG4gICAgICAgICAgbnltaW4sXG4gICAgICAgICAgbnltYXg7XG5cbiAgICAgIHRoaXMuaXRlckNvdW50LS07XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcbiAgICAgICAgbiA9IG5vZGVzW2ldO1xuICAgICAgICBuLmRuLmR4ID0gMDtcbiAgICAgICAgbi5kbi5keSA9IDA7XG5cbiAgICAgICAgLy9GaW5kIHRoZSBtaW4gYW5kIG1heCBmb3IgYm90aCB4IGFuZCB5IGFjcm9zcyBhbGwgbm9kZXNcbiAgICAgICAgeG1pbiA9IE1hdGgubWluKHhtaW4sIG4uZG5feCAtIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XG4gICAgICAgIHhtYXggPSBNYXRoLm1heCh4bWF4LCBuLmRuX3ggKyAobi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSApO1xuICAgICAgICB5bWluID0gTWF0aC5taW4oeW1pbiwgbi5kbl95IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbikgKTtcbiAgICAgICAgeW1heCA9IE1hdGgubWF4KHltYXgsIG4uZG5feSArIChuLmRuX3NpemUqc2VsZi5jb25maWcuc2NhbGVOb2RlcyArIHNlbGYuY29uZmlnLm5vZGVNYXJnaW4pICk7XG5cbiAgICAgIH1cblxuICAgICAgeHdpZHRoID0geG1heCAtIHhtaW47XG4gICAgICB5aGVpZ2h0ID0geW1heCAtIHltaW47XG4gICAgICB4Y2VudGVyID0gKHhtaW4gKyB4bWF4KSAvIDI7XG4gICAgICB5Y2VudGVyID0gKHltaW4gKyB5bWF4KSAvIDI7XG4gICAgICB4bWluID0geGNlbnRlciAtIHNlbGYuY29uZmlnLnBlcm1pdHRlZEV4cGFuc2lvbip4d2lkdGggLyAyO1xuICAgICAgeG1heCA9IHhjZW50ZXIgKyBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeHdpZHRoIC8gMjtcbiAgICAgIHltaW4gPSB5Y2VudGVyIC0gc2VsZi5jb25maWcucGVybWl0dGVkRXhwYW5zaW9uKnloZWlnaHQgLyAyO1xuICAgICAgeW1heCA9IHljZW50ZXIgKyBzZWxmLmNvbmZpZy5wZXJtaXR0ZWRFeHBhbnNpb24qeWhlaWdodCAvIDI7XG5cbiAgICAgIGdyaWQgPSB7fTsgLy9BbiBvYmplY3Qgb2Ygb2JqZWN0cyB3aGVyZSBncmlkW3Jvd11bY29sXSBpcyBhbiBhcnJheSBvZiBub2RlIGlkcyByZXByZXNlbnRpbmcgbm9kZXMgdGhhdCBmYWxsIGluIHRoYXQgZ3JpZC4gTm9kZXMgY2FuIGZhbGwgaW4gbW9yZSB0aGFuIG9uZSBncmlkXG5cbiAgICAgIGZvcihyb3cgPSAwOyByb3cgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgcm93KyspIHtcbiAgICAgICAgZ3JpZFtyb3ddID0ge307XG4gICAgICAgIGZvcihjb2wgPSAwOyBjb2wgPCBzZWxmLmNvbmZpZy5ncmlkU2l6ZTsgY29sKyspIHtcbiAgICAgICAgICBncmlkW3Jvd11bY29sXSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vUGxhY2Ugbm9kZXMgaW4gZ3JpZFxuICAgICAgZm9yIChpPTA7IGkgPCBub2Rlc0NvdW50OyBpKyspIHtcbiAgICAgICAgbiA9IG5vZGVzW2ldO1xuXG4gICAgICAgIG54bWluID0gbi5kbl94IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbik7XG4gICAgICAgIG54bWF4ID0gbi5kbl94ICsgKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbik7XG4gICAgICAgIG55bWluID0gbi5kbl95IC0gKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbik7XG4gICAgICAgIG55bWF4ID0gbi5kbl95ICsgKG4uZG5fc2l6ZSpzZWxmLmNvbmZpZy5zY2FsZU5vZGVzICsgc2VsZi5jb25maWcubm9kZU1hcmdpbik7XG5cbiAgICAgICAgbWluWEJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueG1pbiAtIHhtaW4pIC8gKHhtYXggLSB4bWluKSApO1xuICAgICAgICBtYXhYQm94ID0gTWF0aC5mbG9vcihzZWxmLmNvbmZpZy5ncmlkU2l6ZSogKG54bWF4IC0geG1pbikgLyAoeG1heCAtIHhtaW4pICk7XG4gICAgICAgIG1pbllCb3ggPSBNYXRoLmZsb29yKHNlbGYuY29uZmlnLmdyaWRTaXplKiAobnltaW4gLSB5bWluKSAvICh5bWF4IC0geW1pbikgKTtcbiAgICAgICAgbWF4WUJveCA9IE1hdGguZmxvb3Ioc2VsZi5jb25maWcuZ3JpZFNpemUqIChueW1heCAtIHltaW4pIC8gKHltYXggLSB5bWluKSApO1xuICAgICAgICBmb3IoY29sID0gbWluWEJveDsgY29sIDw9IG1heFhCb3g7IGNvbCsrKSB7XG4gICAgICAgICAgZm9yKHJvdyA9IG1pbllCb3g7IHJvdyA8PSBtYXhZQm94OyByb3crKykge1xuICAgICAgICAgICAgZ3JpZFtyb3ddW2NvbF0ucHVzaChuLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICBhZGphY2VudE5vZGVzID0ge307IC8vQW4gb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBub2RlIGlkcyBvZiBhZGphY2VudCBub2RlcyAoZWl0aGVyIGluIHNhbWUgZ3JpZCBib3ggb3IgYWRqYWNlbnQgZ3JpZCBib3gpIGZvciBhbGwgbm9kZXNcblxuICAgICAgZm9yKHJvdyA9IDA7IHJvdyA8IHNlbGYuY29uZmlnLmdyaWRTaXplOyByb3crKykge1xuICAgICAgICBmb3IoY29sID0gMDsgY29sIDwgc2VsZi5jb25maWcuZ3JpZFNpemU7IGNvbCsrKSB7XG4gICAgICAgICAgZ3JpZFtyb3ddW2NvbF0uZm9yRWFjaChmdW5jdGlvbihub2RlSWQpIHtcbiAgICAgICAgICAgIGlmKCFhZGphY2VudE5vZGVzW25vZGVJZF0pIHtcbiAgICAgICAgICAgICAgYWRqYWNlbnROb2Rlc1tub2RlSWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3Ioc3ViUm93ID0gTWF0aC5tYXgoMCwgcm93IC0gMSk7IHN1YlJvdyA8PSBNYXRoLm1pbihyb3cgKyAxLCBzZWxmLmNvbmZpZy5ncmlkU2l6ZSAtIDEpOyBzdWJSb3crKykge1xuICAgICAgICAgICAgICBmb3Ioc3ViQ29sID0gTWF0aC5tYXgoMCwgY29sIC0gMSk7IHN1YkNvbCA8PSBNYXRoLm1pbihjb2wgKyAxLCAgc2VsZi5jb25maWcuZ3JpZFNpemUgLSAxKTsgc3ViQ29sKyspIHtcbiAgICAgICAgICAgICAgICBncmlkW3N1YlJvd11bc3ViQ29sXS5mb3JFYWNoKGZ1bmN0aW9uKHN1Yk5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgaWYoc3ViTm9kZUlkICE9PSBub2RlSWQgJiYgYWRqYWNlbnROb2Rlc1tub2RlSWRdLmluZGV4T2Yoc3ViTm9kZUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnROb2Rlc1tub2RlSWRdLnB1c2goc3ViTm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vSWYgdHdvIG5vZGVzIG92ZXJsYXAgdGhlbiByZXB1bHNlIHRoZW1cbiAgICAgIGZvciAoaT0wOyBpIDwgbm9kZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIG4xID0gbm9kZXNbaV07XG4gICAgICAgIGFkamFjZW50Tm9kZXNbbjEuaWRdLmZvckVhY2goZnVuY3Rpb24obm9kZUlkKSB7XG4gICAgICAgICAgdmFyIG4yID0gc2VsZi5zaWdJbnN0LmdyYXBoLm5vZGVzKG5vZGVJZCk7XG4gICAgICAgICAgdmFyIHhEaXN0ID0gbjIuZG5feCAtIG4xLmRuX3g7XG4gICAgICAgICAgdmFyIHlEaXN0ID0gbjIuZG5feSAtIG4xLmRuX3k7XG4gICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoeERpc3QqeERpc3QgKyB5RGlzdCp5RGlzdCk7XG4gICAgICAgICAgdmFyIGNvbGxpc2lvbiA9IChkaXN0IDwgKChuMS5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSArIChuMi5kbl9zaXplKnNlbGYuY29uZmlnLnNjYWxlTm9kZXMgKyBzZWxmLmNvbmZpZy5ub2RlTWFyZ2luKSkpO1xuICAgICAgICAgIGlmKGNvbGxpc2lvbikge1xuICAgICAgICAgICAgc2VsZi5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICAgIG4yLmRuLmR4ICs9IHhEaXN0IC8gZGlzdCAqICgxICsgbjEuZG5fc2l6ZSk7XG4gICAgICAgICAgICAgIG4yLmRuLmR5ICs9IHlEaXN0IC8gZGlzdCAqICgxICsgbjEuZG5fc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuMi5kbi5keCArPSB4d2lkdGggKiAwLjAxICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgICBuMi5kbi5keSArPSB5aGVpZ2h0ICogMC4wMSAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGk9MDsgaSA8IG5vZGVzQ291bnQ7IGkrKykge1xuICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgIGlmKCFuLmZpeGVkKSB7XG4gICAgICAgICAgbi5kbl94ID0gbi5kbl94ICsgbi5kbi5keCAqIDAuMSAqIHNlbGYuY29uZmlnLnNwZWVkO1xuICAgICAgICAgIG4uZG5feSA9IG4uZG5feSArIG4uZG4uZHkgKiAwLjEgKiBzZWxmLmNvbmZpZy5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLnJ1bm5pbmcgJiYgdGhpcy5pdGVyQ291bnQgPCAxKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydW5uaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLmdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pdGVyQ291bnQgPSB0aGlzLmNvbmZpZy5tYXhJdGVyYXRpb25zO1xuXG4gICAgICB3aGlsZSAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuYXRvbWljR28oKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH07XG5cbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nKSByZXR1cm47XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuc2lnSW5zdC5ncmFwaC5ub2RlcygpO1xuXG4gICAgICB2YXIgcHJlZml4ID0gdGhpcy5zaWdJbnN0LnJlbmRlcmVyc1tzZWxmLmNvbmZpZy5yZW5kZXJlckluZGV4XS5vcHRpb25zLnByZWZpeDtcblxuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gSW5pdCBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2Rlc1tpXS5kbl94ID0gbm9kZXNbaV1bcHJlZml4ICsgJ3gnXTtcbiAgICAgICAgbm9kZXNbaV0uZG5feSA9IG5vZGVzW2ldW3ByZWZpeCArICd5J107XG4gICAgICAgIG5vZGVzW2ldLmRuX3NpemUgPSBub2Rlc1tpXVtwcmVmaXggKyAnc2l6ZSddO1xuICAgICAgICBub2Rlc1tpXS5kbiA9IHtcbiAgICAgICAgICBkeDogMCxcbiAgICAgICAgICBkeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX2V2ZW50RW1pdHRlcltzZWxmLnNpZ0luc3QuaWRdLmRpc3BhdGNoRXZlbnQoJ3N0YXJ0Jyk7XG4gICAgICB0aGlzLmdvKCk7XG4gICAgfTtcblxuICAgIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5zaWdJbnN0LmdyYXBoLm5vZGVzKCk7XG5cbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5lYXNpbmcpIHtcbiAgICAgICAgX2V2ZW50RW1pdHRlcltzZWxmLnNpZ0luc3QuaWRdLmRpc3BhdGNoRXZlbnQoJ2ludGVycG9sYXRlJyk7XG4gICAgICAgIHNpZ21hLnBsdWdpbnMuYW5pbWF0ZShcbiAgICAgICAgICBzZWxmLnNpZ0luc3QsXG4gICAgICAgICAge1xuICAgICAgICAgICAgeDogJ2RuX3gnLFxuICAgICAgICAgICAgeTogJ2RuX3knXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlYXNpbmc6IHNlbGYuZWFzaW5nLFxuICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2lnSW5zdC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5kbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uZG5feCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uZG5feSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2V2ZW50RW1pdHRlcltzZWxmLnNpZ0luc3QuaWRdLmRpc3BhdGNoRXZlbnQoJ3N0b3AnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogc2VsZi5kdXJhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBBcHBseSBjaGFuZ2VzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2Rlc1tpXS54ID0gbm9kZXNbaV0uZG5feDtcbiAgICAgICAgICBub2Rlc1tpXS55ID0gbm9kZXNbaV0uZG5feTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnSW5zdC5yZWZyZXNoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzW2ldLmRuID0gbnVsbDtcbiAgICAgICAgICBub2Rlc1tpXS5kbl94ID0gbnVsbDtcbiAgICAgICAgICBub2Rlc1tpXS5kbl95ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBfZXZlbnRFbWl0dGVyW3NlbGYuc2lnSW5zdC5pZF0uZGlzcGF0Y2hFdmVudCgnc3RvcCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmtpbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2lnSW5zdCA9IG51bGw7XG4gICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLmVhc2luZyA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJmYWNlXG4gICAqIC0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgbGF5b3V0IGFsZ29yaXRobS5cblxuICAgKiBSZWNvZ25pemVkIG9wdGlvbnM6XG4gICAqICoqKioqKioqKioqKioqKioqKioqKipcbiAgICogSGVyZSBpcyB0aGUgZXhoYXVzdGl2ZSBsaXN0IG9mIGV2ZXJ5IGFjY2VwdGVkIHBhcmFtZXRlciBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNwZWVkICAgICAgICAgICAgICAgQSBsYXJnZXIgdmFsdWUgaW5jcmVhc2VzIHRoZSBjb252ZXJnZW5jZSBzcGVlZCBhdCB0aGUgY29zdCBvZiBwcmVjaXNpb25cbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBzY2FsZU5vZGVzICAgICAgICAgIFRoZSByYXRpbyB0byBzY2FsZSBub2RlcyBieSAtIGEgbGFyZ2VyIHJhdGlvIHdpbGwgbGVhZCB0byBtb3JlIHNwYWNlIGFyb3VuZCBsYXJnZXIgbm9kZXNcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBub2RlTWFyZ2luICAgICAgICAgIEEgZml4ZWQgbWFyZ2luIHRvIGFwcGx5IGFyb3VuZCBub2RlcyByZWdhcmRsZXNzIG9mIHNpemVcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBtYXhJdGVyYXRpb25zICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0gYmVmb3JlIHRoZSBsYXlvdXQgY29tcGxldGVzLlxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIGdyaWRTaXplICAgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIHRvIHVzZSB3aGVuIHBhcnRpb25pbmcgbm9kZXMgaW50byBhIGdyaWQgZm9yIGVmZmljaWVudCBjb21wdXRhdGlvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHBlcm1pdHRlZEV4cGFuc2lvbiAgQSBwZXJtaXR0ZWQgZXhwYW5zaW9uIGZhY3RvciB0byB0aGUgb3ZlcmFsbCBzaXplIG9mIHRoZSBuZXR3b3JrIGFwcGxpZWQgYXQgZWFjaCBpdGVyYXRpb25cbiAgICogICB7P2ludGVnZXJ9ICAgICAgICAgICByZW5kZXJlckluZGV4ICAgICAgIFRoZSBpbmRleCBvZiB0aGUgcmVuZGVyZXIgdG8gdXNlIGZvciBub2RlIGNvLW9yZGluYXRlcy4gRGVmYXVsdHMgdG8gemVyby5cbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgICAgICAgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhIGZ1bmN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY0luT3V0IGVhc2luZyBmcm9tIHRoaXMgcGFja2FnZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgICAgICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgXCJhbmltYXRpb25zVGltZVwiIHNldHRpbmcgdmFsdWUgb2YgdGhlIHNpZ21hIGluc3RhbmNlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvbmZpZyAgVGhlIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXJ9IFJldHVybnMgYW4gZXZlbnQgZW1pdHRlci5cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5jb25maWdOb3ZlcmxhcCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xuXG4gICAgaWYgKCFjb25maWcpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhcmd1bWVudDogXCJjb25maWdcIicpO1xuXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlIGlmIHVuZGVmaW5lZFxuICAgIGlmICghX2luc3RhbmNlW3NpZ0luc3QuaWRdKSB7XG4gICAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0gPSBuZXcgTm92ZXJsYXAoKTtcblxuICAgICAgX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXSA9IHt9O1xuICAgICAgc2lnbWEuY2xhc3Nlcy5kaXNwYXRjaGVyLmV4dGVuZChfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdKTtcblxuICAgICAgLy8gQmluZGluZyBvbiBraWxsIHRvIGNsZWFyIHRoZSByZWZlcmVuY2VzXG4gICAgICBzaWdJbnN0LmJpbmQoJ2tpbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgX2luc3RhbmNlW3NpZ0luc3QuaWRdLmtpbGwoKTtcbiAgICAgICAgX2luc3RhbmNlW3NpZ0luc3QuaWRdID0gbnVsbDtcbiAgICAgICAgX2V2ZW50RW1pdHRlcltzaWdJbnN0LmlkXSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0uaW5pdChzaWdJbnN0LCBjb25maWcpO1xuXG4gICAgcmV0dXJuIF9ldmVudEVtaXR0ZXJbc2lnSW5zdC5pZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBsYXlvdXQgYWxnb3JpdGhtLiBJdCB3aWxsIHVzZSB0aGUgZXhpc3RpbmcgY29uZmlndXJhdGlvbiBpZiBub1xuICAgKiBuZXcgY29uZmlndXJhdGlvbiBpcyBwYXNzZWQuXG5cbiAgICogUmVjb2duaXplZCBvcHRpb25zOlxuICAgKiAqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIEhlcmUgaXMgdGhlIGV4aGF1c3RpdmUgbGlzdCBvZiBldmVyeSBhY2NlcHRlZCBwYXJhbWV0ZXIgaW4gdGhlIHNldHRpbmdzXG4gICAqIG9iamVjdFxuICAgKlxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHNwZWVkICAgICAgICAgICAgICAgQSBsYXJnZXIgdmFsdWUgaW5jcmVhc2VzIHRoZSBjb252ZXJnZW5jZSBzcGVlZCBhdCB0aGUgY29zdCBvZiBwcmVjaXNpb25cbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBzY2FsZU5vZGVzICAgICAgICAgIFRoZSByYXRpbyB0byBzY2FsZSBub2RlcyBieSAtIGEgbGFyZ2VyIHJhdGlvIHdpbGwgbGVhZCB0byBtb3JlIHNwYWNlIGFyb3VuZCBsYXJnZXIgbm9kZXNcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBub2RlTWFyZ2luICAgICAgICAgIEEgZml4ZWQgbWFyZ2luIHRvIGFwcGx5IGFyb3VuZCBub2RlcyByZWdhcmRsZXNzIG9mIHNpemVcbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBtYXhJdGVyYXRpb25zICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0gYmVmb3JlIHRoZSBsYXlvdXQgY29tcGxldGVzLlxuICAgKiAgIHs/aW50ZWdlcn0gICAgICAgICAgIGdyaWRTaXplICAgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIHRvIHVzZSB3aGVuIHBhcnRpb25pbmcgbm9kZXMgaW50byBhIGdyaWQgZm9yIGVmZmljaWVudCBjb21wdXRhdGlvblxuICAgKiAgIHs/bnVtYmVyfSAgICAgICAgICAgIHBlcm1pdHRlZEV4cGFuc2lvbiAgQSBwZXJtaXR0ZWQgZXhwYW5zaW9uIGZhY3RvciB0byB0aGUgb3ZlcmFsbCBzaXplIG9mIHRoZSBuZXR3b3JrIGFwcGxpZWQgYXQgZWFjaCBpdGVyYXRpb25cbiAgICogICB7P2ludGVnZXJ9ICAgICAgICAgICByZW5kZXJlckluZGV4ICAgICAgIFRoZSBpbmRleCBvZiB0aGUgcmVuZGVyZXIgdG8gdXNlIGZvciBub2RlIGNvLW9yZGluYXRlcy4gRGVmYXVsdHMgdG8gemVyby5cbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgICAgICAgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlIHNpZ21hLnV0aWxzLmVhc2luZ3MgcGFja2FnZSBvciBhIGZ1bmN0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY0luT3V0IGVhc2luZyBmcm9tIHRoaXMgcGFja2FnZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgICAgICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgXCJhbmltYXRpb25zVGltZVwiIHNldHRpbmcgdmFsdWUgb2YgdGhlIHNpZ21hIGluc3RhbmNlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGNvbmZpZyAgVGhlIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzaWdtYS5jbGFzc2VzLmRpc3BhdGNoZXJ9IFJldHVybnMgYW4gZXZlbnQgZW1pdHRlci5cbiAgICovXG5cbiAgc2lnbWEucHJvdG90eXBlLnN0YXJ0Tm92ZXJsYXAgPSBmdW5jdGlvbihjb25maWcpIHtcblxuICAgIHZhciBzaWdJbnN0ID0gdGhpcztcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnTm92ZXJsYXAoc2lnSW5zdCwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBfaW5zdGFuY2Vbc2lnSW5zdC5pZF0uc3RhcnQoKTtcblxuICAgIHJldHVybiBfZXZlbnRFbWl0dGVyW3NpZ0luc3QuaWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBoYXMgc3RhcnRlZCBhbmQgaXMgbm90IGNvbXBsZXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHNpZ21hLnByb3RvdHlwZS5pc05vdmVybGFwUnVubmluZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHNpZ0luc3QgPSB0aGlzO1xuXG4gICAgcmV0dXJuICEhX2luc3RhbmNlW3NpZ0luc3QuaWRdICYmIF9pbnN0YW5jZVtzaWdJbnN0LmlkXS5ydW5uaW5nO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpOyIsIi8qKlxuICogVGhpcyBwbHVnaW4gcHJvdmlkZXMgYSBtZXRob2QgdG8gYW5pbWF0ZSBhIHNpZ21hIGluc3RhbmNlIGJ5IGludGVycG9sYXRpbmdcbiAqIHNvbWUgbm9kZSBwcm9wZXJ0aWVzLiBDaGVjayB0aGUgc2lnbWEucGx1Z2lucy5hbmltYXRlIGZ1bmN0aW9uIGRvYyBvciB0aGVcbiAqIGV4YW1wbGVzL2FuaW1hdGUuaHRtbCBjb2RlIHNhbXBsZSB0byBrbm93IG1vcmUuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2Ygc2lnbWEgPT09ICd1bmRlZmluZWQnKVxuICAgIHRocm93ICdzaWdtYSBpcyBub3QgZGVjbGFyZWQnO1xuXG4gIHNpZ21hLnV0aWxzLnBrZygnc2lnbWEucGx1Z2lucycpO1xuXG4gIHZhciBfaWQgPSAwLFxuICAgICAgX2NhY2hlID0ge307XG5cbiAgLy8gVE9PTElORyBGVU5DVElPTlM6XG4gIC8vICoqKioqKioqKioqKioqKioqKlxuICBmdW5jdGlvbiBwYXJzZUNvbG9yKHZhbCkge1xuICAgIGlmIChfY2FjaGVbdmFsXSlcbiAgICAgIHJldHVybiBfY2FjaGVbdmFsXTtcblxuICAgIHZhciByZXN1bHQgPSBbMCwgMCwgMF07XG5cbiAgICBpZiAodmFsLm1hdGNoKC9eIy8pKSB7XG4gICAgICB2YWwgPSAodmFsIHx8ICcnKS5yZXBsYWNlKC9eIy8sICcnKTtcbiAgICAgIHJlc3VsdCA9ICh2YWwubGVuZ3RoID09PSAzKSA/XG4gICAgICAgIFtcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDApICsgdmFsLmNoYXJBdCgwKSwgMTYpLFxuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMSkgKyB2YWwuY2hhckF0KDEpLCAxNiksXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KVxuICAgICAgICBdIDpcbiAgICAgICAgW1xuICAgICAgICAgIHBhcnNlSW50KHZhbC5jaGFyQXQoMCkgKyB2YWwuY2hhckF0KDEpLCAxNiksXG4gICAgICAgICAgcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMyksIDE2KSxcbiAgICAgICAgICBwYXJzZUludCh2YWwuY2hhckF0KDQpICsgdmFsLmNoYXJBdCg1KSwgMTYpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmICh2YWwubWF0Y2goL14gKnJnYmE/ICpcXCgvKSkge1xuICAgICAgdmFsID0gdmFsLm1hdGNoKFxuICAgICAgICAvXiAqcmdiYT8gKlxcKCAqKFswLTldKikgKiwgKihbMC05XSopICosICooWzAtOV0qKSAqKCwuKik/XFwpICokL1xuICAgICAgKTtcbiAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgK3ZhbFsxXSxcbiAgICAgICAgK3ZhbFsyXSxcbiAgICAgICAgK3ZhbFszXVxuICAgICAgXTtcbiAgICB9XG5cbiAgICBfY2FjaGVbdmFsXSA9IHtcbiAgICAgIHI6IHJlc3VsdFswXSxcbiAgICAgIGc6IHJlc3VsdFsxXSxcbiAgICAgIGI6IHJlc3VsdFsyXVxuICAgIH07XG5cbiAgICByZXR1cm4gX2NhY2hlW3ZhbF07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9ycyhjMSwgYzIsIHApIHtcbiAgICBjMSA9IHBhcnNlQ29sb3IoYzEpO1xuICAgIGMyID0gcGFyc2VDb2xvcihjMik7XG5cbiAgICB2YXIgYyA9IHtcbiAgICAgIHI6IGMxLnIgKiAoMSAtIHApICsgYzIuciAqIHAsXG4gICAgICBnOiBjMS5nICogKDEgLSBwKSArIGMyLmcgKiBwLFxuICAgICAgYjogYzEuYiAqICgxIC0gcCkgKyBjMi5iICogcFxuICAgIH07XG5cbiAgICByZXR1cm4gJ3JnYignICsgW2MuciB8IDAsIGMuZyB8IDAsIGMuYiB8IDBdLmpvaW4oJywnKSArICcpJztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYW5pbWF0ZSBzb21lIHNwZWNpZmllZCBub2RlIHByb3BlcnRpZXMuIEl0IHdpbGxcbiAgICogYmFzaWNhbGx5IGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBpbnRlcnBvbGF0ZSB0aGUgdmFsdWVzIGFuZCBjYWxsIHRoZVxuICAgKiByZWZyZXNoIG1ldGhvZCBkdXJpbmcgYSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBIZXJlIGlzIHRoZSBleGhhdXN0aXZlIGxpc3Qgb2YgZXZlcnkgYWNjZXB0ZWQgcGFyYW1ldGVycyBpbiB0aGUgc2V0dGluZ3NcbiAgICogb2JqZWN0OlxuICAgKlxuICAgKiAgIHs/YXJyYXl9ICAgICAgICAgICAgIG5vZGVzICAgICAgQW4gYXJyYXkgb2Ygbm9kZSBvYmplY3RzIG9yIG5vZGUgaWRzLiBJZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IHNwZWNpZmllZCwgYWxsIG5vZGVzIG9mIHRoZSBncmFwaFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBhbmltYXRlZC5cbiAgICogICB7PyhmdW5jdGlvbnxzdHJpbmcpfSBlYXNpbmcgICAgIEVpdGhlciB0aGUgbmFtZSBvZiBhbiBlYXNpbmcgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzIHBhY2thZ2Ugb3IgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljSW5PdXQgZWFzaW5nIGZyb20gdGhpcyBwYWNrYWdlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICogICB7P251bWJlcn0gICAgICAgICAgICBkdXJhdGlvbiAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiBJZiBub3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgdGhlIFwiYW5pbWF0aW9uc1RpbWVcIiBzZXR0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBvZiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBiZSB1c2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ZWFkLlxuICAgKiAgIHs/ZnVuY3Rpb259ICAgICAgICAgIG9uQ29tcGxldGUgRXZlbnR1YWxseSBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbiBpcyBlbmRlZC5cbiAgICpcbiAgICogQHBhcmFtICB7c2lnbWF9ICAgcyAgICAgICBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgYW5pbWF0ZSBBbiBoYXNoIHdpdGggdGhlIGtleXMgYmVpbmcgdGhlIG5vZGUgcHJvcGVydGllc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGludGVycG9sYXRlLCBhbmQgdGhlIHZhbHVlcyBiZWluZyB0aGUgcmVsYXRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCB2YWx1ZXMuXG4gICAqIEBwYXJhbSAgez9vYmplY3R9IG9wdGlvbnMgRXZlbnR1YWxseSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICAgKi9cbiAgc2lnbWEucGx1Z2lucy5hbmltYXRlID0gZnVuY3Rpb24ocywgYW5pbWF0ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgaWQgPSArK19pZCxcbiAgICAgICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uIHx8IHMuc2V0dGluZ3MoJ2FuaW1hdGlvbnNUaW1lJyksXG4gICAgICAgIGVhc2luZyA9IHR5cGVvZiBvLmVhc2luZyA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIHNpZ21hLnV0aWxzLmVhc2luZ3Nbby5lYXNpbmddIDpcbiAgICAgICAgICB0eXBlb2Ygby5lYXNpbmcgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgIG8uZWFzaW5nIDpcbiAgICAgICAgICBzaWdtYS51dGlscy5lYXNpbmdzLnF1YWRyYXRpY0luT3V0LFxuICAgICAgICBzdGFydCA9IHNpZ21hLnV0aWxzLmRhdGVOb3coKSxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIHN0YXJ0UG9zaXRpb25zO1xuXG4gICAgaWYgKG8ubm9kZXMgJiYgby5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2Ygby5ub2Rlc1swXSA9PT0gJ29iamVjdCcpXG4gICAgICAgIG5vZGVzID0gby5ub2RlcztcbiAgICAgIGVsc2VcbiAgICAgICAgbm9kZXMgPSBzLmdyYXBoLm5vZGVzKG8ubm9kZXMpOyAvLyBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBJRHNcbiAgICB9XG4gICAgZWxzZVxuICAgICAgbm9kZXMgPSBzLmdyYXBoLm5vZGVzKCk7XG5cbiAgICAvLyBTdG9yZSBpbml0aWFsIHBvc2l0aW9uczpcbiAgICBzdGFydFBvc2l0aW9ucyA9IG5vZGVzLnJlZHVjZShmdW5jdGlvbihyZXMsIG5vZGUpIHtcbiAgICAgIHZhciBrO1xuICAgICAgcmVzW25vZGUuaWRdID0ge307XG4gICAgICBmb3IgKGsgaW4gYW5pbWF0ZSlcbiAgICAgICAgaWYgKGsgaW4gbm9kZSlcbiAgICAgICAgICByZXNbbm9kZS5pZF1ba10gPSBub2RlW2tdO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCB7fSk7XG5cbiAgICBzLmFuaW1hdGlvbnMgPSBzLmFuaW1hdGlvbnMgfHwgT2JqZWN0LmNyZWF0ZSh7fSk7XG4gICAgc2lnbWEucGx1Z2lucy5raWxsKHMpO1xuXG4gICAgLy8gRG8gbm90IHJlZnJlc2ggZWRnZXF1YWR0cmVlIGR1cmluZyBkcmFnOlxuICAgIHZhciBrLFxuICAgICAgICBjO1xuICAgIGZvciAoayBpbiBzLmNhbWVyYXMpIHtcbiAgICAgIGMgPSBzLmNhbWVyYXNba107XG4gICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICB2YXIgcCA9IChzaWdtYS51dGlscy5kYXRlTm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbjtcblxuICAgICAgaWYgKHAgPj0gMSkge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGFuaW1hdGUpXG4gICAgICAgICAgICBpZiAoayBpbiBhbmltYXRlKVxuICAgICAgICAgICAgICBub2RlW2tdID0gbm9kZVthbmltYXRlW2tdXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWxsb3cgdG8gcmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICAgIHZhciBrLFxuICAgICAgICAgICAgYztcbiAgICAgICAgZm9yIChrIGluIHMuY2FtZXJhcykge1xuICAgICAgICAgIGMgPSBzLmNhbWVyYXNba107XG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZWZyZXNoKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygby5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIG8ub25Db21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IGVhc2luZyhwKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBhbmltYXRlKVxuICAgICAgICAgICAgaWYgKGsgaW4gYW5pbWF0ZSkge1xuICAgICAgICAgICAgICBpZiAoay5tYXRjaCgvY29sb3IkLykpXG4gICAgICAgICAgICAgICAgbm9kZVtrXSA9IGludGVycG9sYXRlQ29sb3JzKFxuICAgICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbnNbbm9kZS5pZF1ba10sXG4gICAgICAgICAgICAgICAgICBub2RlW2FuaW1hdGVba11dLFxuICAgICAgICAgICAgICAgICAgcFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlW2tdID1cbiAgICAgICAgICAgICAgICAgIG5vZGVbYW5pbWF0ZVtrXV0gKiBwICtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb25zW25vZGUuaWRdW2tdICogKDEgLSBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcy5yZWZyZXNoKCk7XG4gICAgICAgIHMuYW5pbWF0aW9uc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RlcCgpO1xuICB9O1xuXG4gIHNpZ21hLnBsdWdpbnMua2lsbCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBmb3IgKHZhciBrIGluIChzLmFuaW1hdGlvbnMgfHwge30pKVxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocy5hbmltYXRpb25zW2tdKTtcblxuICAgIC8vIEFsbG93IHRvIHJlZnJlc2ggZWRnZXF1YWR0cmVlOlxuICAgIHZhciBrLFxuICAgICAgICBjO1xuICAgIGZvciAoayBpbiBzLmNhbWVyYXMpIHtcbiAgICAgIGMgPSBzLmNhbWVyYXNba107XG4gICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9O1xufSkuY2FsbCh3aW5kb3cpO1xuIiwiLyoqXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBhIG1ldGhvZCB0byBkcmFnICYgZHJvcCBub2Rlcy4gQ2hlY2sgdGhlXG4gKiBzaWdtYS5wbHVnaW5zLmRyYWdOb2RlcyBmdW5jdGlvbiBkb2Mgb3IgdGhlIGV4YW1wbGVzL2Jhc2ljLmh0bWwgJlxuICogZXhhbXBsZXMvYXBpLWNhbmR5Lmh0bWwgY29kZSBzYW1wbGVzIHRvIGtub3cgbW9yZS5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBzaWdtYSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgdGhyb3cgJ3NpZ21hIGlzIG5vdCBkZWNsYXJlZCc7XG5cbiAgc2lnbWEudXRpbHMucGtnKCdzaWdtYS5wbHVnaW5zJyk7XG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGFkZCBgbW91c2Vkb3duYCwgYG1vdXNldXBgICYgYG1vdXNlbW92ZWAgZXZlbnRzIHRvIHRoZVxuICAgKiBub2RlcyBpbiB0aGUgYG92ZXJOb2RlYGV2ZW50IHRvIHBlcmZvcm0gZHJhZyAmIGRyb3Agb3BlcmF0aW9ucy4gSXQgdXNlc1xuICAgKiBgbGluZWFyIGludGVycG9sYXRpb25gIFtodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXVxuICAgKiBhbmQgYHJvdGF0aW9uIG1hdHJpeGAgW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm90YXRpb25fbWF0cml4XSB0b1xuICAgKiBjYWxjdWxhdGUgdGhlIFggYW5kIFkgY29vcmRpbmF0ZXMgZnJvbSB0aGUgYGNhbWAgb3IgYHJlbmRlcmVyYCBub2RlXG4gICAqIGF0dHJpYnV0ZXMuIFRoZXNlIGF0dHJpYnV0ZXMgcmVwcmVzZW50IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbm9kZXMgaW5cbiAgICogdGhlIHJlYWwgY29udGFpbmVyLCBub3QgaW4gY2FudmFzLlxuICAgKlxuICAgKiBGaXJlZCBldmVudHM6XG4gICAqICoqKioqKioqKioqKipcbiAgICogc3RhcnRkcmFnICBGaXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkcmFnLlxuICAgKiBkcmFnICAgICAgIEZpcmVkIHdoaWxlIHRoZSBub2RlIGlzIGRyYWdnZWQuXG4gICAqIGRyb3AgICAgICAgRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgZHJhZyBpZiB0aGUgbm9kZSBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgKiBkcmFnZW5kICAgIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGRyYWcuXG4gICAqXG4gICAqIFJlY29nbml6ZWQgcGFyYW1ldGVyczpcbiAgICogKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gICAgcyAgICAgICAgVGhlIHJlbGF0ZWQgc2lnbWEgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSAge3JlbmRlcmVyfSByZW5kZXJlciBUaGUgcmVsYXRlZCByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIERyYWdOb2RlcyhzLCByZW5kZXJlcikge1xuICAgIHNpZ21hLmNsYXNzZXMuZGlzcGF0Y2hlci5leHRlbmQodGhpcyk7XG5cbiAgICAvLyBBIHF1aWNrIGhhcmRjb2RlZCBydWxlIHRvIHByZXZlbnQgcGVvcGxlIGZyb20gdXNpbmcgdGhpcyBwbHVnaW4gd2l0aCB0aGVcbiAgICAvLyBXZWJHTCByZW5kZXJlciAod2hpY2ggaXMgaW1wb3NzaWJsZSBhdCB0aGUgbW9tZW50KTpcbiAgICAvLyBpZiAoXG4gICAgLy8gICBzaWdtYS5yZW5kZXJlcnMud2ViZ2wgJiZcbiAgICAvLyAgIHJlbmRlcmVyIGluc3RhbmNlb2Ygc2lnbWEucmVuZGVyZXJzLndlYmdsXG4gICAgLy8gKVxuICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vICAgICAnVGhlIHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIFdlYkdMIHJlbmRlcmVyJ1xuICAgIC8vICAgKTtcblxuICAgIC8vIEluaXQgdmFyaWFibGVzOlxuICAgIHZhciBfc2VsZiA9IHRoaXMsXG4gICAgICBfcyA9IHMsXG4gICAgICBfYm9keSA9IGRvY3VtZW50LmJvZHksXG4gICAgICBfcmVuZGVyZXIgPSByZW5kZXJlcixcbiAgICAgIF9tb3VzZSA9IHJlbmRlcmVyLmNvbnRhaW5lci5sYXN0Q2hpbGQsXG4gICAgICBfY2FtZXJhID0gcmVuZGVyZXIuY2FtZXJhLFxuICAgICAgX25vZGUgPSBudWxsLFxuICAgICAgX3ByZWZpeCA9ICcnLFxuICAgICAgX2hvdmVyU3RhY2sgPSBbXSxcbiAgICAgIF9ob3ZlckluZGV4ID0ge30sXG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZSxcbiAgICAgIF9pc01vdXNlT3ZlckNhbnZhcyA9IGZhbHNlLFxuICAgICAgX2RyYWcgPSBmYWxzZTtcblxuICAgIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIHNpZ21hLnJlbmRlcmVycy5zdmcpIHtcbiAgICAgICAgX21vdXNlID0gcmVuZGVyZXIuY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gSXQgcmVtb3ZlcyB0aGUgaW5pdGlhbCBzdWJzdHJpbmcgKCdyZWFkXycpIGlmIGl0J3MgYSBXZWdHTCByZW5kZXJlci5cbiAgICBpZiAocmVuZGVyZXIgaW5zdGFuY2VvZiBzaWdtYS5yZW5kZXJlcnMud2ViZ2wpIHtcbiAgICAgIF9wcmVmaXggPSByZW5kZXJlci5vcHRpb25zLnByZWZpeC5zdWJzdHIoNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wcmVmaXggPSByZW5kZXJlci5vcHRpb25zLnByZWZpeDtcbiAgICB9XG5cbiAgICByZW5kZXJlci5iaW5kKCdvdmVyTm9kZScsIG5vZGVNb3VzZU92ZXIpO1xuICAgIHJlbmRlcmVyLmJpbmQoJ291dE5vZGUnLCB0cmVhdE91dE5vZGUpO1xuICAgIHJlbmRlcmVyLmJpbmQoJ2NsaWNrJywgY2xpY2spO1xuXG4gICAgX3MuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgX3NlbGYudW5iaW5kQWxsKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBVbmJpbmQgYWxsIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICB0aGlzLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX21vdXNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG5vZGVNb3VzZURvd24pO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuICAgICAgX3JlbmRlcmVyLnVuYmluZCgnb3Zlck5vZGUnLCBub2RlTW91c2VPdmVyKTtcbiAgICAgIF9yZW5kZXJlci51bmJpbmQoJ291dE5vZGUnLCB0cmVhdE91dE5vZGUpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZXMgdGhlIGdsb2JhbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQgbW9yZSBhY2N1cmF0ZWx5IHRoYW5cbiAgICAvLyBlbGVtZW50Lm9mZnNldFRvcCBhbmQgZWxlbWVudC5vZmZzZXRMZWZ0LlxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChlbGVtZW50KSB7XG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgIHZhciBnZXRDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCkucmVwbGFjZSgncHgnLCAnJykpIHx8IDA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctbGVmdCcpLFxuICAgICAgICB0b3A6IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgZ2V0Q3NzUHJvcGVydHkoJ3BhZGRpbmctdG9wJylcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XG4gICAgICAvLyBldmVudCB0cmlnZ2VyZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2xpY2tcbiAgICAgIF9pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbm9kZU1vdXNlTW92ZSk7XG4gICAgICBfYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuXG4gICAgICBpZiAoIV9ob3ZlclN0YWNrLmxlbmd0aCkge1xuICAgICAgICBfbm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZU92ZXIoZXZlbnQpIHtcbiAgICAgIC8vIERvbid0IHRyZWF0IHRoZSBub2RlIGlmIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAgaWYgKF9ob3ZlckluZGV4W2V2ZW50LmRhdGEubm9kZS5pZF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgbm9kZSB0byBhcnJheSBvZiBjdXJyZW50IG5vZGVzIG92ZXJcbiAgICAgIF9ob3ZlclN0YWNrLnB1c2goZXZlbnQuZGF0YS5ub2RlKTtcbiAgICAgIF9ob3ZlckluZGV4W2V2ZW50LmRhdGEubm9kZS5pZF0gPSB0cnVlO1xuXG4gICAgICBpZihfaG92ZXJTdGFjay5sZW5ndGggJiYgISBfaXNNb3VzZURvd24pIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IG5vZGUgdG8gYmUgdGhlIGxhc3Qgb25lIGluIHRoZSBhcnJheVxuICAgICAgICBfbm9kZSA9IF9ob3ZlclN0YWNrW19ob3ZlclN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBfbW91c2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyZWF0T3V0Tm9kZShldmVudCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIGFycmF5XG4gICAgICB2YXIgaW5kZXhDaGVjayA9IF9ob3ZlclN0YWNrLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlOyB9KS5pbmRleE9mKGV2ZW50LmRhdGEubm9kZSk7XG4gICAgICBfaG92ZXJTdGFjay5zcGxpY2UoaW5kZXhDaGVjaywgMSk7XG4gICAgICBkZWxldGUgX2hvdmVySW5kZXhbZXZlbnQuZGF0YS5ub2RlLmlkXTtcblxuICAgICAgaWYoX2hvdmVyU3RhY2subGVuZ3RoICYmICEgX2lzTW91c2VEb3duKSB7XG4gICAgICAgIC8vIE9uIG91dCwgc2V0IHRoZSBjdXJyZW50IG5vZGUgdG8gYmUgdGhlIG5leHQgc3RhdGVkIGluIGFycmF5XG4gICAgICAgIF9ub2RlID0gX2hvdmVyU3RhY2tbX2hvdmVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIF9pc01vdXNlRG93biA9IHRydWU7XG4gICAgICB2YXIgc2l6ZSA9IF9zLmdyYXBoLm5vZGVzKCkubGVuZ3RoO1xuXG4gICAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgbm9kZSBpbiB0aGUgZ3JhcGgsIHRoZSBwbHVnaW4gY2Fubm90IGFwcGx5XG4gICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gU28gdHJlYXQgaXQgYXMgaWYgYSB1c2VyIGlzIGRyYWdnaW5nXG4gICAgICAvLyB0aGUgZ3JhcGhcbiAgICAgIGlmIChfbm9kZSAmJiBzaXplID4gMSkge1xuICAgICAgICBfbW91c2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbm9kZU1vdXNlRG93bik7XG4gICAgICAgIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xuICAgICAgICBfYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbm9kZU1vdXNlVXApO1xuXG4gICAgICAgIC8vIERvIG5vdCByZWZyZXNoIGVkZ2VxdWFkdHJlZSBkdXJpbmcgZHJhZzpcbiAgICAgICAgdmFyIGssXG4gICAgICAgICAgICBjO1xuICAgICAgICBmb3IgKGsgaW4gX3MuY2FtZXJhcykge1xuICAgICAgICAgIGMgPSBfcy5jYW1lcmFzW2tdO1xuICAgICAgICAgIGlmIChjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjLmVkZ2VxdWFkdHJlZS5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlYWN0aXZhdGUgZHJhZyBncmFwaC5cbiAgICAgICAgX3JlbmRlcmVyLnNldHRpbmdzKHttb3VzZUVuYWJsZWQ6IGZhbHNlLCBlbmFibGVIb3ZlcmluZzogZmFsc2V9KTtcbiAgICAgICAgX3MucmVmcmVzaCgpO1xuXG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ3N0YXJ0ZHJhZycsIHtcbiAgICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgICBjYXB0b3I6IGV2ZW50LFxuICAgICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG5vZGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICBfaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIF9tb3VzZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBub2RlTW91c2VEb3duKTtcbiAgICAgIF9ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG5vZGVNb3VzZU1vdmUpO1xuICAgICAgX2JvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG5vZGVNb3VzZVVwKTtcblxuICAgICAgLy8gQWxsb3cgdG8gcmVmcmVzaCBlZGdlcXVhZHRyZWU6XG4gICAgICB2YXIgayxcbiAgICAgICAgICBjO1xuICAgICAgZm9yIChrIGluIF9zLmNhbWVyYXMpIHtcbiAgICAgICAgYyA9IF9zLmNhbWVyYXNba107XG4gICAgICAgIGlmIChjLmVkZ2VxdWFkdHJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYy5lZGdlcXVhZHRyZWUuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFjdGl2YXRlIGRyYWcgZ3JhcGguXG4gICAgICBfcmVuZGVyZXIuc2V0dGluZ3Moe21vdXNlRW5hYmxlZDogdHJ1ZSwgZW5hYmxlSG92ZXJpbmc6IHRydWV9KTtcbiAgICAgIF9zLnJlZnJlc2goKTtcblxuICAgICAgaWYgKF9kcmFnKSB7XG4gICAgICAgIF9zZWxmLmRpc3BhdGNoRXZlbnQoJ2Ryb3AnLCB7XG4gICAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgICAgY2FwdG9yOiBldmVudCxcbiAgICAgICAgICByZW5kZXJlcjogX3JlbmRlcmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX3NlbGYuZGlzcGF0Y2hFdmVudCgnZHJhZ2VuZCcsIHtcbiAgICAgICAgbm9kZTogX25vZGUsXG4gICAgICAgIGNhcHRvcjogZXZlbnQsXG4gICAgICAgIHJlbmRlcmVyOiBfcmVuZGVyZXJcbiAgICAgIH0pO1xuXG4gICAgICBfZHJhZyA9IGZhbHNlO1xuICAgICAgX25vZGUgPSBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBub2RlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBpZihuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVPdXQpO1xuICAgICAgICB2YXIgdGltZU91dCA9IHNldFRpbWVvdXQoZXhlY3V0ZU5vZGVNb3VzZU1vdmUsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY3V0ZU5vZGVNb3VzZU1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZU5vZGVNb3VzZU1vdmUoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBjYWxjdWxhdGVPZmZzZXQoX3JlbmRlcmVyLmNvbnRhaW5lciksXG4gICAgICAgICAgICB4ID0gZXZlbnQuY2xpZW50WCAtIG9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgeSA9IGV2ZW50LmNsaWVudFkgLSBvZmZzZXQudG9wLFxuICAgICAgICAgICAgY29zID0gTWF0aC5jb3MoX2NhbWVyYS5hbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihfY2FtZXJhLmFuZ2xlKSxcbiAgICAgICAgICAgIG5vZGVzID0gX3MuZ3JhcGgubm9kZXMoKSxcbiAgICAgICAgICAgIHJlZiA9IFtdO1xuXG4gICAgICAgIC8vIEdldHRpbmcgYW5kIGRlcm90YXRpbmcgdGhlIHJlZmVyZW5jZSBjb29yZGluYXRlcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBhdXggPSB7XG4gICAgICAgICAgICB4OiBuLnggKiBjb3MgKyBuLnkgKiBzaW4sXG4gICAgICAgICAgICB5OiBuLnkgKiBjb3MgLSBuLnggKiBzaW4sXG4gICAgICAgICAgICByZW5YOiBuW19wcmVmaXggKyAneCddLFxuICAgICAgICAgICAgcmVuWTogbltfcHJlZml4ICsgJ3knXSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlZi5wdXNoKGF1eCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseWluZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi5cbiAgICAgICAgLy8gaWYgdGhlIG5vZGVzIGFyZSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgd2UgdXNlIHRoZSBjYW1lcmEgcmF0aW8gdG8gaW50ZXJwb2xhdGVcbiAgICAgICAgaWYgKHJlZlswXS54ID09PSByZWZbMV0ueCAmJiByZWZbMF0ueSA9PT0gcmVmWzFdLnkpIHtcbiAgICAgICAgICB2YXIgeFJhdGlvID0gKHJlZlswXS5yZW5YID09PSAwKSA/IDEgOiByZWZbMF0ucmVuWDtcbiAgICAgICAgICB2YXIgeVJhdGlvID0gKHJlZlswXS5yZW5ZID09PSAwKSA/IDEgOiByZWZbMF0ucmVuWTtcbiAgICAgICAgICB4ID0gKHJlZlswXS54IC8geFJhdGlvKSAqICh4IC0gcmVmWzBdLnJlblgpICsgcmVmWzBdLng7XG4gICAgICAgICAgeSA9IChyZWZbMF0ueSAvIHlSYXRpbykgKiAoeSAtIHJlZlswXS5yZW5ZKSArIHJlZlswXS55O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4UmF0aW8gPSAocmVmWzFdLnJlblggLSByZWZbMF0ucmVuWCkgLyAocmVmWzFdLnggLSByZWZbMF0ueCk7XG4gICAgICAgICAgdmFyIHlSYXRpbyA9IChyZWZbMV0ucmVuWSAtIHJlZlswXS5yZW5ZKSAvIChyZWZbMV0ueSAtIHJlZlswXS55KTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBjb29yZGluYXRlcyBhcmUgdGhlIHNhbWUsIHdlIHVzZSB0aGUgb3RoZXIgcmF0aW8gdG8gaW50ZXJwb2xhdGVcbiAgICAgICAgICBpZiAocmVmWzFdLnggPT09IHJlZlswXS54KSB7XG4gICAgICAgICAgICB4UmF0aW8gPSB5UmF0aW87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlZlsxXS55ID09PSByZWZbMF0ueSkge1xuICAgICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggPSAoeCAtIHJlZlswXS5yZW5YKSAvIHhSYXRpbyArIHJlZlswXS54O1xuICAgICAgICAgIHkgPSAoeSAtIHJlZlswXS5yZW5ZKSAvIHlSYXRpbyArIHJlZlswXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm90YXRpbmcgdGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICBfbm9kZS54ID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICAgIF9ub2RlLnkgPSB5ICogY29zICsgeCAqIHNpbjtcblxuICAgICAgICBfcy5yZWZyZXNoKCk7XG5cbiAgICAgICAgX2RyYWcgPSB0cnVlO1xuICAgICAgICBfc2VsZi5kaXNwYXRjaEV2ZW50KCdkcmFnJywge1xuICAgICAgICAgIG5vZGU6IF9ub2RlLFxuICAgICAgICAgIGNhcHRvcjogZXZlbnQsXG4gICAgICAgICAgcmVuZGVyZXI6IF9yZW5kZXJlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcmZhY2VcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqXG4gICAqID4gdmFyIGRyYWdOb2Rlc0xpc3RlbmVyID0gc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMocywgcy5yZW5kZXJlcnNbMF0pO1xuICAgKi9cbiAgdmFyIF9pbnN0YW5jZSA9IHt9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gcyBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICogQHBhcmFtICB7cmVuZGVyZXJ9IHJlbmRlcmVyIFRoZSByZWxhdGVkIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMgPSBmdW5jdGlvbihzLCByZW5kZXJlcikge1xuICAgIC8vIENyZWF0ZSBvYmplY3QgaWYgdW5kZWZpbmVkXG4gICAgaWYgKCFfaW5zdGFuY2Vbcy5pZF0pIHtcbiAgICAgIF9pbnN0YW5jZVtzLmlkXSA9IG5ldyBEcmFnTm9kZXMocywgcmVuZGVyZXIpO1xuICAgIH1cblxuICAgIHMuYmluZCgna2lsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2lnbWEucGx1Z2lucy5raWxsRHJhZ05vZGVzKHMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9pbnN0YW5jZVtzLmlkXTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGFuZCBraWxscyB0aGUgZHJhZ05vZGVzIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzaWdtYX0gcyBUaGUgcmVsYXRlZCBzaWdtYSBpbnN0YW5jZS5cbiAgICovXG4gIHNpZ21hLnBsdWdpbnMua2lsbERyYWdOb2RlcyA9IGZ1bmN0aW9uKHMpIHtcbiAgICBpZiAoX2luc3RhbmNlW3MuaWRdIGluc3RhbmNlb2YgRHJhZ05vZGVzKSB7XG4gICAgICBfaW5zdGFuY2Vbcy5pZF0udW5iaW5kQWxsKCk7XG4gICAgICBkZWxldGUgX2luc3RhbmNlW3MuaWRdO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh3aW5kb3cpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYXJyYXlzID0gcmVxdWlyZShcIi4vYXJyYXlzXCIpO1xudmFyIExpbmtlZExpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGFuIGVtcHR5IExpbmtlZCBMaXN0LlxuICAgICogQGNsYXNzIEEgbGlua2VkIGxpc3QgaXMgYSBkYXRhIHN0cnVjdHVyZSBjb25zaXN0aW5nIG9mIGEgZ3JvdXAgb2Ygbm9kZXNcbiAgICAqIHdoaWNoIHRvZ2V0aGVyIHJlcHJlc2VudCBhIHNlcXVlbmNlLlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuICAgICAgICAvKipcbiAgICAgICAgKiBGaXJzdCBub2RlIGluIHRoZSBsaXN0XG4gICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAqIExhc3Qgbm9kZSBpbiB0aGUgbGlzdFxuICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbGlzdFxuICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICogQHByaXZhdGVcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uRWxlbWVudHMgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGlzIGxpc3QuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBlbGVtZW50IHRvIGJlIGFkZGVkLlxuICAgICogQHBhcmFtIHtudW1iZXI9fSBpbmRleCBvcHRpb25hbCBpbmRleCB0byBhZGQgdGhlIGVsZW1lbnQuIElmIG5vIGluZGV4IGlzIHNwZWNpZmllZFxuICAgICogdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGlzIGxpc3QuXG4gICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IHdhcyBhZGRlZCBvciBmYWxzZSBpZiB0aGUgaW5kZXggaXMgaW52YWxpZFxuICAgICogb3IgaWYgdGhlIGVsZW1lbnQgaXMgdW5kZWZpbmVkLlxuICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmICh1dGlsLmlzVW5kZWZpbmVkKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLm5FbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5uRWxlbWVudHMgfHwgdXRpbC5pc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5jcmVhdGVOb2RlKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5uRWxlbWVudHMgPT09IDAgfHwgdGhpcy5sYXN0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmlyc3Qgbm9kZSBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLm5FbGVtZW50cykge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGF0IHRoZSBlbmQuXG4gICAgICAgICAgICB0aGlzLmxhc3ROb2RlLm5leHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIC8vIENoYW5nZSBmaXJzdCBub2RlLlxuICAgICAgICAgICAgbmV3Tm9kZS5uZXh0ID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMubm9kZUF0SW5kZXgoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdOb2RlLm5leHQgPSBwcmV2Lm5leHQ7XG4gICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubkVsZW1lbnRzKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgbGlzdC5cbiAgICAqIEByZXR1cm4geyp9IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0IG9yIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBpc1xuICAgICogZW1wdHkuXG4gICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3ROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdE5vZGUuZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhpcyBsaXN0LlxuICAgICogQHJldHVybiB7Kn0gdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgbGlzdCBvciB1bmRlZmluZWQgaWYgdGhlIGxpc3QgaXNcbiAgICAqIGVtcHR5LlxuICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3ROb2RlLmVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpbiB0aGlzIGxpc3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGRlc2lyZWQgaW5kZXguXG4gICAgICogQHJldHVybiB7Kn0gdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5kZXggaXNcbiAgICAgKiBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmVsZW1lbnRBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlQXRJbmRleChpbmRleCk7XG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBpbiB0aGlzIGxpc3Qgb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlXG4gICAgICogc3BlY2lmaWVkIGVsZW1lbnQsIG9yIC0xIGlmIHRoZSBMaXN0IGRvZXMgbm90IGNvbnRhaW4gdGhpcyBlbGVtZW50LlxuICAgICAqIDxwPklmIHRoZSBlbGVtZW50cyBpbnNpZGUgdGhpcyBsaXN0IGFyZVxuICAgICAqIG5vdCBjb21wYXJhYmxlIHdpdGggdGhlID09PSBvcGVyYXRvciBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICogcHJvdmlkZWQgdG8gcGVyZm9ybSBzZWFyY2hlcywgdGhlIGZ1bmN0aW9uIG11c3QgcmVjZWl2ZSB0d28gYXJndW1lbnRzIGFuZFxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgPSBmdW5jdGlvbihwZXQxLCBwZXQyKSB7XG4gICAgICogIHJldHVybiBwZXQxLm5hbWUgPT09IHBldDIubmFtZTtcbiAgICAgKiB9XG4gICAgICogPC9wcmU+XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIE9wdGlvbmFsXG4gICAgICogZnVuY3Rpb24gdXNlZCB0byBjaGVjayBpZiB0d28gZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IGluIHRoaXMgbGlzdCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZVxuICAgICAqIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCwgb3IgLTEgaWYgdGhpcyBsaXN0IGRvZXMgbm90IGNvbnRhaW4gdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBlcXVhbHNGID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgICAgICBpZiAodXRpbC5pc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbHNGKGN1cnJlbnROb2RlLmVsZW1lbnQsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICAgICAgICogPHA+SWYgdGhlIGVsZW1lbnRzIGluc2lkZSB0aGUgbGlzdCBhcmVcbiAgICAgICAqIG5vdCBjb21wYXJhYmxlIHdpdGggdGhlID09PSBvcGVyYXRvciBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICAgKiBwcm92aWRlZCB0byBwZXJmb3JtIHNlYXJjaGVzLCB0aGUgZnVuY3Rpb24gbXVzdCByZWNlaXZlIHR3byBhcmd1bWVudHMgYW5kXG4gICAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGV5IGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBFeGFtcGxlOjwvcD5cbiAgICAgICAqXG4gICAgICAgKiA8cHJlPlxuICAgICAgICogY29uc3QgcGV0c0FyZUVxdWFsQnlOYW1lID0gZnVuY3Rpb24ocGV0MSwgcGV0Mikge1xuICAgICAgICogIHJldHVybiBwZXQxLm5hbWUgPT09IHBldDIubmFtZTtcbiAgICAgICAqIH1cbiAgICAgICAqIDwvcHJlPlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gZWxlbWVudCB0byBzZWFyY2ggZm9yLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gT3B0aW9uYWxcbiAgICAgICAqIGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgaWYgdHdvIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBsaXN0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudCwgZmFsc2VcbiAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbmRleE9mKGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSA+PSAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGluIHRoaXMgbGlzdC5cbiAgICAgKiA8cD5JZiB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZSBsaXN0IGFyZVxuICAgICAqIG5vdCBjb21wYXJhYmxlIHdpdGggdGhlID09PSBvcGVyYXRvciBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICogcHJvdmlkZWQgdG8gcGVyZm9ybSBzZWFyY2hlcywgdGhlIGZ1bmN0aW9uIG11c3QgcmVjZWl2ZSB0d28gYXJndW1lbnRzIGFuZFxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgPSBmdW5jdGlvbihwZXQxLCBwZXQyKSB7XG4gICAgICogIHJldHVybiBwZXQxLm5hbWUgPT09IHBldDIubmFtZTtcbiAgICAgKiB9XG4gICAgICogPC9wcmU+XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gZWxlbWVudCB0byBiZSByZW1vdmVkIGZyb20gdGhpcyBsaXN0LCBpZiBwcmVzZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGxpc3QgY29udGFpbmVkIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIGVxdWFsc0YgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgICAgIGlmICh0aGlzLm5FbGVtZW50cyA8IDEgfHwgdXRpbC5pc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbHNGKGN1cnJlbnROb2RlLmVsZW1lbnQsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMubGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5FbGVtZW50cy0tO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBvZiB0aGUgZWxlbWVudHMgZnJvbSB0aGlzIGxpc3QuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlyc3ROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMubkVsZW1lbnRzID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpc3QgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxpc3QuXG4gICAgICogVHdvIGxpc3RzIGFyZSBlcXVhbCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICogQHBhcmFtIHtMaW5rZWRMaXN0fSBvdGhlciB0aGUgb3RoZXIgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbFxuICAgICAqIGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgaWYgdHdvIGVsZW1lbnRzIGFyZSBlcXVhbC4gSWYgdGhlIGVsZW1lbnRzIGluIHRoZSBsaXN0c1xuICAgICAqIGFyZSBjdXN0b20gb2JqZWN0cyB5b3Ugc2hvdWxkIHByb3ZpZGUgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlXG4gICAgICogdGhlID09PSBvcGVyYXRvciBpcyB1c2VkIHRvIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gZWxlbWVudHMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxpc3QgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxpc3QuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyLCBlcXVhbHNGdW5jdGlvbikge1xuICAgICAgICB2YXIgZXFGID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIExpbmtlZExpc3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSgpICE9PSBvdGhlci5zaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHNBdXgodGhpcy5maXJzdE5vZGUsIG90aGVyLmZpcnN0Tm9kZSwgZXFGKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmVxdWFsc0F1eCA9IGZ1bmN0aW9uIChuMSwgbjIsIGVxRikge1xuICAgICAgICB3aGlsZSAobjEgIT09IG51bGwgJiYgbjIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghZXFGKG4xLmVsZW1lbnQsIG4yLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbjEgPSBuMS5uZXh0O1xuICAgICAgICAgICAgbjIgPSBuMi5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoaXMgbGlzdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggZ2l2ZW4gaW5kZXguXG4gICAgICogQHJldHVybiB7Kn0gcmVtb3ZlZCBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVFbGVtZW50QXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMubkVsZW1lbnRzIHx8IHRoaXMuZmlyc3ROb2RlID09PSBudWxsIHx8IHRoaXMubGFzdE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLm5FbGVtZW50cyA9PT0gMSkge1xuICAgICAgICAgICAgLy9GaXJzdCBub2RlIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuZmlyc3ROb2RlLmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMubm9kZUF0SW5kZXgoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmZpcnN0Tm9kZS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3ROb2RlID0gdGhpcy5maXJzdE5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZXZpb3VzLm5leHQgPT09IHRoaXMubGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5sYXN0Tm9kZS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdE5vZGUgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAhPT0gbnVsbCAmJiBwcmV2aW91cy5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHByZXZpb3VzLm5leHQuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gcHJldmlvdXMubmV4dC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubkVsZW1lbnRzLS07XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoaXMgbGlzdCBpbiBvcmRlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6Kn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgaXQgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiB0aGUgZWxlbWVudCB2YWx1ZSwgdG8gYnJlYWsgdGhlIGl0ZXJhdGlvbiB5b3UgY2FuXG4gICAgICogb3B0aW9uYWxseSByZXR1cm4gZmFsc2UuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmZpcnN0Tm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soY3VycmVudE5vZGUuZWxlbWVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIHRoZSBvcmRlciBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBsaW5rZWQgbGlzdCAobWFrZXMgdGhlIGxhc3RcbiAgICAgKiBlbGVtZW50IGZpcnN0LCBhbmQgdGhlIGZpcnN0IGVsZW1lbnQgbGFzdCkuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmZpcnN0Tm9kZTtcbiAgICAgICAgdmFyIHRlbXAgPSBudWxsO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICAgICAgY3VycmVudCA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB0aGlzLmZpcnN0Tm9kZSA9IHRoaXMubGFzdE5vZGU7XG4gICAgICAgIHRoaXMubGFzdE5vZGUgPSB0ZW1wO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBsaXN0IGluIHByb3BlclxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjwqPn0gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoaXMgbGlzdCxcbiAgICAgKiBpbiBwcm9wZXIgc2VxdWVuY2UuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuZmlyc3ROb2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2goY3VycmVudE5vZGUuZWxlbWVudCk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoaXMgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhpcyBsaXN0LlxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5FbGVtZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgbm8gZWxlbWVudHMuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGxpc3QgY29udGFpbnMgbm8gZWxlbWVudHMuXG4gICAgICovXG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubkVsZW1lbnRzIDw9IDA7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5cy50b1N0cmluZyh0aGlzLnRvQXJyYXkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLm5vZGVBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5uRWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gKHRoaXMubkVsZW1lbnRzIC0gMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3ROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5maXJzdE5vZGU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXggJiYgbm9kZSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogaXRlbSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTsgLy8gRW5kIG9mIGxpbmtlZCBsaXN0XG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rZWRMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlua2VkTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaW5rZWRMaXN0XzEgPSByZXF1aXJlKFwiLi9MaW5rZWRMaXN0XCIpO1xudmFyIFF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgcXVldWUuXG4gICAgICogQGNsYXNzIEEgcXVldWUgaXMgYSBGaXJzdC1Jbi1GaXJzdC1PdXQgKEZJRk8pIGRhdGEgc3RydWN0dXJlLCB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGFkZGVkIHRvIHRoZSBxdWV1ZSB3aWxsIGJlIHRoZSBmaXJzdCBvbmUgdG8gYmUgcmVtb3ZlZC4gVGhpc1xuICAgICAqIGltcGxlbWVudGF0aW9uIHVzZXMgYSBsaW5rZWQgbGlzdCBhcyBhIGNvbnRhaW5lci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IExpbmtlZExpc3RfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGludG8gdGhlIGVuZCBvZiB0aGlzIHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIHRoZSBlbGVtZW50IHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IHdhcyBpbnNlcnRlZCwgb3IgZmFsc2UgaWYgaXQgaXMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5hZGQoZWxlbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBpbnRvIHRoZSBlbmQgb2YgdGhpcyBxdWV1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSB0aGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCB3YXMgaW5zZXJ0ZWQsIG9yIGZhbHNlIGlmIGl0IGlzIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5hZGQoZWxlbSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW5kIHJlbW92ZXMgdGhlIGhlYWQgb2YgdGhpcyBxdWV1ZS5cbiAgICAgKiBAcmV0dXJuIHsqfSB0aGUgaGVhZCBvZiB0aGlzIHF1ZXVlLCBvciB1bmRlZmluZWQgaWYgdGhpcyBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBRdWV1ZS5wcm90b3R5cGUuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdC5zaXplKCkgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMubGlzdC5maXJzdCgpO1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZUVsZW1lbnRBdEluZGV4KDApO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMsIGJ1dCBkb2VzIG5vdCByZW1vdmUsIHRoZSBoZWFkIG9mIHRoaXMgcXVldWUuXG4gICAgICogQHJldHVybiB7Kn0gdGhlIGhlYWQgb2YgdGhpcyBxdWV1ZSwgb3IgdW5kZWZpbmVkIGlmIHRoaXMgcXVldWUgaXMgZW1wdHkuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3Quc2l6ZSgpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0LmZpcnN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGlzIHF1ZXVlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGlzIHF1ZXVlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LnNpemUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHF1ZXVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICAgKiA8cD5JZiB0aGUgZWxlbWVudHMgaW5zaWRlIHRoaXMgc3RhY2sgYXJlXG4gICAgICogbm90IGNvbXBhcmFibGUgd2l0aCB0aGUgPT09IG9wZXJhdG9yLCBhIGN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gc2hvdWxkIGJlXG4gICAgICogcHJvdmlkZWQgdG8gcGVyZm9ybSBzZWFyY2hlcywgdGhlIGZ1bmN0aW9uIG11c3QgcmVjZWl2ZSB0d28gYXJndW1lbnRzIGFuZFxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuIEV4YW1wbGU6PC9wPlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiBjb25zdCBwZXRzQXJlRXF1YWxCeU5hbWUgKHBldDEsIHBldDIpIHtcbiAgICAgKiAgcmV0dXJuIHBldDEubmFtZSA9PT0gcGV0Mi5uYW1lO1xuICAgICAqIH1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbSBlbGVtZW50IHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWxcbiAgICAgKiBmdW5jdGlvbiB0byBjaGVjayBpZiB0d28gZWxlbWVudHMgYXJlIGVxdWFsLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBxdWV1ZSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChlbGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmNvbnRhaW5zKGVsZW0sIGVxdWFsc0Z1bmN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYW5kIG9ubHkgaWYgdGhpcyBxdWV1ZSBjb250YWlucyBubyBpdGVtczsgZmFsc2VcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgUXVldWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3Quc2l6ZSgpIDw9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBvZiB0aGUgZWxlbWVudHMgZnJvbSB0aGlzIHF1ZXVlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0LmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnQgaW4gdGhpcyBxdWV1ZSBpblxuICAgICAqIEZJRk8gb3JkZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpOip9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUsIGl0IGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogdGhlIGVsZW1lbnQgdmFsdWUsIHRvIGJyZWFrIHRoZSBpdGVyYXRpb24geW91IGNhblxuICAgICAqIG9wdGlvbmFsbHkgcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIFF1ZXVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBRdWV1ZTtcbn0oKSk7IC8vIEVuZCBvZiBxdWV1ZVxuZXhwb3J0cy5kZWZhdWx0ID0gUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWV1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBpdGVtXG4gKiB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheS40XG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSBpbiB3aGljaCB0byBzZWFyY2ggdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSB0aGUgZWxlbWVudCB0byBzZWFyY2guXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbCBmdW5jdGlvbiB1c2VkIHRvXG4gKiBjaGVjayBlcXVhbGl0eSBiZXR3ZWVuIDIgZWxlbWVudHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcbiAqIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGFycmF5LCBvciAtMSBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKSB7XG4gICAgdmFyIGVxdWFscyA9IGVxdWFsc0Z1bmN0aW9uIHx8IHV0aWwuZGVmYXVsdEVxdWFscztcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFscyhhcnJheVtpXSwgaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG4vKipcbiAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50XG4gKiB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gYXJyYXkgdGhlIGFycmF5IGluIHdoaWNoIHRvIHNlYXJjaCB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHRoZSBlbGVtZW50IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50XG4gKiB3aXRoaW4gdGhlIHNwZWNpZmllZCBhcnJheSBvciAtMSBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBlcXVhbHMgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGVxdWFscyhhcnJheVtpXSwgaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydHMubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBhcnJheSB0aGUgYXJyYXkgaW4gd2hpY2ggdG8gc2VhcmNoIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gdGhlIGVsZW1lbnQgdG8gc2VhcmNoLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsT2JqZWN0KTpib29sZWFuPX0gZXF1YWxzRnVuY3Rpb24gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBhcnJheSBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHJldHVybiBpbmRleE9mKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikgPj0gMDtcbn1cbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcbi8qKlxuICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2N1cnJlbmNlIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoZSBzcGVjaWZpZWQgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSBpbiB3aGljaCB0byBzZWFyY2ggZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHRoZSBlbGVtZW50IHRvIHNlYXJjaC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gKiBjaGVjayBlcXVhbGl0eSBiZXR3ZWVuIDIgZWxlbWVudHMuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcnJheSBjaGFuZ2VkIGFmdGVyIHRoaXMgY2FsbC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IGluZGV4T2YoYXJyYXksIGl0ZW0sIGVxdWFsc0Z1bmN0aW9uKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCBhcnJheSBlcXVhbFxuICogdG8gdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSB0aGUgYXJyYXkgaW4gd2hpY2ggdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY3kgb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gaXRlbSB0aGUgZWxlbWVudCB3aG9zZSBmcmVxdWVuY3kgaXMgdG8gYmUgZGV0ZXJtaW5lZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LE9iamVjdCk6Ym9vbGVhbj19IGVxdWFsc0Z1bmN0aW9uIG9wdGlvbmFsIGZ1bmN0aW9uIHVzZWQgdG9cbiAqIGNoZWNrIGVxdWFsaXR5IGJldHdlZW4gMiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIGFycmF5XG4gKiBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZnJlcXVlbmN5KGFycmF5LCBpdGVtLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHZhciBlcXVhbHMgPSBlcXVhbHNGdW5jdGlvbiB8fCB1dGlsLmRlZmF1bHRFcXVhbHM7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgZnJlcSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzKGFycmF5W2ldLCBpdGVtKSkge1xuICAgICAgICAgICAgZnJlcSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmVxO1xufVxuZXhwb3J0cy5mcmVxdWVuY3kgPSBmcmVxdWVuY3k7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIHNwZWNpZmllZCBhcnJheXMgYXJlIGVxdWFsIHRvIG9uZSBhbm90aGVyLlxuICogVHdvIGFycmF5cyBhcmUgY29uc2lkZXJlZCBlcXVhbCBpZiBib3RoIGFycmF5cyBjb250YWluIHRoZSBzYW1lIG51bWJlclxuICogb2YgZWxlbWVudHMsIGFuZCBhbGwgY29ycmVzcG9uZGluZyBwYWlycyBvZiBlbGVtZW50cyBpbiB0aGUgdHdvXG4gKiBhcnJheXMgYXJlIGVxdWFsIGFuZCBhcmUgaW4gdGhlIHNhbWUgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheTEgb25lIGFycmF5IHRvIGJlIHRlc3RlZCBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheTIgdGhlIG90aGVyIGFycmF5IHRvIGJlIHRlc3RlZCBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCxPYmplY3QpOmJvb2xlYW49fSBlcXVhbHNGdW5jdGlvbiBvcHRpb25hbCBmdW5jdGlvbiB1c2VkIHRvXG4gKiBjaGVjayBlcXVhbGl0eSBiZXR3ZWVuIGVsZW1lbWVudHMgaW4gdGhlIGFycmF5cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhcnJheTEsIGFycmF5MiwgZXF1YWxzRnVuY3Rpb24pIHtcbiAgICB2YXIgZXF1YWxzID0gZXF1YWxzRnVuY3Rpb24gfHwgdXRpbC5kZWZhdWx0RXF1YWxzO1xuICAgIGlmIChhcnJheTEubGVuZ3RoICE9PSBhcnJheTIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5MS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFscyhhcnJheTFbaV0sIGFycmF5MltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxzID0gZXF1YWxzO1xuLyoqXG4gKiBSZXR1cm5zIHNoYWxsb3cgYSBjb3B5IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFycmF5IHRoZSBhcnJheSB0byBjb3B5LlxuICogQHJldHVybiB7QXJyYXl9IGEgY29weSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvcHkoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuY29uY2F0KCk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuLyoqXG4gKiBTd2FwcyB0aGUgZWxlbWVudHMgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbnMgaW4gdGhlIHNwZWNpZmllZCBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBpbiB3aGljaCB0byBzd2FwIGVsZW1lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IGkgdGhlIGluZGV4IG9mIG9uZSBlbGVtZW50IHRvIGJlIHN3YXBwZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaiB0aGUgaW5kZXggb2YgdGhlIG90aGVyIGVsZW1lbnQgdG8gYmUgc3dhcHBlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFycmF5IGlzIGRlZmluZWQgYW5kIHRoZSBpbmRleGVzIGFyZSB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnJheSwgaSwgaikge1xuICAgIGlmIChpIDwgMCB8fCBpID49IGFycmF5Lmxlbmd0aCB8fCBqIDwgMCB8fCBqID49IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICBhcnJheVtqXSA9IHRlbXA7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLnN3YXAgPSBzd2FwO1xuZnVuY3Rpb24gdG9TdHJpbmcoYXJyYXkpIHtcbiAgICByZXR1cm4gJ1snICsgYXJyYXkudG9TdHJpbmcoKSArICddJztcbn1cbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoaXMgYXJyYXlcbiAqIHN0YXJ0aW5nIGZyb20gaW5kZXggMCB0byBsZW5ndGggLSAxLlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IGluIHdoaWNoIHRvIGl0ZXJhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6Kn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSwgaXQgaXNcbiAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6IHRoZSBlbGVtZW50IHZhbHVlLCB0byBicmVhayB0aGUgaXRlcmF0aW9uIHlvdSBjYW5cbiAqIG9wdGlvbmFsbHkgcmV0dXJuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGFycmF5LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyYXlfMSA9IGFycmF5OyBfaSA8IGFycmF5XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhcnJheV8xW19pXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGVsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXlzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5leHBvcnRzLmhhcyA9IGZ1bmN0aW9uIChvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn07XG4vKipcbiAqIERlZmF1bHQgZnVuY3Rpb24gdG8gY29tcGFyZSBlbGVtZW50IG9yZGVyLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0Q29tcGFyZSA9IGRlZmF1bHRDb21wYXJlO1xuLyoqXG4gKiBEZWZhdWx0IGZ1bmN0aW9uIHRvIHRlc3QgZXF1YWxpdHkuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5leHBvcnRzLmRlZmF1bHRFcXVhbHMgPSBkZWZhdWx0RXF1YWxzO1xuLyoqXG4gKiBEZWZhdWx0IGZ1bmN0aW9uIHRvIGNvbnZlcnQgYW4gb2JqZWN0IHRvIGEgc3RyaW5nLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUb1N0cmluZyhpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdDT0xMRUNUSU9OX05VTEwnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1VuZGVmaW5lZChpdGVtKSkge1xuICAgICAgICByZXR1cm4gJ0NPTExFQ1RJT05fVU5ERUZJTkVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuICckcycgKyBpdGVtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICckbycgKyBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0VG9TdHJpbmcgPSBkZWZhdWx0VG9TdHJpbmc7XG4vKipcbiogSm9pbnMgYWxsIHRoZSBwcm9wZXJpZXMgb2YgdGhlIG9iamVjdCB1c2luZyB0aGUgcHJvdmlkZWQgam9pbiBzdHJpbmdcbiovXG5mdW5jdGlvbiBtYWtlU3RyaW5nKGl0ZW0sIGpvaW4pIHtcbiAgICBpZiAoam9pbiA9PT0gdm9pZCAwKSB7IGpvaW4gPSAnLCc7IH1cbiAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ0NPTExFQ1RJT05fTlVMTCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiAnQ09MTEVDVElPTl9VTkRFRklORUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyhpdGVtKSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRvcmV0ID0gJ3snO1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLmhhcyhpdGVtLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9yZXQgPSB0b3JldCArIGpvaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvcmV0ID0gdG9yZXQgKyBwcm9wICsgJzonICsgaXRlbVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9yZXQgKyAnfSc7XG4gICAgfVxufVxuZXhwb3J0cy5tYWtlU3RyaW5nID0gbWFrZVN0cmluZztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiAodHlwZW9mIGZ1bmMpID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyB1bmRlZmluZWQuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqKSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYSBzdHJpbmcuXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbi8qKlxuICogUmV2ZXJzZXMgYSBjb21wYXJlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VDb21wYXJlRnVuY3Rpb24oY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGNvbXBhcmVGdW5jdGlvbikgfHwgIWlzRnVuY3Rpb24oY29tcGFyZUZ1bmN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUZ1bmN0aW9uKGQsIHYpICogLTE7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5yZXZlcnNlQ29tcGFyZUZ1bmN0aW9uID0gcmV2ZXJzZUNvbXBhcmVGdW5jdGlvbjtcbi8qKlxuICogUmV0dXJucyBhbiBlcXVhbCBmdW5jdGlvbiBnaXZlbiBhIGNvbXBhcmUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29tcGFyZVRvRXF1YWxzKGNvbXBhcmVGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyZUZ1bmN0aW9uKGEsIGIpID09PSAwO1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBhcmVUb0VxdWFscyA9IGNvbXBhcmVUb0VxdWFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiaW1wb3J0IFF1ZXVlIGZyb20gXCJ0eXBlc2NyaXB0LWNvbGxlY3Rpb25zL2Rpc3QvbGliL1F1ZXVlXCI7XG5pbXBvcnQge2lzVW5kZWZpbmVkfSBmcm9tIFwidHlwZXNjcmlwdC1jb2xsZWN0aW9ucy9kaXN0L2xpYi91dGlsXCI7XG5sZXQgc2lnbWEgPSByZXF1aXJlKCdzaWdtYScpO1xuKDxhbnk+d2luZG93KS5zaWdtYSA9IHNpZ21hO1xucmVxdWlyZSgnc2lnbWEvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmRyYWdOb2Rlcy9zaWdtYS5wbHVnaW5zLmRyYWdOb2RlcycpO1xucmVxdWlyZSgnc2lnbWEvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmFuaW1hdGUvc2lnbWEucGx1Z2lucy5hbmltYXRlJyk7XG5yZXF1aXJlKCdzaWdtYS9wbHVnaW5zL3NpZ21hLmxheW91dC5ub3ZlcmxhcC9zaWdtYS5sYXlvdXQubm92ZXJsYXAnKTtcblxuZXhwb3J0IGVudW0gU3RhdHVzIHtcbiAgICBSVU5OSU5HLFxuICAgIFNVQ0NFU1MsXG4gICAgRkFJTFVSRVxufVxuXG5mdW5jdGlvbiB0ZXJtaW5hdGVBbmRSZXR1cm4oaWQ6IG51bWJlciwgYmxhY2tib2FyZDogYW55LCBzdGF0dXM6IFN0YXR1cykge1xuICAgIGRlbGV0ZSBibGFja2JvYXJkW2lkXTtcbiAgICByZXR1cm4gc3RhdHVzO1xufVxuXG5leHBvcnQgdHlwZSBFZmZlY3QgPSAoKSA9PiB2b2lkXG5leHBvcnQgdHlwZSBQcmVjb25kaXRpb24gPSAoKSA9PiBib29sZWFuXG5leHBvcnQgdHlwZSBUaWNrID0gKCkgPT4gU3RhdHVzXG5leHBvcnQgdHlwZSBBY3Rpb25UaWNrID0gKHByZWNvbmRpdGlvbjogUHJlY29uZGl0aW9uLCBlZmZlY3Q6IEVmZmVjdCwgdGlja3NSZXF1aXJlZD86IG51bWJlcikgPT4gVGlja1xuLyoqXG4gKiBUaGUgZ3VhcmQgdGljayBpcyB0byBhZGQgYSBwcmVjb25kaXRpb24gdG8gdGhlIGNvbXBvc2l0ZSB0aWNrc1xuICovXG5leHBvcnQgdHlwZSBHdWFyZFRpY2sgPSAocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGFzdFRpY2s6IFRpY2ssIG5lZ2F0ZT86IGJvb2xlYW4pID0+IFRpY2tcbi8qKlxuICogU2VxdWVuY2UvU2VsZWN0b3JcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcG9zaXRlVGljayA9IChhc3RUaWNrczogVGlja1tdKSA9PiBUaWNrXG5cbnZhciBibGFja2JvYXJkID0ge307XG5cbmZ1bmN0aW9uIGdldEFjdGlvblRpY2soaWQ6IG51bWJlcik6IEFjdGlvblRpY2sge1xuICAgIHJldHVybiAocHJlY29uZGl0aW9uLCBlZmZlY3QsIHRpY2tzUmVxdWlyZWQgPSAxKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlY29uZGl0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJsYWNrYm9hcmRbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdLnRpY2tzRG9uZSA9IHRpY2tzUmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJsYWNrYm9hcmRbaWRdLnRpY2tzRG9uZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0udGlja3NEb25lLS07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdGF0dXMuUlVOTklORztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmF0ZUFuZFJldHVybihpZCwgYmxhY2tib2FyZCwgU3RhdHVzLlNVQ0NFU1MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1cy5GQUlMVVJFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRHdWFyZFRpY2soKTogR3VhcmRUaWNrIHtcbiAgICByZXR1cm4gKHByZWNvbmRpdGlvbiwgYXN0VGljaywgbmVnYXRlID0gZmFsc2UpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9jZWVkID0gbmVnYXRlID8gIXByZWNvbmRpdGlvbigpIDogcHJlY29uZGl0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2VlZCA/IGV4ZWN1dGUoYXN0VGljaykgOiBTdGF0dXMuRkFJTFVSRTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2VxdWVuY2VUaWNrKGlkOiBudW1iZXIpOiBDb21wb3NpdGVUaWNrIHtcbiAgICByZXR1cm4gKGFzdFRpY2tzKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWJsYWNrYm9hcmRbaWRdKSB7XG4gICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAoYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4IDwgYXN0VGlja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkU3RhdHVzID0gZXhlY3V0ZShhc3RUaWNrc1tibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXhdKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZFN0YXR1cyA9PSBTdGF0dXMuUlVOTklORylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0YXR1cy5SVU5OSU5HO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkU3RhdHVzID09IFN0YXR1cy5GQUlMVVJFKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVybWluYXRlQW5kUmV0dXJuKGlkLCBibGFja2JvYXJkLCBTdGF0dXMuRkFJTFVSRSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRTdGF0dXMgPT0gU3RhdHVzLlNVQ0NFU1MpXG4gICAgICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlcm1pbmF0ZUFuZFJldHVybihpZCwgYmxhY2tib2FyZCwgU3RhdHVzLlNVQ0NFU1MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3RvclRpY2soaWQ6IG51bWJlcik6IENvbXBvc2l0ZVRpY2sge1xuICAgIHJldHVybiAoYXN0VGlja3MpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxhY2tib2FyZFtpZF0pIHtcbiAgICAgICAgICAgICAgICBibGFja2JvYXJkW2lkXSA9IHt9O1xuICAgICAgICAgICAgICAgIGJsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChibGFja2JvYXJkW2lkXS5jdXJyZW50SW5kZXggPCBhc3RUaWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTdGF0dXMgPSBleGVjdXRlKGFzdFRpY2tzW2JsYWNrYm9hcmRbaWRdLmN1cnJlbnRJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkU3RhdHVzID09IFN0YXR1cy5SVU5OSU5HKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RhdHVzLlJVTk5JTkc7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRTdGF0dXMgPT0gU3RhdHVzLlNVQ0NFU1MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXJtaW5hdGVBbmRSZXR1cm4oaWQsIGJsYWNrYm9hcmQsIFN0YXR1cy5TVUNDRVNTKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFN0YXR1cyA9PSBTdGF0dXMuRkFJTFVSRSlcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tib2FyZFtpZF0uY3VycmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVybWluYXRlQW5kUmV0dXJuKGlkLCBibGFja2JvYXJkLCBTdGF0dXMuRkFJTFVSRSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlKGFzdFRpY2s6IFRpY2spOiBTdGF0dXMge1xuICAgIHJldHVybiBhc3RUaWNrKCk7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gYWN0aW9uKHByZWNvbmRpdGlvbjogUHJlY29uZGl0aW9uLCBlZmZlY3Q6IEVmZmVjdCwgdGlja3NSZXF1aXJlZD86IG51bWJlcik6IFRpY2sge1xuICAgIHJldHVybiBnZXRBY3Rpb25UaWNrKGdsb2JhbElkQ291bnRlcisrKShwcmVjb25kaXRpb24sIGVmZmVjdCwgdGlja3NSZXF1aXJlZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGd1YXJkKHByZWNvbmRpdGlvbjogUHJlY29uZGl0aW9uLCBhc3RUaWNrOiBUaWNrKTogVGljayB7XG4gICAgcmV0dXJuIGdldEd1YXJkVGljaygpKHByZWNvbmRpdGlvbiwgYXN0VGljayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWdfZ3VhcmQocHJlY29uZGl0aW9uOiBQcmVjb25kaXRpb24sIGFzdFRpY2s6IFRpY2spOiBUaWNrIHtcbiAgICByZXR1cm4gZ2V0R3VhcmRUaWNrKCkocHJlY29uZGl0aW9uLCBhc3RUaWNrLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBDeWNsZXMgb3ZlciBpdHMgY2hpbGRyZW46IGl0ZXJhdGVzIHRvIHRoZSBuZXh0IGNoaWxkIG9uIHN1Y2Nlc3Mgb2YgYSBjaGlsZFxuICogU3VjY2VlZHMgaWYgYWxsIHN1Y2NlZWQsIGVsc2UgZmFpbHNcbiAqIEBwYXJhbSB7VGlja1tdfSBhc3RUaWNrc1xuICogQHJldHVybnMge1RpY2t9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW5jZShhc3RUaWNrczogVGlja1tdKTogVGljayB7XG4gICAgcmV0dXJuIGdldFNlcXVlbmNlVGljayhnbG9iYWxJZENvdW50ZXIrKykoYXN0VGlja3MpO1xufVxuXG4vKipcbiAqIEN5Y2xlcyBvdmVyIGl0cyBjaGlsZHJlbjogaXRlcmF0ZXMgdG8gdGhlIG5leHQgY2hpbGQgb24gZmFpbHVyZSBvZiBhIGNoaWxkKHRoaW5rIG9mIGl0IGFzIGlmLWVsc2UgYmxvY2tzKVxuICogU3VjY2VlZHMgaWYgZXZlbiBvbmUgc3VjY2VlZHMsIGVsc2UgZmFpbHNcbiAqIEBwYXJhbSB7VGlja1tdfSBhc3RUaWNrc1xuICogQHJldHVybnMge1RpY2t9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rvcihhc3RUaWNrczogVGlja1tdKTogVGljayB7XG4gICAgcmV0dXJuIGdldFNlbGVjdG9yVGljayhnbG9iYWxJZENvdW50ZXIrKykoYXN0VGlja3MpO1xufVxuXG5cbi8qLS0tLS0tLS0tLS0tLS0tIEFQSXMgLS0tLS0tLS0tLS0tLS0tICovXG5cblxuLy8wLiB1dGlsaXRpZXNcbi8vIG1pbiBhbmQgbWF4IGFyZSBpbmNsdXNpdmVcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kTnVtYmVyKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG59XG5cbi8vMS4gc3RvcnkgaW5zdGFuY2VcblxuLy8xLjEgbG9jYXRpb25zXG5leHBvcnQgdmFyIGxvY2F0aW9uR3JhcGggPSB7fTtcblxuLy9hZGQgdG8gYm90aCBzaWRlc1xuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2F0aW9uKGxvY2F0aW9uTmFtZTogc3RyaW5nLCBhZGphY2VudExvY2F0aW9uczogc3RyaW5nW10pIHtcbiAgICBpZiAobG9jYXRpb25HcmFwaFtsb2NhdGlvbk5hbWVdID09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhdGlvbkdyYXBoW2xvY2F0aW9uTmFtZV0gPSBbXTtcbiAgICB9XG4gICAgbG9jYXRpb25HcmFwaFtsb2NhdGlvbk5hbWVdID0gbG9jYXRpb25HcmFwaFtsb2NhdGlvbk5hbWVdLmNvbmNhdChhZGphY2VudExvY2F0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkamFjZW50TG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbkdyYXBoW2FkamFjZW50TG9jYXRpb25zW2ldXSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uR3JhcGhbYWRqYWNlbnRMb2NhdGlvbnNbaV1dID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbG9jYXRpb25HcmFwaFthZGphY2VudExvY2F0aW9uc1tpXV0ucHVzaChsb2NhdGlvbk5hbWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyZUFkamFjZW50KGxvY2F0aW9uMTogc3RyaW5nLCBsb2NhdGlvbjI6IHN0cmluZyk6Ym9vbGVhbiB7XG4gICAgY29uc29sZS5sb2coXCJBcmUgYWRqYWNlbnQ6IFwiICsgbG9jYXRpb24xICsgXCIsIFwiK2xvY2F0aW9uMik7XG4gICAgaWYgKGxvY2F0aW9uR3JhcGhbbG9jYXRpb24xXSA9PSB1bmRlZmluZWQgfHwgbG9jYXRpb25HcmFwaFtsb2NhdGlvbjJdID09IHVuZGVmaW5lZCl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRWl0aGVyIG9uZS9ib3RoIGxvY2F0aW9ucyB1bmRlZmluZWRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2F0aW9uR3JhcGhbbG9jYXRpb24xXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobG9jYXRpb25HcmFwaFtsb2NhdGlvbjFdW2ldID09IGxvY2F0aW9uMil7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vcGF0aGZpbmRpbmcgcHJpbWl0aXZlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbihzdGFydDogc3RyaW5nLCBkZXN0aW5hdGlvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgIHZhciBwcmV2aW91cyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBsb2NhdGlvbkdyYXBoKSB7XG4gICAgICAgIHZpc2l0ZWRba2V5XSA9IGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdGVkW3N0YXJ0XSA9IHRydWU7XG5cbiAgICB2YXIgbXlRdWV1ZSA9IG5ldyBRdWV1ZTxzdHJpbmc+KCk7XG4gICAgbXlRdWV1ZS5lbnF1ZXVlKHN0YXJ0KTtcblxuICAgIHdoaWxlICghbXlRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQ6IHN0cmluZyA9IG15UXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSBsb2NhdGlvbkdyYXBoW2N1cnJlbnRdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRbbmVpZ2hib3JzW2ldXSkge1xuICAgICAgICAgICAgICAgIG15UXVldWUuZW5xdWV1ZShuZWlnaGJvcnNbaV0pO1xuICAgICAgICAgICAgICAgIHZpc2l0ZWRbbmVpZ2hib3JzW2ldXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNbbmVpZ2hib3JzW2ldXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VycmVudDogc3RyaW5nID0gZGVzdGluYXRpb247XG4gICAgaWYgKGN1cnJlbnQgPT0gc3RhcnQpXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIHdoaWxlIChwcmV2aW91c1tjdXJyZW50XSAhPSBzdGFydCkge1xuICAgICAgICBjdXJyZW50ID0gcHJldmlvdXNbY3VycmVudF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbi8vMS4yIGFnZW50c1xuZXhwb3J0IHZhciBhZ2VudHMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEFnZW50KGFnZW50TmFtZTogc3RyaW5nKSB7XG4gICAgYWdlbnRzLnB1c2goYWdlbnROYW1lKTtcbiAgICByZXR1cm4gYWdlbnROYW1lO1xufVxuXG4vLzEuMyBpdGVtc1xuZXhwb3J0IHZhciBpdGVtcyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkSXRlbShpdGVtTmFtZTogc3RyaW5nKSB7XG4gICAgaXRlbXMucHVzaChpdGVtTmFtZSk7XG4gICAgcmV0dXJuIGl0ZW1OYW1lO1xufVxuXG4vLzEuNCB2YXJpYWJsZXNcbnZhciB2YXJpYWJsZXMgPSB7fTtcbnZhciBhZ2VudFZhcmlhYmxlcyA9IHt9O1xudmFyIGl0ZW1WYXJpYWJsZXMgPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFZhcmlhYmxlKHZhck5hbWU6IHN0cmluZywgdmFsdWU6IGFueSkge1xuICAgIHZhcmlhYmxlc1t2YXJOYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YXJOYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWdlbnRWYXJpYWJsZShhZ2VudDogc3RyaW5nLCB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdKSlcbiAgICAgICAgYWdlbnRWYXJpYWJsZXNbYWdlbnRdID0ge307XG5cbiAgICBhZ2VudFZhcmlhYmxlc1thZ2VudF1bdmFyTmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZSh2YXJOYW1lOiBzdHJpbmcpOiBhbnkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh2YXJpYWJsZXNbdmFyTmFtZV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCIgbm90IHNldCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlc1t2YXJOYW1lXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFnZW50VmFyaWFibGUoYWdlbnQ6IHN0cmluZywgdmFyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGFnZW50VmFyaWFibGVzW2FnZW50XSkgfHwgaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdW3Zhck5hbWVdKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIFwiICsgdmFyTmFtZSArIFwiIGZvciBhZ2VudCBcIiArIGFnZW50ICsgXCIgbm90IHNldCFcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYWdlbnRWYXJpYWJsZXNbYWdlbnRdW3Zhck5hbWVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYXJpYWJsZU5vdFNldCh2YXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQodmFyaWFibGVzW3Zhck5hbWVdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWdlbnRWYXJpYWJsZU5vdFNldChhZ2VudDogc3RyaW5nLCB2YXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoYWdlbnRWYXJpYWJsZXNbYWdlbnRdKSB8fCBpc1VuZGVmaW5lZChhZ2VudFZhcmlhYmxlc1thZ2VudF1bdmFyTmFtZV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SXRlbVZhcmlhYmxlKGl0ZW06IHN0cmluZywgdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV0pKVxuICAgICAgICBpdGVtVmFyaWFibGVzW2l0ZW1dID0ge307XG5cbiAgICBpdGVtVmFyaWFibGVzW2l0ZW1dW3Zhck5hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbVZhcmlhYmxlKGl0ZW06IHN0cmluZywgdmFyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV0pIHx8IGlzVW5kZWZpbmVkKGl0ZW1WYXJpYWJsZXNbaXRlbV1bdmFyTmFtZV0pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmFyaWFibGUgXCIgKyB2YXJOYW1lICsgXCIgZm9yIGl0ZW0gXCIgKyBpdGVtICsgXCIgbm90IHNldCFcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbVZhcmlhYmxlc1tpdGVtXVt2YXJOYW1lXTtcbn1cblxuXG4vLzJcbi8vYWdlbnQtYmVoYXZpb3IgdHJlZSBtYXBwaW5nXG52YXIgYWdlbnRUcmVlcyA9IHt9O1xuXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoVHJlZVRvQWdlbnQoYWdlbnQ6IHN0cmluZywgdHJlZTogVGljaykge1xuICAgIGFnZW50VHJlZXNbYWdlbnRdID0gdHJlZTtcbn1cblxuLy8zLjFcbi8vdXNlciBhY3Rpb25zXG4vL1RPRE8gYWRkIHZhcmlhYmxlcyB0byB1c2VyIGFjdGlvbiB0ZXh0c1xudmFyIHVzZXJJbnRlcmFjdGlvbk9iamVjdCA9IHtcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHVzZXJBY3Rpb25zVGV4dDogW10sXG4gICAgYWN0aW9uRWZmZWN0c1RleHQ6IFwiXCJcbn1cbnZhciB1c2VySW50ZXJhY3Rpb25UcmVlcyA9IFtdO1xudmFyIHVzZXJBY3Rpb25zID0ge307XG5cbmZ1bmN0aW9uIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCkge1xuICAgIHVzZXJJbnRlcmFjdGlvbk9iamVjdC50ZXh0ID0gXCJcIjtcbiAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0ID0gW107XG4gICAgdXNlckFjdGlvbnMgPSB7fTsvL3tcIkdvIHRvIGxvY2F0aW9uIFhcIiA6IGVmZmVjdFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXNlckludGVyYWN0aW9uVHJlZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhlY3V0ZSh1c2VySW50ZXJhY3Rpb25UcmVlc1tpXSk7XG4gICAgfVxufVxuXG5leHBvcnQgbGV0IGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbiA9ICh0ZXh0OiBzdHJpbmcpID0+XG4gICAgYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB1c2VySW50ZXJhY3Rpb25PYmplY3QudGV4dCArPSBcIlxcblwiICsgdGV4dCwgMFxuICAgICk7XG5leHBvcnQgbGV0IGRpc3BsYXlBY3Rpb25FZmZlY3RUZXh0ID0gKHRleHQ6IHN0cmluZykgPT4gdXNlckludGVyYWN0aW9uT2JqZWN0LmFjdGlvbkVmZmVjdHNUZXh0ICs9IFwiXFxuXCIgKyB0ZXh0O1xuXG5leHBvcnQgbGV0IGFkZFVzZXJBY3Rpb25UcmVlID0gKHRleHQ6IHN0cmluZywgZWZmZWN0VHJlZTogVGljaykgPT4gYWN0aW9uKFxuICAgICgpID0+IHRydWUsXG4gICAgKCkgPT4gbWFwVXNlckFjdGlvblRvVHJlZSh0ZXh0LCBlZmZlY3RUcmVlKSwgMFxuKTtcblxuZXhwb3J0IGxldCBhZGRVc2VyQWN0aW9uID0gKHRleHQ6IHN0cmluZywgZWZmZWN0OiAoKSA9PiBhbnkpID0+XG4gICAgYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiBtYXBVc2VyQWN0aW9uVG9UcmVlKHRleHQsIGFjdGlvbigoKT0+dHJ1ZSwgZWZmZWN0LCAwKSksIDBcbiAgICApO1xuXG5mdW5jdGlvbiBtYXBVc2VyQWN0aW9uVG9UcmVlKHRleHQ6IHN0cmluZywgdHJlZTogVGljaykge1xuICAgIHVzZXJBY3Rpb25zW3RleHRdID0gdHJlZTtcbiAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0LnB1c2godGV4dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKHRpY2s6IFRpY2spIHtcbiAgICB1c2VySW50ZXJhY3Rpb25UcmVlcy5wdXNoKHRpY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVVzZXJBY3Rpb24odGV4dDogc3RyaW5nKSB7XG4gICAgLy9leGVjdXRlIHRoZSB1c2VyIGFjdGlvblxuICAgIHVzZXJJbnRlcmFjdGlvbk9iamVjdC5hY3Rpb25FZmZlY3RzVGV4dCA9IFwiXCI7XG4gICAgdmFyIHVzZXJBY3Rpb25FZmZlY3RUcmVlID0gdXNlckFjdGlvbnNbdGV4dF07XG4gICAgZXhlY3V0ZSh1c2VyQWN0aW9uRWZmZWN0VHJlZSk7XG59XG5cbi8vNC5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHJ1blVzZXJJbnRlcmFjdGlvblRyZWVzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VySW50ZXJhY3Rpb25PYmplY3QoKSB7XG4gICAgcmV0dXJuIHVzZXJJbnRlcmFjdGlvbk9iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdvcmxkVGljayhcbikge1xuICAgIC8vYWxsIGFnZW50IHRpY2tzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZ2VudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRyZWUgPSBhZ2VudFRyZWVzW2FnZW50c1tpXV07XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodHJlZSkpIHtcbiAgICAgICAgICAgIHNldFZhcmlhYmxlKFwiZXhlY3V0aW5nQWdlbnRcIiwgYWdlbnRzW2ldKTtcbiAgICAgICAgICAgIGV4ZWN1dGUodHJlZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuVXNlckludGVyYWN0aW9uVHJlZXMoKTtcbn0iLCJpbXBvcnQge1xuICAgIGFkZEFnZW50LCBzZXRBZ2VudFZhcmlhYmxlLCBhZGRJdGVtLCBhZGRMb2NhdGlvbiwgc2V0VmFyaWFibGUsIGdldE5leHRMb2NhdGlvbiwgYWN0aW9uLFxuICAgIGdldFJhbmROdW1iZXIsIGdldFZhcmlhYmxlLCBzZXF1ZW5jZSwgc2VsZWN0b3IsIGV4ZWN1dGUsIFByZWNvbmRpdGlvbiwgZ2V0QWdlbnRWYXJpYWJsZSwgbmVnX2d1YXJkLCBndWFyZCxcbiAgICBpc1ZhcmlhYmxlTm90U2V0LCBkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24sIGFkZFVzZXJBY3Rpb24sIGFkZFVzZXJJbnRlcmFjdGlvblRyZWUsIGluaXRpYWxpemUsXG4gICAgZ2V0VXNlckludGVyYWN0aW9uT2JqZWN0LCBleGVjdXRlVXNlckFjdGlvbiwgd29ybGRUaWNrLCBhdHRhY2hUcmVlVG9BZ2VudCwgc2V0SXRlbVZhcmlhYmxlLCBnZXRJdGVtVmFyaWFibGUsXG4gICAgZGlzcGxheUFjdGlvbkVmZmVjdFRleHQsIGFyZUFkamFjZW50LCBhZGRVc2VyQWN0aW9uVHJlZSwgbG9jYXRpb25HcmFwaCwgYWdlbnRzLCBpdGVtcywgVGlja1xufSBmcm9tIFwiLi9zY3JpcHRpbmdcIjtcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCJ0eXBlc2NyaXB0LWNvbGxlY3Rpb25zL2Rpc3QvbGliL3V0aWxcIjtcbi8vcmVxdWlyZSBhbGwgdGhlIGxpYnJhcnkgbmVlZGVkXG5sZXQgc2lnbWEgPSByZXF1aXJlKCdsaW5rdXJpb3VzJyk7XG4oPGFueT53aW5kb3cpLnNpZ21hID0gc2lnbWE7XG5yZXF1aXJlKCdsaW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMvc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMnKTtcbnJlcXVpcmUoJ2xpbmt1cmlvdXMvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmFuaW1hdGUvc2lnbWEucGx1Z2lucy5hbmltYXRlJyk7XG5yZXF1aXJlKCdsaW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEubGF5b3V0cy5ub3ZlcmxhcC9zaWdtYS5sYXlvdXRzLm5vdmVybGFwJyk7XG5yZXF1aXJlKCdsaW5rdXJpb3VzL3BsdWdpbnMvc2lnbWEucmVuZGVyZXJzLmxpbmt1cmlvdXMvY2FudmFzL3NpZ21hLmNhbnZhcy5ub2Rlcy5kZWYnKTtcbnJlcXVpcmUoJ2xpbmt1cmlvdXMvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLnRvb2x0aXBzL3NpZ21hLnBsdWdpbnMudG9vbHRpcHMnKTtcbnJlcXVpcmUoJ2xpbmt1cmlvdXMvcGx1Z2lucy9zaWdtYS5wbHVnaW5zLmRlc2lnbi9zaWdtYS5wbHVnaW5zLmRlc2lnbicpO1xuXG5cbi8vQSBjb21tb25seSB1c2VkIHR5cGVcbnR5cGUgbWFwcyA9IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW10gfTtcbi8vRmlsZSBuYW1lc1xubGV0IGZpbGVQcmVmaXggPSBcIi4uL2RhdGEvXCI7XG5sZXQgZmlsZXMgPSBbXCJjZmdHcmFtbWEuY3N2XCIsIFwiUHJlZml4LmNzdlwiLCBcIk5QQ2NvbnN0cmFpbnQudHh0XCJdO1xuXG4vL0Egc3RydWN0dXJlIGZvciBoaWVyYXJjaGljYWwgZ2VuZXJhdGlvblxuY2xhc3MgY2ZnVHJlZXMge1xuICAgIC8vdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICB2YWw6IHN0cmluZztcbiAgICAvL1RoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgIGJyYW5jaGVzOiBjZmdUcmVlc1tdIHwgbnVsbDtcbiAgICAvL0EgcGFpciBmb3IgdW5pcXVlIGlkXG4gICAgaWRMYWJlbDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgICAvL0EgZGljdCBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIGJ1aWxkaW5nc1xuICAgIGFzc29ydGVkRGljdDogbWFwcztcbiAgICAvL1RoZSBpdGVtcyBvbiBjdXJyZW50IGxvY2F0aW9uXG4gICAgaXRlbXM6IHN0cmluZ1tdIHwgbnVsbDtcbiAgICAvL1RoZSBuYW1lIG9mIHVwcGVyIGxheWVyIGxvY2F0aW9uXG4gICAgcHJldk5hbWU6IHN0cmluZ1xuXG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHJ1bGU6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sIHByZWZpeDogc3RyaW5nW10sIHByZXZOYW1lOiBTdHJpbmcpIHtcbiAgICAgICAgbGV0IGNsZWFuTmFtZTogc3RyaW5nO1xuICAgICAgICBsZXQgaWRwcmU6IHN0cmluZyA9ICcnO1xuICAgICAgICBsZXQgbGFiZWxwcmU6IHN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLmJyYW5jaGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZExhYmVsID0ge307XG4gICAgICAgIHRoaXMuYXNzb3J0ZWREaWN0ID0ge307XG4gICAgICAgIHRoaXMuaXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZOYW1lID0gcHJldk5hbWU7XG4gICAgICAgIC8vJCBtZWFucyB0aGUgbmFtZXMgaGFzIGEgcHJlZml4IGFzIHByZXZpb3VzIG5hbWVcbiAgICAgICAgLy8jIG1lYW5zIHRoZSBsb2NhdGlvbiBpcyBleHBhbmRhYmxlXG4gICAgICAgIC8vISBtZWFucyB0aGUgbmFtZXMgYXJlIGl0ZW1zXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJyEnKSkge1xuICAgICAgICAgICAgbGV0IGl0ZW1uYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gocHJldk5hbWUgKyBcIiBcIiArIGl0ZW1uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuaWRMYWJlbFtwcmV2TmFtZSArIFwiIFwiICsgaXRlbW5hbWVdID0gaXRlbW5hbWU7XG4gICAgICAgICAgICB0aGlzLnZhbCA9ICdpdGVtJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuYW1lLmVuZHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICBjbGVhbk5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGlkcHJlID0gcHJldk5hbWUgKyBcIiBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW5OYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBpZHByZSA9IHJldFJhbmQocHJlZml4KSArICcgJztcbiAgICAgICAgICAgICAgICBsYWJlbHByZSA9IGlkcHJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icmFuY2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNsZWFuTmFtZSA9IGNsZWFuTmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuOiBzdHJpbmdbXSA9IHByb2Nlc3NSYW5kKHJ1bGVbY2xlYW5OYW1lXSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0JyYW5jaCA9IG5ldyBjZmdUcmVlcyh2YWx1ZSwgcnVsZSwgcHJlZml4LCBpZHByZSArIGNsZWFuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmUodGhpcy5pZExhYmVsLCBuZXdCcmFuY2guaWRMYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmUodGhpcy5hc3NvcnRlZERpY3QsIG5ld0JyYW5jaC5hc3NvcnRlZERpY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJyYW5jaGVzLnB1c2gobmV3QnJhbmNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbCA9IGlkcHJlICsgY2xlYW5OYW1lO1xuICAgICAgICAgICAgdGhpcy5pZExhYmVsW3RoaXMudmFsXSA9IGxhYmVscHJlICsgY2xlYW5OYW1lO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYXNzb3J0ZWREaWN0W2NsZWFuTmFtZS50b0xvd2VyQ2FzZSgpXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzc29ydGVkRGljdFtjbGVhbk5hbWUudG9Mb3dlckNhc2UoKV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXNzb3J0ZWREaWN0W2NsZWFuTmFtZS50b0xvd2VyQ2FzZSgpXS5wdXNoKHRoaXMudmFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFZhbHVlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbDtcbiAgICB9XG5cbiAgICBnZXRCcmFuY2hlcygpOiBjZmdUcmVlc1tdIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYW5jaGVzO1xuICAgIH1cblxuICAgIGdldElkTGFiZWxQYWlyKCk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgICAgICByZXR1cm4gdGhpcy5pZExhYmVsO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB0aGUgY2hpbGRyZW4ncyBsb2NhdGlvbiBuYW1lc1xuICAgIGdldEJyYW5jaFZhbHVlcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIGxldCByZXQ6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmICh0aGlzLmJyYW5jaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHRoaXMuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsICE9ICdpdGVtJykge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWx1ZS52YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vcmV0dXJuIGEgZGljdCBmb3IgZXhwYW5kYWJsZSBsb2NhdGlvbnMgYW5kIHRoZWlyIGNoaWxkcmVuXG4gICAgZ2V0RXhwYW5kTGlzdCgpOiBtYXBzIHtcbiAgICAgICAgbGV0IGV4cGFuZExpc3Q6IG1hcHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYnJhbmNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXhwYW5kTGlzdFt0aGlzLnZhbF0gPSB0aGlzLmdldEJyYW5jaFZhbHVlcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSBvZiB0aGlzLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZShleHBhbmRMaXN0LCB0cmVlLmdldEV4cGFuZExpc3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGFuZExpc3Q7XG4gICAgfVxuXG4gICAgLy9yZXR1cm4gYSBwYWlyIG9mIGVhY2ggbG9jYXRpb24gYW5kIHRoZWlyIHBhcmVudHMnIGxvY2F0aW9uXG4gICAgZ2V0UHJldm5hbWVMaXN0KCk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xuICAgICAgICBsZXQgUHJldm5hbWVMaXN0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgb2YgdGhpcy5nZXRCcmFuY2hWYWx1ZXMoKSkge1xuICAgICAgICAgICAgUHJldm5hbWVMaXN0W25hbWVdID0gdGhpcy52YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnJhbmNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSBvZiB0aGlzLmJyYW5jaGVzKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZShQcmV2bmFtZUxpc3QsIHRyZWUuZ2V0UHJldm5hbWVMaXN0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcmV2bmFtZUxpc3Q7XG4gICAgfVxuXG4gICAgLy9yZXR1cm4gYSBkaWN0IGZvciBhc3NvcnRlZCB0eXBlc1xuICAgIGdldEFzc29ydGVkRGljdCgpOiBtYXBzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzb3J0ZWREaWN0O1xuICAgIH1cblxuICAgIC8vcmV0dXJuIGEgZGljdCBmb3IgdGhlIGxvY2F0aW9uIGFuZCBpdGVtcyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggbG9jYXRpb24uXG4gICAgZ2V0SXRlbXNMaXN0KCk6IG1hcHMge1xuICAgICAgICBsZXQgcmV0OiBtYXBzID0ge307XG4gICAgICAgIGlmICh0aGlzLml0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldFt0aGlzLnByZXZOYW1lXSA9IHRoaXMuaXRlbXNcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5icmFuY2hlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0cmVlIG9mIHRoaXMuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lKHJldCwgdHJlZS5nZXRJdGVtc0xpc3QoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvL3JldHVybiBhIGxpc3Qgb2YgYWxsIGxvY2F0aW9ucyBpbiB0aGUgbWFwXG4gICAgZ2V0QWxsbG9jYXRpb25zKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgbGV0IHJldDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgcmV0LnB1c2godGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgaWYgKHRoaXMuYnJhbmNoZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5icmFuY2hlcykge1xuICAgICAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoY2hpbGQuZ2V0QWxsbG9jYXRpb25zKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcHJpbnQoKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgIGlmICh0aGlzLmJyYW5jaGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHRoaXMuYnJhbmNoZXMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wcmludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8vQSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIHRvIGRpY3Rpb25hcnlcbmZ1bmN0aW9uIGNvbWJpbmUoZGljdDE6IHsgW2tleTogc3RyaW5nXTogYW55IH0sIGRpY3QyOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIE9iamVjdC5rZXlzKGRpY3QyKSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGljdDFbdmFsXSkpIHtcbiAgICAgICAgICAgIGRpY3QxW3ZhbF0gPSBkaWN0Mlt2YWxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGljdDFbdmFsXSA9IGRpY3QxW3ZhbF0uY29uY2F0KGRpY3QyW3ZhbF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWN0MTtcbn1cblxuLy9BIGZ1bmN0aW9uIGZvciByZXR1cm4gYW5kIGRlbGV0ZSBhIHJhbmRvbSBudW1iZXIgZnJvbSBhIGxpc3RcbmZ1bmN0aW9uIHJldFJhbmQobGlzdDogYW55W10pIHtcbiAgICBsZXQgaW5kZXggPSBnZXRSYW5kTnVtYmVyKDAsIGxpc3QubGVuZ3RoIC0gMSk7XG4gICAgbGV0IHJldCA9IGxpc3RbaW5kZXhdO1xuICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG4vL1JlYWRpbmcgdGhlIGZpbGVzXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZXMoKTogUHJvbWlzZTxtYXBzPiB7XG4gICAgbGV0IGRhdGE6IG1hcHMgPSB7fTtcblxuICAgIGZvciAobGV0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGxldCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSB0aGlzLnJlc3BvbnNlVGV4dC5zcGxpdCgvXFxufFxcclxcbi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZmlsZV0gPSBsaW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KEVycm9yKHJlcS5zdGF0dXNUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcS5vcGVuKFwiR0VUXCIsIGZpbGVQcmVmaXggKyBmaWxlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXEucmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgcmVxLnNlbmQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbn1cblxuLy9jYWxsIGFsbCB0aGUgZnVuY3Rpb25zIG5lZWRlZFxucmVhZEZpbGVzKCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBsZXQgdHJlZTogY2ZnVHJlZXMgPSBnZW5lcmF0ZVRyZWUodmFsdWUpO1xuICAgIC8vdHJlZS5wcmludCgpO1xuICAgIC8vIGxldCBjb25kaXRpb246IGNvbnN0cmFpbiA9IHByb2Nlc3NDb25kaXRpb24odmFsdWUpO1xuICAgIEluaXRpYWxpemVWaWxpbGxhbmUodHJlZSk7XG59KTtcblxuLy9Gcm9tIHRoZSByYXcgZGF0YSB0byBnZW5lcmF0ZSB0aGUgY29udGV4dC1mcmVlIGdyYW1tYXIgdHJlZXMgZm9yIHRoZSBtYXBcbmZ1bmN0aW9uIGdlbmVyYXRlVHJlZShkYXRhOiBtYXBzKTogY2ZnVHJlZXMge1xuICAgIGxldCBQcmVmaXg6IHN0cmluZ1tdID0gZGF0YVsnUHJlZml4LmNzdiddO1xuICAgIGxldCBuZXdSdWxlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgbGV0IHJhd1J1bGUgPSBkYXRhWydjZmdHcmFtbWEuY3N2J107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByb3dzID0gcmF3UnVsZVtpXS5zcGxpdCgnLCcpO1xuICAgICAgICBuZXdSdWxlW3Jvd3NbMF1dID0gcm93c1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjZmdUcmVlcygnI1VuaXZlcnNpdHkgTWFwJCcsIG5ld1J1bGUsIFByZWZpeCwgJycpO1xufVxuXG4vL0ZvciBlYWNoIGVsZW1lbnRzIG9mIGNvbnRleHQgZnJlZSBncmFtbWFyLCBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIgb2YgY2VydGFpbiB0eXBlXG4vLyBvZiBidWlsZGluZ3MgYWNjb3JkaW5nIHRvIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtXG5mdW5jdGlvbiBwcm9jZXNzUmFuZChkYXRhOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgbGV0IGNoaWxkcmVuID0gZGF0YS5zcGxpdCgnOycpO1xuICAgIGxldCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgZWxlbWVudHMgPSBjaGlsZHJlbltqXS5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgbnVtID0gZ2V0UmFuZE51bWJlcihOdW1iZXIoZWxlbWVudHNbMV0pLCBOdW1iZXIoZWxlbWVudHNbMl0pKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBudW07IGsrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy9SYW5kb21seSBnZW5lcmF0ZSBhIGNvbm5lY3RlZCBncmFwaHMgZnJvbSBhIGxpc3Qgb2Ygbm9kZXNcbi8vVGhlIGNvbm5lY3RlZCBncmFwaCBpcyBvbmUtZGlyZWN0aW9uIGZvciB0aGUgYWRkTG9jYXRpb24gZnVuY3Rpb24gb2YgdmlsbGFuZWxsZVxuZnVuY3Rpb24gY29ubmVjdE5vZGVzKGxvY2F0aW9uOiBzdHJpbmdbXSk6IG1hcHMge1xuICAgIGxldCBub2RlczogbWFwcyA9IHt9O1xuICAgIGxldCB2aXNpdGVkOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmlzaXRlZFtsb2NhdGlvbltpXV0gPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCByZXN0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy9yYW5kb21seSBnZW5lcmF0ZSBhIGdyYXBoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQobm9kZXNbbG9jYXRpb25baV1dKSkge1xuICAgICAgICAgICAgbm9kZXNbbG9jYXRpb25baV1dID0gW11cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsb2NhdGlvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG5vZGVzW2xvY2F0aW9uW2pdXSkpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tsb2NhdGlvbltqXV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgKDIgLyBsb2NhdGlvbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbbG9jYXRpb25baV1dLnB1c2gobG9jYXRpb25bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vbWFraW5nIHN1cmUgaXQgaXMgY29ubmVjdGVkXG4gICAgLy9Vc2luZyBkZnMgdG8gZGlmZmVyZW50aWF0ZSBjbHVzdGVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHZpc2l0ZWRbbG9jYXRpb25baV1dID09IGZhbHNlKSB7XG4gICAgICAgICAgICBsZXQgaXRlbTogc3RyaW5nID0gbG9jYXRpb25baV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKGxvY2F0aW9uW2ldKTtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtjdXJdID09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkW2N1cl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gY3VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIG5vZGVzW2N1cl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9Db25uZWN0IHRoZSBjbHVzdGVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbm9kZXNbcmVzdFtpXV0ucHVzaChyZXN0W2kgKyAxXSk7XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cblxuXG5mdW5jdGlvbiBJbml0aWFsaXplVmlsaWxsYW5lKFRyZWU6IGNmZ1RyZWVzKSB7XG4gICAgLy9nZXQgaXRlbUxpc3QgZm9yIGRpc3BsYXkgaXRlbXNcbiAgICBsZXQgaXRlbXNMaXN0OiBtYXBzID0gVHJlZS5nZXRJdGVtc0xpc3QoKTtcbiAgICAvL2dldCBleHBhbmRMaXN0IHRvIGdlbmVyYXRlIGEgZXhwYW5kIGdyYXBoXG4gICAgbGV0IGV4cGFuZExpc3Q6IG1hcHMgPSBUcmVlLmdldEV4cGFuZExpc3QoKTtcbiAgICAvL2dldCB0aGUgaW5pdGlhbGl6ZWQgaWQgcGFpclxuICAgIGxldCBpZExhYmVsUGFpcjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IFRyZWUuZ2V0SWRMYWJlbFBhaXIoKTtcbiAgICAvL2dldCB0aGUgaW5pdGlhbGl6ZWQgcHJldm5hbWUgcGFpcnNcbiAgICBsZXQgUHJldm5hbWVMaXN0OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0gVHJlZS5nZXRQcmV2bmFtZUxpc3QoKTtcbiAgICAvLyBhZ2VudHNcbiAgICBsZXQgTlBDID0gYWRkQWdlbnQoXCJOUENcIik7XG4gICAgLy9pdGVtc1xuICAgIC8vYWRkIGl0ZW1zIHRvIHRoZSB2aWxsYW5lbGxlXG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGl0ZW1zTGlzdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtc0xpc3Rba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWRkSXRlbShpdGVtc0xpc3Rba2V5XVtpXSk7XG4gICAgICAgICAgICBzZXRJdGVtVmFyaWFibGUoaXRlbXNMaXN0W2tleV1baV0sIFwiY3VycmVudExvY2F0aW9uXCIsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL0dlbmVyYXRlIHRoZSBleHBhbmRHcmFwaCBmcm9tIHRoZSBtb2RpZmllZCBleHBhbmRMaXN0XG4gICAgLy9Gb3IgZWFjaCBleHBhbmRhYmxlIGxvY2F0aW9uLCB0aGUgZGljdGlvbmFyeSBjb250YWlucyBhIHJhbmRvbWx5IGNvbm5lY3RlZCBncmFwaCBmb3IgYWxsIGl0cyBjaGlsZHJlblxuICAgIC8vVGhlIGdyYXBoIGlzIG9uZSBkaXJlY3Rpb25cbiAgICBsZXQgZXhwYW5kR3JhcGg6IHsgW2tleTogc3RyaW5nXTogbWFwcyB9ID0ge307XG4gICAgZm9yIChsZXQga2V5cyBvZiBPYmplY3Qua2V5cyhleHBhbmRMaXN0KSkge1xuICAgICAgICBleHBhbmRHcmFwaFtrZXlzXSA9IGNvbm5lY3ROb2RlcyhleHBhbmRMaXN0W2tleXNdKTtcbiAgICB9XG5cbiAgICAvL0FkZCBsb2NhdGlvbnMgdG8gdmlsbGFuZWxsZVxuICAgIGZ1bmN0aW9uIGFkZExvY2F0aW9uR3JhcGgoZ3JhcGg6IG1hcHMpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGdyYXBoKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBUcmVlLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBhZGRMb2NhdGlvbihrZXksIGdyYXBoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkTG9jYXRpb25HcmFwaChleHBhbmRMaXN0KTtcblxuICAgIGZvciAobGV0IGtleSBpbiBleHBhbmRHcmFwaCkge1xuICAgICAgICBhZGRMb2NhdGlvbkdyYXBoKGV4cGFuZEdyYXBoW2tleV0pO1xuICAgIH1cblxuICAgIC8vSW5pdGlhbGl6ZSBsb2NhdGlvbnMgdG8gYXNzaWduIGl0ZW1zIGFuZCBhZ2VudFxuICAgIGxldCBsb2NhdGlvbnMgPSBPYmplY3Qua2V5cyhsb2NhdGlvbkdyYXBoKTtcbiAgICAvL0luaXRpYWxpemUgcGxheWVyIHRvIGJlIGF0IG9uZSBvZiB0aGUgZW50cmFuY2Ugb2YgYWxsIHVuaXZlcnNpdGllc1xuICAgIGxldCBhbGxVbml2ZXJzaXR5ID0gZXhwYW5kTGlzdFtUcmVlLmdldFZhbHVlKCldO1xuXG4vLyB2YXJpYWJsZXNcbiAgICBsZXQgaXRlbURpc3BsYXkgPSBzZXRWYXJpYWJsZShcIml0ZW1EaXNwbGF5XCIsIGZhbHNlKTtcbiAgICBsZXQgaW52ZW50b3J5ID0gc2V0VmFyaWFibGUoXCJpbnZlbnRvcnlcIiwgW10pO1xuICAgIGxldCBzZWxlY3RlZCA9IHNldFZhcmlhYmxlKFwic2VsZWN0ZWRcIiwgZmFsc2UpO1xuICAgIGxldCBlbmRHYW1lID0gc2V0VmFyaWFibGUoXCJlbmRHYW1lXCIsIGZhbHNlKTtcbiAgICBsZXQgc2VsZWN0ZWRVbml2ZXJzaXR5ID0gc2V0VmFyaWFibGUoXCJzZWxlY3RlZFVuaXZlcnNpdHlcIiwgZmFsc2UpO1xuICAgIGxldCBtZWV0ID0gc2V0VmFyaWFibGUoXCJtZWV0XCIsIGZhbHNlKTtcblxuXG4vL05QQ1xuICAgIHNldEFnZW50VmFyaWFibGUoTlBDLCBcImN1cnJlbnRMb2NhdGlvblwiLCByZXRSYW5kKGxvY2F0aW9ucykpO1xuLy9wbGF5ZXJcbiAgICBsZXQgcGxheWVyTG9jYXRpb24gPSBzZXRWYXJpYWJsZShcInBsYXllckxvY2F0aW9uXCIsIHJldFJhbmQoYWxsVW5pdmVyc2l0eSkpO1xuXG4vLyAyLiBEZWZpbmUgQlRzXG5cbiAgICAvL3JlY292ZXIgdGhlIGFycmF5IG9mIGFsbCB1bml2ZXJzaXRpZXMgYW5kIGxvY2F0aW9uXG4gICAgbG9jYXRpb25zID0gT2JqZWN0LmtleXMobG9jYXRpb25HcmFwaCk7XG4gICAgYWxsVW5pdmVyc2l0eSA9IGV4cGFuZExpc3RbVHJlZS5nZXRWYWx1ZSgpXTtcblxuICAgIGxldCBzZXRSYW5kTnVtYmVyID0gYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzZXRWYXJpYWJsZShcInJhbmROdW1iZXJcIiwgZ2V0UmFuZE51bWJlcigxLCBsb2NhdGlvbnMubGVuZ3RoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIDBcbiAgICApO1xuICAgIC8vSW5pdGlhbGl6ZSBiZWhhdmlvciB0cmVlIGZvciBOUENzXG4gICAgbGV0IEJUbGlzdDogVGlja1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhsb2NhdGlvbnNbaV0pO1xuICAgICAgICBsZXQgYWN0aW9uczogVGljayA9IGFjdGlvbigoKSA9PiBnZXRWYXJpYWJsZShcInJhbmROdW1iZXJcIikgPT0gaSArIDEsICgpID0+IHNldFZhcmlhYmxlKFwiZGVzdGluYXRpb25cIiwgbG9jYXRpb25zW2ldKSwgMCk7XG4gICAgICAgIEJUbGlzdC5wdXNoKGFjdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgYXREZXN0aW5hdGlvbjogUHJlY29uZGl0aW9uID0gKCkgPT4gZ2V0VmFyaWFibGUoXCJkZXN0aW5hdGlvblwiKSA9PSBnZXRBZ2VudFZhcmlhYmxlKE5QQywgXCJjdXJyZW50TG9jYXRpb25cIik7XG4gICAgbGV0IHNldERlc3RpbmF0aW9uUHJlY29uZDogUHJlY29uZGl0aW9uID0gKCkgPT4gaXNWYXJpYWJsZU5vdFNldChcImRlc3RpbmF0aW9uXCIpIHx8IGF0RGVzdGluYXRpb24oKTtcblxuLy8gY3JlYXRlIGJlaGF2aW9yIHRyZWVzXG4gICAgbGV0IHNldE5leHREZXN0aW5hdGlvbiA9IHNlcXVlbmNlKFtcbiAgICAgICAgc2V0UmFuZE51bWJlcixcbiAgICAgICAgc2VsZWN0b3IoQlRsaXN0KSxcbiAgICBdKTtcblxuICAgIGxldCBnb3RvTmV4dExvY2F0aW9uID0gYWN0aW9uKFxuICAgICAgICAoKSA9PiB0cnVlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzZXRBZ2VudFZhcmlhYmxlKE5QQywgXCJjdXJyZW50TG9jYXRpb25cIiwgZ2V0TmV4dExvY2F0aW9uKGdldEFnZW50VmFyaWFibGUoTlBDLCBcImN1cnJlbnRMb2NhdGlvblwiKSwgZ2V0VmFyaWFibGUoXCJkZXN0aW5hdGlvblwiKSkpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJOUEMgaXMgYXQ6IFwiICsgZ2V0QWdlbnRWYXJpYWJsZShOUEMsIFwiY3VycmVudExvY2F0aW9uXCIpKVxuICAgICAgICB9LFxuICAgICAgICAwXG4gICAgKTtcbiAgICAvL2FnZW50cyBCVCBmb3IgcGxheWVyIG1lZXRpbmcgdGhlIGFnZW50c1xuICAgIGxldCBzZXRSYW5kTnVtYmVyXzIgPSBhY3Rpb24oXG4gICAgICAgICgpID0+IHRydWUsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHNldFZhcmlhYmxlKFwicmFuZE51bWJlclwiLCBnZXRSYW5kTnVtYmVyKDEsIDMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgMFxuICAgICk7XG4gICAgbGV0IG1lZXRQbGF5ZXIgPSBzZXF1ZW5jZShbc2V0UmFuZE51bWJlcl8yLFxuICAgICAgICBndWFyZCgoKSA9PiBnZXRBZ2VudFZhcmlhYmxlKE5QQywgXCJjdXJyZW50TG9jYXRpb25cIikgPT0gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pLFxuICAgICAgICAgICAgc2VsZWN0b3IoW1xuICAgICAgICAgICAgICAgIGFjdGlvbigoKSA9PiBnZXRWYXJpYWJsZShcInJhbmROdW1iZXJcIikgPT0gMSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZSgnZW5kTWV0aG9kJywgJ2xvdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoc2VsZWN0ZWRVbml2ZXJzaXR5LCBnZXRfdW5pKGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKSkpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShlbmRHYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9LCAwKSxcbiAgICAgICAgICAgICAgICBhY3Rpb24oKCkgPT4gZ2V0VmFyaWFibGUoXCJyYW5kTnVtYmVyXCIpID09IDIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoJ2VuZE1ldGhvZCcsICdkaWUnKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFyaWFibGUoZW5kR2FtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSwgMCksXG4gICAgICAgICAgICAgICAgYWN0aW9uKCgpID0+IGdldFZhcmlhYmxlKFwicmFuZE51bWJlclwiKSA9PSAzLCAoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShtZWV0LCB0cnVlKSwgMClcbiAgICAgICAgICAgIF0pKV0pO1xuXG5cbiAgICBsZXQgc2VhcmNoID0gc2VxdWVuY2UoW1xuICAgICAgICBzZWxlY3RvcihbXG4gICAgICAgICAgICBndWFyZChzZXREZXN0aW5hdGlvblByZWNvbmQsIHNldE5leHREZXN0aW5hdGlvbiksXG4gICAgICAgICAgICBhY3Rpb24oKCkgPT4gdHJ1ZSwgKCkgPT4ge1xuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgXSksXG4gICAgICAgIGdvdG9OZXh0TG9jYXRpb24sXG4gICAgXSk7XG5cbiAgICBsZXQgTlBDQlQgPSBzZWxlY3RvcihbXG4gICAgICAgIG1lZXRQbGF5ZXIsXG4gICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgIHNlYXJjaCwgbWVldFBsYXllclxuICAgICAgICBdKVxuICAgIF0pO1xuXG4vL2F0dGFjaCBiZWhhdmlvdXIgdHJlZXMgdG8gYWdlbnRzXG4gICAgYXR0YWNoVHJlZVRvQWdlbnQoTlBDLCBOUENCVCk7XG5cbiAgICAvL2EgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIHVuaXZlcnNpdHkgdGhlIGN1cnJlbnQgbG9jYXRpb24gaXMgaW5cbiAgICBmdW5jdGlvbiBnZXRfdW5pKGxvYzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgdmFyIHVuaTogc3RyaW5nID0gbG9jO1xuICAgICAgICB3aGlsZSAoUHJldm5hbWVMaXN0W3VuaV0gIT0gVHJlZS5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICB1bmkgPSBQcmV2bmFtZUxpc3RbdW5pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pO1xuICAgIH1cblxuICAgIC8vIDMuIENvbnN0cnVjdCBzdG9yeVxuXG4gICAgLy8gY3JlYXRlIHVzZXIgYWN0aW9ucyBmcm9tIHRoZSBncmFwaHNcbiAgICBmb3IgKGxldCBrZXkgaW4gbG9jYXRpb25HcmFwaCkge1xuICAgICAgICBsZXQgc2VxOiBhbnlbXSA9IFtdO1xuICAgICAgICBzZXEucHVzaChkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJZb3UgZW50ZXIgdGhlIFwiICsgaWRMYWJlbFBhaXJba2V5XSArIFwiLlwiKSk7XG4gICAgICAgIHNlcS5wdXNoKGFkZFVzZXJBY3Rpb24oXCJTZWxlY3QgVW5pdmVyc2l0eS5cIiwgKCkgPT4gc2V0VmFyaWFibGUoc2VsZWN0ZWQsIHRydWUpKSk7XG4gICAgICAgIHNlcS5wdXNoKGFkZFVzZXJBY3Rpb24oXCJTdGF5IHdoZXJlIHlvdSBhcmUuXCIsICgpID0+IHtcbiAgICAgICAgfSkpO1xuICAgICAgICAvL0NoZWNrIHdoZXRoZXIgaXQncyBpbiBhIGxvd2VyIGxheWVyXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsb2NhdGlvbkdyYXBoKS5pbmNsdWRlcyhQcmV2bmFtZUxpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgIHNlcS5wdXNoKGFkZFVzZXJBY3Rpb24oXCJHbyBvdXRzaWRlIHRvIFwiICsgaWRMYWJlbFBhaXJbUHJldm5hbWVMaXN0W2tleV1dICsgXCIuXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiwgUHJldm5hbWVMaXN0W2tleV0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vQ2hlY2sgd2hldGhlciBpdCdzIGhhcyBhIGNoaWxkcmVuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhleHBhbmRMaXN0KS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBzZXEucHVzaChhZGRVc2VyQWN0aW9uKFwiR28gaW5zaWRlIFwiICsgaWRMYWJlbFBhaXJba2V5XSArIFwiIHRvIGVudGVyIFwiICsgaWRMYWJlbFBhaXJbZXhwYW5kTGlzdFtrZXldWzBdXSArIFwiLlwiLCAoKSA9PiBzZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbiwgZXhwYW5kTGlzdFtrZXldWzBdKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGdyYXBoID0gY29tcGxldGVHcmFwaChleHBhbmRHcmFwaFtQcmV2bmFtZUxpc3Rba2V5XV0pO1xuICAgICAgICBmb3IgKGxldCBhZGogb2YgZ3JhcGhba2V5XSkge1xuICAgICAgICAgICAgc2VxLnB1c2goYWRkVXNlckFjdGlvbihcIkVudGVyIHRoZSBcIiArIGlkTGFiZWxQYWlyW2Fkal0gKyBcIi5cIiwgKCkgPT4gc2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24sIGFkaikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBTdGF0ZUJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGtleSAmJlxuICAgICAgICAgICAgZ2V0VmFyaWFibGUoaXRlbURpc3BsYXkpID09IGZhbHNlICYmXG4gICAgICAgICAgICBnZXRWYXJpYWJsZShzZWxlY3RlZCkgPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIGdldFZhcmlhYmxlKGVuZEdhbWUpID09IGZhbHNlLFxuICAgICAgICAgICAgc2VxdWVuY2Uoc2VxKSk7XG4gICAgICAgIGFkZFVzZXJJbnRlcmFjdGlvblRyZWUoU3RhdGVCVCk7XG4gICAgfVxuXG4gICAgLy9CZWhhdmlvciB0cmVlIGZvciBkaXNwbGF5aW5nIGl0ZW1zXG4gICAgbGV0IHNob3dpdGVtQlQgPSBndWFyZCgoKSA9PiAhaXNVbmRlZmluZWQoaXRlbXNMaXN0W2dldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKV0pICYmIGl0ZW1zTGlzdFtnZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbildLmxlbmd0aCAhPSAwICYmIGdldFZhcmlhYmxlKGl0ZW1EaXNwbGF5KSA9PSBmYWxzZSxcbiAgICAgICAgc2VxdWVuY2UoW1xuICAgICAgICAgICAgICAgIGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbihcIllvdSBub3RpY2UgaXRlbXMgbHlpbmcgYXJvdW5kLlwiKSxcbiAgICAgICAgICAgICAgICBhZGRVc2VyQWN0aW9uKFwic2hvdyBhbGwgdGhlIGl0ZW1zXCIsICgpID0+IHNldFZhcmlhYmxlKGl0ZW1EaXNwbGF5LCB0cnVlKSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSk7XG4gICAgLy9hdHRhY2ggdGhlIGJ0IHRvIHRociB0cmVlXG4gICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShzaG93aXRlbUJUKTtcblxuICAgIC8vQ3JlYXRlIGJlaGF2aW9yIHRyZWVzIGZvciBldmVyeSBpdGVtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IEl0ZW1CVCA9IGd1YXJkKCgpID0+IGdldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKSA9PSBnZXRJdGVtVmFyaWFibGUoaXRlbXNbaV0sIFwiY3VycmVudExvY2F0aW9uXCIpXG4gICAgICAgICAgICAmJiBnZXRWYXJpYWJsZShpdGVtRGlzcGxheSkgPT0gdHJ1ZSxcbiAgICAgICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgICAgICBhZGRVc2VyQWN0aW9uKFwiUGljayB1cCB0aGUgXCIgKyBpZExhYmVsUGFpcltpdGVtc1tpXV0gKyBcIi5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShpdGVtRGlzcGxheSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VySW52ID0gZ2V0VmFyaWFibGUoaW52ZW50b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgY3VySW52LnB1c2goaXRlbXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpdGVtc0xpc3RbZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pXS5zcGxpY2UoaXRlbXNMaXN0W2dldFZhcmlhYmxlKHBsYXllckxvY2F0aW9uKV0uaW5kZXhPZihpdGVtc1tpXSksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5QWN0aW9uRWZmZWN0VGV4dChcIllvdSBwaWNrIHVwIHRoZSBcIiArIGl0ZW1zW2ldICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJdGVtVmFyaWFibGUoaXRlbXNbaV0sIFwiY3VycmVudExvY2F0aW9uXCIsIFwicGxheWVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYXJpYWJsZShpbnZlbnRvcnksIGN1ckludilcbiAgICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgICkpO1xuICAgICAgICBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKEl0ZW1CVCk7XG4gICAgfVxuXG4gICAgLy9CVCBmb3Igc2VsZWN0aW5nIHVuaXZlcnNpdGllc1xuICAgIHZhciB1bml2ZXJzaXR5U2VxOiBhbnlbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsVW5pdmVyc2l0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICB1bml2ZXJzaXR5U2VxLnB1c2goYWRkVXNlckFjdGlvbihcInNlbGVjdCBcIiArIGFsbFVuaXZlcnNpdHlbaV0gKyBcIi5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgc2V0VmFyaWFibGUoc2VsZWN0ZWRVbml2ZXJzaXR5LCBhbGxVbml2ZXJzaXR5W2ldKTtcbiAgICAgICAgICAgIHNldFZhcmlhYmxlKCdlbmRNZXRob2QnLCAnc2VsZWN0Jyk7XG4gICAgICAgICAgICBzZXRWYXJpYWJsZShlbmRHYW1lLCB0cnVlKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBsZXQgdW5pdmVyc2l0eUJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUoc2VsZWN0ZWQpID09IHRydWUgJiYgZ2V0VmFyaWFibGUoZW5kR2FtZSkgPT0gZmFsc2UsXG4gICAgICAgIHNlcXVlbmNlKHVuaXZlcnNpdHlTZXEpKTtcbiAgICBhZGRVc2VySW50ZXJhY3Rpb25UcmVlKHVuaXZlcnNpdHlCVCk7XG4gICAgLy9JbnRlcmFjdGlvbiBCVCBmb3IgZGlzcGxheWluZyBtZWV0aW5nIGRlc2NyaXB0aW9uIFxuICAgIGxldCBtZWV0QlQgPSBndWFyZCgoKSA9PiBnZXRWYXJpYWJsZShtZWV0KSA9PSB0cnVlLFxuICAgICAgICBzZXF1ZW5jZShbXG4gICAgICAgICAgICBhY3Rpb24oKCkgPT4gdHJ1ZSwgKCkgPT4gc2V0VmFyaWFibGUobWVldCwgZmFsc2UpLCAwKSxcbiAgICAgICAgICAgIGRpc3BsYXlEZXNjcmlwdGlvbkFjdGlvbihcIk5vdGhpbmcgaGFwcGVucyBiZXR3ZWVuIHlvdSBhbmQgdGhlIHN0cmFuZ2VyXCIpXSkpO1xuICAgIGFkZFVzZXJJbnRlcmFjdGlvblRyZWUobWVldEJUKTtcblxuICAgIC8vQlQgZm9yIGxvY2F0aW9uIGRlc2NyaXB0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICBpZiAocmFuZCA8IDAuMSkge1xuICAgICAgICAgICAgbGV0IGJyb2tlbkJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGxvY2F0aW9uc1tpXSAmJlxuICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKGl0ZW1EaXNwbGF5KSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKHNlbGVjdGVkKSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKGVuZEdhbWUpID09IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKCdUaGUgcGxhY2UgeW91IGVudGVyIGlzIGJyb2tlbiEnKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIGFkZFVzZXJJbnRlcmFjdGlvblRyZWUoYnJva2VuQlQpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmQgPCAwLjIpIHtcbiAgICAgICAgICAgIGxldCBmYW5jeUJUID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUocGxheWVyTG9jYXRpb24pID09IGxvY2F0aW9uc1tpXSAmJlxuICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKGl0ZW1EaXNwbGF5KSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKHNlbGVjdGVkKSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKGVuZEdhbWUpID09IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURlc2NyaXB0aW9uQWN0aW9uKCdUaGUgcGxhY2UgeW91IGVudGVyIGlzIGZhbmN5IScpXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShmYW5jeUJUKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL0JUIGZvciBlbmQgb2YgdGhlIGdhbWVcbiAgICAvL1RoZSBnYW1lIG1heSBlbmQgd2hlbiB0aGUgcGxheWVyIHNlbGVjdCB1bml2ZXJzaXR5IFxuICAgIC8vT3IgdGhlIHBsYXllciBtZWV0IGFuIGFnZW50IGFuZCBmYWxsIGluIGxvdmUgd2l0aCBoaW0gXG4gICAgLy9PciB0aGUgcGxheWVyIG1lZXQgYW4gYWdlbnQgYW5kIGFjY2lkZW50YWxseSBraWxsZWQgYnkgaGltXG4gICAgbGV0IGdhbWVPdmVyID0gZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUoZW5kR2FtZSkgPT0gdHJ1ZSxcbiAgICAgICAgc2VsZWN0b3IoW1xuICAgICAgICAgICAgICAgIGFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gZ2V0VmFyaWFibGUoJ2VuZE1ldGhvZCcpID09ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySW50ZXJhY3Rpb25PYmplY3QudGV4dCArPSBcIlxcblwiICsgXCJZb3UgZGVjaWRlIHRvIGdvIHRvIFwiICsgZ2V0VmFyaWFibGUoc2VsZWN0ZWRVbml2ZXJzaXR5KSArIFwiIVwiXG4gICAgICAgICAgICAgICAgICAgIH0sIDBcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gZ2V0VmFyaWFibGUoJ2VuZE1ldGhvZCcpID09ICdsb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckludGVyYWN0aW9uT2JqZWN0LnRleHQgKz0gXCJcXG5cIiArIFwiWW91IGZhbGwgaW4gbG92ZSB3aXRoIHRoZSBvbmUgeW91IG1ldCwgZmluYWxseSBkZWNpZGUgZ28gdG8gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhcmlhYmxlKHNlbGVjdGVkVW5pdmVyc2l0eSkgKyAnISdcbiAgICAgICAgICAgICAgICAgICAgfSwgMFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZ3VhcmQoKCkgPT4gZ2V0VmFyaWFibGUoJ2VuZE1ldGhvZCcpID09ICdkaWUnLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGVzY3JpcHRpb25BY3Rpb24oXCJTYWRseSwgWW91IGFyZSBraWxsZWQgYnkgdGhlIHN0cmFuZ2VyIHlvdSBtZWV0IVwiKSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgKSlcbiAgICA7XG4gICAgYWRkVXNlckludGVyYWN0aW9uVHJlZShnYW1lT3Zlcik7XG5cbi8vSW5pdGlhbGl6ZSBzaWdtYSBmb3IgcGxheWVyIGFuZCBOUENcbiAgICBsZXQgc2lnbWFQbGF5ZXIgPSBuZXcgc2lnbWEoe1xuICAgICAgICBncmFwaDoge1xuICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgZWRnZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgICAgICB0eXBlOiAnY2FudmFzJyxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogJ3BsYXllci1jb250YWluZXInXG4gICAgICAgIH0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICBub2RlQm9yZGVyU2l6ZTogNSxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlQm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIGRlZmF1bHROb2RlSG92ZXJCb3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgZGVmYXVsdE5vZGVDb2xvcjogJyMwMDAnLFxuICAgICAgICAgICAgZGVmYXVsdExhYmVsQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIGRlZmF1bHRFZGdlQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgIGVkZ2VDb2xvcjogJ2RlZmF1bHQnLFxuICAgICAgICAgICAgbWF4Tm9kZVNpemU6IDIwLFxuICAgICAgICAgICAgc2lkZU1hcmdpbjogMTVcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHNpZ21hTlBDID0gbmV3IHNpZ21hKHtcbiAgICAgICAgZ3JhcGg6IHtcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIGVkZ2VzOiBbXVxuICAgICAgICB9LFxuICAgICAgICByZW5kZXJlcjoge1xuICAgICAgICAgICAgdHlwZTogJ2NhbnZhcycsXG4gICAgICAgICAgICBjb250YWluZXI6ICdOUEMtY29udGFpbmVyJ1xuICAgICAgICB9LFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgICAgbm9kZUJvcmRlclNpemU6IDUsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZUJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBkZWZhdWx0Tm9kZUNvbG9yOiAnIzAwMCcsXG4gICAgICAgICAgICBkZWZhdWx0TGFiZWxDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgZGVmYXVsdEVkZ2VDb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgZWRnZUNvbG9yOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICBtYXhOb2RlU2l6ZTogMjAsXG4gICAgICAgICAgICBzaWRlTWFyZ2luOiAxNVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvL0EgdW5pcXVlIElEIGZvciBlYWNoIGVkZ2UuXG4gICAgbGV0IGVkZ2VJRDogbnVtYmVyID0gMDtcblxuICAgIC8vQ2xlYXIgdXAgdGhlIGdyYXBoLlxuICAgIGZ1bmN0aW9uIGNsZWFyKHNpZ21hOiBhbnkpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gc2lnbWEuZ3JhcGgubm9kZXMoKTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgc2lnbWEuZ3JhcGguZHJvcE5vZGUobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1RoZSBncmFwaCBnZW5lcmF0ZSBieSBjb25uZWN0LW5vZGUgaXMgb25lIGRpcmVjdGlvblxuICAgIC8vVGhpcyBmdW5jdGlvbiBtYWtlIGl0IHR3by1kaXJlY3Rpb25cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUdyYXBoKGdyYXBoOiBtYXBzKSB7XG4gICAgICAgIGxldCByZXRHcmFwaDogbWFwcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZ3JhcGgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChyZXRHcmFwaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldEdyYXBoW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldEdyYXBoW2tleV0gPSByZXRHcmFwaFtrZXldLmNvbmNhdChncmFwaFtrZXldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxvYyBvZiBncmFwaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHJldEdyYXBoW2xvY10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldEdyYXBoW2xvY10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0R3JhcGhbbG9jXS5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldEdyYXBoO1xuICAgIH1cblxuICAgIC8vU2hvdyB0aGUgYWRqYWNlbnQgbm9kZSBvZiB0aGUgaW5wdXQgbm9kZVxuICAgIGZ1bmN0aW9uIHNob3dBcm91bmQoaW5wdXQ6IHN0cmluZywgc2lnbWFJbnN0YW5jZTogYW55KSB7XG4gICAgICAgIGxldCBncmFwaCA9IGNvbXBsZXRlR3JhcGgoZXhwYW5kR3JhcGhbUHJldm5hbWVMaXN0W2lucHV0XV0pO1xuICAgICAgICBsZXQgYWRqYWNlbnQgPSBncmFwaFtpbnB1dF07XG4gICAgICAgIGxldCBudW1iZXJMYXllciA9IGFkamFjZW50Lmxlbmd0aDtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbWFJbnN0YW5jZS5ncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICAvLyBNYWluIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgaWQ6IGlucHV0LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBpZExhYmVsUGFpcltpbnB1dF0sXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJMYXllcjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2lnbWFJbnN0YW5jZS5ncmFwaC5ub2RlcyhhZGphY2VudFtpXSkpKSB7XG4gICAgICAgICAgICAgICAgc2lnbWFJbnN0YW5jZS5ncmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFpbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBpZDogYWRqYWNlbnRbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpZExhYmVsUGFpclthZGphY2VudFtpXV0sXG4gICAgICAgICAgICAgICAgICAgIHg6IE1hdGguY29zKE1hdGguUEkgKiAyICogKGkgLSAxIC8gMykgLyBudW1iZXJMYXllcikgKiA0MCArIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoaW5wdXQpLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IE1hdGguc2luKE1hdGguUEkgKiAyICogKGkgLSAxIC8gMykgLyBudW1iZXJMYXllcikgKiA0MCArIHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoaW5wdXQpLnksXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDE1LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWdtYUluc3RhbmNlLmdyYXBoLmFkZEVkZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiAnZWRnZScgKyAoZWRnZUlEKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc291cmNlOiBhZGphY2VudFtpXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHNpZ21hSW5zdGFuY2UuZ3JhcGgubm9kZXMoaW5wdXQpLmlkLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiI2ZmZlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3coaW5wdXRpZDogc3RyaW5nLCBzaWdtYUluc3RhbmNlOiBhbnkpIHtcbiAgICAgICAgbGV0IGdyYXBoID0gY29tcGxldGVHcmFwaChleHBhbmRHcmFwaFtQcmV2bmFtZUxpc3RbaW5wdXRpZF1dKTtcbiAgICAgICAgbGV0IGFkamFjZW50ID0gZ3JhcGhbaW5wdXRpZF07XG4gICAgICAgIHNob3dBcm91bmQoaW5wdXRpZCwgc2lnbWFJbnN0YW5jZSlcbiAgICAgICAgLy9TaG93IGFkZGl0aW9uYWwgbm9kZXMgaWYgYWxsIHRoZSBub2RlIGluIHRoaXMgbGF5ZXIgaXMgc21hbGwgZW5vdWdoXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhncmFwaCkubGVuZ3RoIDwgMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyMSBvZiBhZGphY2VudCkge1xuICAgICAgICAgICAgICAgIHNob3dBcm91bmQobGF5ZXIxLCBzaWdtYUluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3QWRqYWNlbnQgPSBncmFwaFtsYXllcjFdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGxheWVyMiBvZiBuZXdBZGphY2VudCkge1xuICAgICAgICAgICAgICAgICAgICBzaG93QXJvdW5kKGxheWVyMiwgc2lnbWFJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9mb3IgZHJhZ2dpbmcgdGhlIG5vZGVzLlxuICAgIGxldCBkcmFnTGlzdGVuZXIxID0gc2lnbWEucGx1Z2lucy5kcmFnTm9kZXMoXG4gICAgICAgIHNpZ21hUGxheWVyLCBzaWdtYVBsYXllci5yZW5kZXJlcnNbMF0pO1xuXG4gICAgZHJhZ0xpc3RlbmVyMS5iaW5kKCdzdGFydGRyYWcnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG4gICAgZHJhZ0xpc3RlbmVyMS5iaW5kKCdkcmFnJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuICAgIGRyYWdMaXN0ZW5lcjEuYmluZCgnZHJvcCcsIGZ1bmN0aW9uIChldmVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkcmFnTGlzdGVuZXIxLmJpbmQoJ2RyYWdlbmQnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG5cbiAgICBsZXQgZHJhZ0xpc3RlbmVyMiA9IHNpZ21hLnBsdWdpbnMuZHJhZ05vZGVzKFxuICAgICAgICBzaWdtYU5QQywgc2lnbWFOUEMucmVuZGVyZXJzWzBdKTtcblxuICAgIGRyYWdMaXN0ZW5lcjIuYmluZCgnc3RhcnRkcmFnJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuICAgIGRyYWdMaXN0ZW5lcjIuYmluZCgnZHJhZycsIGZ1bmN0aW9uIChldmVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkcmFnTGlzdGVuZXIyLmJpbmQoJ2Ryb3AnLCBmdW5jdGlvbiAoZXZlbnQ6IHN0cmluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgfSk7XG4gICAgZHJhZ0xpc3RlbmVyMi5iaW5kKCdkcmFnZW5kJywgZnVuY3Rpb24gKGV2ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQpO1xuICAgIH0pO1xuXG5cbi8vNC4gUnVuIHRoZSB3b3JsZFxuICAgIGluaXRpYWxpemUoKTtcbiAgICBsZXQgdXNlckludGVyYWN0aW9uT2JqZWN0ID0gZ2V0VXNlckludGVyYWN0aW9uT2JqZWN0KCk7XG5cbi8vUkVOREVSSU5HLS0tLS1cbi8vbGV0IGRpc3BsYXlQYW5lbCA9IHt4OiA1MDAsIHk6IDB9O1xuICAgIGxldCB0ZXh0UGFuZWwgPSB7eDogNDUwLCB5OiAzNTB9O1xuICAgIGxldCBhY3Rpb25zUGFuZWwgPSB7eDogNDcwLCB5OiAzNzV9O1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAvL2dldCBhbGwgdGhlIHBhcmVudHMgbG9jYXRpb25zIG9mIHRoZSBhZ2VudHNcbiAgICAgICAgbGV0IE5QQ1ByZXZzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgcGxheWVyUHJldnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGxldCBOUENQcmV2TG9jczogc3RyaW5nO1xuICAgICAgICBsZXQgUGxheWVyUHJldkxvY3M6IHN0cmluZztcbiAgICAgICAgLy9nZXQgYWdlbnRzJyBjdXJyZW50IGxvY2F0aW9uXG4gICAgICAgIGxldCBOUENMb2NhdGlvbiA9IGdldEFnZW50VmFyaWFibGUoTlBDLCBcImN1cnJlbnRMb2NhdGlvblwiKTtcbiAgICAgICAgbGV0IHBsYXllckwgPSBnZXRWYXJpYWJsZShwbGF5ZXJMb2NhdGlvbik7XG4gICAgICAgIC8vZ2VuZXJhdGUgYWxsIHRoZSBwYXJlbnRzIGxvY2F0aW9ucyBvZiB0aGUgTlBDXG4gICAgICAgIE5QQ1ByZXZMb2NzID0gUHJldm5hbWVMaXN0W05QQ0xvY2F0aW9uXTtcbiAgICAgICAgd2hpbGUgKE5QQ1ByZXZMb2NzICE9IFRyZWUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgTlBDUHJldnMucHVzaChOUENQcmV2TG9jcyk7XG4gICAgICAgICAgICBOUENQcmV2TG9jcyA9IFByZXZuYW1lTGlzdFtOUENQcmV2TG9jc107XG4gICAgICAgIH1cbiAgICAgICAgLy9nZW5lcmF0ZSBhbGwgdGhlIHBhcmVudHMgbG9jYXRpb25zIG9mIHRoZSBwbGF5ZXJcbiAgICAgICAgUGxheWVyUHJldkxvY3MgPSBQcmV2bmFtZUxpc3RbcGxheWVyTF07XG4gICAgICAgIHdoaWxlIChQbGF5ZXJQcmV2TG9jcyAhPSBUcmVlLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHBsYXllclByZXZzLnB1c2goUGxheWVyUHJldkxvY3MpO1xuICAgICAgICAgICAgUGxheWVyUHJldkxvY3MgPSBQcmV2bmFtZUxpc3RbUGxheWVyUHJldkxvY3NdO1xuICAgICAgICB9XG4gICAgICAgIC8vQ2xlYXIgdGhlIHByZXZpb3VzIHNjZW5lXG4gICAgICAgIGNsZWFyKHNpZ21hUGxheWVyKTtcbiAgICAgICAgY2xlYXIoc2lnbWFOUEMpO1xuICAgICAgICAvL1Nob3dcbiAgICAgICAgc2hvdyhwbGF5ZXJMLCBzaWdtYVBsYXllcik7XG4gICAgICAgIHNob3coTlBDTG9jYXRpb24sIHNpZ21hTlBDKTtcbiAgICAgICAgLy9Nb2RpZnkgdGhlIGxldmVsIGluZGljYXRvciBmb3IgcGxheWVyIHBlcnNwZWN0aXZlXG4gICAgICAgIHZhciBwbGF5ZXJUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImxlZnR0ZXh0XCIpO1xuICAgICAgICB2YXIgcGxheWVyaW5uZXJIdG1sOiBzdHJpbmcgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGxheWVyUHJldnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBsYXllcmlubmVySHRtbCArPSAnPHNwYW4gY2xhc3M9XCJwbGF5ZXJkb3RcIj48L3NwYW4+JztcbiAgICAgICAgfVxuICAgICAgICAvL2FkZGluZyBoaWdoZXIgbGV2ZWwgbG9jYXRpb24gbmFtZXMgZm9yIHBsYXllciBwZXJzcGVjdGl2ZVxuICAgICAgICBpZiAoUHJldm5hbWVMaXN0W3BsYXllckxdID09IFRyZWUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgcGxheWVyaW5uZXJIdG1sICs9ICcgICcgKyBUcmVlLmdldFZhbHVlKCkgKyAnLyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbGF5ZXJpbm5lckh0bWwgKz0gJyAgJyArIFByZXZuYW1lTGlzdFtQcmV2bmFtZUxpc3RbcGxheWVyTF1dICsgJy8nO1xuICAgICAgICAgICAgcGxheWVyaW5uZXJIdG1sICs9IFByZXZuYW1lTGlzdFtwbGF5ZXJMXSArICcvJztcbiAgICAgICAgfVxuICAgICAgICAvL01vZGlmeSB0aGUgbGV2ZWwgaW5kaWNhdG9yIGZvciBwbGF5ZXIgcGVyc3BlY3RpdmVcbiAgICAgICAgcGxheWVyVGV4dFswXS5pbm5lckhUTUwgPSBwbGF5ZXJpbm5lckh0bWw7XG4gICAgICAgIHZhciBBZ2VudFRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwicmlnaHR0ZXh0XCIpO1xuICAgICAgICB2YXIgQWdlbnRpbm5lckh0bWw6IHN0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBOUENQcmV2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgQWdlbnRpbm5lckh0bWwgKz0gJzxzcGFuIGNsYXNzPVwiYWdlbnRkb3RcIj48L3NwYW4+JztcbiAgICAgICAgfVxuICAgICAgICAvL2FkZGluZyBoaWdoZXIgbGV2ZWwgbG9jYXRpb24gbmFtZXMgZm9yIGFnZW50IHBlcnNwZWN0aXZlXG4gICAgICAgIGlmIChQcmV2bmFtZUxpc3RbTlBDTG9jYXRpb25dID09IFRyZWUuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgQWdlbnRpbm5lckh0bWwgKz0gJyAgJyArIFRyZWUuZ2V0VmFsdWUoKSArICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFnZW50aW5uZXJIdG1sICs9ICcgICcgKyBQcmV2bmFtZUxpc3RbUHJldm5hbWVMaXN0W05QQ0xvY2F0aW9uXV0gKyAnLyc7XG4gICAgICAgICAgICBBZ2VudGlubmVySHRtbCArPSBQcmV2bmFtZUxpc3RbTlBDTG9jYXRpb25dICsgJy8nO1xuICAgICAgICB9XG4gICAgICAgIEFnZW50VGV4dFswXS5pbm5lckhUTUwgPSBBZ2VudGlubmVySHRtbDtcbiAgICAgICAgLy9zaG93IHRoZSBsb2NhdGlvbnMgb2YgcGxheWVyIGFuZCBhZ2VudHMgb24gdGhlIGdyYXBoXG4gICAgICAgIC8vdGhlIGltYWdlIG9mIGJveSBmcm9tIGh0dHA6Ly93d3cudXJsdGFyZ2V0LmNvbS9pY29uLXN5bWJvbC1wZW9wbGUtYm95LW1hbi1tYWxlLWNhcnRvb24tc2NvdXQuaHRtbFxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHNpZ21hUGxheWVyLmdyYXBoLm5vZGVzKCkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09IE5QQ0xvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pbWFnZSA9IHt1cmw6ICcuLi9pbWFnZXMvYm95LnBuZyd9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gcGxheWVyTCkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW1hZ2UgPSB7dXJsOiAnLi4vaW1hZ2VzL3BsYXllcjIucG5nJ307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTlBDUHJldnMuaW5jbHVkZXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmJvcmRlcl9jb2xvciA9ICcjZmYwMDAwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoaXRlbXNMaXN0W25vZGUuaWRdKSAmJiBpdGVtc0xpc3Rbbm9kZS5pZF0ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICBub2RlLmJvcmRlcl9jb2xvciA9ICcjMDAwMEZGJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBub2RlIG9mIHNpZ21hTlBDLmdyYXBoLm5vZGVzKCkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlkID09IHBsYXllckwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmltYWdlID0ge3VybDogJy4uL2ltYWdlcy9wbGF5ZXIyLnBuZyd9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT0gTlBDTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBub2RlLmltYWdlID0ge3VybDogJy4uL2ltYWdlcy9ib3kucG5nJ307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGxheWVyUHJldnMuaW5jbHVkZXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmJvcmRlcl9jb2xvciA9ICcjQURGRjJGJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaWdtYVBsYXllci5yZWZyZXNoKCk7XG4gICAgICAgIHNpZ21hTlBDLnJlZnJlc2goKTtcblxuICAgICAgICAvL2FsZ29yaXRobSBmb3Igbm8gbGFwcGluZyBsYXlvdXQuXG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBub2RlTWFyZ2luOiA1MCxcbiAgICAgICAgICAgIGdyaWRTaXplOiA1LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vQ29uZmlndXJlIHRoZSBhbGdvcml0aG1cbiAgICAgICAgbGV0IGxpc3RlbmVyMSA9IHNpZ21hUGxheWVyLmNvbmZpZ05vdmVybGFwKGNvbmZpZyk7XG4gICAgICAgIGxldCBsaXN0ZW5lcjIgPSBzaWdtYU5QQy5jb25maWdOb3ZlcmxhcChjb25maWcpO1xuXG5cbiAgICAgICAgLy9CaW5kIGFsbCBldmVudHM6XG4gICAgICAgIGxpc3RlbmVyMS5iaW5kKCdzdGFydCBzdG9wIGludGVycG9sYXRlJywgZnVuY3Rpb24gKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdGVuZXIyLmJpbmQoJ3N0YXJ0IHN0b3AgaW50ZXJwb2xhdGUnLCBmdW5jdGlvbiAoZXZlbnQ6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vU3RhcnQgdGhlIGFsZ29yaXRobTpcbiAgICAgICAgc2lnbWFQbGF5ZXIuc3RhcnROb3ZlcmxhcCgpO1xuICAgICAgICBzaWdtYU5QQy5zdGFydE5vdmVybGFwKCk7XG5cbiAgICAgICAgZGlzcGxheVRleHRBbmRBY3Rpb25zKCk7XG4gICAgfVxuXG4gICAgLy9HZXQgY2FudmFzXG4gICAgbGV0IGNhbnZhcyA9IDxIVE1MQ2FudmFzRWxlbWVudD4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc3BsYXknKTtcbiAgICBsZXQgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgbGV0IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgbGV0IHlPZmZzZXQgPSBhY3Rpb25zUGFuZWwueSArIDI1O1xuICAgIGxldCB5T2Zmc2V0SW5jcmVtZW50ID0gMzA7XG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5VGV4dEFuZEFjdGlvbnMoKSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KHRleHRQYW5lbC54LCB0ZXh0UGFuZWwueSwgMTAwMCwgMTAwMCk7XG4gICAgICAgIHlPZmZzZXQgPSBhY3Rpb25zUGFuZWwueSArIDI1O1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IFwiMTVwdCBDYWxpYnJpXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY29uc29sZS5sb2coXCJBY3Rpb25zIGVmZmVjdCB0ZXh0OiBcIiArIHVzZXJJbnRlcmFjdGlvbk9iamVjdC5hY3Rpb25FZmZlY3RzVGV4dCk7XG4gICAgICAgIGxldCB0ZXh0VG9EaXNwbGF5ID0gdXNlckludGVyYWN0aW9uT2JqZWN0LmFjdGlvbkVmZmVjdHNUZXh0Lmxlbmd0aCAhPSAwID8gdXNlckludGVyYWN0aW9uT2JqZWN0LmFjdGlvbkVmZmVjdHNUZXh0IDogdXNlckludGVyYWN0aW9uT2JqZWN0LnRleHQ7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dFRvRGlzcGxheSwgdGV4dFBhbmVsLngsIHRleHRQYW5lbC55ICsgMjApO1xuXG4gICAgICAgIGNvbnRleHQuZm9udCA9IFwiMTVwdCBDYWxpYnJpXCI7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdXNlckFjdGlvblRleHQgPSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0W2ldO1xuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dCh1c2VyQWN0aW9uVGV4dCwgYWN0aW9uc1BhbmVsLnggKyAyMCwgeU9mZnNldCk7XG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5T2Zmc2V0ICs9IHlPZmZzZXRJbmNyZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwbGF5QXJyb3coKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5QXJyb3coKSB7XG4gICAgICAgIGlmICh1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aCAhPSAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdChhY3Rpb25zUGFuZWwueCwgYWN0aW9uc1BhbmVsLnksIDIwLCAxMDAwKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoXCI+IFwiLCA0NzAsIGFjdGlvbnNQYW5lbC55ICsgMjUgKyAoY3VycmVudFNlbGVjdGlvbiAqIHlPZmZzZXRJbmNyZW1lbnQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuLy9Vc2VyIGlucHV0XG4gICAgZnVuY3Rpb24ga2V5UHJlc3MoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRBY3Rpb24gPSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0W2N1cnJlbnRTZWxlY3Rpb25dO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzZWxlY3RlZEFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlVXNlckFjdGlvbihzZWxlY3RlZEFjdGlvbik7XG4gICAgICAgICAgICAgICAgd29ybGRUaWNrKCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlEb3duKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSA0MCkgey8vZG93blxuICAgICAgICAgICAgaWYgKHVzZXJJbnRlcmFjdGlvbk9iamVjdC51c2VyQWN0aW9uc1RleHQubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uKys7XG4gICAgICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb24gJSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5QXJyb3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gMzgpIHsvL3VwXG4gICAgICAgICAgICBpZiAodXNlckludGVyYWN0aW9uT2JqZWN0LnVzZXJBY3Rpb25zVGV4dC5sZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24tLTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlbGVjdGlvbiA8IDApXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSB1c2VySW50ZXJhY3Rpb25PYmplY3QudXNlckFjdGlvbnNUZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgZGlzcGxheUFycm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9Jbml0aWFsaXplIHRoZSB2aXN1YWxpemF0aW9uXG4gICAgcmVuZGVyKCk7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwga2V5UHJlc3MsIGZhbHNlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlEb3duLCBmYWxzZSk7XG59Il19
